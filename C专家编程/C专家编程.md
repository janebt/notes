# Expert C Programming: Deep C Secrets  #
## 第1章  C：穿越时空的迷雾##
### 1.1 C语言的史前阶段 ###
### 1.2 C语言的早期体验 ###
### 1.3 标准I/O库和C预处理器 ###
### 1.4 K&R C ###
### 1.5 今日之ANSI C ###
### 1.6 它很棒，但它符合标准吗 ###
### 1.7 编译限制 ###
### 1.8 ANSI C标准的结构 ###
### 1.9 阅读ANSI C标准，寻找乐趣和裨益 ###
- char **p 和 const char **p不匹配
- 在一个符号前加const限定符指示表示这个符号表不能被赋值。
- const最有用之处：限定函数的形参。

### 1.10 “安静的改变”究竟有多少安静 ###
### 1.11 轻松一下————由编译器定义的Pragmas效果 ###
- GNU：GNU's not Unix :一个Unix自由软件实现方案

## 第2章 这不是Bug，而是语言特性 ##
### 2.1 这关语言特性何事，在Fortran里这就是Bug呀###
- NUL & NULL：NUL表示结束一个ASCII字符串；NULL表示什么都不指向（空指针）

### 2.2 多做之过###
### 2.3 误做之过 ###
- 在C中，const不是真正表示常量。e.g const int TWO=2；在switch...case中error
- 相邻字符串常量会合并成一个新字符串.  e.g. "it " "is"  : "it is"
- char *A[]={"1","2",}：最后的逗号 没任何影响
-  <有#include的左定界符的意思
-  优先级

        .       >    *
        []      >    *
        ()      >    *
        ==和！=  >    位操作符
        ==和！=  >    赋值符
        算术     >    移位

### 2.4 少做之过 ###
- 编译器使用maximal munch strategy
- 显式分配的内容不会被销毁

### 2.5 轻松一下————有些特性确实就是Bug ###
### 2.6 参考文献 ###

## 第3章 分析C语言的声明 ##
### 3.1只有编译器才会喜欢的语法 ###
### 3.2 声明是如何形成的 ###
- 参数在传递时尽可能的放入寄存器（PS：一个int参数一般会传到寄存器中，而结构参数很可能传到堆栈中）

### 3.3 优先级规则 ###
- C语言声明的优先级规则：

        A 声明从它的名字开始读取，然后按照优先级顺序依次读取
        B 优先级从高到低依次是：
            B.1 声明中被括号括起来的那部分
            B.2 后缀操作符：括号（）表示这是要给函数，而方括号【】表示这是一个数组
            B.3 前缀操作符：星号*表示“指向...的指针”
        C 如果const和（或）volatile关键字的后面紧跟类型说明符（如int，long等），那它作用于类型说明符。在其他情况下，const和（或）volatile关键字作用于它左边相邻的指针星号。

- 图3-1，如何解析C语言的声明

### 3.4 通过图表分析C语言的声明 ###
### 3.5 type得分可以成为你的朋友 ###
- 不要在一个typedef中放入几个声明器

### 3.6 typedef int x[10]和#define x int[10]的区别 ###
- typedef和宏替换的区别：

        1. 可以用其他类型说明符对宏类型名扩展，但typedef定义的类型名不行。e.g.typedef int b;unsigned b i;//非法
        2. 连续几个变量的声明中，用typedef定义的类型能保证声明中所有变量均为同一种类型，而用#define无法保证

### 3.7 typedef struct foo{...foo;}的含义 ###
- 如果用同一个标识符表示结构类型和typedef声明引入的标签，那么以后使用这个标识符时前面就不必加上关键字“struct”。
e.g. typedef struct fruit{int weight,price_per_lb;}fruit;  等于  struct fruit mandarin;fruit mandarin;
- 不要对结构体使用typerdef，typedef应用在：

        数组、结构、指针以及函数的组合类型
        可移植类型。
        可为后面的强制类型转换提供一个简单的名字。

### 3.8 理解所有分析过程的代码段 ###
- 把C语言的声明翻译成通俗语言。P71

### 3.9 轻松一下————驱动物理实体的软件 ###
- 可以将字符串比较strcmp()写成宏的方式，简化风格

## 第4章 令人震惊的事实：数组和指针并不相同 ##
### 4.1 数组并非指针 ###
### 4.2 我的代码为什么无法运行 ###
### 4.3 什么事声明，什么事定义 ###
- 左值在编译时可知，右值在运行时可知。
- 指针和数组的区别：前者间接访问数据，首先取指针内容，将其作为地址，然后从中提取；后者直接访问数据

### 4.4 使声明与定义相匹配 ###
### 4.5 数组和指针的其他区别 ###
- 定义指针时，只有初始化字符串常量才会分配内存。这个字符串被定义为只读，如果试图修改这个字符串值，会出现段错误。

### 4.6 轻松一下————回文的乐趣 ###

## 第5章 对链接的思考 ##
### 5.1 函数库、链接和载入 ###
- 编译器分割：C预处理器 ->(p) 前段（语法和语义检查） ->(0) 后端（代码生成器） ->(c) 优化器 ->(2) 汇编程序 ->(a) 链接-载入器 (1)
- 可使用-#选项查看编译过程的各个独立阶段，-V选项能提供版本信息。
- -W选项向各个阶段传递选项信息，后面加一个字符（代表哪个阶段）和一个逗号，然后是具体选项。（e.g.-W1）

### 5.2 动态链接的优点 ###
- 动态链接的目的之一是ABI(Application Binary Interface)。
- 动态链接必须保证4个特定函数库：libc、libsys(其他系统函数)、libX(X windowing)和libnsl(网络服务)。
- 系统调用mmap()把文件映射到进程的地址空间中。当问及包含可执行文件的指令时更适宜。
- 处理.o创建链接库：静态用ar, 动态用ld
-动态链接库使用方法：生成使用gcc -fPIC -shared -o libfruit.so tomato.c;使用：gcc fruit.c libfruit.so -o fruit
- 对于函数库应该始终使用位置无关代码；对于共享库，位置无关代码格外有用。
- 纯代码。纯可执行文件只包含代码（无静态和初始化过的数据）从堆栈或其他（非纯）段引用数据。

### 5.3 函数库链接的5个特殊秘密 ###
- 可用nm工具列出函数库所包含的函数
- 如果在链接时找不到符号定义，参考P99搜索/usr/ccs/lib和/usr/lib两个目录
- 静态链接在处理archive时，它只是在archive中查找载入器当时所知的未定义符号。简而言之，各个静态链接库出现的顺序非常重要。
- Tip：函数库选项-I应该始终放在命令行最右边

### 5.4 警惕Interpositioning ###
- Interpositioning:通过编写与库函数同名的函数来取代库函数的行为
- 准则：不要让程序中任何符号成为全局的，除非有意将其作为程序接口之一。

### 5.5 产生链接器报告文件 ###
- ld：-m让链接器产生一个报告；-D：提供更好的链接-编辑调试。

### 5.6 轻松一下————看看谁在说话：挑战Turning测验 ###

## 第6章 运动的诗章：运行时数据结构 ##
### 6.1 a.out及其传说 ###
- a.out历史：assembler output
- 超级块(superblock,Unix文件系统基础数据结构)的神奇数字是：0x011954。是Kirk McKusick生日

### 6.2 段 ###
- -ELF（原意为"Extensible Linker Format",可扩展链接器格式、现在表示"Executable and Linking Format",可执行文件和链接格式）。
- 在Unix中，段表示一个二进制文件相关的内容块
- P118 图6-1 C语句的各部分会出现在哪些段中
- BSS段("Block Started by Symbol"(由符号开始的块))，BSS只保存没有值得变量，事实上并不需要保存这些变量的映像。
- 查看可执行文件中的段：

        数据段保存在目标文件中
        BSS段不保存在目标文件中（除了记录BSS段在运行时所需要的大小）
        文本段是最容易受优化措施影响的段
        a.out文件的大小受调试状态下编译的影响，但段不受影响

### 6.3 操作系统在a.out文件里干了些什么 ###
- 图6.3 显示共享库的虚拟地址空间布局
- 堆栈段的功能：

        为局部变量提供空间
        函数调用的维护性信息
        用作暂时的存储区

### 6.4 C语言运行时系统在a.out文件里干了些什么 ###
### 6.5 当函数被调用时发生了什么：过程活动记录###
- 过程活动记录：一种数据结构，用于支持过程调用，并记录返调用结束后返回调用点所需的全部信息。
- 头文件/usr/include/sys/frame.h描述过程活动记录在UNIX系统中的样子。（Ubuntu目录不同）
- C语言不允许函数的嵌套，因为简化了C编译器，活动记录不需要包含一个指向外层函数的活动记录的指针。

### 6.6 auto和static关键字 ###
- static：用于返回指向函数内部定义的变量的指针；保存在数据段中。生存期是整个程序
- auto：实际中程序员从不用，供编译器设计者使用；用于标记符号表条目。
- 过程活动记录可能不在堆栈中（寄存器窗口）

### 6.7 控制线程 ###
- 每一个线程函数都需要自己的堆栈保存自己的位置，每个线程堆栈为1M（需要时增长），各个堆栈中有个red zone页

### 6.8 setjmp和longjmp ###
- 作用：弥补C语言有限的转移能力；错误恢复
- 函数：

        setjmp(jmp_buf j)必须先调用。表示“使用变量j记录现在位置，函数返回0”
        longjmp(jmp_buf j，int i)可接着被调用。表示“回到j所记录的位置，使其看上去像从原先的setjmp()函数返回一样。函数返回i，作用为告知是调用了这个函数”
        longjmp()，j的内容被销毁
 
- longjmp和goto区别：

        1. goto不能跳出C语言当前的函数，而longjmp甚至能跳到其他文件的函数中
        2. longjmp只能跳到曾今到的地方。

- 保证局部变量longjmp过程中值不变的方法：声明为volatile
- 使用setjmp和longjmp的任何文件，必须包含头文件<setjmp.h>

### 6.9 UNIX中的堆栈段 ###
- 在堆栈顶部的下端有一个称为red zone的小型区域，若对其引用不会失败

### 6.10 MS-DOS中的堆栈段 ###
- DOS中建立可执行文件，堆栈大小必须同时确定，不能在运行时增长
- 80x86架构，段的最大限制是64K字节

### 6.11 有用的C语言工具 ###
- 表6-1：用于检查源代码的工具
- 表6-2：用于检查可执行文件的工具
- 表6-3：性能优化辅助的工具

### 6.12 轻松一下————卡耐基-梅隆大学的编程难题 ###
### 6.13 只适用于高级学员阅读的材料 ###

## 第7章 对内存的思考 ##
### 7.1 Intel 80x86 ###
### 7.2 Intel 80x86内存模型以及它的工作原理 ###
- 在80x86内存模型中，地址空间被分割以64KB为单位的区域，称为段
- 不同的段地址和偏移地址形成的指针可能指向同一个内存地址
- 使用"huge"关键字（huge内存模式），**两个位模式不同但指向同一个内存地址的指针被错误认为不等**的这些情况会自动完成。"large"不会。
- Microsoft C中，far关键字表示指针存储段寄存器和偏移地址；near关键字表示指针只存储16位的偏移地址，它的段地址使用当前数据段或堆栈段寄存器的值
- P144 PC的内存模型
- 关键字所修改的是右边的项目，而const、volatile修饰符修改de是左边紧邻的项目

### 7.3 虚拟内存 ###
- 虚拟内存：页。一般几K
- 磁盘中有交换区：保存从内存中换出的进程。大小一般是物理内存的几倍

### 7.4 Cache存储器 ###
- sun使用两种类型的cache

        全写法：每次写入cache时总是同时写入内存
        写回法：第一次写入，只对cache写入；如果已被写过的cache需要再写时，如果第一次写入的结果未保存，要先写入内存中；内核切换进程，所有数据也要写入内存中

-Cache的组成：
    
        行：对cache访问的单位。两部分：数据部分+标签（指定代表的地址）
        块： cache行内数据；保存来回移动于cache行和内存之间的字节数据。典型为32字节。

### 7.5 数据段和堆 ###
- 堆中获取内存：malloc、calloc、realloc等
- calloc：在返回指针前将之前分配好的内存内容清空为零。
- realloc：改变指针所指向的内存块大小；它经常把内存拷贝到别的地方然后将指向新地址的指针返回；在动态增加表的大小很有用
- 堆回收的一种机制：建立一个可用块（“自由存储区”）的链表，每块由malloc分配的内存块都在自己的前面标明大小。有用arena描述内存分配器管理的内存块的集合
- 堆的末端有一个break指针，对内存引用超过break位置会出错；系统调用brk和sbrk移动break指针。一般不必显式调用，若分配的内存容量很大，brk会被自动调用。
- 可用mmap系统调用映射/dev/zero文件，获得以后能返回给系统内核的内存。

### 7.6 内存泄漏 ###
-  避免内存泄漏方法：使用alloca()分配动态内存。当离开调用alloca的函数会自动释放内存；PS：alloca（）在栈上分配内存
-  不提倡alloca：不一定可移植，如果硬件不支持很难高效实现
-  检测内存泄漏：swap -s；ps命令
-  使用版本合适的扩展的malloc函数

### 7.7 总线错误 ###
- 总线错误和段错误出现在有问题的内存引用时
- 总线错误：几乎都是未对齐的读写
- 段错误：内存单元异常。通常是解除引用一个未初始化或非法值的指针。如果指针引用一个不在地址空间的地址
- 如果未初始化指针恰好具有未对其的值，会产生总线错误而不是段错误。
- 导致段错误的直接原因：

        解除引用一个包含非法值的指针
        解除引用一个空指针
        在未得到正确的权限时进行访问。
        用完堆栈或堆空间

- 导致段错误的常见编程错误：

        1. 坏指针值错误：a.指针赋值前使用;b.向库函数传送一个坏指针;c.释放指针后再访问
        2. 改写错误：在动态分配内存两端之外写数据，或改写一些堆管理数据结构。
        3. 指针释放引起的错误：释放同一个内存块2次，或释放一块未曾malloc分配的内存，或释放正在使用的内存，或释放一个无效的指针。
        
- 在链表中释放元素的方法：通过使用临时变量存储下一个元素的地址

### 7.8 轻松一下————"Thing King"和“页面游戏” ###

## 第8章 为什么程序员无法分清万圣节和圣诞节 ##
### 8.1 Portzebie度量衡系统 ###
### 8.2 根据位模式构筑图形 ###
### 8.3 在等待时类型发生了变化 ###
- 在K&R C中，由于函数的参数是表达式，会发生类型提升；如果在ANSI C中，使用恰当的函数原型，类型提升不会发生，否则也会发生

### 8.4 原型之痛 ###
### 8.5 原型在什么地方会失败 ###
### 8.6 不需要按回车就能得到一个字符 ###
- 阻塞式读入：I/O设置为raw状态；若终端没有字符输入，进程一直等待；
- 非阻塞式读入：使用ioctl()（I/O控制）系统调用；提供一个针对终端特性的良好控制层，可告诉是否有键摁下。这种类型I/O称为轮询。
- 使用系统调用后，检查全局变量errno很好。P181
- 显示控制相关：curses函数库

### 8.7 用C语言实现有限状态机 ###
- 有限状态机(FSM)可以实现成：

        声明：     void (*state[MAX_STATUS])();
        初始化：    如果知道函数名extern int a(),b(),c(),d()，可以用int (*state[])={a,b,c,d};
        函数调用：   (*state[i])();

### 8.8 软件比硬件更困难 ###
- debugging hooks

### 8.9 如何进行强制类型转换，为何要运行类型强制转换 ###
### 8.10 轻松一下————国际C语言婚礼代码大赛 ###

## 第9章 再论数组 ##
### 9.1 声明时候数组与指针相同 ###
- 数组和指针在编译器处理时不同，运行时的表达形式也不一样，可能产生不同的代码。

### 9.2 为什么会发生混淆 ###
- 什么时候数组和指针相同：

        1. 表达式中的数组名（与声明不同）被编译器当作一个指向该数组第一个元素的指针
        2. 下标总是与指针的便宜了相同
        3. 函数的声明中，数组名被编译器当作指向该数组第一个元素的饿指针

- 表达式中指针和数组可互换，因为在编译器中都是指针。就像加法一样，a[6]和6[a]相同

### 9.3 为什么C语言把数组形参当作指针 ###
- 倾向把参数定义为指针而不是数组

### 9.4 数组片段的下标 ###
### 9.5 数组和指针可交换性的总结 ###
### 9.6 C语言的多维数组 ###
- C中多维数组最右的下标最先变化：“行主序”
- 多维数组初始化可以在最后初始化值后加一个逗号：`int a[][3]={{0,0,0},{1,1,1},};`
- 字符串常量才可以初始化指针数组，原因是：行不等长，但字符串中可以以NULL结束，从而可以不等长

### 9.7 轻松一下————软件/硬件平衡 ###

## 第10章 再论指针 ##
### 10.1 多维数组的内存布局 ### 
### 10.2 指针数组就是Iliffe向量 ###
### 10.3 在锯齿状数组上使用指针 ###
- “数组的数组”会改写成“数组的指针”，而不是指针的指针

### 10.4 向函数传递一个一维数组 ###

### 10.5 使用指针向函数传递一个多维数组 ###
- 必须提供除最左边一维以外所有维的长度

### 10.6 使用指针从函数返回一个数组 ###
- e.g. int (*paf())[20];

### 10.7 使用指针创建和使用动态数组 ###
- 使用string实用程序从二进制文件内部查看程序可能产生的错误信息很有帮助

### 10.8 轻松一下————程序检测的限制 ###

## 第11章 你懂得C，所以C++不在话下 ##
### 11.1 初始OOP ###
### 11.2 抽象————取事物的本质特性 ###
### 11.3 封装————把相关的类型、数据和函数组合在一起 ###
### 11.4 展示一些类————用户定义类型享有和预定义类型一样的权限 ###
### 11.5 访问控制 ###
### 11.6 声明 ###
### 11.7 如何调用成员函数 ###
### 11.8 继承————复用已经定义的操作 ###
### 11.9 多重继承————从两个或更多的基类派生 ###
### 11.10 重载————作用于不同类型的同一操作具有相同的名字 ###
- 重载总是在编译时进行解析

### 11.11 C++如何进行操作符重载 ###
### 11.12 C++的输入/输出(I/O) ###
### 11.13 多态————运行时绑定 ###
### 11.14 解释 ###
- 想用派生类的同名函数取代基类的同名函数时没需要在被取代的基类成员函数前加上virtual

### 11.15 C++如何表现多态 ###
- 单继承通过在每个对象中增加vptr指针实现虚拟函数。vptr指针指向一个vtbl的函数向量指针（虚拟函数表，也称V表）

### 11.16 新奇玩意————多态 ###
### 11.17 C++的其他要点 ###
### 11.18 如果我的目标是那里，我不会从这里起步 ###
- C中，字符常量的类型是int？？？

### 11.19 它或许过于复杂，但却是唯一可行的方案 ###
### 11.20 轻松一下————死亡计算机协会 ###
### 11.21 更多阅读材料 ###

## 附录A 程序员工作面试的秘密 ##
### A.1 硅谷程序员面试 ###
### A.2 怎样才能检测到链表中存在循环 ###
- 追击指针

### A.3 C语言中不同的增值语句的区别何在 ###

### A.4 库函数调用和系统调用区别何在 ###

### A.5 文件描述符与文件指针有何不同 ###
- 文件描述符是开放文件的每个进程表的一个偏移量，用于UNIX系统调用中，用于标识文件。
- FILE指针保存一个FILE结构的地址。FILE结构用于表示开放的I/O流;用于ANSI C标准的I/O库调用中，用于标识文件。

### A.6 编写一些代码，确定一个变量是有符号数还是无符号数 ###
- 可为：
    
    `#define ISUNSIGNED(a) (a>=0 && ~a >=0)`
    `#define ISUNSIGNED(type) ((type(0) - 1 > 0)`

### A.7 打印一颗二叉树的值的时间复杂度是多少 ###
- O(N)

### A.8 从文件中随机提取一个字符串 ###
### A.9 轻松一下————如何用气压计测量建筑物的高度 ###

## 附录B 术语表 ##
