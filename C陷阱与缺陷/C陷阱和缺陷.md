#C陷阱和缺陷
##第0章 导读
##第1章 词法“陷阱”
###1.1 ==不同于==
###1.2 & 和 | 不同于 && 和 ||
###1.3 词法分析中的“贪心法”
###1.4 整型常量
* 如果一个整型常量的第一个字符是数字0,那么该常量被视为八进制数。
###1.5字符与字符串
* 如果用printf('/n') 代替 printf("\n")会产生错误，而且编译器还不会报错。
* 有的C编译器允许在一个字符常量或字符串常量中包括多个字符。如用'yes'代替"yes"。前者是一个整数值，由'y'、'e'、's'代表的整数值按编译器的实现方式组合得到。  
PS：VC++6.0和GCC采用依次用后一个字符覆盖前一个字符的方法；Borland C++和LCC采用忽略多余字节，最后结果为第一个字符的整数值。  

##第2章 语法“陷阱”
###2.1 理解函数声明
* 可在声明符中使用任意括号
(*(void (*)())0)();

###2.2 运算符的优先级问题
* 15种运算符顺序
* 6个关系运算符中，==和!=的优先级要低于其他
* 按位异或运算符的优先级介于按位与运算符和按位或运算符之间。

###2.3 注意作为语句结束标志的分号
###2.4 switch语句
###2.5 函数调用  
###2.6 “悬挂”else引发的问题     
* 可以用收尾定界符显示说明，C中可用宏定义达到类似效果。 

##第3章 语义“陷阱”
###3.1 指针与数组
* 数组的大小编译时要被确定。C99支持变长数组，GCC实现变长数组
* 指针和二维数组转换（！！！）

###3.2  非数组指针
###3.3 作为参数的数组声明
###3.4 避免“举隅法”
###3.5 空指针并非空字符串
* 将0赋值给一个指针变量时，绝不能企图使用该指针所指向的内存中存储的内容。
e.g. if(strcmp(p,(char *)0) ==0 )…或printf(p)非法

###3.6边界计算与不对称边界
* 用第一个入界点和第一个出界点来表示一个数值范围。
* 将上界视为某序列中第一个被占用的元素。下界视为序列中第一个被释放的元素

###3.7 求值顺序
###3.8 运算符&&、||和！
###3.9 整数溢出
* 两个操作数都是有符号数时，会发生溢出
* 一种可行的方式是将有符号数转化为无符号数

###3.10 为函数main提供返回值
##第4章 连接
###4.1 什么是连接器
* 注意命名冲突

###4.2 声明和定义
###4.3 命名冲突与static修饰符
* 如果一个函数仅仅被同一个源文件的其他函数调用，应该声明为static

###4.4 形参、实参与返回值
###4.5 检查外部类型
###4.6 头文件
##第5章 库函数
###5.1 返回整数的getchar函数
e.g. char c;c=getchar()会被截断
###5.2 更新顺序文件
fseek
###5.3 缓冲输出和内存分配
* Setbuf(stdout,buf)：知道buf填满或是程序员直接调用fflush，buf实际内容才写入到stdout中  
e.g. char buf[BUFSIZE];setbuf(stdout,buf);错误。因为main函数结束后会清理buf缓冲区空间，但是在此之前buf字符数组已经被释放。
改正方法：静态数组+static或是动态分配缓冲区
###5.4 使用errno检测错误
* 在调用库函数，首先检测错误指示的返回值，确定程序执行已失败，再检查errno。

###5.5库函数signal
    #include <signal.h>   
	signal(signal type,handler function)   
这里的signal type代表系统头文件signal.h中定义的某些常量，用来标识signal函数将要捕获的信号类型。这里的handler function是指定事件发生时将要加以调用的事件处理函数。
##第6章 预处理器
* 修改某些特定实例
* 希望一个程序块看似函数，却没有函数的调用开销

###6.1 不能忽视宏定义中的空格
###6.2 宏并不是函数
###6.3 宏并不是语句
###6.4 宏并不是类型定义
##第7章 可移植性缺陷
###7.1 应对C语音标准变更
###7.2 标示符名称的限制
###7.3 整数的大小
###7.4 字符时有符号整数还是无符号整数
* 使用unsigned char来进行类型转换
###7.5 移位运算符
* 如果被移位的对象长度是n位，那么移位计数必须大于等于0，严格小于n
###7.6 内存置0
###7.7 除法运算时发生的截断
程序最好避免为负数的情况，并声明为无符号数
###7.8随机数的大小
###7.9大小写转换
###7.10 首先释放，然后重新分配
* realloc。    
PS：在UNIX中，即使内存已经释放，依旧可以使用realloc函数。比如有时候:    

		for(p = head; p!=NULL;p=p->next)  
			free((char *)p);
可以运行      

###7.11 可移植性问题的一个例子
* 基于1的补码：二进制表示下限为-(2^N-1)
基于2 的补码：二进制表示下限为-(2^N)

##第8章 建议与答案
###8.1  建议
* 不要说服自己相信“皇帝的新装”
* 直接了当表明意图
* 考察最简单的特例
* 使用不对称边界
* 注意潜伏在暗处的bug
* 防御性编程

###8.2 答案
* 对于负数，除2和移位运算会得到不同结果
* %x和%X分别打印小写和大写
* %g、%f和%e打印浮点数，区别在于：

		g：不需要按列对其的浮点数；保留6位有效数字
		%e：一律用指数形式；小数点后6位
		%f：强制禁止使用指数形式；小数点后6位

* 标志字符+：规定每个待打印的数值在输出时都应该以它的符号（正号或负号）作为第一个字符
* 可用*替换域宽修饰符与精度修饰符 e.g.printf("…%.*s …",…,NAMESIZE,name,…)
* 
		%p:以某种形式打印一个指针
		%n：用于指出已经打印的字符数，这个数存储在对应参数（一个整型指针）所指向的整数里

PS：varargs.h和stdargs.h部分未看
