# 第1章 JavaScript是什么 #
## 1.1 历史简述 ##
## 1.2 JavaScript实现 ##
- 组成:
  核心(ECMAScript)
  文档对象模型(DOM)
  浏览器对象模型(BOM)

### 1.2.1 ECMAScript ###
- ECMAScript仅仅是一个描述，定义了脚本语言的所有属性、方法和对象。其他语言可以实现ECMAScript作为功能的基准。
- 每个浏览器都有自己的ECMAScript接口实现，然后这个实现又被扩展。

##### 1.ECMAScript的版本 #####
##### 2.什么是ECMAScript兼容 #####
一个脚本语言必须满足下列四项原则(e.g. ECMA-262):

- 按照ECMA-262中描述的支持所有的“类型、值、对象、属性、函数和程序语法及语义”
- 支持Unicode字符标准
- 可以增加没有在ECMA-262中指定的“额外的类型、值、对象、属性和函数”，
- 可以支持没有在ECMA-262中定义的“程序和正则表达式语法”

#### 3.Web浏览器中的ECMAScript支持 ####

### 1.2.2 文档对象模型DOM ###
- DOM（文档对象模型）是HTML和XML的API。DOM把整个页面规划成由节点层次构成的文档。DOM通过创建树来表示文档。

##### 1. 为什么要使用DOM  #####

##### 2. DOM级别 #####
- DOM Level1：DOM Core + DOM HTML。前者提供基于XML的文档结构图，后者添加HTML专用的对象和方法扩展DOM Core。目标只有规划文档结构。
- DOM Level2：引入几种DOM新模块：
  DOM视图————描述跟踪文档的各种视图(即CSS样式化之前和CSS样式化之后的文档)的接口
  DOM事件————描述事件的接口
  DOM样式————描述处理基于CSS样式的接口
  DOM遍历和范围————描述遍历和操作文档树的接口
- DOM Level3：引入了以统一的方式载入和保存文档的方法以及验证文档的方法。

##### 3.其他DOM #####
##### 4.Web浏览器中的DOM支持 #####

### 1.2.3 浏览器对象模型（BOM） ###
- 从根本上讲，BOM只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的JavaScript扩展算作BOM的一部分。

## 1.3 JavaScript版本

## 1.4 小结 ##



# 第2章 在 HTML 中使用 JavaScript 

## 2.1 <script>元素

HTML 4.01为\<script>定义了下列6个属性。

-  async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。
-  charset：可选。表示通过src属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。
-  defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。IE7及更早版本对嵌入脚本也支持这个属性。
-  language：已废弃。原来用于表示编写代码使用的脚本语言（如JavaScript、JavaScript1.2或VBScript）。大多数浏览器会忽略这个属性，因此也没有必要再用了。
-  src：可选。表示包含要执行代码的外部文件。
-  type：可选。可以看成是language的替代属性；表示编写代码使用的脚本语言的内容类型（也称为MIME类型）。考虑到约定俗成和最大限度的浏览器兼容性，目前type 属性的值依旧还是text/javascript。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为text/javascript。


1. 需要注意的是，带有src属性的\<script>元素不应该在其\<script>和\</script>标签之间再包含额外的JavaScript代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。
2. 无论如何包含代码，只要不存在defer和async属性，浏览器都会按照\<script>元素在页面中出现的先后顺序对它们依次进行解析。

### 2.1.1 标签的位置

- 在文档的\<head>元素中包含所有JavaScript文件，意味着必须等到全部JavaScript代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到\<body>标签时才开始呈现内容）。
- 现代Web应用程序一般都把全部JavaScript引用放在\<body>元素中页面内容的后面

### 2.1.2 延迟脚本

- HTML 4.01为\<script>标签定义了defer属性。这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在\<script>元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。
- 在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在DOMContentLoaded事件触发前执行，因此最好只包含一个延迟脚本。
- defer属性只适用于外部脚本文件。这一点在HTML5中已经明确规定，因此支持HTML5的实现会忽略给嵌入脚本设置的defer属性。
- IE4～IE7还支持对嵌入脚本的defer属性，但IE8及之后版本则完全支持HTML5规定的行为。把延迟脚本放在页面底部仍然是最佳选择。
- 在XHTML文档中，要把defer属性设置为defer="defer"。

### 2.1.3 异步脚本

- async只适用于外部脚本文件，并告诉浏览器立即下载文件。但与defer不同的是，标记为async的脚本并不保证按照指定它们的先后顺序执行。

- 建议异步脚本不要在加载期间修改DOM。
- 异步脚本一定会在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。支持异步脚本的浏览器有Firefox 3.6、Safari 5和Chrome。
- XHTML文档中，要把async属性设置为async="async

### 2.1.4 在XHTML中的用法

- 可扩展超文本标记语言，即XHTML（Extensible HyperText Markup Language），是将HTML作为XML的应用而重新定义的一个标准。


- 避免在XHTML中出现类似语法错误的方法有两个。
  1. 用相应的HTML实体（<）替换代码中所有的小于号（<）
  2. 用一个CData片段来包含JavaScript代码。在XHTML（XML）中，CData片段是文档中的一个特殊区域，这个区域中可以包含不需要解析的任意格式的文本内容。


- 在将页面的MIME类型指定为"application/xhtml+xml"的情况下会触发XHTML模式。并不是所有浏览器都支持以这种方式提供XHTML文档。

### 2.1.5 不推荐使用的语法

- Netscape与Mosaic协商并提出了一个解决方案，让不支持\<script>元素的浏览器能够隐藏嵌入的JavaScript代码。这个方案就是把JavaScript代码包含在一个HTML注释中

## 2.2 嵌入代码与外部文件

- 在HTML中嵌入JavaScript代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含JavaScript代码。
  - 可维护性：遍及不同HTML页面的JavaScript会造成维护问题。
  - 可缓存：浏览器能够根据具体的设置缓存链接的所有外部JavaScript文件。
  - 适应未来：通过外部文件来包含JavaScript无须使用前面提到XHTML或注释hack。

## 2.3 文档模式

- IE5.5 引入了文档模式的概念,最初的两种文档模式是：混杂模式（quirks mode）和标准模式。
- IE又提出一种所谓的准标准模式（almost standards mode）


- 如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。


- 对于标准模式，可以通过使用下面任何一种文档类型来开启：

  ```
  <!-- HTML 4.01 严格型--> 
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" 
  "http://www.w3.org/TR/html4/strict.dtd"> 

  <!-- XHTML 1.0 严格型--> 
  <!DOCTYPE html PUBLIC 
  "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"> 

  <!-- HTML 5 --> 
  <!DOCTYPE html> 
  ```


- 对于准标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发.e.g.

  ```
  <!-- HTML 4.01 过渡型--> 
  <!DOCTYPE HTML PUBLIC 
  "-//W3C//DTD HTML 4.01 Transitional//EN" 
  "http://www.w3.org/TR/html4/loose.dtd"> 

  <!-- HTML 4.01 框架集型--> 
  <!DOCTYPE HTML PUBLIC 
  "-//W3C//DTD HTML 4.01 Frameset//EN" 
  "http://www.w3.org/TR/html4/frameset.dtd"> 

  <!-- XHTML 1.0 过渡型--> 
  <!DOCTYPE html PUBLIC 
  "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 

  <!-- XHTML 1.0 框架集型--> 
  <!DOCTYPE html PUBLIC 
  "-//W3C//DTD XHTML 1.0 Frameset//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"> 
  ```

## 2.4 <noscript>元素

- 用以在不支持JavaScript 的浏览器中显示替代的内容。
- 这个元素可以包含能够出现在档\<body>中的任何HTML元素——\<script>元素除外。
- 包含在\<noscript>元素中的内容只有在下列情况下才会显示出来：
  - 浏览器不支持脚本；
  - 浏览器支持脚本，但脚本被禁用。

## 2.5小结

-  在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。
-  所有\<script>元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用defer 和async 属性的情况下，只有在解析完前面\<script>元素中的代码之后，才会开始解析后面\<script>元素中的代码。
-  由于浏览器会先解析完不使用defer属性的\<script>元素中的代码，然后再解析后面的内容，所以一般应该把\<script>元素放在页面最后，即主要内容后面，\</body>标签前面。
-  使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。
-  使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。

# 第3章 基本概念 #

## 3.1 语法 ##
### 3.1.1 区分大小写

### 3.1.2 标识符

- 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其他字符可以是字母、下划线、美元符号或数字。
- 按照惯例，ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写

### 3.1.3 注释

### 3.1.4 严格模式

- 严格模式是为JavaScript定义了一种不同的解析与执行模型。在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。


- 要在整个脚本中启用严格模式，可以在顶部添加如下代码：

  ```
  "use strict"; 
  ```


- 严格模式下，JavaScript 的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支持严格模式的浏览器包括IE10+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。

### 3.1.5 语句

## 3.2 关键字和保留字

- 保留字某种意义是为将来的关键字保留的单词。


- 第5版把在非严格模式下运行时的保留字缩减为下列这些：

  class	 enum	 extends		super 

  const	 export	 import 

- 在严格模式下，第5版还对以下保留字施加了限制：

  implements		package		public 

  interface 		private 		static 

  let 				protected 	yield 

## 3.3 变量 ##
- 在严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。

PS：

- 变量应遵循一条著名的命名规则:
  Gamel标记法————首字母小写，接下来单词大写开头
  Pascal标记法————首字母大写，接下来单词大写开头
  匈牙利类型标记法————在Pascal标记法的变量前附加一个小写字母（或小写字母序列），说明类型。

  ```
  类型					前缀
  数组					a
  布尔型				b
  浮点型（数字）		f
  函数					fn
  整型（数字）			i
  对象					o
  正则表达式			re
  字符串				s
  变型（可以是任何类型）	v
  ```

- ECMAScript的解释程序遇到未声明过的标识符时，用该变量名创建一个全局变量，并将其初始化成指定的值。

## 3.4 数据类型

- ECMAScript中有5种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。还有1种复杂数据类型——Object，Object本质上是由一组无序的名值对组成的

### 3.4.1 typeof操作符

- 对变量或值调用typeof返回：undefined、boolen、number、string、object（引用类型Object或空类型）、function
- 注意，typeof是一个操作符而不是函数，圆括号尽管可以使用，但不是必需的。
- 有些时候，typeof操作符会返回一些令人迷惑但技术上却正确的值。比如，调用typeof null会返回"object"，因为特殊值null被认为是一个空的对象引用。Safari 5及之前版本、Chrome 7及之前版本在对正则表达式调用typeof操作符时会返回"function"，而其他浏览器在这种情况下会返回"object"。
- 从技术角度讲，函数在ECMAScript中是对象，不是一种数据类型。然而，函数也
  确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。

### 3.4.2 Undefined类型

- 当声明的变量未初始化时，默认值是undefined。
- 对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型（对未经声明的变量调用delete不会导致错误，但这样做没什么实际意义，而且在严格模式下确实会导致错误）。
- 注意，undefined并不同于未定义的值，但typeof运算符并不真正区分这两种值,都会返回undefined值。
- 当函数无明确返回值时，返回值也是undefined

### 3.4.3 Null类型

- 从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回"object"的原因
- 值undefined实际是从值null派生来的，因此两者相等
- 两者含义不同，undefined是声明了变量但未初始化，null表示尚未存在的对象。如果函数或方法要返回对象，返回通常是null。
- 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用
- 只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。

### 3.4.4 Boolean类型

- 有两个值true和false

- 即使false不等于0,0也可以转换成false

- 需要注意的是，Boolean类型的字面值true和false是区分大小写的。

- 可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。

  | 数据类型      | 换为true的值            | 转换为false的值 |
  | --------- | ------------------- | ---------- |
  | Boolean   | true                | false      |
  | String    | 任何非空字符串             | ""（空字符串）   |
  | Number    | 任何非零数字值（包括无穷大）      | 0和NaN      |
  | Object    | 任何对象                | null       |
  | Undefined | N/A（not applicable） | undefined  |

### 3.4.5 Number类型

- 使用IEEE754格式来表示整数和浮点数值
- 整数可以代表8进制（0开头）和16进制（0x开头），返回的结果都是十进制结果。
- 八进制字面量在严格模式下是无效的，会导致支持的JavaScript引擎抛出错误。

#### 1.浮点数值

- 浮点数必须包括小数点和小数点后的一位数字。
- ECMAScript会不失时机地将浮点数值转换为整数值。
- 浮点变量在计算前，真正存储的是字符串。
- 指数:e表示法（即科学计数法）e.g.3.2e7,3-e7
- 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。

#### 2.数值范围

几个特殊值也是Number类型:

- Number.MAX_VALUE和Number.MIN_VALUE，它们定义乐乐Number值集合的外边界。不过计算生成的值可以不在其间。


- 当生成数大于Number.MAX_VALUE，被赋值Number.POSITIVE_INFINITY,同样也有Number.NEGATIVE_INFINITY。可以调用isFinit()方法，确保该数不是无穷大。


- 访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正Infinity 的值。

#### 3.NaN

- NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。
- 任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。
- NaN与任何值都不相等，包括NaN本身。
- isNaN()函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试将这个值转换为数值。

#### 4.数值转换

- 有3个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。

##### Number()函数的转换规则：

- 如果是Boolean值，true和false将分别被转换为1和0。
- 如果是数字值，只是简单的传入和返回。
- 如果是null值，返回0。
- 如果是undefined，返回NaN。


- 如果是字符串，遵循下列规则：
  - 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值
  - 如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值（同样，也会忽略前导零）
  - 如果字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值
  - 如果字符串是空的（不包含任何字符），则将其转换为0；
  - 如果字符串中包含除上述格式之外的字符，则将其转换为NaN。


- 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。

##### parseInt()

- parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN；也就是说，用parseInt()转换空字符串会返回NaN（Number()对空字符返回0）。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。
- 如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式
- 在使用parseInt()解析像八进制字面量的字符串时，ECMAScript 3和5存在分歧。e.g.在ECMAScript 5 JavaScript引擎中，parseInt()已经不具有解析八进制值的能力，因此前导的零会被认为无效
- 为了消除在使用parseInt()函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。

##### parseFloat()

- 除了第一个小数点有效之外，parseFloat()与parseInt()的第二个区别在于它始终都会忽略前导的零。
- parseFloat()只解析十进制值，十六进制格式的字符串则始终会被转换成0
- 如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。

### 3.4.6 String类型

- 没有固定大小的原始值，用字符串存储0或更多的Unicode字符（由16位整数表示）
- 字面常量由""或’‘声明，两者功能相同。
- isNaN()确实也适用于对象。在基于对象调用isNaN()函数时，会首先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用toString()方法，再测试返回值。而这个过程也是ECMAScript中内置函数和操作符的一般执行流程

#### 1. 字符字面量

#### 2. 字符串的特点

- ECMAScript中的字符串是不可变的。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量

#### 3. 转换为字符串

##### toString()方法

- 数值、布尔值、对象和字符串值（没错，每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有toString()方法。但null和undefined值没有这个方法。


- 在调用数值的toString()方法时，可以传递一个参数：输出数值的基数

##### String()

- 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果
- 如果值是null，则返回"null"
- 如果值是undefined，则返回"undefined"

### 3.4.7 Object类型

- 在ECMAScript中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。（但这不是推荐的做法）


- Object的每个实例都具有下列属性和方法
  -  constructor：保存着用于创建当前对象的函数。
  -  hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定 
  -  isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型。
  -  propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
  -  toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
  -  toString()：返回对象的字符串表示。
  -  valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。


- ECMA-262中对象的行为不一定适用于JavaScript中的其他对象。浏览器环境中的对象，比如BOM和DOM中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。

## 3.5 操作符

### 3.5.1 一元操作符

#### 1. 递增和递减操作符

- 这4个操作符对任何值都适用，遵循下列规则
  -  在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字符串变量变成数值变量。
  -  在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN
                       字符串变量变成数值变量。
  -  在应用于布尔值false时，先将其转换为0再执行加减1的操作。布尔值变量变成数值变量。
  -  在应用于布尔值true时，先将其转换为1再执行加减1的操作。布尔值变量变成数值变量。
  -  在应用于浮点数值时，执行加减1的操作。
  -  在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。

#### 2. 一元加和减操作符

- 一元加操作符放在数值前面，对数值不会产生任何影响
- 在对非数值应用一元加操作符时，一元加操作符会像Number()转型函数一样对这个值执行转换。
- 一元减操作符应用于数值时，该值会变成负数
- 当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数

### 3.5.2 位操作符

- ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。


- 负数同样以二进制码存储，但使用的格式是二进制补码。


- 这个转换过程也导致了一个严重的副效应，即在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理。


- 如果对非数值应用位操作符，会先使用Number()函数将该值转换为一个数值（自动完成），然后
  再应用位操作。得到的结果将是一个数值。

#### 1. 按位非（NOT）

- 按位非操作的本质：操作数的负值减1。

#### 2. 按位与（AND）

#### 3. 按位或（OR

#### 4. 按位异或（XOR）

#### 5. 左移

- 左移不会影响操作数的符号位。

#### 6. 有符号的右移

- 符号位的值来填充空位

#### 7. 无符号右移

- 无符号右移是以0来填充空位

### 3.5.3 布尔操作符

#### 1. 逻辑非

- 逻辑非操作符遵循下列规则：
  - 如果操作数是一个对象，返回false；
  - 如果操作数是一个空字符串，返回true；
  - 如果操作数是一个非空字符串，返回false；
  - 如果操作数是数值0，返回true；
  - 如果操作数是任意非0数值（包括Infinity），返回false；
  - 如果操作数是null，返回true；
  - 如果操作数是NaN，返回true；
  - 如果操作数是undefined，返回true。


- 同时使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为

#### 2. 逻辑与

- 遵循规则：
  -  如果第一个操作数是对象，则返回第二个操作数；
  -  如果第二个操作数是对象，则只有在第一个操作数的求值结果为true 的情况下才会返回该对象；
  -  如果两个操作数都是对象，则返回第二个操作数；
  -  如果有一个操作数是null，则返回null；
  -  如果有一个操作数是NaN，则返回NaN；
  -  如果有一个操作数是undefined，则返回undefined。

#### 3. 逻辑或

- 遵循规则：
  - 如果第一个操作数是对象，则返回第一个操作数；
  - 如果第一个操作数的求值结果为false，则返回第二个操作数；
  - 如果两个操作数都是对象，则返回第一个操作数；
  - 如果两个操作数都是null，则返回null；
  - 如果两个操作数都是NaN，则返回NaN；
  - 如果两个操作数都是undefined，则返回undefined。

### 3.5.4 乘性操作符

#### 1. 乘法

- 遵循规则：
  - 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而
    如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；
  - 如果有一个操作数是NaN，则结果是NaN；
  - 如果是Infinity与0相乘，则结果是NaN；
  - 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号； 
  - 如果是Infinity与Infinity相乘，则结果是Infinity；
  - 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

#### 2. 除法

- 遵循规则：
  - 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而
    如果只有一个操作数有符号，那么结果就是负数。如果商超过了ECMAScript数值的表示范围，
    则返回Infinity或-Infinity；
  - 如果有一个操作数是NaN，则结果是NaN；
  - 如果是Infinity被Infinity除，则结果是NaN；
  - 如果是零被零除，则结果是NaN；
  - 如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
  - 如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
  - 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

#### 3.求模

- 遵循规则：
  - 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
  - 如果被除数是无穷大值而除数是有限大的数值，则结果是NaN；
  - 如果被除数是有限大的数值而除数是零，则结果是NaN；
  - 如果是Infinity被Infinity除，则结果是NaN；
  - 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
  - 如果被除数是零，则结果是零；
  - 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

### 3.5.5 加性操作符

#### 1. 加法

- 如果两个操作符都是数值，遵循规则：
  - 如果有一个操作数是NaN，则结果是NaN；
  - 如果是Infinity加Infinity，则结果是Infinity；
  - 如果是-Infinity加-Infinity，则结果是-Infinity；
  - 如果是Infinity加-Infinity，则结果是NaN；
  - 如果是+0加+0，则结果是+0；
  - 如果是0加0，则结果是0；
  - 如果是+0加0，则结果是+0。


- 如果两个操作符都是数值，遵循规则：
  - 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
  - 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。


- 如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。
- 对于undefined和null，则分别调用String()函数并取得字符串"undefined"和"null"。

#### 2. 减法

- 遵循规则：
  - 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；
  - 如果有一个操作数是NaN，则结果是NaN；
  - 如果是Infinity减Infinity，则结果是NaN；
  - 如果是-Infinity减-Infinity，则结果是NaN；
  - 如果是Infinity减-Infinity，则结果是Infinity；
  - 如果是-Infinity减Infinity，则结果是-Infinity；
  - 如果是+0减+0，则结果是+0；
  - 如果是+0减-0，则结果是-0
  - 如果是-0减-0，则结果是+0；
  - 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN；
  - 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

### 3.5.6 关系操作符

- 遵循规则：
  - 如果两个操作数都是数值，则执行数值比较。
  - 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
  - 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
  - 如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较。
  - 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。

### 3.5.7 相等操作符

#### 1. 相等和不相等

- 转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：
  - 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
  - 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
  - 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较


- 遵循规则:
  - null和undefined是相等的。
  - 要比较相等性之前，不能将null和undefined转换成其他任何值。
  - 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN。
  - 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

#### 2. 全等和不全等

- 除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符由3个等于号（===）表示，它只在两个操作数未经转换就相等的情况下返回true


- 由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。

### 3.5.8 条件操作符

### 3.5.9 赋值操作符

- 有符号右移/赋值（>>=）
- 无符号右移/赋值（>>>=）

### 3.5.10 逗号操作符

## 3.6语句

### 3.6.1 if语句

### 3.6.2 do-while语句

### 3.6.3 while语句

### 3.6.4 for语句

### 3.6.5 for-in语句

- for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。

  ```
  for (property in expression) statement
  ```


- ECMAScript对象的属性没有顺序。因此，通过for-in循环输出的属性名的顺序是不可预测的。


- 如果表示要迭代的对象的变量值为null 或undefined，for-in 语句会抛出错误。ECMAScript 5更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined。

### 3.6.6 label语句

### 3.6.7 break和continue语句

### 3.6.8 with语句

- with语句的作用是将代码的作用域设置到一个特定的对象中。


- with语句的语法如下：

  ```
  with (expression) statement; 
  ```


- 定义with语句的目的主要是为了简化多次编写同一个对象的工作


- 在with语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location对象中是否有同名的属性。如果发现了同名属性，则以location对象属性的值作为变量的值。


- 严格模式下不允许使用with语句，否则将视为语法错误。


- 由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。

### 3.6.9 switch语句

- 首先，可以在switch语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。
- 其次，每个case的值不一定是常量，可以是变量，甚至是表达式。


- switch语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串"10"不等于数值10）。

## 3.7 函数

- return语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回undefined值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。


- 严格模式对函数有一些限制：
  -  不能把函数命名为eval或arguments；
  -  不能把参数命名为eval或arguments；
  -  不能出现两个命名参数同名的情况。

### 3.7.1 理解参数

- ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。


- 实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。
- ECMAScript函数的一个重要特点：命名的参数只提供便利，但不是必需的。
- 另外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。但在ECMAScript中，没有这些条条框框，解析器不会验证命名参数。
- 另一个与参数相关的重要方面，就是arguments对象可以与命名参数一起使用
- 没有传递值的命名参数将自动被赋予undefined值。这就跟定义了变量但又没有初始化一样。
- 严格模式对如何使用arguments对象做出了一些限制。首先，有些赋值（直接修改arguments等）会变得无效。其次，重写arguments的值会导致语法错误（代码将不会执行）。
- ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。

### 3.7.2 没有重载

- ECMAScript函数不能像传统意义上那样实现重载。
- ECMAScirpt函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。
- 如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。
- 通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。

## 3.8小结

# 第4章 变量、作用域和内存问题

## 4.1 基本类型和引用类型的值

- 在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。
- 与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。
- 引用类型的值是按引用访问的

### 4.1.1 动态的属性

### 4.1.2 复制变量值

### 4.1.3 传递参数

### 4.1.4 检测类型

- ECMAScript提供了instanceof操作符

  ```
  result= variableinstanceof constructor
  ```


- IE和Firefox中，对正则表达式应用typeof会返回"object"。

## 4.2 执行环境及作用域

- 每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。
- 在Web浏览器中，全局执行环境被认为是window对象
- 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。


- 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。

### 4.2.1 延长作用域链

- 有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。
  - try-catch语句的catch块；
  - with语句。


- 对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。


- 在IE8 及之前版本的JavaScript 实现中，存在一个与标准不一致的地方，即在catch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句的变量对象中。换句话说，即使是在catch块的外部也可以访问到错误对象。IE9修复了这个问题。

### 4.2.2 没有块级作用域

- 在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。在使用for语句时尤其要牢记这一差异，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在
  于循环外部的执行环境中。

#### 1. 声明变量

- 使用var声明的变量会自动被添加到最接近的环境中。

#### 2. 查询标识符

- 搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。

## 4.3 垃圾收集

- 垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，通常有两个策略。

### 4.3.1 标记清除

- 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

### 4.3.2 引用计数

- 引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。
- BOM和DOM中的对象就是使用C++以COM（Component Object Model，组件对象模型）对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。
- 只要在IE中涉及COM对象，就会存在循环引用的问题。


- IE9把BOM和DOM对象都转换成了真正的JavaScript对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。

### 4.3.3 性能问题

- IE的垃圾收集器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象（或数组）字面量和数组元素（slot）或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。


- IE7改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。


- 事实上，在有的浏览器中可以触发垃圾收集过程，但不建议这样做。在IE中，调用window.CollectGarbage()方法会立即执行垃圾收集。在Opera 7及更高版本中，调用window.opera.collect()也会启动垃圾收集例程。

### 4.3.4 管理内存

- 其中最主要的一个问题，就是分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。


- 优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用（dereferencing）。


- 解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收

## 4.4 小结

- 引用类型的值是对象，保存在堆内存中；
- 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符
- 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
- 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；

# 第5章 引用类型 

- 在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。
- 引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。
- 虽然引用类型与类看起来相似，但它们并不是相同的概念。

## 5.1 Object类型

- 创建Object实例的方式有两种。
  - 第一种是使用new操作符后跟Object构造函数
  - 另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。


- 使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象


- 在通过对象字面量定义对象时，实际上不会调用Object构造函数（Firefox 2及更早版本会调用Object构造函数；但Firefox 3之后就不会了）。


- 一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。


- 方括号语法Vs点表示法：
  - 主要优点是可以通过变量来访问属性
  - 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。


- 通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。

## 5.2 Array类型

- 创建数组的基本方式有两种。
  - 第一种是使用Array构造函数
    - 可以给构造函数传递该数量
    - 可以向Array构造函数传递数组中应该包含的项
    - 在使用Array构造函数时也可以省略new操作符
  - 第二种基本方式是使用数组字面量表示法


- 在数组字面量的最后一项添加逗号的结果：在IE中，values会成为一个包含3个项且每项的值分别为1、2和undefined的数组；在其他浏览器中，values会成为一个包含2项且值分别为1和2的数组。在像这种省略值的情况下，IE8及之前版本每一项都将获得undefined值；


- 与对象一样，在使用数组字面量表示法时，也不会调用Array构造函数


- 数组的length属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。再访问就会显示undefined


- 如果将其length属性设置为大于数组项数的值，则新增的每一项都会取得undefined值


- 数组最多可以包含4 294 967 295个项，而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。

### 5.2.1 检测数组

- 对于一个网页，或者一个全局作用域而言，使用instanceof操作符就能得到满意的结果问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。


- Array.isArray()方法，这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。用法如下：

  ```
  if (Array.isArray(value)){ 
  //对数组执行某些操作
  } 
  ```


- 支持Array.isArray()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 10.5+和Chrome。

### 5.2.2 转换方法

- 调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。
- 调用valueOf()返回的还是数组。


- 当调用数组的toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的toLocale- String()方法，而不是toString()方法。


- alert()要接收字符串参数，所以它会在后台调用toString()方法
- 数组继承的toLocaleString()、toString()和valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。


- 如果使用join()方法，则可以使用不同的分隔符来构建这个字符串。join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。


- 如果数组中的某一项的值是null 或者undefined，那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示。

### 5.2.3 栈方法

- push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。
- pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。

### 5.2.4 队列方法

- shift()，它能够移除数组中的第一个项并返回该项，同时将数组长度减1。
- ECMAScript还为数组提供了一个unshift()方法。顾名思义，unshift()与shift()的用途相反：它能在数组前端添加任意个项并返回新数组的长度。


- IE7及更早版本对JavaScript的实现中存在一个偏差，其unshift()方法总是返回undefined而不是数组的新长度。IE8在非兼容模式下会返回正确的长度值。

### 5.2.5 重排序方法

- reverse()方法会反转数组项的顺序。
- 默认情况，sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。因此，这种排序方式在很多情况下都不是最佳方案。

### 5.2.6 操作方法

- concat()方法
  - 可以基于当前数组中的所有项创建一个新数组。
  - 具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。


- slice()方法
  - 它能够基于当前数组中的一或多个项创建一个新数组。
  - slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。
  - 在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。
  - 如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。
  - 注意，slice()方法不会影响原始数组。
  - 如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。
  - 如果结束位置小于起始位置，则返回空数组。


- splice()方法
  - 主要用途是向数组的中部插入项
  - 使用方式：
    - **删除**：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。
    - **插入**：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。
    - **替换**：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起
      始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。
  - 返回一个数组，该数组中包含从原始数组中删除的项

### 5.2.7 位置方法

- indexOf()和lastIndexOf()。
  - 都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。
  - 其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。
  - 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1
  - 在比较第一个参数与数组中的每一项时，会使用全等操作符
  - 支持它们的浏览器包括IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。

### 5.2.8 迭代方法

- 定义了5个迭代方法。
  - 每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值。
  - 传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。
  - 返回值
    - every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true
    - filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。
    - forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
    - map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
    - some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
  - 以上方法都不会修改数组中的包含的值。
  - every()和some()，它们都用于查询数组中的项是否满足某个条件。
  - forEach()本质上与使用for循环迭代数组一样。
  - 支持这些迭代方法的浏览器有IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。

### 5.2.9 归并方法

- reduce()和reduceRight()。
  - 都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。
  - 都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。
  - 支持这两个归并函数的浏览器有IE9+、Firefox 3+、Safari 4+、Opera 10.5和Chrome。

## 5.3 Date类型

- Date类型使用自UTC


- 为了简化传入表示该日期的毫秒数的过程，提供了两个方法：Date.parse()和Date.UTC()。
- Date.parse()
  - Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。
  - ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。美国的浏览器通常都接受下列日期格式：
    - “月/日/年”，如6/13/2004；
    - “英文月名 日,年”，如January 12,2004；
    - “英文星期几 英文月名 日 年 时:分:秒 时区”，如Tue May 25 2004 00:00:00 GMT-0700。
    - ISO 8601 扩展格式YYYY-MM-DDTHH:mm:ss.ss（例如2004-05-25T00:00:00）。只有兼容
      ECMAScript 5的实现支持这种格式。
  - 如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。
  - 不同浏览器中的实现有许多奇怪的行为，有一种倾向是将超出范围的值替换成当前的值，以便生成输出。而Opera则倾向于插入当前月份的当前日期


- Date.UTC()
  - 返回表示日期的毫秒数。
  - Date.UTC()的参数分别是年份、基于0的月份（一月是0，二月是1，以此类推）、月中的哪一天（1到31）、小时数（0到23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0。


- ECMAScript 5添加了Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。
  - 支持Data.now()方法的浏览器包括IE9+、Firefox 3+、Safari 3+、Opera 10.5和Chrome。在不支
    持它的浏览器中，使用+操作符把Data对象转换成字符串，也可以达到同样的目的。

### 5.3.1 继承的方法

- Date类型也重写了toLocaleString()、toString()和valueOf()方法
  - Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息
  - toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。
  - Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。。因此，可以方便使用比较操作符（小于或大于）来比较日期值。

### 5.3.2 日期格式化方法

- 将日期格式化为字符串的方法
  - toDateString()——以特定于实现的格式显示星期几、月、日和年；
  - toTimeString()——以特定于实现的格式显示时、分、秒和时区；
  - toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
  - toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
  - toUTCString()——以特定于实现的格式完整的UTC日期。


-  还有一个名叫toGMTString()的方法，这是一个与toUTCString()等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript推荐现在编写的代码一律使用toUTCString()方法。

### 5.3.3日期/时间组件方法

- UTC日期指的是在没有时区偏差的情况下（将日期转换为GMT时间）的日期值。

| 方 法                    | 说 明                                    |
| :--------------------- | :------------------------------------- |
| getTime()              | 返回表示日期的毫秒数；与valueOf()方法返回的值相同          |
| setTime(毫秒)            | 以毫秒数设置日期，会改变整个日期                       |
| getFullYear()          | 取得4位数的年份（如2007而非仅07）                   |
| getUTCFullYear()       | 返回UTC日期的4位数年份                          |
| setFullYear(年)         | 设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）      |
| setUTCFullYear(年)      | 设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）   |
| getMonth()             | 返回日期中的月份，其中0表示一月，11表示十二月               |
| getUTCMonth()          | 返回UTC日期中的月份，其中0表示一月，11表示十二月            |
| setMonth(月)            | 设置日期的月份。传入的月份值必须大于0，超过11则增加年份          |
| setUTCMonth(月)         | 设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份       |
| getDate()              | 返回日期月份中的天数（1到31）                       |
| getUTCDate()           | 返回UTC日期月份中的天数（1到31）                    |
| setDate(日)             | 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份     |
| setUTCDate(日)          | 设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份  |
| getDay()               | 返回日期中星期的星期几（其中0表示星期日，6表示星期六）           |
| getUTCDay()            | 返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六）        |
| getHours()             | 返回日期中的小时数（0到23）                        |
| getUTCHours()          | 返回UTC日期中的小时数（0到23）                     |
| setHours(时)            | 设置日期中的小时数。传入的值超过了23则增加月份中的天数           |
| setUTCHours(时)         | 设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数        |
| getMinutes()           | 返回日期中的分钟数（0到59）                        |
| getUTCMinutes()        | 返回UTC日期中的分钟数（0到59）                     |
| setMinutes(分)          | 设置日期中的分钟数。传入的值超过59则增加小时数               |
| setUTCMinutes(分)       | 设置UTC日期中的分钟数。传入的值超过59则增加小时数            |
| getSeconds()           | 返回日期中的秒数（0到59）                         |
| getUTCSeconds()        | 返回UTC日期中的秒数（0到59）                      |
| setSeconds(秒)          | 设置日期中的秒数。传入的值超过了59会增加分钟数               |
| setUTCSeconds(秒)       | 设置UTC日期中的秒数。传入的值超过了59会增加分钟数            |
| getMilliseconds()      | 返回日期中的毫秒数                              |
| getUTCMilliseconds()   | 返回UTC日期中的毫秒数                           |
| setMilliseconds(毫秒)    | 设置日期中的毫秒数                              |
| setUTCMilliseconds(毫秒) | 设置UTC日期中的毫秒数                           |
| getTimezoneOffset()    | 返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某 |

## 5.4 RegExp类型

- 语法

  ```
  var expression = /pattern/ flags ;
  ```
  - 模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。
    - g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
    - i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
    - m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。


- 模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：( [ { \ ^ $ | ) ? * + .]} 


- 另一种创建正则表达式的方式是使用RegExp构造函数
  - 它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。
  - 由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此（例如字符\会变成`\\\\`）


- 在ECMAScript 3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例


- ECMAScript 5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例。IE9+、Firefox 4+和Chrome都据此做出了修改。

### 5.4.1 RegExp实例属性

- RegExp属性
  -  global：布尔值，表示是否设置了g标志。
  -  ignoreCase：布尔值，表示是否设置了i标志。
  -  lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。
  -  multiline：布尔值，表示是否设置了m标志。
  -  source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。

### 5.4.2 RegExp实例方法

- 主要方法是exec()，该方法是专门为捕获组而设计的。
  - exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。
  - 返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。
  - 对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不
    设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项
  - IE 的JavaScript 实现在lastIndex 属性上存在偏差，即使在非全局模式下，lastIndex属性每次也会变化。


- 第二个方法是test()
  - 接受一个字符串参数
  - 在模式与该参数匹配的情况下返回true；否则，返回false。
  - test()方法经常被用在if语句中
- RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。即使是通过调用RegExp构造函数创建的。
- 正则表达式的valueOf()方法返回正则表达式本身。


### 5.4.3 RegExp构造函数属性

- RegExp构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。

- 这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。

- 这些属性分别有一个长属性名和一个短属性名（Opera是例外，它不支持短属性名）。

  - | 长属性名         | 短属性名 | 说 明                                 |
    | ------------ | ---- | ----------------------------------- |
    | input        | $_   | 最近一次要匹配的字符串。Opera未实现此属性             |
    | lastMatch    | $&   | 最近一次的匹配项。Opera未实现此属性                |
    | lastParen    | $+   | 最近一次匹配的捕获组。Opera未实现此属性              |
    | leftContext  | $`   | input字符串中lastMatch之前的文本             |
    | multiline    | $*   | 布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性 |
    | rightContext | $'   | Input字符串中lastMatch之后的文本             |

  - 由于这些短属性名大都不是有效的ECMAScript标识符，因此必须通过方括号语法来访问它们

- 还有多达9个用于存储捕获组的构造函数属性。访问这些属性的语法是RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。

### 5.4.4 模式的局限性

- ECMAScript正则表达式不支持的特性
  - 匹配字符串开始和结尾的\A和\Z锚（ 但支持以插入符号（^）和美元符号（$）来匹配字符串的开始和结尾。）
  - 向后查找（lookbehind）（但完全支持向前查找（lookahead）。）
  - 并集和交集类
  - 原子组（atomic grouping）
  - Unicode支持（单个字符除外，如\uFFFF）
  - 命名的捕获组(但支持编号的捕获组。)
  - s（single，单行）和x（free-spacing，无间隔）匹配模式
  - 条件匹配
  - 正则表达式注释

## 5.5 Function类型

- 每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。
- 由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。


- 函数定义的方式:
  - 函数声明语法定义

    ```
    function sum (num1, num2) { 
    return num1 + num2; 
    } 
    ```

  - 函数表达式定义

    ```
    var sum = function(num1, num2){ 
    return num1 + num2; 
    }; 
    ```

  - 使用Function构造函数

    ```
    var sum = new Function("num1", "num2", "return num1 + num2");
    ```

    - Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。
    - 不推荐, 因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串）
    - 利于理解“函数是对象，函数名是指针”的概念

### 5.5.1 没有重载（深入理解）

- 将函数名想象为指针，也有助于理解为什么ECMAScript中没有函数重载的概念。


### 5.5.2 函数声明与函数表达式

- 解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。


- 在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。


- 除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。
- 可以同时使用函数声明和函数表达式，例如var sum = function sum(){}。不过，这种语法在Safari中会导致错误。

### 5.5.3 作为值的函数

- 可将一个函数作为另一个函数的结果返回，这也是极为有用的一种技术。



- 要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。

### 5.5.4 函数内部属性

- 函数内部有两个特殊的对象：arguments和this。
- arguments
  - arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。
    - 可解决递归算法的函数的执行与函数名紧密耦合


- this
  - this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。


- ECMAScript 5也规范化了另一个函数对象的属性：caller。（Opera的早期版本不支持）
  - 这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。


- 当函数在严格模式下运行时，访问arguments.callee 会导致错误。ECMAScript 5还定义了arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清arguments.caller和函数的caller属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。

### 5.5.5 函数属性和方法

- ECMAScript中的函数是对象。每个函数都包含两个属性：length和prototype。


- length
  - 表示函数希望接收的命名参数的个数


- prototype
  - 对于ECMAScript中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。
  - 创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的
  - 在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。


- 每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。
- apply()
  - apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。
  - 在严格模式下，未指定环境对象而调用函数，则this值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this 值将是undefined。
- call()方法
  - call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。
  - 对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来
- 事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。



//---缺了很多东西，sigh



# 第8章 BOM

## 8.1 window

### 8.1.1 全局作用域

- 全局变量（函数）会成为window对象的属性

- 定义全局变量与在window对象上直接定义属性差别：

  - 全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。

    [^原因]: 使用var语句添加的window属性有一个名为[[Configurable\]\]的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete操作符删除。IE8及更早版本在遇到使用delete删除window属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9及更高版本不会抛出错误。

  - 尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在。

- Windows Mobile平台的IE浏览器不允许通过window.property = value之类的形式，直接在window对象上创建新的属性或方法。可是，在全局作用域中声明的所有变量和函数，照样会变成window对象的成员。

### 8.1.2 窗口关系及框架

- 如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象。每个window对象都有一个name属性，其中包含框架的名称。


- top对象始终指向最高（最外）层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。因为对于在一个框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而非最高层的框架。所以最好使用top而非window

- parent（父）对象始终指向当前框架的直接上层框架。在某些情况下，parent有可能等于top；但在没有框架的情况下，parent一定等于top（此时它们都等于window）。

  > 注意，除非最高层窗口是通过window.open()打开的（本章后面将会讨论），否则其window对象的name属性不会包含任何值。

- self对象，它始终指向window；实际上，self和window对象可以互换使用。引入self对象的目的只是为了与top和parent对象对应起来，因此它不格外包含其他值。

  > 在使用框架的情况下，浏览器中会存在多个Global对象。在每个框架中定义的全局变量会自动成为框架中window对象的属性。由于每个window对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。例如，top.Object并不等于top.frames[0].Object。这个问题会影响到对跨框架传递的对象使用instanceof操作符。

### 8.1.3 窗口位置

- 使用screenLeft 和screenTop，无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。

  > IE、Safari、Opera和Chrome都提供了screenLeft 和screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox则在screenX和screenY属性中提供相同的窗口位置信息，Safari和Chrome也同时支持这两个属性。Opera虽然也支持screenX和screenY属性，但与screenLeft和screenTop属性并不对应，因此建议大家不要在Opera中使用它们。

  > 在IE、Opera中，screenLeft和screenTop中保存的是从屏幕左边和上边到由window对象表示的页面可见区域的距离。换句话说，如果window对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即y轴坐标为0，那 么screenTop的值就是位于页面可见区域上方的浏览器工具栏的像素高度。但是，在Chrome、Firefox和Safari中，screenY或screenTop中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y轴坐标为0时返回0

  > Firefox、Safari和Chrome始终返回页面中每个框架的top.screenX 和top.screenY 值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用screenX和screenY每次也都会返回相同的值。而IE和Opera则会给出框架相对于屏幕边界的精确坐标值。

- 使用moveTo()和moveBy()方法倒是有可能将窗口精确地移动到一个新位置。两个方法都接收两个参数，moveTo()接收的是新位置的x和y坐标值，而moveBy()接收的是在水平和垂直方向上移动的像素数。

  > 需要注意的是，这两个方法可能会被浏览器禁用；而且，在Opera和IE 7（及更高版本）中默认就是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window对象使用。

### 8.1.4 窗口大小

- 4个属性：innerWidth、innerHeight、outerWidth和outerHeight。

  - 在IE9+、Safari和Firefox中，outerWidth和outerHeight返回浏览器窗口本身的尺寸（无论是从最外层的window对象还是从某个框架访问）。
  - 在Opera中，这两个属性的值表示页面视图容器的大小。而innerWidth和innerHeight
    则表示该容器中页面视图区的大小（减去边框宽度）。
  - 在Chrome中，outerWidth、outerHeight 与innerWidth、innerHeight返回相同的值，即视口（viewport）大小而非浏览器窗口大小。
  - IE8及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过DOM提供了页面可见区域的相关信息。

- 在IE、Firefox、Safari、Opera和Chrome中，document.documentElement.clientWidth和
  document.documentElement.clientHeight中保存了页面视口的信息。在IE6中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过document.body.clientWidth和document.body. clientHeight取得相同信息。而对于混杂模式下的Chrome，则无论通过document.documentEle- ment还是document.body中的clientWidth和clientHeight属性，都可以取得视口的大小。虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小

- 对于移动设备，window.innerWidth和window.innerHeight保存着可见视口，也就是屏幕上可见页面区域的大小。

  - 移动IE 浏览器不支持这些属性，但通过document.documentElement.clientWidth和document.documentElement.clientHeihgt提供了相同的信息。
  - 在其他移动浏览器中，document.documentElement 度量的是布局视口，即渲染后页面的实际大小（与可见视口不同，可见视口只是整个页面中的一小部分）。移动IE 浏览器把布局视口的信息保存在document.body.clientWidth和document.body.clientHeight中。这些值不会随着页面缩放变化。

- 使用resizeTo()和resizeBy()方法可以调整浏览器窗口的大小。resizeTo()接收浏览器窗口的新宽度和新高度，而resizeBy()接收新窗口与原窗口的宽度和高度之差。

  > 这两个方法与移动窗口位置的方法类似，也有可能被浏览器禁用；而且，在Opera和IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的window对象使用。

### 8.1.5 导航和打开窗口

- window.open()方法
  - 接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。
  - 第二个参数， 可以是已有窗口或框架的名称，也可以是特殊的窗口名称：\_self、\_parent、\_top或\_blank。

1. #### 弹出窗口

   - 如果传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。

   - 第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下表列出了可以出现在这个字符串中的设置选项。

     | 设 置        | 值      | 说 明                                      |
     | ---------- | ------ | ---------------------------------------- |
     | fullscreen | yes或no | 表示浏览器窗口是否最大化。仅限IE                        |
     | height     | 数值     | 表示新窗口的高度。不能小于100height  数值  表示新窗口的高度。不能小于100 |
     | left       | 数值     | 表示新窗口的左坐标。不能是负值                          |
     | location   | yes或no | 表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏可能会隐藏，也可能会被禁用（取决于浏览器） |
     | menubar    | yes或no | 表示是否在浏览器窗口中显示菜单栏。默认值为no                  |
     | resizable  | yes或no | 表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为no           |
     | scrollbars | yes或no | 表示如果内容在视口中显示不下，是否允许滚动。默认值为no             |
     | status     | yes或no | 表示是否在浏览器窗口中显示状态栏。默认值为no                  |
     | toolbar    | yes或no | 表示是否在浏览器窗口中显示工具栏。默认值为no                  |
     | top        | 数值     | 表示新窗口的上坐标。不能是负值                          |
     | width      | 数值     | 表示新窗口的宽度。不能小于100                         |

   > 可以通过逗号分隔的名值对列表来指定,其中，名值对以等号表示（注意，整个特性字符串中不允许出现空格）其中，名值对以等号表示（注意，整个特性字符串中不允许出现空格）

- window.open()方法会返回一个指向新窗口的引用。引用的对象与其他window对象大致相似，但我们可以对其进行更多控制。
- close()方法还可以关闭新打开的窗口。
  - 仅适用于通过window.open()打开的弹出窗口。
  - 对于浏览器的主窗口，如果没有得到用户的允许是不能关闭它的。
  - 弹出窗口倒是可以调用top.close()在不经用户允许的情况下关闭自己。弹出窗口关闭之后，窗口的引用仍然还在，但除了像下面这样检测其closed属性之外，已经没有其他用处了。
  - 新创建的window对象有一个opener属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window对象（top）中有定义，而且指向调用window.open()的窗口或框架。
  - 有些浏览器（如IE8和Chrome）会在独立的进程中运行每个标签页。当一个标签页打开另一个标签页时，如果两个window对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。在Chrome中，将新创建的标签页的opener属性设置为null，即表示在单独的进程中运行新标签页

1. #### 安全限制

   - 对弹出窗口施加了多方面的安全限制
   - 在打开计算机硬盘中的网页时，IE会解除对弹出窗口的某些限制。但是在服务器上执行这些代码会受到对弹出窗口的限制。

2. #### 弹出窗口屏蔽程序

   - 如果是浏览器内置的屏蔽程序阻止的弹出窗口，那么window.open()很可能会返回null
   - 如果是浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误。
   - 因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对window.open()的调用封装在一个try-catch块中，如下所示。

### 8.1.6 间歇调用和超时调用

- 超时调用需要使用window对象的setTimeout()方法，它接受两个参数：要执行的代码和以毫秒
  表示的时间（即在执行代码前需要等待多少毫秒）。由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数。
- setTimeout()的第二个参数告诉JavaScript再过多长时间把当前任务添加到队列中。
- 要取消尚未执行的超时调用计划，可以调用clearTimeout()方法并将相应的超时调用ID作为参数传递给它

> 超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined。

- 设置间歇调用的方法是setInterval()，它接受的参数与setTimeout()相同
- 一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而使用超时调用，则完全可以避免这一点。

### 8.1.7 系统对话框

- alert()、confirm()和prompt()方法
- 这几个方法打开的对话框都是同步和模态的。
- prompt()方法生成的，这是一个“提示”框，用于提示用户输入一些文本。提示框中除了显示OK和Cancel按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。
  - prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。
- Google Chrome浏览器还引入了一种新特性。如果当前脚本在执行过程中会打开两个或多个对话框，那么从第二个对话框开始，每个对话框中都会显示一个复选框，以便用户阻止后续的对话框显示，除非用户刷新页面（见图8-6）。IE9和Firefox 4也实现了它。
- “查找”和“打印”。这两个对话框都是异步显示的，能够将控制权立即交还给脚本。这两个对话框与用户通过浏览器菜单的“查找”和“打印”命令打开的对话框相同。而在JavaScript中则可以像下面这样通过window对象的find()和print()方法打开它们。这两个方法同样不会就用户在对话框中的操作给出任何信息，因此它们的用处有限。Chrome的对话框计数器也不会将它们计算在内。

## 8.2 location对象

- location 对象是很特别的一个对象，因为它既是window 对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。

- location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。

  | 属 性 名    | 例 子                  | 说 明                                      |
  | -------- | -------------------- | ---------------------------------------- |
  | hash     | "#contents"          | 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 |
  | host     | "www.wrox.com:80"    | 返回服务器名称和端口号（如果有）                         |
  | hostname | "www.wrox.com"       | 返回不带端口号的服务器名称                            |
  | href     | "http:/www.wrox.com" | 返回当前加载页面的完整URL。而location对象的              |
  | pathname | "/WileyCDA/"         | 返回URL中的目录和（或）文件名                         |
  | port     | "8080"               | 返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串    |
  | protocol | "http:"              | 返回页面使用的协议。通常是http:或https:                |
  | search   | "?q=javascript"      | 返回URL的查询字符串。这个字符串以问号开头                   |

### 8.2.1 查询字符串参数

- 上面的属性访问URL包含的查询字符串的属性并不方便。尽管location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。因此需要创建函数

### 8.2.2 位置操作

- 使用location对象改变浏览器的位置

  - 使用assign()方法并为其传递一个URL

    ```
    location.assign("http://www.wrox.com");
    ```

  - 如果是将location.href 或 window.location设置为一个URL值，也会以该值调用assign()方法。

    ```
    window.location = "http://www.wrox.com"; 
    location.href = "http://www.wrox.com"; 
    ```

  - 修改location对象的其他属性也可以改变当前加载的页面。

    - 每次修改location的属性（hash除外），页面都会以新URL重新加载。

    > 在IE8、Firefox 1、Safari 2+、Opera 9+和Chrome中，修改hash的值会在浏览器的历史记录中生成一条新记录。在IE的早期版本中，hash属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含hash的URL时才会被更新。

  - 上述任何一种方式修改URL之后，浏览器的历史记录中就会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用replace()方法。

    - 只接受一个参数，即要导航到的URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录。

  - reload() 方法，作用是重新加载当前显示的页面。

    - 如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true。
    - 位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。

## 8.3 navigator对象

- navigator对象，现在已经成为识别客户端浏览器的事实标准。

| 属性或方法                     | 说 明                                      |
| ------------------------- | ---------------------------------------- |
| appCodeName               | 浏览器的名称。通常都是Mozilla，即使在非Mozilla浏览器中也是如此   |
| appMinorVersion           | 次版本信息                                    |
| appName                   | 完整的浏览器名称                                 |
| appVersion                | 浏览器的版本。一般不与实际的浏览器                        |
| buildID                   | 浏览器编译版本                                  |
| cookieEnabled             | 表示cookie是否启用                             |
| cpuClass                  | 客户端计算机中使用的CPU类型（x86、68K、Alpha、PPC或Other） |
| javaEnabled()             | 表示当前浏览器中是否启用了Java                        |
| language                  | 浏览器的主语言                                  |
| mimeTypes                 | 在浏览器中注册的MIME类型数组                         |
| onLine                    | 表示浏览器是否连接到了因特网                           |
| opsProfile                | 似乎早就不用了。查不到相关文档                          |
| oscpu                     | 客户端计算机的操作系统或使用的CPU                       |
| platform                  | 浏览器所在的系统平台                               |
| plugins                   | 浏览器中安装的插件信息的数组                           |
| preference()              | 设置用户的首选项                                 |
| product                   | 产品名称（如 Gecko）                            |
| productSub                | 关于产品的次要信息（如Gecko的版本）                     |
| registerContentHandler()  | 针对特定的MIME类型将一个站点注册为处理程序                  |
| registerProtocolHandler() | 针对特定的协议将一个站点注册为处理程序                      |
| securityPolicy            | 已经废弃。安全策略的名称。为了与Netscape Navigator 4向后兼容而保留下来 |
| systemLanguage            | 操作系统的语言                                  |
| taintEnabled()            | 已经废弃。表示是否允许变量被修改（taint）。为了与Netscape Navigator 3向后兼容而保留下来 |
| userAgent                 | 浏览器的用户代理字符串                              |
| userLanguage              | 操作系统的默认语言                                |
| userProfile               | 借以访问用户个人信息的对象                            |
| vendor                    | 浏览器的品牌                                   |
| vendorSub                 | 有关供应商的次要信息                               |

### 8.3.1 检测插件

- 对于非IE 浏览器，可以使用plugins数组。该数组中的每一项都包含下列属性

  - name：插件的名字。
  - description：插件的描述。
  - filename：插件的文件名。
  - length：插件所处理的MIME类型数量。

  > 每个插件对象本身也是一个MimeType对象的数组，这些对象可以通过方括号语法来访问。每个MimeType对象有4个属性：包含MIME类型描述的description、回指插件对象的enabledPlugin、表示与MIME类型对应的文件扩展名的字符串suffixes（以逗号分隔）和表示完整MIME类型字符串的type。

- 在IE 中检测插件的唯一方式就是使用专有的ActiveXObject类型，并尝试创建一个特定插件的实例。IE是以COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其COM标识符。

> plugins集合有一个名叫refresh()的方法，用于刷新plugins以反映最新安装的插件。这个方法接收一个参数：表示是否应该重新加载页面的一个布尔值。如果将这个值设置为true，则会重新加载包含插件的所有页面；否则，只更新plugins集合，不重新加载页面。

### 8.3.2 注册处理程序

- registerContentHandler()和registerProtocolHandler()方法。HTML5中定义。这两个方法可以让一个站点指明它可以处理特定类型的信息。
- registerContentHandler()方法接收三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名称。
- registerProtocolHandler()方法，它也接收三个参数：要处理的协议（例如，mailto或ftp）、处理该协议的页面的URL和应用程序的名称。

## 8.4 screen对象

- screen对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息

| 属 性                  | 说 明                    |
| -------------------- | ---------------------- |
| availHeight          | 屏幕的像素高度减系统部件高度之后的值（只读） |
| availLeft            | 未被系统部件占用的最左侧的像素值（只读）   |
| availTop             | 未被系统部件占用的最上方的像素值（只读）   |
| availWidth           | 屏幕的像素宽度减系统部件宽度之后的值（只读） |
| bufferDepth          | 读、写用于呈现屏外位图的位数         |
| colorDepth           | 用于表现颜色的位数；多数系统都是32（只读） |
| deviceXDPI           | 屏幕实际的水平DPI（只读）         |
| deviceYDPI           | 屏幕实际的垂直DPI（只读）         |
| fontSmoothingEnabled | 表示是否启用了字体平滑（只读）        |
| height               | 屏幕的像素高度                |
| left                 | 当前屏幕距左边的像素距离           |
| logicalXDPI          | 屏幕逻辑的水平DPI（只读）         |
| logicalYDPI          | 屏幕逻辑的垂直DPI（只读）         |
| pixelDepth           | 屏幕的位深（只读）              |
| top                  | 当前屏幕距上边的像素距离           |
| updateInterval       | 读、写以毫秒表示的屏幕刷新时间间隔      |
| width                | 屏幕的像素宽度                |

## 8.5 history对象

- 使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。
  - 这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。
  - 可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做


- 可以使用两个简写方法back()和forward()来代替go()。
- history对象还有一个length属性，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length等于0。
- 当页面的URL改变时，就会生成一条历史记录。在IE8 及更高版本、Opera、Firefox、Safari 3及更高版本以及Chrome中，这里所说的改变包括URL中hash的变化（因此，设置location.hash会在这些浏览器中生成一条新的历史记录）。

## 8.6 小结



# 第9章 客户端检测

## 9.1 能力检测

- 能力检测的基本模式如下：
  ​

  ```
  if (object.propertyInQuestion){ 
  	//使用object.propertyInQuestion 
  } 
  ```

- 两个重要的概念

  - 先检测达成目的的最常用的特性。
  - 必须测试实际要用到的特性。一个特性存在，不一定意味着另一个特性也存在。

### 9.1.1 更可靠的能力检测

- 能力检测对于想知道某个特性是否会按照适当方式行事（而不仅仅是某个特性存在）非常有用。
- 在可能的情况下，要尽量使用typeof进行能力检测。特别是，宿主对象没有义务让typeof返回合理的值。
  - DOM对象是宿主对象，IE及更早版本中的宿主对象是通过COM而非JScript实现的。因此，document.createElement()函数确实是一个COM对象，所以typeof才会返回"object"。IE9纠正了这个问题，对所有DOM方法都返回"function"。
  - 关于typeof的行为不标准，ActiveX对象（只有IE支持）与其他对象的行为差异很大。
- 目前使用isHostMethod()方法还是比较可靠的，因为它考虑到了浏览器的怪异行为。

```
function isHostMethod(object, property) { 
    var t = typeof object[property]; 
    return t=='function' || 
    (!!(t=='object' && object[property])) || 
    t=='unknown'; 
} 
```

### 9.1.2 能力检测，不是浏览器检测

- 检测某个或某几个特性并不能够确定浏览器。实际上，根据浏览器不同将能力组合起来是更可取的方式。

## 9.2 怪癖检测

- 怪癖检测（quirks detection）的目标是识别浏览器的特殊行为。但与能力检测确认浏览器支持什么能力不同，怪癖检测是想要知道浏览器存在什么缺陷（“怪癖”也就是bug）。

## 9.3 用户代理检测

- 争议最大的一种客户端检测技术叫做用户代理检测。用户代理检测通过检测用户代理字符串来确定实际使用的浏览器。在每一次HTTP请求过程中，用户代理字符串是作为响应首部发送的，而且该字符串可以通过JavaScript的navigator.userAgent属性访问。
- 在服务器端，通过检测用户代理字符串来确定用户使用的浏览器是一种常用而且广为接受的做法。而在客户端，用户代理检测一般被当作一种万不得已才用的做法，其优先级排在能力检测和（或）怪癖检测之后。
- 所谓电子欺骗，就是指浏览器通过在自己的用户代理字符串加入一些错误或误导性信息，来达到欺骗服务器的目的。

9.3.1 用户代理字符串的历史

- HTTP规范（包括1.0和1.1版）明确规定，浏览器应该发送简短的用户代理字符串，指明浏览器的名称和版本号。

#### 1.早期的浏览器

- Netscape在坚持将产品名和版本号作为用户代理字符串开头的基础上，又在后面依次添加了下列信息。
  - 语言：即语言代码，表示应用程序针对哪种语言设计。
  - 平台：即操作系统和（或）平台，表示应用程序的运行环境。
  - 加密类型：即安全加密的类型。可能的值有U（128位加密）、I（40位加密）和N（未加密）。

#### 2.Netscape Navigator 3和Internet Explorer 3

#### 3.Netscape Communicator 4和IE4～IE8

- 增加IE8这个记号有助于分辨浏览器到底是IE7（没有Trident记号），还是运行在兼容模式下的IE8。

#### 4.Gecko

- Gecko是Firefox的呈现引擎。
- 很多时候，检测特定的浏览器还不如搞清楚它是否基于Gecko更重要。

#### 5.WebKit

- 基于WebKit的所有浏览器都将自己标识为Mozilla 5.0，与基于Gecko的浏览器完全一样。
- 一般来说，确定浏览器是否基于WebKit要比确定它是不是Safari更有价值，就像针对Gecko一样。

#### 6.Konqueror

- Konqueror，是一款基于KHTML开源呈现引擎的浏览器。

#### 7.Chrome

- Chrome浏览器以WebKit作为呈现引擎，但使用了不同的JavaScript引擎。

#### 8.Opera

- Opera是主要浏览器中唯一一个使用产品名和版本号来完全彻底地标识自身的浏览器。
- Opera 9以后，出现了两种修改用户代理字符串的方式。
  - 一种方式是将自身标识为另外一个浏览器，如Firefox或者IE。在这种方式下，用户代理字符串就如同Firefox或IE的用户代理字符串一样，只不过末尾追加了字符串Opera及Opera的版本号。
  - 另一种方式，就是把自己装扮成Firefox或IE。在这种隐瞒真实身份的情况下，用户代理字符串实际上与其他浏览器返回的相同——既没有Opera字样，也不包含Opera版本信息。

#### 9.iOS和Android

### 9.3.2 用户代理字符串检测技术

#### 1.识别呈现引擎

- 如前所述，确切知道浏览器的名字和版本号不如确切知道它使用的是什么呈现引擎。

- 要正确地识别呈现引擎，关键是检测顺序要正确。由于用户代理字符串存在诸多不一致的地方，如果检测顺序不对，很可能会导致检测结果不正确。

  - 第一步是识别Opera，因为它的用户代理字符串有可能完全模仿其他浏览器

  > 要识别Opera，必须得检测window.opera对象。Opera 5及更高版本中都有这个对象，用以保存与浏览器相关的标识信息以及与浏览器直接交互。在Opera 7.6及更高版本中，调用version()方法可以返回一个表示浏览器版本的字符串，而这也是确定Opera版本号的最佳方式。
  >
  > 要检测更早版本的Opera，可以直接检查用户代理字符串，因为那些版本还不支持隐瞒身份。

  - 第二位检测的呈现引擎是WebKit

  > 因为WebKit的用户代理字符串中包含"Gecko"和"KHTML"这两个子字符串，所以如果首先检测它们，很可能会得出错误的结论。
  >
  > 不过，WebKit的用户代理字符串中的"AppleWebKit"是独一无二的，因此检测这个字符串最合适。

  - 第三位是KHTML

  > 同样，KHTML的用户代理字符串中也包含"Gecko"，因此在排除KHTML之前，我们无法准确检测基于Gecko的浏览器。KHTML的版本号与WebKit的版本号在用户代理字符串中的格式差不多，因此可以使用类似的正则表达式。此外，由于Konqueror 3.1及更早版本中不包含KHTML的版本，故而就要使用Konqueror的版本来代替。

  - 第四位是Gecko

  > Gecko的版本号位于字符串"rv:"与一个闭括号之间，因此为了提取出这个版本号，正则表达式要查找所有不是闭括号的字符，还要查找字符串"Gecko/"后跟8个数字。

  - 最后要检测的呈现引擎是IE

  > IE的版本号位于字符串"MSIE"的后面、一个分号的前面

#### 2.识别浏览器

- 只有呈现引擎还不能说明存在所需的JavaScript功能。
- 可在代码中又添加了私有变量browser，用于保存每个主要浏览器的属性。
  - 对Opera和IE而言，browser对象中的值等于engine对象中的值。
  - 对Konqueror而言，browser.konq和browser.ver属性分别等于engine.khtml和engine.ver属性。
  - 在检测Firefox的版本时，首先要找到字符串"Firefox/"，然后提取出该字符串后面的数值（即版本号）。

#### 3.识别平台

- 在某些条件下，平台可能是必须关注的问题。
- 与呈现引擎不同，在不能访问操作系统或版本的情况下，平台信息通常是很有限的。对这三个平台而言，浏览器一般只报告Windows版本。
- 在确定平台时，检测navigator.platform要比检测用户代理字符串更简单，后者在不同浏览器中会给出不同的平台信息。而navigator.platform 属性可能的值包括"Win32"、"Win64"、

#### 4.识别Windows操作系统

- 第一步：匹配Windows 95和Windows 98这两个字符串。
- 第二步：Gecko在表示Windows NT时会在末尾添加"4.0"

#### 5.识别移动设备

#### 6.识别游戏系统

### 9.3.3 完整的代码

- 书中包含完整的用户代理字符串检测脚本，包括检测呈现引擎、平台、Windows操作系统、移动设备和游戏系统。

### 9.3.4 使用方法

- 用户代理检测一般适用于下列情形 :
  - 不能直接准确地使用能力检测或怪癖检测。

## 9.4 小结

- ​


# 第10章 DOM

- 注意，IE中的所有DOM对象都是以COM对象的形式实的。这意味着IE中的DOM对象与原生JavaScript对象的行为或活动特点并不一致。

## 10.1 节点层次

- 文档节点是每个文档的根节点。
- 文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。
  - 在HTML页面中，文档元素始终都是<html>元素。
  - 在XML中，没有预定义的元素，因此任何元素都可能成为文档元素。
- 每一段标记都可以通过树中的一个节点来表示：HTML元素通过元素节点表示，特性通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12种节点类型，这些类型都继承自一个基类型。

### 10.1.1 Node类型

- DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript 中是作为Node 类型实现的；除了IE 之外，在其他所有浏览器中都可以访问到这个类型。

- JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。

- 每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一：

  - Node.ELEMENT_NODE(1)；
  - Node.ATTRIBUTE_NODE(2)；
  - Node.TEXT_NODE(3)；
  - Node.CDATA_SECTION_NODE(4)；
  - Node.ENTITY_REFERENCE_NODE(5)；
  - Node.ENTITY_NODE(6)；
  - Node.PROCESSING_INSTRUCTION_NODE(7)；
  - Node.COMMENT_NODE(8)；
  - Node.DOCUMENT_NODE(9)；
  - Node.DOCUMENT_TYPE_NODE(10)；
  - Node.DOCUMENT_FRAGMENT_NODE(11)；
  - Node.NOTATION_NODE(12)。

- 通过比较上面这些常量，可以很容易地确定节点的类型

  ```javascript
  if (someNode.nodeType == 1){ //适用于所有浏览器
  	alert("Node is an element."); 
  } 
  ```

#### 1.nodeName和nodeValue属性

- 这两个属性的值完全取决于节点的类型。在使用这两个值以前，最好是像下面这样先检测一下节点的类型。

#### 2.节点关系

- 每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。
- 请注意，虽然可以通过方括号语法来访问NodeList的值，而且这个对象也有length属性，但它并不是Array的实例。NodeList对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。
- 访问保存在NodeList中的节点——可以通过方括号，也可以使用item()方法。
- 对arguments对象使用Array.prototype.slice()方法可以将其转换为数组。由于IE8及更早版本将NodeList
  实现为一个COM对象，而我们不能像使用JScript对象那样使用这种对象。要想在IE中将NodeList转换为数组，必须手动枚举所有成员。
- 每个节点都有一个parentNode属性，该属性指向文档树中的父节点。
- 包含在childNodes列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的previousSibling
  和nextSibling属性，可以访问同一列表中的其他节点。列表中第一个节点的previousSibling属性值为null，而列表中最后一个节点的nextSibling属性的值同样也为null
- 父节点与其第一个和最后一个子节点之间也存在特殊关系。父节点的firstChild和lastChild属性分别指向其childNodes列表中的第一个和最后一个节点。如果没有子节点，那么firstChild和lastChild的值均为null。
- hasChildNodes()也是一个非常有用的方法，这个方法在节点包含一或多个子节点的情况下返回true；应该说，这是比查询childNodes列表的length属性更简单的方法。
- 所有节点都有的最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。通过这个属性，我们可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档节点。

#### 3. 操作节点

- 最常用的方法是appendChild()，用于向childNodes列表的末尾添加一个节点。添加节点后，childNodes的新增节点、父节点及以前的最后一个子节点的关系指针都会相应地得到更新。
- 如果需要把节点放在childNodes 列表中某个特定的位置上，而不是放在末尾，那么可以使用insertBefore()方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是null，则insertBefore()与appendChild()执行相同的操作
- replaceChild()方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。
- 如果只想移除而非替换节点，可以使用removeChild()方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值
- 四个方法操作的都是某个节点的子节点，另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生。

#### 4. 其他方法

- 有两个方法是所有类型的节点都有的。第一个就是cloneNode()，用于创建调用这个方法的节点的一个完全相同的副本。
  - cloneNode()方法接受一个布尔值参数，表示是否执行深复制。
    - 在参数为true的情况下，执行深复制，也就是复制节点及其整个子节点树；
    - 在参数为false的情况下，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此，这个节点副本就成为了一个“孤儿”，除非通过appendChild()、insertBefore()或replaceChild()将它添加到文档中。

> cloneNode()方法不会复制添加到DOM节点中的JavaScript属性，例如事件处
> 理程序等。这个方法只复制特性、（在明确指定的情况下也复制）子节点，其他一切
> 都不会复制。IE在此存在一个bug，即它会复制事件处理程序，所以我们建议在复制
> 之前最好先移除事件处理程序。

- normalize()方法，这个方法唯一的作用就是处理文档树中的文本节点。
  - 由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。

### 10.1.2 Document类型

- 在浏览器中，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML页面。而且，document对象是window对象的一个属性，因此可以将其作为全局对象来访问。
- Document节点具有下列特征：
  - nodeType的值为9；
  - nodeName的值为"#document"；
  - nodeValue的值为null；
  - parentNode的值为null；
  - ownerDocument的值为 null；
  - 其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment。

#### 1. 文档的子节点

- 虽然DOM标准规定Document节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment，但还有两个内置的访问其子节点的快捷方式。

  - 第一个就是documentElement属性，该属性始终指向HTML页面中的<html>元素。
  - 另一个就是通过childNodes列表访问文档元素，但通过documentElement属性则能更快捷、更直接地访问该元素。

- 作为HTMLDocument的实例，document对象还有一个body属性，直接指向<body>元素。因为开发人员经常要使用这个元素，所以document.body在JavaScript代码中出现的频率非常高，其用法如下。
  `var body = document.body; //取得对<body>的引用`

- 所有浏览器都支持document.documentElement和document.body属性。

- Document另一个可能的子节点是DocumentType。通常将<!DOCTYPE>标签看成一个与文档其他部分不同的实体，可以通过doctype属性（在浏览器中是document.doctype）来访问它的信息。

  `var doctype = document.doctype; //取得对<!DOCTYPE>的引用`

- 浏览器对document.doctype的支持差别很大:

  - IE8 及之前版本：如果存在文档类型声明，会将其错误地解释为一个注释并把它当作Comment节点；而document.doctype的值始终为null。
  - IE9+及Firefox：如果存在文档类型声明，则将其作为文档的第一个子节点；document.doctype是一个DocumentType节点，也可以通过document.firstChild或document.childNodes[0]访问同一个节点。
  - Safari、Chrome和Opera：如果存在文档类型声明，则将其解析，但不作为文档的子节点。document.doctype是一个DocumentType节点，但该节点不会出现在document.childNodes中。

- 从技术上说，出现在<html>元素外部的注释应该算是文档的子节点。然而，不同的浏览器在是否解析这些注释以及能否正确处理它们等方面，也存在很大差异。

  - IE8及之前版本、Safari 3.1及更高版本、Opera和Chrome只为第一条注释创建节点，不为第二条注释创建节点。结果，第一条注释就会成为document.childNodes中的第一个子节点。
  - IE9及更高版本会将第一条注释创建为document.childNodes中的一个注释节点，也会将第二条注释创建为document.childNodes中的注释子节点。
  - Firefox以及Safari 3.1之前的版本会完全忽略这两条注释。

#### 2. 文档信息

- title属性
  - 包含着<title>元素中的文本——显示在浏览器窗口的标题栏或标签页上。
  - 通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。
  - 修改title属性的值不会改变<title>元素。
- URL
  - URL属性中包含页面完整的URL（即地址栏中显示的URL）
- domain
  - domain属性中只包含页面的域名
- referrer
  - referrer属性中则保存着链接到当前页面的那个页面的URL。
  - 在没有来源页面的情况下，referrer属性中可能会包含空字符串。
- URL与domain属性是相互关联的。
- 在这3个属性中，只有domain是可以设置的。但由于安全方面的限制，也并非可以给domain设置任何值。不能将这个属性设置为URL中不包含的域
- 当页面中包含来自其他子域的框架或内嵌框架时，能够设置document.domain就非常方便了。由于跨域安全限制，来自不同子域的页面无法通过JavaScript 通信。而通过将每个页面的document.domain设置为相同的值，这些页面就可以互相访问对方包含的JavaScript对象了。
- 浏览器对domain属性还有一个限制，即如果域名一开始是“松散的”（loose），那么不能将它再设置为“紧绷的”（tight）。换句话说，在将document.domain设置为"wrox.com"之后，就不能再将其设置回"p2p.wrox.com"，否则将会导致错误

#### 3. 查找元素

- 取得元素的操作：getElementById()和getElementsByTagName()
- getElementById()
  - 接收一个参数：要取得的元素的ID。
  - 如果找到相应的元素则返回该元素，如果不存在带有相应ID的元素，则返回null。
  - 注意，这里的ID必须与页面中元素的id特性（attribute）严格匹配，包括大小写。(IE8及较低版本不区分ID的大小写)
  - 如果页面中多个元素的ID值相同，getElementById()只返回文档中第一次出现的元素。IE7及较低版本还为此方法添加了一个有意思的“怪癖”：name 特性与给定ID 匹配的表单元素（<input>、<textarea>、<button>及<select>）也会被该方法返回。
- getElementsByTagName()
  - 接受一个参数，即要取得元素的标签名，而返回的是包含零或多个元素的NodeList。
  - 在HTML文档中，这个方法会返回一个HTMLCollection对象，作为一个“动态”集合，该对象与NodeList非常类似
  - HTMLCollection对象还有一个方法，叫做namedItem()，使用这个方法可以通过元素的name特性取得集合中的项。
  - 要想取得文档中的所有元素，可以向getElementsByTagName()中传入"*"。按照它们出现的先后顺序。
- getElementsByName()
  - 只有HTMLDocument类型才有的方法
  - 最常使用getElementsByName()方法的情况是取得单选按钮；为了确保发送给浏览器的值正确无误，所有单选按钮必须具有相同的name特性
  - 与getElementsByTagName()类似，getElementsByName()方法也会返回一个HTMLCollectioin。
  - 但是，对于这里的单选按钮来说，namedItem()方法则只会取得第一项（因为每一项的name特性都相同）

#### 4. 特殊集合

- document对象还有一些特殊的集合，都是HTMLCollection对象，为访问文档常用的部分提供了快捷方式
  - document.anchors，包含文档中所有带name特性的<a>元素；
  - document.applets，包含文档中所有的<applet>元素，因为不再推荐使用<applet>元素，所以这个集合已经不建议使用了；
  - document.forms，包含文档中所有的<form>元素，与document.getElementsByTagName("form")得到的结果相同；
  - document.images，包含文档中所有的<img>元素，与document.getElementsByTagName ("img")得到的结果相同；
  - document.links，包含文档中所有带href特性的<a>元素。

#### 5. DOM一致性检测

- document.implementation属性就是为检测浏览器实现了DOM的哪些部分提供相应信息和功能的对象，与浏览器对DOM的实现直接对应。

- DOM1级只为document.implementation规定了一个方法，即hasFeature()。

  - 这个方法接受两个参数：要检测的DOM功能的名称及版本号。

  - 如果浏览器支持给定名称和版本的功能，则该方法返回true

    | 功 能            | 版 本 号       | 说 明                             |
    | -------------- | ----------- | ------------------------------- |
    | Core           | 1.0、2.0、3.0 | 基本的DOM，用于描述表现文档的节点树             |
    | XML            | 1.0、2.0、3.0 | Core的XML扩展，添加了对CDATA、处理指令及实体的支持 |
    | HTML           | 1.0、2.0     | XML的HTML扩展，添加了对HTML特有元素及实体的支持   |
    | Views          | 2.0         | 基于某些样式完成文档的格式化                  |
    | StyleSheets    | 2.0         | 将样式表关联到文档                       |
    | CSS            | 2.0         | 对层叠样式表1级的支持                     |
    | CSS2           | 2.0         | 对层叠样式表2级的支持                     |
    | Events         | 2.0，3.0     | 常规的DOM事件                        |
    | UIEvents       | 2.0，3.0     | 用户界面事件                          |
    | MouseEvents    | 2.0，3.0     | 由鼠标引发的事件（click、mouseover等）      |
    | MutationEvents | 2.0，3.0     | DOM树变化时引发的事件                    |
    | HTMLEvents     | 2.0         | HTML4.01事件                      |
    | Range          | 2.0         | 用于操作DOM树中某个范围的对象和方法             |
    | Traversal      | 2.0         | 遍历DOM树的方法                       |
    | LS             | 3.0         | 文件与DOM树之间的同步加载和保存               |
    | LS-Async       | 3.0         | 文件与DOM树之间的异步加载和保存               |
    | Validation     | 3.0         | 在确保有效的前提下修改DOM树的方法              |

  - hasFeature()也有缺点，因为实现者可以自行决定是否与DOM规范的不同部分保持一致。建议多数情况下，在使用DOM的某些特殊的功能之前，最好除了检测hasFeature()之外，还同时使用能力检测。

#### 6. 文档写入

- 将输出流写入到网页中：write()、writeln()、open()和close()。
- write()和writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。write()会原样写入，而writeln()则会在字符串的末尾添加一个换行符（\n）。在页面被加载的过程中，可以使用这两个方法向页面中动态地
  加入内容
- 还可以使用write()和writeln()方法动态地包含外部资源，例如JavaScript文件等。在包含JavaScript文件时，必须注意不能像下面的例子那样直接包含字符串"</script>"，因为这会导致该字符串被解释为脚本块的结束，它后面的代码将无法执行。（使用"<\/script>"）
- 如果在文档加载结束后再调用document.write()，那么输出的内容将会重写整个页面
- 方法open()和close()分别用于打开和关闭网页的输出流。如果是在页面加载期间使用write()或writeln()方法，则不需要用到这两个方法

> 严格型XHTML文档不支持文档写入。

### 10.1.3 Element类型

- Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。Element节点具有以下特征：
  - nodeType的值为1；
  - nodeName的值为元素的标签名；
  - nodeValue的值为null；
  - parentNode可能是Document或Element；
  - 其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。
- 要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性；这两个属性会返回相同的值。但可能会有大小写差别，因为在HTML中，标签名始终都以全部大写表示；而在XML（有时候也包括XHTML）中，标签名则始终会与源代码中的保持一致。

#### 1. HTML元素

- 所有HTML元素都由HTMLElement类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性。

- id，元素在文档中的唯一标识符。

- title，有关元素的附加说明信息，一般通过工具提示条显示出来。

- lang，元素内容的语言代码，很少使用。

- dir，语言的方向，值为"ltr"（left-to-right，从左至右）或"rtl"（right-to-left，从右至左），也很少使用。

- className，与元素的class特性对应，即为元素指定的CSS类。没有将这个属性命名为class，是因为class是ECMAScript的保留字

- 所有HTML元素以及与之关联的类型：

  | 元 素        | 类 型                     | 元 素      | 类 型                 |
  | ---------- | ----------------------- | -------- | ------------------- |
  | A          | HTMLAnchorElement       | EM       | HTMLElement         |
  | ABBR       | HTMLElement             | FIELDSET | HTMLFieldSetElement |
  | ACRONYM    | HTMLElement             | FONT     | HTMLFontElement     |
  | ADDRESS    | HTMLElement             | FORM     | HTMLFormElement     |
  | APPLET     | HTMLAppletElement       | FRAME    | HTMLFrameElement    |
  | AREA       | HTMLAreaElement         | FRAMESET | HTMLFrameSetElement |
  | B          | HTMLElement             | H1       | HTMLHeadingElement  |
  | BASE       | HTMLBaseElement         | H2       | HTMLHeadingElement  |
  | BASEFONT   | HTMLBaseFontElement     | H3       | HTMLHeadingElement  |
  | BDO        | HTMLElement             | H4       | HTMLHeadingElement  |
  | BIG        | HTMLElement             | H5       | HTMLHeadingElement  |
  | BLOCKQUOTE | HTMLQuoteElement        | H6       | HTMLHeadingElement  |
  | BODY       | HTMLBodyElement         | HEAD     | HTMLHeadElement     |
  | BR         | HTMLBRElement           | HR       | HTMLHRElement       |
  | BUTTON     | HTMLButtonElement       | HTML     | HTMLHtmlElement     |
  | CAPTION    | HTMLTableCaptionElement | I        | HTMLElement         |
  | CENTER     | HTMLElement             | IFRAME   | HTMLIFrameElement   |
  | CITE       | HTMLElement             | IMG      | HTMLImageElement    |
  | CODE       | HTMLElement             | INPUT    | HTMLInputElement    |

  | COL      | HTMLTableColElement  | INS      | HTMLModElement          |
  | -------- | -------------------- | -------- | ----------------------- |
  | COLGROUP | HTMLTableColElement  | ISINDEX  | HTMLIsIndexElement      |
  | DD       | HTMLElement          | KBD      | HTMLElement             |
  | DEL      | HTMLModElement       | LABEL    | HTMLLabelElement        |
  | DFN      | HTMLElement          | LEGEND   | HTMLLegendElement       |
  | DIR      | HTMLDirectoryElement | LI       | HTMLLIElement           |
  | DIV      | HTMLDivElement       | LINK     | HTMLLinkElement         |
  | DL       | HTMLDListElement     | MAP      | HTMLMapElement          |
  | DT       | HTMLElement          | MENU     | HTMLMenuElement         |
  | META     | HTMLMetaElement      | STRONG   | HTMLElement             |
  | NOFRAMES | HTMLElement          | STYLE    | HTMLStyleElement        |
  | NOSCRIPT | HTMLElement          | SUB      | HTMLElement             |
  | OBJECT   | HTMLObjectElement    | SUP      | HTMLElement             |
  | OL       | HTMLOListElement     | TABLE    | HTMLTableElement        |
  | OPTGROUP | HTMLOptGroupElement  | TBODY    | HTMLTableSectionElement |
  | OPTION   | HTMLOptionElement    | TD       | HTMLTableCellElement    |
  | P        | HTMLParagraphElement | TEXTAREA | HTMLTextAreaElement     |
  | PARAM    | HTMLParamElement     | TFOOT    | HTMLTableSectionElement |
  | PRE      | HTMLPreElement       | TH       | HTMLTableCellElement    |
  | Q        | HTMLQuoteElement     | THEAD    | HTMLTableSectionElement |

  | S      | HTMLElement       | TITLE | HTMLTitleElement    |
  | ------ | ----------------- | ----- | ------------------- |
  | SAMP   | HTMLElement       | TR    | HTMLTableRowElement |
  | SCRIPT | HTMLScriptElement | TT    | HTMLElement         |
  | SELECT | HTMLSelectElement | U     | HTMLElement         |
  | SMALL  | HTMLElement       | UL    | HTMLUListElement    |
  | SPAN   | HTMLElement       | VAR   | HTMLElement         |
  | STRIKE | HTMLElement       |       |                     |

#### 2. 取得特性

- 操作特性的DOM方法主要有三个，分别是getAttribute()、setAttribute()和removeAttribute()。这三个方法可以针对任何特性使用，包括那些以HTMLElement类型属性的形式定义的特性。

  - 注意，传递给getAttribute()的特性名与实际的特性名相同。因此要想得到class特性值，应该传入"class"而不是"className"，后者只有在通过对象属性访问特性时才用。如果给定名称的特性不存在，getAttribute()返回null。
  - 通过getAttribute()方法也可以取得自定义特性（即标准HTML语言中没有的特性）的值。

  > 特性的名称是不区分大小写的，即"ID"和"id"代表的都是同一个特性。另外也要注意，根据HTML5规范，自定义特性应该加上data-前缀以便验证。

  - 只有公认的（非自定义的）特性才会以属性的形式添加到DOM对象中。（IE除外, 认为自定义特性也创建属性）

  - 有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过getAttribute()返回的值并不相同。

    - 第一类特性就是style，用于通过CSS为元素指定样式。在通过getAttribute()访问时，返回的style特性值中包含的是CSS文本，而通过属性来访问它则会返回一个对象。

    > 由于style属性是用于以编程方式访问元素样式的，因此并没有直接映射到style特性。

    - 第二类与众不同的特性是onclick这样的事件处理程序。当在元素上使用时，onclick特性中包含的是JavaScript 代码，如果通过getAttribute()访问，则会返回相应代码的字符串。而在访问onclick属性时，则会返回一个JavaScript函数（如果未在元素中指定相应特性，则返回null）。

    > 这是因为onclick及其他事件处理程序属性本身就应该被赋予函数值。

#### 3. 设置特性

- setAttribute()
  - 接受两个参数：要设置的特性名和值。
    - 如果特性已经存在，setAttribute()会以指定的值替换现有的值；
    - 如果特性不存在，setAttribute()则创建该属性并设置相应的值。
  - 通过setAttribute()方法既可以操作HTML特性也可以操作自定义特性。
  - 通过这个方法设置的特性名会被统一转换为小写形式。
  - 因为所有特性都是属性，所以直接给属性赋值可以设置特性的值
  - 为DOM元素添加一个自定义的属性，该属性不会自动成为元素的特性。可是，自定义属性在IE中会被当作元素的特性，反之亦然。
  - 在IE7及以前版本中，setAttribute()存在一些异常行为。通过这个方法设置class和style特性，没有任何效果，而使用这个方法设置事件处理程序特性时也一样
- removeAttribute()，这个方法用于彻底删除元素的特性。
  - 调用这个方法不仅会清除特性的值，而且也会从元素中完全删除特性
  - 这个方法并不常用，但在序列化DOM元素时，可以通过它来确切地指定要包含哪些特性。
  - IE6及以前版本不支持removeAttribute()。

#### 4. attributes属性

- Element类型是使用attributes属性的唯一一个DOM节点类型。
- attributes属性中包含一个NamedNodeMap，与NodeList类似，也是一个“动态”的集合。元素的每一个特性都由一个Attr节点表示，每个节点都保存在NamedNodeMap对象中。
- NamedNodeMap对象拥有下列方法。
  - getNamedItem(name)：返回nodeName属性等于name的节点；
  - removeNamedItem(name)：从列表中移除nodeName属性等于name的节点；
  - setNamedItem(node)：向列表中添加节点，以节点的nodeName属性为索引；
  - item(pos)：返回位于数字pos位置处的节点。
- attributes属性中包含一系列节点，每个节点的nodeName就是特性的名称，而节点的nodeValue就是特性的值。
- 调用 removeNamedItem() 方法与在元素上调用 removeAttribute()方法的效果相同——直接删除具有给定名称的特性。两个方法间唯一的区别，即removeNamedItem()返回表示被删除特性的Attr节点。
- setNamedItem()是一个很不常用的方法，通过这个方法可以为元素添加一个新特性，为此需要为它传入一个特性节点
- 如果想要遍历元素的特性，attributes属性倒是可以派上用场。

#### 5. 创建元素

- document.createElement()方法可以创建新元素。
  - 这个方法只接受一个参数，即要创建元素的标签名。这个标签名在HTML文档中不区分大小写，而在XML（包括XHTML）文档中，则是区分大小写的。
- 在使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocuemnt属性。
- 在IE中可以以另一种方式使用createElement()，即为这个方法传入完整的元素标签，也可以包含属性。这种方式有助于避开在IE7及更早版本中动态创建元素的某些问题。下面是已知的一些这类问题。
  - 不能设置动态创建的<iframe>元素的name特性。
  - 不能通过表单的reset()方法重设动态创建的<input>元素。
  - 动态创建的type特性值为"reset"的<buttou>元素重设不了表单。
  - 动态创建的一批name相同的单选按钮彼此毫无关系。name值相同的一组单选按钮本来应该用于表示同一选项的不同值，但动态创建的一批这种单选按钮之间却没有这种关系。

#### 6. 元素的子节点

- 不同浏览器在看待这些节点方面存在显著的不同如果需要通过childNodes属性遍历子节点，那么一定不要忘记浏览器间的这一差别。这意味着在执行某项操作以前，通常都要先检查一下nodeTpye属性

- 如果想通过某个特定的标签名取得子节点或后代节点该怎么办呢？实际上，元素也支持getElementsByTagName()方法。在通过元素调用这个方法时，除了搜索起点是当前元素之外，其他方面都跟通过document调用这个方法相同，因此结果只会返回当前元素的后代。

  ```
  var ul = document.getElementById("myList");
  var items = ul.getElementsByTagName("li");
  ```

### 10.1.4 Text类型

- 文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。
- Text节点具有以下特征：
  - nodeType的值为3；
  - nodeName的值为"#text"；
  - nodeValue的值为节点所包含的文本；
  - parentNode是一个Element；
  - 不支持（没有）子节点。
- 可通过nodeValue属性或data属性访问Text节点中包含的文本，这两个属性中包含的值相同。对nodeValue的修改也会通过data反映出来，反之亦然。
- 使用下列方法可以操作节点中的文本。
  - appendData(text)：将text添加到节点的末尾。
  - deleteData(offset, count)：从offset指定的位置开始删除count个字符。
  - insertData(offset, text)：在offset指定的位置插入text。
  - replaceData(offset, count, text)：用text替换从offset指定的位置开始到offset+count为止处的文本。
  - splitText(offset)：从offset指定的位置将当前文本节点分成两个文本节点。
  - substringData(offset, count)：提取从offset指定的位置开始到offset+count为止处的字符串。
- 文本节点还有一个length 属性，保存着节点中字符的数目。
- 在默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在。

#### 1. 创建文本节点

- document.createTextNode()创建新文本节点
  - 这个方法接受一个参数——要插入节点中的文本。
  - 与设置已有文本节点的值一样，作为参数的文本也将按照HTML或XML的格式进行编码。
  - 在创建新文本节点的同时，也会为其设置ownerDocument属性。
  - 如果两个文本节点是相邻的同胞节点，那么这两个节点中的文本就会连起来显示，中间不会有空格。

#### 2. 规范化文本节点

- normalize()
  - 在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个节点，结果节点的nodeValue等于将合并前每个文本节点的nodeValue值拼接起来的值。
  - 浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行DOM操作的结果出现。
  - 在某些情况下，执行normalize()方法会导致IE6崩溃。

#### 3. 分割文本节点

- splitText()
  - 这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割nodeValue值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。
  - 这个方法会返回一个新文本节点，该节点与原节点的parentNode相同。
- 分割文本节点是从文本节点中提取数据的一种常用DOM解析技术。

### 10.1.5 Comment类型

- 注释在DOM中是通过Comment类型来表示的。
- Comment节点具有下列特征：
  - nodeType的值为8；
  - nodeName的值为"#comment"；
  - nodeValue的值是注释的内容；
  - parentNode可能是Document或Element；
  - 不支持（没有）子节点。
- Comment类型与Text类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法。
- 使用document.createComment()并为其传递注释文本也可以创建注释节点
- 尽管IE9 没有把注释当成元素，但它仍然通过一个名为HTMLCommentElement的构造函数来表示注释。

### 10.1.6 CDATASection类型

- CDATASection 类型只针对基于XML的文档，表示的是CDATA区域。与Comment 类似，
- CDATASection 类型继承自Text 类型，因此拥有除splitText()之外的所有字符串操作方法。
- CDATASection节点具有下列特征：
  - nodeType的值为4；
  - nodeName的值为"#cdata-section"；
  - nodeValue的值是CDATA区域中的内容；
  - parentNode可能是Document或Element；
  - 不支持（没有）子节点。
- CDATA区域只会出现在XML文档中，因此多数浏览器都会把CDATA区域错误地解析为Comment或Element。
- 在真正的XML文档中，可以使用document.createCDataSection()来创建CDATA区域，只需为其传入节点的内容即可。
- 在Firefox、Safari、Chrome和Opera中，可以访问CDATASection类型的构造函数和原型。IE9及之前版本不支持这个类型。

### 10.1.7 DocumentType类型

- DocumentType类型在Web浏览器中并不常用，仅有Firefox、Safari和Opera支持它。
- DocumentType包含着与文档的doctype有关的所有信息，它具有下列特征：
  - nodeType的值为10；
  - nodeName的值为doctype的名称；
  - nodeValue的值为null；
  - parentNode是Document；
  - 不支持（没有）子节点。
- 在DOM1级中，DocumentType对象不能动态创建，而只能通过解析文档代码的方式来创建。
- 支持它的浏览器会把DocumentType 对象保存在document.doctype 中。
- DOM1级描述了DocumentType对象的3个属性：name、entities和notations。
  - name表示文档类型的名称；
  - entities是由文档类型描述的实体的NamedNodeMap对象；
  - notations是由文档类型描述的符号的NamedNodeMap对象。
  - 通常，浏览器中的文档使用的都是HTML或XHTML文档类型，因而entities和notations都是空列表（列表中的项来自行内文档类型声明）。
- IE9 会给document.doctype赋正确的对象，但仍然不支持访问DocumentType类型。

### 10.1.8 DocumentFragment类型

- 在所有节点类型中，只有DocumentFragment 在文档中没有对应的标记。
- DOM规定文档片段（document fragment）是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。
- DocumentFragment节点具有下列特征：
  - nodeType的值为11；
  - nodeName的值为"#document-fragment"；
  - nodeValue的值为null；
  - parentNode的值为null；
  - 子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection 或 EntityReference。
- 虽然不能把文档片段直接添加到文档中，但可以将它作为一个“仓库”来使用，即可以在里面保存将来可能会添加到文档中的节点。如果逐个地添加列表项，将会导致浏览器反复渲染要创建文档片段，可以使用document.createDocumentFragment()方法
- 文档片段继承了Node的所有方法，通常用于执行那些针对文档的DOM操作。
- 如果将文档中的节点添加到文档片段中，就会从文档树中移除该节点，也不会从浏览器中再看到该节点。添加到文档片段中的新节点同样也不属于文档树。

### 10.1.9 Attr类型

- 元素的特性在DOM中以Attr类型来表示。在所有浏览器中（包括IE8），都可以访问Attr类型的构造函数和原型。从技术角度讲，特性就是存在于元素的attributes属性中的节点。
- 特性节点具有下列特征：
  - nodeType的值为2；
  - nodeName的值是特性的名称；
  - nodeValue的值是特性的值；
  - parentNode的值为null；
  - 在HTML中不支持（没有）子节点；
  - 在XML中子节点可以是Text或EntityReference。
- 尽管它们也是节点，但特性却不被认为是DOM文档树的一部分。开发人员最常使用的是getAttribute()、setAttribute()和remveAttribute()方法，很少直接引用特性节点。
- Attr对象有3个属性：name、value和specified。
  - name是特性名称（与nodeName的值相同）
  - value是特性的值（与nodeValue的值相同）
  - specified是一个布尔值，用以区别特性是在代码中指定的，还是默认的。
- 使用document.createAttribute()并传入特性的名称可以创建新的特性节点。
- 为了将新创建的特性添加到元素中，必须使用元素的setAttributeNode()方法。
- 添加特性之后，可以通过下列任何方式访问该特性：attributes属性、getAttributeNode()方法以及getAttribute()方法。其中，attributes和getAttributeNode()都会返回对应特性的Attr节点，而getAttribute()则只返回特性的值。不建议直接访问特性节点。

## 10.2 DOM操作技术

### 10.2.1 动态脚本

- 创建动态脚本也有两种方式：插入外部文件和直接插入JavaScript代码。
- 动态加载的外部JavaScript文件能够立即运行；另一种指定JavaScript代码的方式是行内方式
- IE 将<script>视为一个特殊的元素，不允许DOM访问其子节点。不过，可以使用<script>元素的text属性来指定JavaScript代码
- 以这种方式加载的代码会在全局作用域中执行，而且当脚本执行后将立即可用。
- 实际上，这样执行代码与在全局作用域中把相同的字符串传递给eval()是一样的。

### 10.2.2 动态样式

- 能够把CSS样式包含到HTML页面中的元素有两个。
- <link>元素用于包含来自外部的文件，而<style>元素用于指定嵌入的样式。
- 需要注意的是，必须将<link>元素添加到<head>而不是<body>元素，才能保证在所有浏览器中的行为一致。
- 加载外部样式文件的过程是异步的，也就是加载样式与执行JavaScript代码的过程没有固定的次序。
- 另一种定义样式的方式是使用<style>元素来包含嵌入式CSS，可以在Firefox、Safari、Chrome和Opera中运行，在IE中则会报错。

> IE将<style>视为一个特殊的、与<script>类似的节点，不允许访问其子节点。事实上，IE此时抛出的错误与向<script>元素添加子节点时抛出的错误相同。

- 解决IE中这个问题的办法，就是访问元素的styleSheet属性，该属性又有一个cssText属性，可以接受CSS代码

> 如果专门针对IE编写代码，务必小心使用styleSheet.cssText属性。在重用同一个<style>元素并再次设置这个属性时，有可能会导致浏览器崩溃。同样，将cssText属性设置为空字符串也可能导致浏览器崩溃。

### 10.2.3 操作表格

- 为<table>元素添加的属性和方法如下。
  - caption：保存着对<caption>元素（如果有）的指针。
  - tBodies：是一个<tbody>元素的HTMLCollection。
  - tFoot：保存着对<tfoot>元素（如果有）的指针。
  - tHead：保存着对<thead>元素（如果有）的指针。
  - rows：是一个表格中所有行的HTMLCollection。
  - createTHead()：创建<thead>元素，将其放到表格中，返回引用。
  - createTFoot()：创建<tfoot>元素，将其放到表格中，返回引用。
  - createCaption()：创建<caption>元素，将其放到表格中，返回引用。
  - deleteTHead()：删除<thead>元素。
  - deleteTFoot()：删除<tfoot>元素。
  - deleteCaption()：删除<caption>元素。
  - deleteRow(pos)：删除指定位置的行。
  - insertRow(pos)：向rows集合中的指定位置插入一行。
- 为<tbody>元素添加的属性和方法如下。
  - rows：保存着<tbody>元素中行的HTMLCollection。
  - deleteRow(pos)：删除指定位置的行。
  - insertRow(pos)：向rows集合中的指定位置插入一行，返回对新插入行的引用。
- 为<tr>元素添加的属性和方法如下。
  - cells：保存着<tr>元素中单元格的HTMLCollection。
  - deleteCell(pos)：删除指定位置的单元格。
  - insertCell(pos)：向cells集合中的指定位置插入一个单元格，返回对新插入单元格的引用。

### 10.2.4使用NodeList

- NodeList、NamedNodeMap和HTMLCollection，这三个集合都是“动态的”
- 从本质上说，所有NodeList对象都是在访问DOM文档时实时运行的查询。
- 如果想要迭代一个NodeList，最好是使用length属性初始化第二个变量，然后将迭代器与该变量进行比较
- 一般来说，应该尽量减少访问NodeList的次数。因为每次访问NodeList，都会运行一次基于文档的查询。所以，可以考虑将从NodeList中取得的值缓存起来。

## 10.3小结

- DOM由各种节点构成，简要总结如下。
  - 最基本的节点类型是Node，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自Node
  - Document类型表示整个文档，是一组分层节点的根节点。在JavaScript中，document对象是Document的一个实例。使用document对象，有很多种方式可以查询和取得节点。
  - Element节点表示文档中的所有HTML或XML元素，可以用来操作这些元素的内容和特性。
  - 另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA区域和文档片段。
- 访问DOM的操作在多数情况下都很直观，不过在处理<script>和<style>元素时还是存在一些复杂性。由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这些区别导致了在针对这些元素使用innerHTML时，以及在创建新元素时的一些问题。
- 理解DOM的关键，就是理解DOM对性能的影响。DOM操作往往是JavaScript程序中开销最大的部分，而因访问NodeList导致的问题为最多。NodeList对象都是“动态的”，这就意味着每次访问NodeList对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少DOM操作。

# 第11章 DOM 扩展

- 对DOM的两个主要的扩展是Selectors API（选择符API）和HTML5
- 还有一个不那么引人瞩目的Element Traversal（元素遍历）规范，为DOM添加了一些属性。

## 11.1 选择符API

- Selectors API 是由W3C发起制定的一个标准，致力于让浏览器原生支持CSS查询。
- Selectors API Level 1的核心是两个方法：querySelector()和querySelectorAll()。
- 目前已完全支持Selectors API Level 1的浏览器有IE 8+、Firefox 3.5+、Safari 3.1+、Chrome和Opera 10+。

### 11.1.1 querySelector()方法

- querySelector()方法接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。

### 11.1.2 querySelectorAll()方法

- 这个方法返回的是一个NodeList的实例。
- 具体来说，返回的值实际上是带有所有属性和方法的NodeList，而其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询。
- 只要传给querySelectorAll()方法的CSS选择符有效，该方法都会返回一个NodeList对象，而不管找到多少匹配的元素。

### 11.1.3 matchesSelector()方法

- matchesSelector()方法
  - 接收一个参数，即CSS选择符
  - 如果调用元素与该选择符匹配，返回true；否则，返回false。
- 浏览器支持性不确定，因此，如果你想使用这个方法，最好是编写一个包装函数。

## 11.2 元素遍历

- 对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。
- Element Traversal API为DOM元素添加了以下5个属性。
  - childElementCount：返回子元素（不包括文本节点和注释）的个数。
  - firstElementChild：指向第一个子元素；firstChild的元素版。
  - lastElementChild：指向最后一个子元素；lastChild的元素版。
  - previousElementSibling：指向前一个同辈元素；previousSibling的元素版。
  - nextElementSibling：指向后一个同辈元素；nextSibling的元素版。
- 支持的浏览器为DOM元素添加了这些属性，利用这些元素不必担心空白文本节点，从而可以更方便地查找DOM元素了。
- 支持Element Traversal规范的浏览器有IE 9+、Firefox 3.5+、Safari 4+、Chrome和Opera 10+。

## 11.3  HTML5

### 11.3.1 与类相关的扩充

#### 1. getElementsByClassName()方法

- 可通过document对象及所有HTML元素调用该方法。这个方法是通过既有的DOM功能实现的，而原生的实现具有极大的性能优势。


- 指定类的所有元素的NodeList。传入多个类名时，类名的先后顺序不重要。
- 调用这个方法时，只有位于调用元素子树中的元素才会返回。在document 对象上调用getElementsByClassName()始终会返回与类名匹配的所有元素，在元素上调用该方法就只会返回后代元素中匹配的元素。
- 支持getElementsByClassName()方法的浏览器有IE 9+、Firefox 3+、Safari 3.1+、Chrome和Opera 9.5+。

#### 2. classList属性

- 在操作类名时，需要通过className属性添加、删除和替换类名。因为className中是一个字符串，所以即使只修改字符串一部分，也必须每次都设置整个字符串的值。
- HTML5新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加classList属性。这个classList属性是新集合类型DOMTokenList的实例。与其他DOM集合类似，DOMTokenList有一个表示自己包含多少元素的length属性，而要取得每个元素可以使用item()方法，也可以使用方括号语法。
- 这个新类型还定义如下方法。
  - add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。
  - contains(value)：表示列表中是否存在给定的值，如果存在则返回true，否则返回false。
  - remove(value)：从列表中删除给定的字符串。
  - toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。
- 有了classList属性，除非你需要全部删除所有类名，或者完全重写元素的class属性，否则也就用不到className属性了。
- 支持classList属性的浏览器有Firefox 3.6+和Chrome。

### 11.3.2 焦点管理

- HTML5也添加了辅助管理DOM焦点的功能。
- 首先就是document.activeElement属性，这个属性始终会引用DOM中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入（通常是通过按Tab键）和在代码中调用focus()方法。
  - 默认情况下，文档刚刚加载完成时，document.activeElement中保存的是document.body元素的引用。文档加载期间，document.activeElement的值为null。
- 另外就是新增了document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。
- 查询文档获知哪个元素获得了焦点，以及确定文档是否获得了焦点，这两个功能最重要的用途是提高Web应用的无障碍性。无障碍Web应用的一个主要标志就是恰当的焦点管理
- 实现了这两个属性的浏览器的包括IE 4+、Firefox 3+、Safari 4+、Chrome和Opera 8+。

### 11.3.3 HTMLDocument的变化

#### 1. readyState属性

- IE4最早为document对象引入了readyState属性。然后，其他浏览器也都陆续添加这个属性，最终HTML5把这个属性纳入了标准当中。

- Document的readyState属性有两个可能的值：

  - loading，正在加载文档；
  - complete，已经加载完文档。

- 使用document.readyState的最恰当方式，就是通过它来实现一个指示文档已经加载完成的指示器。

- document.readyState属性的基本用法如下。

  ```
  if (document.readyState == "complete"){
  	//执行操作
  }
  ```

- 支持readyState属性的浏览器有IE4+、Firefox 3.6+、Safari、Chrome和Opera 9+。

#### 2. 兼容模式

- IE为此给document添加了一个名为compatMode的属性，这个属性就是为了告诉开发人员浏览器采用了哪种渲染模式。
- 在标准模式下，document.compatMode的值等于"CSS1Compat"，而在混杂模式下，document.compatMode的值等于"BackCompat"。

#### 3. head属性

- HTML5新增了document.head属性，引用文档的<head>元素。要引用文档的<head>元素，可以结合使用这个属性和另一种后备方法。

  ```
  var head = document.head || document.getElementsByTagName("head")[0];
  ```

- 实现document.head属性的浏览器包括Chrome和Safari 5。

### 11.3.4 字符集属性

- charset属性表示文档中实际使用的字符集，也可以用来指定新字符集。
- 默认情况下，这个属性的值为"UTF-16"，但可以通过<meta>元素、响应头部或直接设置charset属性修改这个值。
- 另一个属性是defaultCharset，表示根据默认浏览器及操作系统的设置，当前文档默认的字符集应该是什么。
- 支持document.charset 属性的浏览器有IE、Firefox、Safari、Opera和Chrome。
- 支持document.defaultCharset属性的浏览器有IE、Safari和Chrome。

### 11.3.5 自定义数据属性

- HTML5规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以data-开头即可。
- 添加了自定义属性之后，可以通过元素的dataset属性来访问自定义属性的值。
- dataset属性的值是DOMStringMap的一个实例，也就是一个名值对儿的映射。在这个映射中，每个data-name形式的属性都会有一个对应的属性，只不过属性名没有data-前缀
- 如果需要给元素添加一些不可见的数据以便进行其他处理，那就要用到自定义数据属性。在跟踪链接或混搭应用中，通过自定义数据属性能方便地知道点击来自页面中的哪个部分。

### 11.3.6 插入标记

- 使用插入标记的技术，直接插入HTML字符串不仅更简单，速度也更快。
- 以下与插入标记相关的DOM扩展已经纳入了HTML5规范。

#### 1. innerHTML属性

- 在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的HTML标记。
  - 不同浏览器返回的文本格式会有所不同。IE和Opera会将所有标签转换为大写形式，而Safari、Chrome和Firefox则会原原本本地按照原先文档中（或指定这些标签时）的格式返回HTML，包括空格和缩进。
- 在写模式下，innerHTML会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。
- 使用innerHTML属性也有一些限制。

> 比如，在大多数浏览器中，通过innerHTML插入<script>元素并不会执行其中的脚本。IE8及更早版本是唯一能在这种情况下执行脚本的浏览器，但必须满足一些条件。一是必须为<script>元素指定defer属性，二是<script>元素必须位于（微软所谓的）“有作用域的元素”（scoped element）之后 。<script>元素被认为是“无作用域的元素”（NoScope element），也就是在页面中看不到的元素，与<style>元素或注释类似。如果通过innerHTML插入的字符串开头就是一个“无作用域的元素”，那么IE会在解析这个字符串前先删除该元素。（可以插入隐藏的<input>域，不影响页面布局）

- 大多数浏览器都支持以直观的方式通过innerHTML插入<style>元素，但在IE8 及更早版本中，<style>也是一个“没有作用域的元素”
- 不支持innerHTML的元素有：<col>、<colgroup>、<frameset>、<head>、<html>、<style>、<table>、<tbody>、<thead>、<tfoot>和<tr>。
- 此外，在IE8及更早版本中，<title>元素也没有innerHTML属性。
- Firefox对在内容类型为application/xhtml+xml的XHTML文档中设置innerHTML有严格的限制。在XHTML文档中使用innerHTML时，XHTML代码必须完全符合要求。如果代码格式不正确，设置innerHTML将会静默地失败。
- 无论什么时候，只要使用innerHTML从外部插入HTML，都应该首先以可靠的方式处理HTML。IE8为此提供了window.toStaticHTML()方法，这个方法接收一个参数，即一个HTML字符串；返回一个经过无害处理后的版本——从源HTML中删除所有脚本节点和事件处理程序属性。

#### 2. outerHTML属性

- 在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。
- 在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。
- 支持outerHTML属性的浏览器有IE4+、Safari 4+、Chrome和Opera 8+。Firefox 7及之前版本都不支持outerHTML属性。

#### 3. insertAdjacentHTML()方法

- 插入标记的最后一个新增方式是insertAdjacentHTML()方法。这个方法最早也是在IE中出现的，
- 它接收两个参数：插入位置和要插入的HTML文本。
  - 第一个参数必须是下列值之一：
    - "beforebegin"，在当前元素之前插入一个紧邻的同辈元素；
    - "afterbegin"，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；
    - "beforeend"，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；
    - "afterend"，在当前元素之后插入一个紧邻的同辈元素。
    - 注意，这些值都必须是小写形式。
  - 第二个参数是一个HTML字符串（与innerHTML和outerHTML的值相同），如果浏览器无法解析该字符串，就会抛出错误。
- 支持insertAdjacentHTML()方法的浏览器有IE、Firefox 8+、Safari、Opera和Chrome。

#### 4. 内存与性能问题

- 使用本节介绍的方法替换子节点可能会导致浏览器的内存占用问题，尤其是在IE 中，问题更加明显。
- 在删除带有事件处理程序或引用了其他JavaScript对象子树时，就有可能导致内存占用问题。

> 在插入大量新HTML标记时，使用innerHTML属性与通过多次DOM操作先创建节点再指定它们之间的关系相比，效率要高得多。这是因为在设置innerHTML或outerHTML时，就会创建一个HTML解析器。这个解析器是在浏览器级别的代码（通常是C++编写的）基础上运行的，因此比执行JavaScript快得多。不可避免地，创建和销毁HTML解析器也会带来性能损失，所以最好能够将设置innerHTML或outerHTML的次数控制在合理的范围内。

### 11.3.7 scrollIntoView()方法

- HTML5最终选择了scrollIntoView()作为标准方法。
- scrollIntoView()可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。
- 如果给这个方法传入true作为参数，或者不传入任何参数，那么窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐。如果传入false作为参数，调用元素会尽可能全部出现在视口中（可能的话，调用元素的底部会与视口顶部平齐。）
- 实际上，为某个元素设置焦点也会导致浏览器滚动并显示出获得焦点的元素。
- 支持scrollIntoView()方法的浏览器有IE、Firefox、Safari和Opera。

## 11.4 专有扩展

### 11.4.1 文档模式

- IE8引入了一个新的概念叫“文档模式”。页面的文档模式决定了可以使用什么功能。到了IE9，总共有以下4种文档模式。

  - IE5：以混杂模式渲染页面（IE5的默认模式就是混杂模式）。IE8及更高版本中的新功能都无法使用。
  - IE7：以IE7标准模式渲染页面。IE8及更高版本中的新功能都无法使用。
  - IE8：以IE8标准模式渲染页面。IE8中的新功能都可以使用，因此可以使用Selectors API、更多CSS2级选择符和某些CSS3功能，还有一些HTML5的功能。不过IE9中的新功能无法使用。
  - IE9：以IE9标准模式渲染页面。IE9中的新功能都可以使用，比如ECMAScript 5、完整的CSS3以及更多HTML5功能。这个文档模式是最高级的模式。

- 要强制浏览器以某种模式渲染页面，可以使用HTTP头部信息X-UA-Compatible，或通过等价的<meta>标签来设置：

  ```
  <meta http-equiv="X-UA-Compatible" content="IE=IEVersion"> 
  ```

  注意，这里IE的版本（IEVersion）有以下一些不同的值，而且这些值并不一定与上述4种文档
  模式对应。

  - Edge：始终以最新的文档模式来渲染页面。忽略文档类型声明。对于IE8，始终保持以IE8标准模式渲染页面。对于IE9，则以IE9标准模式渲染页面。
  - EmulateIE9：如果有文档类型声明，则以IE9标准模式渲染页面，否则将文档模式设置为IE5。
  - EmulateIE8：如果有文档类型声明，则以IE8标准模式渲染页面，否则将文档模式设置为IE5。
  - EmulateIE7：如果有文档类型声明，则以IE7标准模式渲染页面，否则将文档模式设置为IE5。
  - 9：强制以IE9标准模式渲染页面，忽略文档类型声明。
  - 8：强制以IE8标准模式渲染页面，忽略文档类型声明。
  - 7：强制以IE7标准模式渲染页面，忽略文档类型声明。
  - 5：强制将文档模式设置为IE5，忽略文档类型声明。

- 通过document.documentMode属性可以知道给定页面使用的是什么文档模式。这个属性是IE8中新增的，它会返回使用的文档模式的版本号（在IE9中，可能返回的版本号为5、7、8、9）

### 11.4.2 children属性

- children属性是HTMLCollection 的实例，只包含元素中同样还是元素的子节点。除此之外，children属性与childNodes没有什么区别，即在元素只包含元素子节点时，这两个属性的值相同。
- 支持children属性的浏览器有IE5、Firefox 3.5、Safari 2（但有bug）、Safari 3（完全支持）、Opera8和Chrome（所有版本）。IE8及更早版本的children属性中也会包含注释节点，但IE9之后的版本则只返回元素节点。

### 11.4.3 contains()方法

- 调用contains()方法的应该是祖先节点，也就是搜索开始的节点，这个方法接收一个参数，即要检测的后代节点。如果被检测的节点是后代节点，该方法返回true；否则，返回false。

- 支持contains()方法的浏览器有IE、Firefox 9+、Safari、Opera和Chrome。

- 使用DOM Level 3compareDocumentPosition()也能够确定节点间的关系。支持这个方法的浏览器有IE9+、Firefox、Safari、Opera 9.5+和Chrome。这个方法用于确定两个节点间的关系，返回一个表示该关系的位掩码（bitmask）。

  | 掩码   | 节点关系                    |
  | ---- | ----------------------- |
  | 1    | 无关（给定的节点不在当前文档中）        |
  | 2    | 居前（给定的节点在DOM树中位于参考节点之前） |
  | 4    | 居后（给定的节点在DOM树中位于参考节点之后） |
  | 8    | 包含（给定的节点是参考节点的祖先）       |
  | 16   | 被包含（给定的节点是参考节点的后代）      |

- 为模仿contains()方法，应该关注的是掩码16。可以对compareDocumentPosition()的结果执行按位与，以确定参考节点（调用compareDocumentPosition()方法的当前节点）是否包含给定的节点（传入的节点）。

### 11.4.4 插入文本

- innerText和outerText没有被HTML5纳入规范。

#### 1. innerText属性

- 通过innertText 属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。

- 在通过innerText 读取值时，它会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。

- 在通过innerText写入值时，结果会删除元素的所有子节点，插入包含相应文本值的文本节点。

- 由于不同浏览器处理空白符的方式不同，因此输出的文本可能会也可能不会包含原始HTML代码中的缩进。

- 设置innerText属性移除了先前存在的所有子节点，完全改变了DOM子树。此外，设置innerText属性的同时，也对文本中存在的HTML语法字符（小于号、大于号、引号及和号）进行了编码。

- 设置innerText永远只会生成当前节点的一个子文本节点，而为了确保只生成一个子文本节点，就必须要对文本进行HTML编码。利用这一点，可以通过innerText属性过滤掉HTML标签。方法是将innerText设置为等于innerText，这样就可以去掉所有HTML标签，比如：

  ```
  div.innerText = div.innerText;
  ```

- 支持innerText 属性的浏览器包括IE4+、Safari 3+、Opera 8+和Chrome。Firefox虽然不支持innerText，但支持作用类似的textContent属性。

- textContent是DOM Level 3规定的一个属性，其他支持textContent属性的浏览器还有IE9+、Safari 3+、Opera 10+和Chrome。

- innerText 与textContent 返回的内容并不完全一样。

  - innerText会忽略行内的样式和脚本，而textContent则会像返回其他文本一样返回行内的样式和脚本代码。避免跨浏览器兼容问题的最佳途径，就是从不包含行内样式或行内脚本的DOM子树副本或DOM片段中读取文本。

#### 2. outerText属性

- 在读取文本值时，outerText与innerText的结果完全一样。
- 但在写模式下，outerText就完全不同了：outerText不只是替换调用它的元素的子节点，而是会替换整个元素（包括子节点）。
- 支持outerText属性的浏览器有IE4+、Safari 3+、Opera 8+和Chrome。由于这个属性会导致调用它的元素不存在，因此并不常用。

### 11.4.5 滚动

- scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。如果将可选的alignCenter参数设置为true，则表示尽量将元素显示在视口中部（垂直方向）。Safari和Chrome实现了这个方法。
- scrollByLines(lineCount)：将元素的内容滚动指定的行高，lineCount值可以是正值，也可以是负值。Safari和Chrome实现了这个方法。
- scrollByPages(pageCount)：将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。Safari和Chrome实现了这个方法。
- 注意，scrollIntoView()和scrollIntoViewIfNeeded()的作用对象是元素的容器，而scrollByLines()和scrollByPages()影响的则是元素自身。

## 11.5小结

- Selectors API，定义了两个方法，让开发人员能够基于CSS选择符从DOM中取得元素，这两个方法是querySelector()和querySelectorAll()。
- Element Traversal，为DOM元素定义了额外的属性，让开发人员能够更方便地从一个元素跳到另一个元素。之所以会出现这个扩展，是因为浏览器处理DOM元素间空白符的方式不一样。
- HTML5，为标准的DOM定义了很多扩展功能。其中包括在innerHTML属性这样的事实标准基础上提供的标准定义，以及为管理焦点、设置字符集、滚动页面而规定的扩展API。



# 第12章 DOM2和DOM3

## 12.1 DOM变化

### 12.1.1 针对XML命名空间的变化

- 从技术上说，HTML不支持XML命名空间，但XHTML支持XML命名空间。
- 命名空间要使用xmlns特性来指定。XHTML的命名空间是`http://www.w3.org/1999/xhtml`，在任何格式良好XHTML页面中，都应该将其包含在<html>元素中
- 要想明确地为XML命名空间创建前缀，可以使用xmlns后跟冒号，再后跟前缀

#### 1. Node类型的变化

在DOM2级中，Node类型包含下列特定于命名空间的属性。

- localName：不带命名空间前缀的节点名称。
- namespaceURI：命名空间URI或者（在未指定的情况下是）null。
- prefix：命名空间前缀或者（在未指定的情况下是）null。

DOM3级在此基础上更进一步，又引入了下列与命名空间有关的方法

- isDefaultNamespace(namespaceURI)：在指定的namespaceURI是当前节点的默认命名空间的情况下返回true。
- lookupNamespaceURI(prefix)：返回给定prefix的命名空间。
- lookupPrefix(namespaceURI)：返回给定namespaceURI的前缀。

#### 2. Document类型的变化

DOM2级中的Document类型也发生了变化，包含了下列与命名空间有关的方法。

- createElementNS(namespaceURI, tagName)：使用给定的tagName创建一个属于命名空间namespaceURI的新元素。
- createAttributeNS(namespaceURI, attributeName)：使用给定的attributeName创建一个属于命名空间namespaceURI的新特性。
- getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName元素的NodeList。

#### 3. Element类型的变化

“DOM2级核心”新增的方法如下。

- getAttributeNS(namespaceURI,localName)：取得属于命名空间namespaceURI且名为localName的特性。
- getAttributeNodeNS(namespaceURI,localName)：取得属于命名空间namespaceURI且名为localName的特性节点。
- getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName元素的NodeList。
- hasAttributeNS(namespaceURI,localName)：确定当前元素是否有一个名为localName的特性，而且该特性的命名空间是namespaceURI。注意，“DOM2级核心”也增加了一个hasAttribute()方法，用于不考虑命名空间的情况。
- removeAttriubteNS(namespaceURI,localName)：删除属于命名空间namespaceURI且名为localName的特性。
- setAttributeNS(namespaceURI,qualifiedName,value)：设置属于命名空间namespaceURI且名为qualifiedName的特性的值为value。
- setAttributeNodeNS(attNode)：设置属于命名空间namespaceURI的特性节点。

#### 4. NamedNodeMap类型的变化

由于特性是通过NamedNodeMap表示的，因此这些方法多数情况下只针对特性使用。

- getNamedItemNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName的项。
- removeNamedItemNS(namespaceURI,localName)：移除属于命名空间namespaceURI且名为localName的项。
- setNamedItemNS(node)：添加node，这个节点已经事先指定了命名空间信息。

由于一般都是通过元素访问特性，所以这些方法很少使用。



### 12.1.2 其他方面的变化

#### 1. DocumentType类型的变化

DocumentType类型新增了3个属性：publicId、systemId和internalSubset。其中，前两个属性表示的是文档类型声明中的两个信息段，这两个信息段在DOM1级中是没有办法访问到的。最后一个属性internalSubset，用于访问包含在文档类型声明中的额外定义

#### 2. Document类型的变化

Document类型的变化中唯一与命名空间无关的方法是importNode()。

- 这个方法的用途是从一个文档中取得一个节点，然后将其导入到另一个文档，使其成为这个文档结构的一部分。
- 需要注意的是，每个节点都有一个ownerDocument属性，表示所属的文档。如果调用appendChild()时传入的节点属于不同的文档（ownerDocument属性的值不一样），则会导致错误。但在调用importNode()时传入不同文档的节点则会返回一个新节点，这个新节点的所有权归当前文档所有。
- 接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使用。
- 这个方法在HTML文档中并不常用，在XML文档中用得比较多。

“DOM2级视图”模块添加了一个名为defaultView的属性，其中保存着一个指针，指向拥有给定文档的窗口（或框架）。

除IE之外的所有浏览器都支持defaultView属性。在IE中有一个等价的属性名叫parentWindow（Opera也支持这个属性）。

“DOM2级核心”还为document.implementation对象规定了两个新方法：createDocumentType()和createDocument()。前者用于创建一个新的DocumentType节点，接受3个参数：文档类型名称、publicId、systemId。

创建新文档时需要用到createDocument()方法。这个方法接受3个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型。

```javascript
e.g.	创建XHTML文档
var doctype = document.implementation.createDocumentType("html",
" -//W3C//DTD XHTML 1.0 Strict//EN","http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd");
var doc = document.implementation.createDocument("http://www.w3.org/1999/xhtml",
"html", doctype);
```

“DOM2级HTML”模块也为document.implementation新增了一个方法，名叫createHTMLDocument()。这个方法的用途是创建一个完整的HTML文档，包括<html>、<head>、<title>和<body>元素。这个方法只接受一个参数，即新创建文档的标题（放在<title>元素中的字符串），返回新的HTML文档

只有Opera和Safari支持这个方法。

#### 3. Node类型的变化

isSupported()方法。

- isSupported()方法用于确定当前节点具有什么能力。
- 接受相同的两个参数：特性名和特性版本号。
- 如果浏览器实现了相应特性，而且能够基于给定节点执行该特性，isSupported()就返回true。
- 这个方法同样也存在与DOM1的hasFeature()方法相同的问题。为此，我们建议在确定某个特性是否可用时，最好还是使用能力检测。

DOM3级引入了两个辅助比较节点的方法：isSameNode()和isEqualNode()。

- 这两个方法都接受一个节点参数，并在传入节点与引用的节点相同或相等时返回true。所谓相同，指的是两个节点引用的是同一个对象。所谓相等，指的是两个节点是相同的类型，具有相等的属性（nodeName、nodeValue，等等），而且它们的attributes和childNodes属性也相等（相同位置包含相同的值）。

DOM3级针对为DOM节点添加额外数据引入了新方法

- setUserData()方法
  - 将数据指定给节点
  - 接受3个参数：要设置的键、实际的数据（可以是任何数据类型）和处理函数。
    - 传入setUserData()中的处理函数会在带有数据的节点被复制、删除、重命名或引入一个文档时调用，因而你可以事先决定在上述操作发生时如何处理用户数据。
    - 处理函数接受5个参数：表示操作类型的数值（1表示复制，2表示导入，3表示删除，4表示重命名）、数据键、数据值、源节点和目标节点。在删除节点时，源节点是null；除在复制节点时，目标节点均为null。

#### 4. 框架的变化

框架和内嵌框架分别用HTMLFrameElement和HTMLIFrameElement表示，它们在DOM2级中都有了一个新属性，名叫contentDocument。

这个属性包含一个指针，指向表示框架内容的文档对象。在此之前，无法直接通过元素取得这个文档对象（只能使用frames集合）。

contentDocument属性是Document类型的实例，Opera、Firefox、Safari和Chrome支持这个属性。IE8之前不支持框架中的contentDocument属性，但支持一个名叫contentWindow的属性，该属性返回框架的window对象，而这个window对象又有一个document属性。

```javascript
要想在上述所有浏览器中访问内嵌框架的文档对象，可以使用下列代码。
var iframe = document.getElementById("myIframe");
var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
```

所有浏览器都支持contentWindow属性。

> 访问框架或内嵌框架的文档对象要受到跨域安全策略的限制。如果某个框架中的页面来自其他域或不同子域，或者使用了不同的协议，那么要访问这个框架的文档对象就会导致错误。



## 12.2 样式

要确定浏览器是否支持DOM2级定义的CSS能力，可以使用下列代码。

```javascript
var supportsDOM2CSS = document.implementation.hasFeature("CSS", "2.0"); 
var supportsDOM2CSS2 = document.implementation.hasFeature("CSS2", "2.0"); 
```

### 12.2.1 访问元素的样式

对于使用短划线（分隔不同的词汇，例如background-image）的CSS属性名，必须将其转换成驼峰大小写形式，才能通过JavaScript来访问。

多数情况下，都可以通过简单地转换属性名的格式来实现转换。其中一个不能直接转换的CSS属性就是float。由于float是JavaScript中的保留字，因此不能用作属性名。“DOM2级样式”规范规定样式对象上相应的属性名应该是cssFloat；Firefox、Safari、Opera和Chrome都支持这个属性，而IE支持的则是styleFloat。

> 在标准模式下，所有度量值都必须指定一个度量单位。在混杂模式下，可以将style.width 设置为"20"，浏览器会假设它是"20px"；但在标准模式下，将style.width设置为"20"会导致被忽略——因为没有度量单位。

#### 1. DOM样式属性和方法

“DOM2级样式”规范还为style对象定义了一些属性和方法。

- cssText：如前所述，通过它能够访问到style特性中的CSS代码。
- length：应用给元素的CSS属性的数量。
- parentRule：表示CSS信息的CSSRule对象。
- getPropertyCSSValue(propertyName)：返回包含给定属性值的CSSValue对象。
- getPropertyPriority(propertyName)：如果给定的属性使用了!important设置，则返回"important"；否则，返回空字符串。
- getPropertyValue(propertyName)：返回给定属性的字符串值。
- item(index)：返回给定位置的CSS属性的名称。
- removeProperty(propertyName)：从样式中删除给定属性。
- setProperty(propertyName,value,priority)：将给定属性设置为相应的值，并加上优先权标志（"important"或者一个空字符串）。

设计length属性的目的，就是将其与item()方法配套使用，以便迭代在元素中定义的CSS属性。在使用length和item()时，style对象实际上就相当于一个集合，都可以使用方括号语法来代替item()来取得给定位置的CSS属性

使用removeProperty()方法移除一个属性，意味着将会为该属性应用默认的样式（从其他样式,,表经层叠而来）。

#### 2. 计算的样式

##### getComputedStyle()

“DOM2级样式”增强了document.defaultView，提供了getComputedStyle()方法。

这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如":after"）。如果不需要伪元素信息，第二个参数可以是null。

getComputedStyle()方法返回一个CSSStyleDeclaration对象（与style属性的类型相同），其中包含当前元素的所有计算的样式。

> ```javascript
> <div id="myDiv" style="background-color: red; border: 1px solid black"></div>
> ```
>
> style里面同名的属性会覆盖myDiv中的同名属性

边框属性可能会也可能不会返回样式表中实际的border规则

##### currentStyle

IE不支持getComputedStyle()方法，但它有一种类似的概念。在IE中，每个具有style属性的元素还有一个currentStyle属性。这个属性是CSSStyleDeclaration的实例，包含当前元素全部计算后的样式。

IE也没有返回border样式，因为这是一个综合属性。

##### 总结

无论在哪个浏览器中，最重要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对象中的CSS属性。

### 12.2.2 操作样式表



CSSStyleSheet类型表示的是样式表，包括通过<link>元素包含的样式表和在<style>元素中定义的样式表。

> 这两个元素本身分别是由HTMLLinkElement和HTMLStyleElement类型表示的。但是，CSSStyleSheet类型相对更加通用一些，它只表示样式表，而不管这些样式表在HTML中是如何定义的。此外，上述两个针对元素的类型允许修改HTML特性，但CSSStyleSheet对象则是一套只读的接口（有一个属性例外）。

确定浏览器是否支持DOM2级样式表。

```javascript
var supportsDOM2StyleSheets = document.implementation.hasFeature("StyleSheets", "2.0"); 
```

CSSStyleSheet 继承自StyleSheet，后者可以作为一个基础接口来定义非CSS样式表。

继承而来的属性:

- disabled：表示样式表是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为true可以禁用样式表。
- href：如果样式表是通过<link>包含的，则是样式表的URL；否则，是null。
- media：当前样式表支持的所有媒体类型的集合。与所有DOM集合一样，这个集合也有一个length属性和一个item()方法。也可以使用方括号语法取得集合中特定的项。如果集合是空列表，表示样式表适用于所有媒体。在IE中，media是一个反映<link>和<style>元素media特性值的字符串。
- ownerNode：指向拥有当前样式表的节点的指针，样式表可能是在HTML中通过<link>或<style/>引入的（在XML中可能是通过处理指令引入的）。如果当前样式表是其他样式表通过@import导入的，则这个属性值为null。IE不支持这个属性。
- parentStyleSheet：在当前样式表是通过@import导入的情况下，这个属性是一个指向导入它的样式表的指针。
- title：ownerNode中title属性的值。
- type：表示样式表类型的字符串。对CSS样式表而言，这个字符串是"type/css"。除了disabled 属性之外，其他属性都是只读的。

除了disabled 属性之外，其他属性都是只读的。

在支持以上所有这些属性的基础上，CSSStyleSheet类型还支持下列属性和方法：

- cssRules：样式表中包含的样式规则的集合。IE不支持这个属性，但有一个类似的rules属性。
- ownerRule：如果样式表是通过@import导入的，这个属性就是一个指针，指向表示导入的规则；否则，值为null。IE不支持这个属性。
- deleteRule(index)：删除cssRules集合中指定位置的规则。IE不支持这个方法，但支持一个类似的removeRule()方法。
- insertRule(rule,index)：向cssRules集合中指定的位置插入rule字符串。IE不支持这个方法，但支持一个类似的addRule()方法。

应用于文档的所有样式表是通过document.styleSheets集合来表示的。

不同浏览器的document.styleSheets返回的样式表也不同。所有浏览器都会包含<style>元素和rel特性被设置为"stylesheet"的<link>元素引入的样式表。IE和Opera也包含rel特性被设置为"alternate stylesheet"的<link>元素引入的样式表。

也可以直接通过<link>或<style>元素取得CSSStyleSheet 对象。DOM规定了一个包含CSSStyleSheet 对象的属性，名叫sheet；除了IE，其他浏览器都支持这个属性。IE 支持的是styleSheet属性。

#### 1. CSS规则

CSSStyleRule对象包含下列属性。

- cssText：返回整条规则对应的文本。由于浏览器对样式表的内部处理方式不同，返回的文本可能会与样式表中实际的文本不一样；Safari始终都会将文本转换成全部小写。IE不支持这个属性。
- parentRule：如果当前规则是导入的规则，这个属性引用的就是导入规则；否则，这个值为null。IE不支持这个属性。
- parentStyleSheet：当前规则所属的样式表。IE不支持这个属性。
- selectorText：返回当前规则的选择符文本。由于浏览器对样式表的内部处理方式不同，返回的文本可能会与样式表中实际的文本不一样（例如，Safari 3之前的版本始终会将文本转换成全部小写）。在Firefox、Safari、Chrome和IE中这个属性是只读的。Opera允许修改selectorText。
- style：一个CSSStyleDeclaration对象，可以通过它设置和取得规则中特定的样式值。
- type：表示规则类型的常量值。对于样式规则，这个值是1。IE不支持这个属性。

#### 2.创建规则

##### insertRule()

DOM规定，要向现有样式表中添加新规则，需要使用insertRule()方法。

这个方法接受两个参数：规则文本和表示在哪里插入规则的索引。

插入的规则将成为样式表中的第一条规则（插入到了位置0）——规则的次序在确档的定层叠之后应用到文规则时至关重要。Firefox、Safari、Opera和Chrome都支持insertRule()方法。

##### addRule()

IE8 及更早版本支持一个类似的方法，名叫addRule()，也接收两必选参数：选择符文本和CSS样式信息；一个可选参数：插入规则的位置。

有关这个方法的规定中说，最多可以使用addRule()添加4 095条样式规则。超出这个上限的调用将会导致错误。

#### 3.删除规则

##### deleteRule()

这个方法接受一个参数：要删除的规则的位置。

IE支持的类似方法叫removeRule()，使用方法相同考虑到删除规则可能会影响CSS层叠的效果，要慎重使用。

### 12.2.3 元素大小

#### 1.偏移量

元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。

通过下列4个属性可以取得元素的偏移量。

- offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。
- offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。
- offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。
- offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。

其中，offsetLeft和offsetTop属性与包含元素有关，包含元素的引用保存在offsetParent属性中。offsetParent属性不一定与parentNode的值相等。

> 例如，<td>元素的offsetParent是作为其祖先元素的<table>元素，因为<table>是在DOM层次中距<td>最近的一个**具有大小**的元素。

要想知道某个元素在页面上的偏移量，将这个元素的offsetLeft和offsetTop与其offsetParent的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。

所有这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性；如果需要重复使用其中某些属性的值，可以将它们保存在局部变量中，以提高性能。

#### 2. 客户区大小

元素的客户区大小（client dimension），指的是元素内容及其内边距所占据的空间大小。

有关客户区大小的属性有两个：clientWidth和clientHeight。其中，clientWidth属性是元素内容区宽度加上左右内边距宽度；clientHeight属性是元素内容区高度加上上下内边距高度。

要确定浏览器视口大小，可以使用document.documentElement或document.body（在IE7 之前的版本中）的
clientWidth和clientHeight。

与偏移量相似，客户区大小也是只读的，也是每次访问都要重新计算的。

#### 3. 滚动大小

与滚动大小相关的属性。

- scrollHeight：在没有滚动条的情况下，元素内容的总高度。
- scrollWidth：在没有滚动条的情况下，元素内容的总宽度。
- scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。
- scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。

对于不包含滚动条的页面而言，这些属性会在不同浏览器间发现一些不一致性问题

- Firefox中这两组属性始终都是相等的，但大小代表的是文档内容区域的实际尺寸，而非视口的尺寸。
- Opera、Safari 3.1及更高版本、Chrome中的这两组属性是有差别的，其中scrollWidth 和scrollHeight等于视口大小，而clientWidth和clientHeight等于文档内容区域的大小。
- IE（在标准模式）中的这两组属性不相等，其中scrollWidth和scrollHeight等于文档内容区域的大小，而clientWidth和clientHeight等于视口大小。

在确定文档的总高度时（包括基于视口的最小高度时），必须取得scrollWidth/clientWidth和scrollHeight/clientHeight中的最大值，才能保证在跨浏览器的环境下得到精确的结果

> 注意，对于运行在混杂模式下的IE，则需要用document.body 代替document.documentElement。

通过scrollLeft和scrollTop属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置。

将元素的scrollLeft和scrollTop设置为0，就可以重置元素的滚动位置。

#### 4.确定元素大小

##### getBoundingClientRect()方法。

这个方法返回会一个矩形对象，包含4个属性：left、top、right和bottom。这些属性给出了元素在页面中相对于视口的位置。

但是，浏览器的实现稍有不同。IE8及更早版本认为文档的左上角坐标是(2, 2)，而其他浏览器包括IE9则将传统的(0,0)作为起点坐标。

对于不支持getBoundingClientRect()的浏览器，可以通过其他手段取得相同的信息。一般来说，right和left的差值与offsetWidth的值相等，而bottom和top的差值与offsetHeight相等。而且，left和top属性大致等于使用getElementLeft()和getElementTop()函数取得的值。

## 12.3遍历

“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker。这两个类型能够基于给定的起点对DOM结构执行深度优先（depth-first）的遍历操作。

在与DOM兼容的浏览器中支持。IE不支持DOM遍历。使用下列代码可以检测浏览器对DOM2级遍历能力的支持情况。

```javascript
var supportsTraversals = document.implementation.hasFeature("Traversal", "2.0");
var supportsNodeIterator = (typeof document.createNodeIterator == "function");
var supportsTreeWalker = (typeof document.createTreeWalker == "function");
```

### 12.3.1 NodeIterator

可使用document.createNodeIterator()方法创建它的新实例。这个方法接受下列4个参数。

- root：想要作为搜索起点的树中的节点。
- whatToShow：表示要访问哪些节点的数字代码。
- filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝某种特定节点的函数。
- entityReferenceExpansion：布尔值，表示是否要扩展实体引用。这个参数在HTML页面中没有用，因为其中的实体引用不能扩展。

##### 参数说明

whatToShow参数是一个位掩码，通过应用一或多个过滤器（filter）来确定要访问哪些节点。这个参数的值以常量形式在NodeFilter类型中定义，如下所示。

- NodeFilter.SHOW_ALL：显示所有类型的节点。
- NodeFilter.SHOW_ELEMENT：显示元素节点。
- NodeFilter.SHOW_ATTRIBUTE：显示特性节点。由于DOM结构原因，实际上不能使用这个值。
- NodeFilter.SHOW_TEXT：显示文本节点。
- NodeFilter.SHOW_CDATA_SECTION：显示CDATA节点。对HTML页面没有用。
- NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML页面没有用。
- NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML页面没有用。
- NodeFilter.SHOW_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML页面没有用。
- NodeFilter.SHOW_COMMENT：显示注释节点。
- NodeFilter.SHOW_DOCUMENT：显示文档节点。
- NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型节点。
- NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段节点。对HTML页面没有用。
- NodeFilter.SHOW_NOTATION：显示符号节点。对HTML页面没有用。

可以使用按位或操作符来组合多个选项

可以通过createNodeIterator()方法的filter参数来指定自定义的NodeFilter对象，或者指定一个功能类似节点过滤器（node filter）的 函 数 。每 个NodeFilter对象只有一个方法，即accept- Node()；如果应该访问给定的节点，该方法返回NodeFilter.FILTER_ACCEPT，如果不应该访问给定的节点，该方法返回NodeFilter.FILTER_SKIP。由于NodeFilter是一个抽象的类型，因此不能直接创建它的实例。在必要时，只要创建一个包含acceptNode()方法的对象，然后将这个对象传入createNodeIterator()中即可。

NodeIterator类型的两个主要方法是nextNode()和previousNode()。

当遍历到DOM子树的最后一个节点时，nextNode()返回null。previousNode()方法的工作机制类似。当遍历到DOM子树的最后一个节点，且previousNode()返回根节点之后，再次调用它就会返回null。

Firefox 3.5之前的版本没有实现createNodeIterator()方法，但支持createTreeWalker()方法。

### 12.3.2 TreeWalker

TreeWalker是NodeIterator的一个更高级的版本，还提供了下列用于在不同方向上遍历DOM结构的方法。

- parentNode()：遍历到当前节点的父节点；
- firstChild()：遍历到当前节点的第一个子节点；
- lastChild()：遍历到当前节点的最后一个子节点；
- nextSibling()：遍历到当前节点的下一个同辈节点；
- previousSibling()：遍历到当前节点的上一个同辈节点。

创建TreeWalker对象要使用document.createTreeWalker()方法，这个方法接受的4个参数与document.createNodeIterator()方法相同：作为遍历起点的根节点、要显示的节点类型、过滤器和一个表示是否扩展实体引用的布尔值。

filter可以返回的值有所不同。除了NodeFilter.FILTER_ACCEPT和NodeFilter.FILTER_SKIP 之外，还可以使用NodeFilter.FILTER_REJECT。

在使用NodeIterator 对象时，NodeFilter.FILTER_SKIP与NodeFilter.FILTER_REJECT的作用相同：跳过指定的节点。但在使用TreeWalker对象时，NodeFilter.FILTER_SKIP会跳过相应节点继续前进到子树中的下一个节点，
而NodeFilter.FILTER_REJECT 则会跳过相应节点及该节点的整个子树。

TreeWalker真正强大的地方在于能够在DOM结构中沿任何方向移动。
TreeWalker类型还有一个属性，名叫currentNode，表示任何遍历方法在上一次遍历中返回的节点。通过设置这个属性也可以修改遍历继续进行的起点

## 12.4 范围

通过范围可以选择文档中的一个区域，而不必考虑节点的界限（选择在后台完成，对用户是不可见的）。在常规的DOM操作不能更有效地修改文档时，使用范围往往可以达到目的。
Firefox、Opera、Safari和Chrome都支持DOM范围。IE以专有方式实现了自己的范围特性。

### 12.4.1 DOM中的范围

##### createRange()方法。

在兼容DOM的浏览器中，这个方法属于document对象。
使用hasFeature()或者直接检测该方法，都可以确定浏览器是否支持范围。

```javascript
var supportsRange = document.implementation.hasFeature("Range", "2.0");
var alsoSupportsRange = (typeof document.createRange == "function");
```

每个范围由一个Range类型的实例表示，这个实例拥有很多属性和方法。下列属性提供了当前范围在文档中的位置信息。

- startContainer：包含范围起点的节点（即选区中第一个节点的父节点）。
- startOffset：范围在startContainer中起点的偏移量。如果startContainer是文本节点、注释节点或CDATA节点，那么startOffset就是范围起点之前跳过的字符数量。否则，startOffset就是范围中第一个子节点的索引。
- endContainer：包含范围终点的节点（即选区中最后一个节点的父节点）。
- endOffset：范围在endContainer中终点的偏移量（与startOffset遵循相同的取值规则）。
- commonAncestorContainer：startContainer和endContainer共同的祖先节点在文档树中位置最深的那个。

#### 1. 用DOM范围实现简单选择

要使用范围来选择文档中的一部分，使用selectNode()或selectNodeContents()。
这两个方法都接受一个参数，即一个DOM节点，然后使用该节点中的信息来填充范围。
其中，selectNode()方法选择整个节点，包括其子节点；而selectNodeContents()方法则只选择节点的子节点。

为了更精细地控制将哪些节点包含在范围中，还可以使用下列方法。

- setStartBefore(refNode)

  将范围的起点设置在refNode之前，因此refNode也就是范围选区中的第一个子节点。同时会将startContainer属性设置为refNode.parentNode，将startOffset属性设置为refNode在其父节点的childNodes集合中的索引。

- setStartAfter(refNode)

  将范围的起点设置在refNode之后，因此refNode也就不在范围之内了，其下一个同辈节点才是范围选区中的第一个子节点。同时会将startContainer属性设置为refNode.parentNode，将startOffset 属性设置为refNode 在其父节点的childNodes集合中的索引加1。

- setEndBefore(refNode)

  将范围的终点设置在refNode之前，因此refNode也就不在范围之内了，其上一个同辈节点才是范围选区中的最后一个子节点。同时会将endContainer属性设置为refNode.parentNode，将endOffset属性设置为refNode在其父节点的childNodes集合中的索引。

- setEndAfter(refNode)

  将范围的终点设置在refNode之后，因此refNode也就是范围选区中的最后一个子节点。同时会将endContainer 属性设置为refNode.parentNode，将endOffset属性设置为refNode在其父节点的childNodes集合中的索引加1。

#### 2. 用DOM范围实现复杂选择

##### setStart()和setEnd()方法

这两个方法都接受两个参数：一个参照节点和一个偏移量值。
对setStart()来说，参照节点会变成startContainer，而偏移量值会变成startOffset。
对于setEnd()来说，参照节点会变成endContainer，而偏移量值会变成endOffset。

setStart()和setEnd()的主要用途，能够选择节点的一部分。

#### 3.操作DOM范围中的内容

##### deleteContents()

这个方法能够从文档中删除范围所包含的内容。由于范围选区在修改底层DOM结构时能够保证格式良好，因此即使内容被删除了，最终的DOM结构依旧是格式良好的。

##### extractContents()

也会从文档中移除范围选区。与deleteContents()方法的区别在于，extractContents()会返回范围的文档片段。利用这个返回的值，可以将范围的内容插入到文档中的其他地方。

##### cloneContents()

创建范围对象的一个副本，然后在文档的其他地方插入该副本。

#### 4.插入DOM范围中的内容

##### insertNode()

向范围选区的开始处插入一个节点
使用这种技术可以插入一些帮助提示信息，例如在打开新窗口的链接旁边插入一幅图像。

##### surroundContents()

环绕范围插入内容。这个方法接受一个参数，即环绕范围内容的节点。
在环绕范围插入内容时，后台会执行下列步骤。

- 提取出范围中的内容（类似执行extractContent()）；
- 将给定节点插入到文档中原来范围所在的位置上；
- 将文档片段的内容添加到给定节点中。

可以使用这种技术来突出显示网页中的某些词句

#### 5.折叠DOM范围

所谓折叠范围，就是指范围中未选择文档的任何部分。可以用文本框来描述折叠范围的过程。

##### collapse()

接受一个参数，一个布尔值，表示要折叠到范围的哪一端。参数true表示折叠到范围的起点，参数false表示折叠到范围的终点。
要确定范围已经折叠完毕，可以检查collapsed属性
检测某个范围是否处于折叠状态，可以帮我们确定范围中的两个节点是否紧密相邻。

#### 6.比较DOM范围

##### compareBoundaryPoints()

确定这些范围是否有公共的边界（起点或终点）。
这个方法接受两个参数：表示比较方式的常量值和要比较的范围。
表示比较方式的常量值如下所示。

- Range.START_TO_START(0)：比较第一个范围和第二个范围的起点；
- Range.START_TO_END(1)：比较第一个范围的起点和第二个范围的终点；
- Range.END_TO_END(2)：比较第一个范围和第二个范围的终点；
- Range.END_TO_START(3)：比较第一个范围的终点和第一个范围的起点。

返回值如下：

- 如果第一个范围中的点位于第二个范围中的点之前，返回-1；
- 如果两个点相等，返回0；如果第一个范围中的点位于第二个范围中的点之后，返回1。

#### 7. 复制DOM范围

##### cloneRange()

这个方法会创建调用它的范围的一个副本。

#### 8. 清理DOM范围

在使用完范围之后，最好是调用detach()方法，以便从创建范围的文档中分离出该范围。

### 12.4.2 IE8及更早版本中的范围

IE8及之前版本不支持DOM范围,支持文本范围。文本范围是IE专有的特性，其他浏览器都不支持。

通过<body>、<button>、<input>和<textarea>等这几个元素，可以调用createTextRange()方法来创建文本范围。

```javascript
var range = document.body.createTextRange();
```

#### 1. 用IE范围实现简单的选择

##### findText()

这个方法会找到第一次出现的给定文本，并将范围移过来以环绕该文本。如果没有找到文本，这个方法返回false；否则返回true。

还可以为findText()传入另一个参数，即一个表示向哪个方向继续搜索的数值。负值表示应该从当前位置向后搜索，而正值表示应该从当前位置向前搜索。

##### moveToElementText()

IE中与DOM中的selectNode()方法最接近，这个方法接受一个DOM元素，并选择该元素的所有文本，包括HTML标签。

在文本范围中包含HTML的情况下，可以使用htmlText属性取得范围的全部内容，包括HTML和文本

##### parentElement()

IE的范围没有任何属性可以随着范围选区的变化而动态更新。不过，其parentElement()方法倒是与DOM的commonAncestorContainer属性类似。

#### 2.使用IE范围实现复杂的选择

##### move()、moveStart()、moveEnd()和expand()

这些方法都接受两个参数：移动单位和移动单位的数量。
其中，移动单位是下列一种字符串值。

- "character"：逐个字符地移动。
- "word"：逐个单词（一系列非空格字符）地移动。
- "sentence"：逐个句子（一系列以句号、问号或叹号结尾的字符）地移动。
- "textedit"：移动到当前范围选区的开始或结束位置。

通过moveStart()方法可以移动范围的起点，通过moveEnd()方法可以移动范围的终点，移动的幅度由单位数量指定

使用expand()方法可以将范围规范化。换句话说，expand()方法的作用是将任何部分选择的文本全部选中。

move()方法则首先会折叠当前范围（让起点和终点相等），然后再将范围移动指定的单位数量

#### 3. 操作IE范围中的内容

可以使用text属性或pasteHTML()方法
注意，在设置text属性的情况下，HTML标签保持不变。
要向范围中插入HTML代码，就得使用pasteHTML()方法
不过，在范围中包含HTML代码时，不应该使用pasteHTML()，因为这样很容易导致不可预料的结果——很可能是格式不正确的HTML。

#### 4. 折叠IE范围

##### collapse()

传入true把范围折叠到起点，传入false把范围折叠到终点。

boundingWidth属性，该属性返回范围的宽度（以像素为单位）。如果boundingWidth属性等于0，就说明范围已经折叠了
此外，还有boundingHeight、boundingLeft 和boundingTop 等属性

#### 5. 比较IE范围

##### compareEndPoints()

compareEndPoints()方法与DOM范围的compareBoundaryPoints()方法类似。
这个方法接受两个参数：比较的类型和要比较的范围。
比较类型的取值范围是下列几个字符串值："StartToStart"、"StartToEnd"、"EndToEnd"和"EndToStart"。这几种比较类型与比较DOM范围时使用的几个值是相同的。
同样与DOM类似的是，compareEndPoints()方法也会按照相同的规则返回值，即如果第一个范围的边界位于第二个范围的边界前面，返回-1；如果二者边界相同，返回0；如果第一个范围的边界位于第二个范围的边界后面，返回1。

##### isEqual()和inRange()

isEqual()用于确定两个范围是否相等，inRange()用于确定一个范围是否包含另一个范围。

#### 6. 复制IE范围

##### duplicate()

在IE中使用duplicate()方法可以复制文本范围，结果会创建原范围的一个副本，新创建的范围会带有与原范围完全相同的属性。

## 12.5 小结

“DOM2级样式”模块主要针对操作元素的样式信息而开发，其特性简要总结如下。

- 每个元素都有一个关联的style对象，可以用来确定和修改行内的样式。
- 要确定某个元素的计算样式（包括应用给它的所有CSS规则），可以使用getComputedStyle()方法。
- IE不支持getComputedStyle()方法，但为所有元素都提供了能够返回相同信息currentStyle属性。
- 可以通过document.styleSheets集合访问样式表。
- 除IE之外的所有浏览器都支持针对样式表的这个接口，IE也为几乎所有相应的DOM功能提供了自己的一套属性和方法。

“DOM2级遍历和范围”模块提供了与DOM结构交互的不同方式，简要总结如下。

- 遍历即使用NodeIterator或TreeWalker对DOM执行深度优先的遍历。
- NodeIterator是一个简单的接口，只允许以一个节点的步幅前后移动。而TreeWalker在提供相同功能的同时，还支持在DOM结构的各个方向上移动，包括父节点、同辈节点和子节点等方向。
- 范围是选择DOM结构中特定部分，然后再执行相应操作的一种手段。
- 使用范围选区可以在删除文档中某些部分的同时，保持文档结构的格式良好，或者复制文档中的相应部分。
- IE8及更早版本不支持“DOM2级遍历和范围”模块，但它提供了一个专有的文本范围对象，可以用来完成简单的基于文本的范围操作。IE9完全支持DOM遍历。




# 第13章 事件

IE8是最后一个仍然使用其专有事件系统的主要浏览器。

## 13.1 事件流

IE的事件流是事件冒泡流，而Netscape Communicator的事件流是事件捕获流。

### 13.1.1 事件冒泡

**IE的事件流叫做事件冒泡**，即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。

所有现代浏览器都支持事件冒泡，但在具体实现上还是有一些差别。IE5.5 及更早版本中的事件冒泡会跳过`<html>`元素（从<body直接跳到document）。IE9、Firefox、Chrom和Safari则将事件一直冒泡到window对象。

### 13.1.2 事件捕获

Netscape Communicator提出事件捕获。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。

**建议使用事件冒泡，在有特殊需要时再使用事件捕获。**

### 13.1.3 DOM事件流

“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。

多数支持DOM事件流的浏览器都实现了一种特定的行为；即使“DOM2级事件”规范明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera 9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。

> IE9、Opera、Firefox、Chrome和Safari都支持DOM事件流；IE8及更早版本不支持DOM事件流。

## 13.2 事件处理程序

### 13.2.1 HTML事件处理程序

为了避免使用HTML实体，可以使用了单引号替代双引号。

事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。

事件处理程序会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象，通过event变量，可以直接访问事件对象，你不用自己定义它，也不用从函数的参数列表中读取。
在这个函数内部，this值等于事件的目标元素

扩展作用域的方式：使用with

```javascript
function(){ 
    with(document){ 
        with(this){ 
        	//元素属性值
        } 
    } 
}
```

在HTML中指定事件处理程序有两个缺点：

1. 存在一个时差问题。因为用户可能会在HTML元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件。为此，很多HTML事件处理程序都会被封装在一个try-catch块中
2. 扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同JavaScript引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。
3. HTML与JavaScript代码紧密耦合。

### 13.2.2 DOM0级事件处理程序

每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写

使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行；换句话说，程序中的this引用当前元素。

删除通过DOM0级方法指定的事件处理程序，将事件处理程序属性的值设置为null即可

### 13.2.3 DOM2级事件处理程序

#### addEventListener()和removeEventListener()

所有DOM节点中都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。

使用DOM2级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。会按照添加的顺序触发

通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过addEventListener()添加的匿名函数将无法移除

传入removeEventListener()中的事件处理程序函数必须与传入addEventListener()中的相同

大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。不建议在事件捕获阶段注册事件处理程序。

> IE9、Firefox、Safari、Chrome和Opera支持DOM2级事件处理程序。

### 13.2.4 IE事件处理程序

attachEvent()和detachEvent()

接受相同的两个参数：事件处理程序名称与事件处理程序函数。由于IE8 及更早版本只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。

注意，attachEvent()的第一个参数是"onclick"，而非DOM的addEventListener()方法中的"click"。

在IE中使用attachEvent()与使用DOM0级方法的主要区别在于事件处理程序的作用域。在使用DOM0级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window。

attachEvent()方法也可以用来为一个元素添加多个事件处理程序，不过，与DOM方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发。

使用attachEvent()添加的事件可以通过detachEvent()来移除，条件是必须提供相同的参数。与DOM方法一样，这也意味着添加的匿名函数将不能被移除。不过，只要能够将对相同函数的引用传给detachEvent()，就可以移除相应的事件处理程序。

> 支持IE事件处理程序的浏览器有IE和Opera。

### 13.2.5 跨浏览器的事件处理程序

第一个要创建的方法是addHandler()，它的职责是视情况分别使用DOM0级方法、DOM2级方法或IE方法来添加事件。这个方法属于一个名叫EventUtil的对象，本书将使用这个对象来处理浏览器间的差异。addHandler()方法接受3个参数：要操作的元素、事件名称和事件处理程序函数。

removeHandler()，它也接受相同的参数。这个方法的职责是移除之前添加的事件处理程序——无论该事件处理程序是采取什么方式添加到元素中的，如果其他方法无效，默认采用DOM0级方法。

addHandler()和removeHandler()没有考虑到所有的浏览器问题，例如在IE中的作用域问题。此外还要注意，DOM0级对每个事件只支持一个事件处理程序。

## 13.3 事件对象

### 13.3.1 DOM中的事件对象

无论指定事件处理程序时使用什么方法（DOM0级或DOM2级），都会传入event对象。

| 属性/方法                      | 类 型          | 读/写  | 说 明                                      |
| -------------------------- | ------------ | ---- | ---------------------------------------- |
| bubbles                    | Boolean      | 只读   | 表明事件是否冒泡                                 |
| cancelable                 | Boolean      | 只读   | 表明是否可以取消事件的默认行为                          |
| currentTarget              | Element      | 只读   | 其事件处理程序当前正在处理事件的那个元素                     |
| defaultPrevented           | Boolean      | 只读   | 为true表示已经调用了preventDefault()（DOM3级事件中新增） |
| detail                     | Integer      | 只读   | 与事件相关的细节信息                               |
| eventPhase                 | Integer      | 只读   | 调用事件处理程序的阶段：1表示捕获阶段，2表示“处于目标”，3表示冒泡阶段    |
| preventDefault()           | Function     | 只读   | 取消事件的默认行为。如果cancelable是true，则可以使用这个方法    |
| stopImmediatePropagation() | Function     | 只读   | 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3级事件中新增） |
| stopPropagation()          | Function     | 只读   | 取消事件的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法   |
| target                     | Element      | 只读   | 事件的目标                                    |
| trusted                    | Boolean      | 只读   | 为true表示事件是浏览器生成的。为false表示事件是由开发人员通过JavaScript创建的（DOM3级事件中新增） |
| type                       | String       | 只读   | 被触发的事件的类型                                |
| view                       | AbstractView | 只读   | 与事件关联的抽象视图。等同于发生事件的                      |

在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则this、currentTarget和target包含相同的值。如果事件处理程序存在于父节点中，那么这些值是不相同的。

在需要通过一个函数处理多个事件时，可以使用type属性。

事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的哪个阶段。这里要注意的是，尽管“处于目标”发生在冒泡阶段，但eventPhase仍然一直等于2。

```javascript
var btn = document.getElementById("myBtn"); 
btn.onclick = function(event){ 
	alert(event.eventPhase); //2 
}; 
document.body.addEventListener("click", function(event){ 
	alert(event.eventPhase); //1 
}, true); 
document.body.onclick = function(event){ 
	alert(event.eventPhase); //3 
}; 
```

> 只有在事件处理程序执行期间，event对象才会存在；一旦事件处理程序执行完成，event对象就会被销毁。

### 13.3.2 IE中的事件对象

在使用DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在，可通过window.event取得了event对象。

如果事件处理程序是使用attachEvent()添加的，也可以通过window对象来访问event对象

如果是通过HTML特性指定的事件处理程序，那么还可以通过一个名叫event的变量来访问event对象

IE的event对象同样也包含与创建它的事件相关的属性和方法。

| 属性/方法        | 类 型     | 读/写  | 说 明                                      |
| ------------ | ------- | ---- | ---------------------------------------- |
| cancelBubble | Boolean | 读/写  | 默认值为false，但将其设置为true就可以取消事件冒泡（与DOM中的stopPropagation()方法的作用相同） |
| returnValue  | Boolean | 读/写  | 默认值为true，但将其设置为false就可以取消事件的默认行为（与DOM中的preventDefault()方法的作用相同） |
| srcElement   | Element | 只读   | 事件的目标（与DOM中的target属性相同）                  |
| type         | String  | 只读   | 被触发的事件的类型                                |

cancelBubble属性与DOM中的stopPropagation()方法作用相同，都是用来停止事件冒泡的。由于IE不支持事件捕获，因而只能取消事件冒泡；但stopPropagatioin()可以同时取消事件捕获和冒泡。

### 13.3.3 跨浏览器的事件对象

EventUtil添加了4个新方法第一个是getEvent()，它返回对event对象的引用。在使用这个方法时，必须假设有一个事件对象传入到事件处理程序中，而且要把该变量传给这个方法

第二个方法是getTarget()，它返回事件的目标。在这个方法内部，会检测event对象的target属性，如果存在则返回该属性的值；否则，返回srcElement属性的值。

第三个方法是preventDefault()，用于取消事件的默认行为。在传入event对象后，这个方法会检查是否存在preventDefault()方法，如果存在则调用该方法。如果preventDefault()方法存在，则将returnValue设置为false。

第四个方法是stopPropagation()，其实现方式类似。首先尝试使用DOM方法阻止事件流，否则就使用cancelBubble属性。

## 13.4 事件类型

“DOM3级事件”规定了以下几类事件。

- UI事件，当用户与页面上的元素交互时触发；
- 焦点事件，当元素获得或失去焦点时触发；
- 鼠标事件，当用户通过鼠标在页面上执行操作时触发；
- 滚轮事件，当使用鼠标滚轮（或类似设备）时触发；
- 文本事件，当在文档中输入文本时触发；
- 键盘事件，当用户通过键盘在页面上执行操作时触发；
- 合成事件，当为IME（Input Method Editor，输入法编辑器）输入字符时触发；
- 变动（mutation）事件，当底层DOM结构发生变化时触发。
- 变动名称事件，当元素或属性名变动时触发。此类事件已经被废弃，没有任何浏览器实现它们。

### 13.4.1 UI事件

现有的UI事件如下：

- DOMActivate：表示元素已经被用户操作（通过鼠标或键盘）激活。这个事件在DOM3级事件中被废弃，但Firefox 2+和Chrome支持它。
- load：当页面完全加载后在window上面触发，当所有框架都加载完毕时在框架集上面触发，当图像加载完毕时在`<img>`元素上面触发，或者当嵌入的内容加载完毕时在`<object>`元素上面触发。 
- unload：当页面完全卸载后在window上面触发，当所有框架都卸载后在框架集上面触发，或者当嵌入的内容卸载完毕后在`<object>`元素上面触发。
- abort：在用户停止下载过程时，如果嵌入的内容没有加载完，则在`<object>`元素上面触发。  
- error：当发生JavaScript错误时在window上面触发，当无法加载图像时在`<img>`元素上面触发，当无法加载嵌入内容时在`<object>`元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发。
- select：当用户选择文本框（`<input>`或`<texterea>`）中的一或多个字符时触发。
- resize：当窗口或框架的大小变化时在window或框架上面触发。
- scroll：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。`<body>`元素中包含所加载页面的滚动条。

除了DOMActivate之外，其他事件在DOM2级事件中都归为HTML事件（DOMActivate在DOM2级中仍然属于UI事件）。要确定浏览器是否支持DOM2级事件规定的HTML事件，可以使用如下代码：

```javascript
var isSupported = document.implementation.hasFeature("HTMLEvents", "2.0"); 
```

要确定浏览器是否支持“DOM3级事件”定义的事件，可以使用如下代码：

```javascript
var isSupported = document.implementation.hasFeature("UIEvent", "3.0");
```

#### 1. load事件

当页面完全加载后（包括所有图像、JavaScript文件、CSS文件等外部资源），就会触发window上面的load事件。

有两种定义onload事件处理程序的方式。
第一种方式是使用如下所示的JavaScript代码：

```javascript
EventUtil.addHandler(window, "load", function(event){ 
	alert("Loaded!"); 
});  
```

这个event对象中不包含有关这个事件的任何附加信息，但在兼容DOM的浏览器中，event.target 属性的值会被设置为document，而IE并不会为这个事件设置srcElement属性。

第二种指定onload事件处理程序的方式是为<body>元素添加一个onload特性

```html
<!DOCTYPE html> 
<html> 
<head>
	<title>Load Event Example</title> 
</head> 
<body onload="alert('Loaded!')"> 
</body> 
</html> 
```

建议尽可能使用JavaScript方式。

> 根据“DOM2级事件”规范，应该在document而非window上面触发load事件。但是，所有浏览器都在window上面实现了该事件，以确保向后兼容。

在创建新的`<img>`元素时，可以为其指定一个事件处理程序，以便图像加载完毕后给出提示。此时，最重要的是要在指定src属性之前先指定事件

有一点需要格外注意：新图像元素不一定要从添加到文档后才开始下载，只要设置了src属性就会开始下载。

> 在不属于DOM文档的图像（包括未添加到文档的`<img>`元素和Image对象）上触发load事件时，IE8及之前版本不会生成event对象。IE9修复了这个问题。

在IE9+、Firefox、Opera、Chrome和Safari 3+及更高版本中，`<script>`元素也会触发load事件，以便开发人员确定动态加载的JavaScript文件是否加载完毕。与图像不同，只有在设置了`<script>`元素的src属性并将该元素添加到文档后，才会开始下载JavaScript文件。换句话说，对于`<script>`元素而言，指定src属性和指定事件处理程序的先后顺序就不重要了。 

IE和Opera还支持`<link>`元素上的load事件，以便开发人员确定样式表是否加载完毕。与`<script>`节点类似，在未指定href属性并将`<link>`元素添加到文档之前也不会开始下载样式表。

#### 2. unload事件

这个事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。

有两种指定onunload事件处理程序的方式。
第一种方式是使用JavaScript，如下所示：

```javascript
EventUtil.addHandler(window, "unload", function(event){ 
	alert("Unloaded"); 
}); 
```

此时生成的event对象在兼容DOM的浏览器中只包含target属性（值为document）。IE8及之
前版本则为这个事件对象提供了srcElement属性。

第二种方式，也是为`<body>`元素添加一个特性

> 根据“DOM2级事件”，应该在`<body>`元素而非window对象上面触发unload事件。不过，所有浏览器都在window上实现了unload事件，以确保向后兼容。

#### 3.resize事件

当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize事件。

这个事件在window（窗口）上面触发，因此可以通过JavaScript或者`<body>`元素中的onresize特性来指定事件处理程序。

推荐使用如下所示的JavaScript方式：

```javascript
EventUtil.addHandler(window, "resize", function(event){ 
	alert("Resized"); 
}); 
```

在兼容DOM的浏览器中，传入事件处理程序中的event对象有一个target属性，值为document；而IE8及之前版本则未提供任何属性。

关于何时会触发resize事件，不同浏览器有不同的机制。IE、Safari、Chrome和Opera会在浏览器窗口变化了1像素时就触发resize事件，然后随着变化不断重复触发。Firefox则只会在用户停止调整窗口大小时才会触发resize事件。

> 浏览器窗口最小化或最大化时也会触发resize事件。

#### 4. scroll事件

在混杂模式下，可以通过`<body>`元素的scrollLeft和scrollTop来监控到这一变化；而在标准模式下，
除Safari之外的所有浏览器都会通过`<html>`元素来反映这一变化（Safari仍然基于`<body>`跟踪滚动位
置）

与resize事件类似，scroll事件也会在文档被滚动期间重复被触发，所以有必要尽量保持事件处理程序的代码简单。

### 13.4.2 焦点事件

利用焦点事件并与document.hasFocus()方法及document.activeElement属性配合，可以知晓用户在页面上的行踪。

有以下6个焦点事件。

- blur：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。
- DOMFocusIn：在元素获得焦点时触发。这个事件与HTML事件focus等价，但它冒泡。只有Opera支持这个事件。DOM3级事件废弃了DOMFocusIn，选择了focusin。
- DOMFocusOut：在元素失去焦点时触发。这个事件是HTML事件blur的通用版本。只有Opera支持这个事件。DOM3级事件废弃了DOMFocusOut，选择了focusout。
- focus：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。
- focusin：在元素获得焦点时触发。这个事件与HTML事件focus等价，但它冒泡。支持这个事件的浏览器有IE5.5+、Safari 5.1+、Opera 11.5+和Chrome。
- focusout：在元素失去焦点时触发。这个事件是HTML事件blur的通用版本。支持这个事件的浏览器有IE5.5+、Safari 5.1+、Opera 11.5+和Chrome。

当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件：

- focusout在失去焦点的元素上触发；
- focusin在获得焦点的元素上触发；
- blur在失去焦点的元素上触发；
- DOMFocusOut在失去焦点的元素上触发；
- focus在获得焦点的元素上触发；
- DOMFocusIn在获得焦点的元素上触发。

要确定浏览器是否支持这些事件，可以使用如下代码：

```javascript
var isSupported = document.implementation.hasFeature("FocusEvent", "3.0"); 
```

> 即使focus和blur不冒泡，也可以在捕获阶段侦听到它们。

### 13.4.3 鼠标与滚轮事件

DOM3级事件中定义了9个鼠标事件，简介如下。

- click：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。这一点对确保易访问性很重要，意味着onclick事件处理程序既可以通过键盘也可以通过鼠标执行。
- dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发。从技术上说，这个事件并不是DOM2级事件规范中规定的，但鉴于它得到了广泛支持，所以DOM3级事件将其纳入了标准。
- mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。
- mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2级事件并没有定义这个事件，但DOM3级事件将它纳入了规范。IE、Firefox 9+和Opera支持这个事件。
- mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2级事件并没有定义这个事件，但DOM3级事件将它纳入了规范。IE、Firefox 9+和Opera支持这个事件。
- mousemove：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。
- mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。
- mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。
- mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。

除了mouseenter和mouseleave，所有鼠标事件都会冒泡，也可以被取消，而取消鼠标事件将会影响浏览器的默认行为。

只有在同一个元素上相继触发mousedown 和mouseup 事件，才会触发click 事件；如果mousedown或mouseup中的一个被取消，就不会触发click事件。类似地，只有触发两次click事件，才会触发一次dblclick事件。

这4个事件触发的顺序始终如下：

1. mousedown 
2. mouseup 
3. click 
4. mousedown 
5. mouseup 
6. click 
7. dblclick

IE8及之前版本中的实现有一个小bug，因此在双击事件中，会跳过第二个mousedown和click事件

使用以下代码可以检测浏览器是否支持以上DOM2级事件（除dbclick、mouseenter 和mouseleave之外）：

```javascript
var isSupported = document.implementation.hasFeature("MouseEvents", "2.0"); 
```

要检测浏览器是否支持上面的所有事件，可以使用以下代码：

```javascript
var isSupported = document.implementation.hasFeature("MouseEvent", "3.0") 
```

#### 1. 客户区坐标位置

客户端位置信息保存在事件对象的clientX和clientY 属性中。所有浏览器都支持这两个属性，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。

注意，这些值中不包括页面滚动的距离，因此这个位置并不表示鼠标在页面上的位置。

#### 2. 页面坐标位置

页面坐标通过事件对象的pageX和pageY属性，能告诉你事件是在页面中的什么位置发生的。换句话说，这两个属性表示鼠标光标在页面中的位置，因此坐标是从页面本身而非视口的左边和顶边计算的。

在页面没有滚动的情况下，pageX和pageY的值与clientX和clientY的值相等。IE8及更早版本不支持事件对象上的页面坐标，不过使用客户区坐标和滚动信息可以计算出

#### 3. 屏幕坐标位置

鼠标事件发生时，不仅会有相对于浏览器窗口的位置，还有一个相对于整个电脑屏幕的位置。而通过screenX和screenY属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。

#### 4. 修改键

这些修改键就是Shift、Ctrl、Alt和Meta（在Windows键盘中是Windows键，在苹果机中是Cmd键），它们经常被用来修改鼠标事件的行为。

DOM为此规定了4个属性，表示这些修改键的状态：shiftKey、ctrlKey、altKey和metaKey。这些属性中包含的都是布尔值，如果相应的键被按下了，则值为true，否则值为false。当某个鼠标事件发生时，通过检测这几个属性就可以确定用户是否同时按下了其中的键。

> IE9、Firefox、Safari、Chrome和Opera都支持这4个键。IE8及之前版本不支持metaKey属性。

#### 5. 相关元素

mouseover和mouserout事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。对mouseover事件而言，事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素。类似地，对mouseout事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。

DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对于mouseover和mouseout事件才包含值；对于其他事件，这个属性的值是null。IE8及之前版本不支持relatedTarget属性，但提供了保存着同样信息的不同属性。在mouseover事件触发时，IE的fromElement属性中保存了相关元素；在mouseout事件触发时，IE的toElement属性中保存着相关元素。（IE9支持所有这些属性。） 

#### 6. 鼠标按钮

对于mousedown和mouseup事件来说，则在其event对象存在一个button属性，表示按下或释放的钮。

DOM的button属性可能有如下3个值：0表示主鼠标按钮，1表示中间的鼠标按钮（鼠标滚轮按钮），2表示次鼠标按钮。

IE8及之前版本也提供了button属性，但这个属性的值与DOM的button属性有很大差异。

- 0：表示没有按下按钮。
- 1：表示按下了主鼠标按钮。
- 2：表示按下了次鼠标按钮。
- 3：表示同时按下了主、次鼠标按钮。
- 4：表示按下了中间的鼠标按钮。 
- 5：表示同时按下了主鼠标按钮和中间的鼠标按钮。
- 6：表示同时按下了次鼠标按钮和中间的鼠标按钮。
- 7：表示同时按下了三个鼠标按钮。

IE中返回的5和7会被转换成DOM模型中的0。

通过检测"MouseEvents"这个特性，就可以确定event对象中存在的button属性中是否包含正确的值。如果测试失败，说明是IE，就必须对相应的值进行规范化。

> 在使用onmouseup事件处理程序时，button的值表示释放的是哪个按钮。此外，如果不是按下或释放了主鼠标按钮，Opera不会触发mouseup 或mousedown 事件。

#### 7. 更多的事件信息

“DOM2级事件”规范在event对象中还提供了detail属性，用于给出有关事件的更多信息。对于鼠标事件来说，detail中包含了一个数值，表示在给定位置上发生了多少次单击。如果鼠标在mousedown和mouseup之间移动了位置，则detail会被重置为0。

IE也通过下列属性为鼠标事件：

- altLeft：布尔值，表示是否按下了Alt键。如果altLeft的值为true，则altKey的值也为true。
- ctrlLeft：布尔值，表示是否按下了Ctrl键。如果ctrlLeft的值为true，则ctrlKey的值也为true。
- offsetX：光标相对于目标元素边界的x坐标。
- offsetY：光标相对于目标元素边界的y坐标。
- shiftLeft：布尔值，表示是否按下了Shift键。如果shiftLeft的值为true，则shiftKey的值也为true。               

#### 8. 鼠标滚轮事件

当用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时（无论向上还是向下），就会触发mousewheel事件。这个事件可以在任何元素上面触发，最终会冒泡到document（IE8）或window（IE9、Opera、Chrome及Safari）对象。

与mousewheel事件对应的event对象除包含鼠标事件的所有标准信息外，还包含一个特殊的wheelDelta属性。当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数；当用户向后滚动鼠标滚轮时，wheelDelta是-120的倍数。

注意：在Opera 9.5之前的版本中，wheelDelta值的正负号是颠倒的。

> 由于mousewheel事件非常流行，而且所有浏览器都支持它，所以HTML 5也加入了该事件。

Firefox支持一个名为DOMMouseScroll的类似事件，也是在鼠标滚轮滚动时触发。包含与鼠标事件有关的所有属性。有关鼠标滚轮的信息则保存在detail属性中，当向前滚动鼠标滚轮时，这个属性的值是-3的倍数，当向后滚动鼠标滚轮时，这个属性的值是3的倍数。可以将DOMMouseScroll事件添加到页面中的任何元素，而且该事件会冒泡到window对象。

#### 9. 触摸设备

 面向触摸设备，要记住以下几点。

- 不支持dblclick事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。
- 轻击可单击元素会触发mousemove事件。如果此操作会导致内容变化，将不再有其他事件发生；如果屏幕没有因此变化，那么会依次发生mousedown、mouseup和click事件。轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了onclick事件处理程序的元素。
- mousemove事件也会触发mouseover和mouseout事件。
- 两个手指放在屏幕上且页面随手指移动而滚动时会触发mousewheel和scroll事件。

#### 10. 无障碍性问题

不建议使用click之外的其他鼠标事件来展示功能或引发代码执行。因为这样会给盲人或视障用户造成极大不便。以下是在使用鼠标事件时应当注意的几个易访问性问题。

- 使用click事件执行代码。有人指出通过onmousedown执行代码会让人觉得速度更快，对视力正常的人来说这是没错的。但是，在屏幕阅读器中，由于无法触发mousedown事件，结果就会造成代码无法执行。
- 不要使用onmouseover向用户显示新的选项。原因同上，屏幕阅读器无法触发这个事件。如果确实非要通过这种方式来显示新选项，可以考虑添加显示相同信息的键盘快捷方式。
- 不要使用dblclick执行重要的操作。键盘无法触发这个事件。

### 13.4.4 键盘与文本事件

对键盘事件的支持主要遵循的是DOM0级。“DOM3级事件”为键盘事件制定了规范，IE9率先完全实现了该规范。其他浏览器也在着手实现这一标准，但仍然有很多遗留的问题。

 有3个键盘事件：

- keydown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。
- keypress：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下Esc键也会触发这个事件。Safari 3.1之前的版本也会在用户按下非字符键时触发keypress事件。


- keyup：当用户释放键盘上的键时触发。

只有一个文本事件：textInput。这个事件是对keypress的补充，用意是在将文本显示给用户之前更容易拦截文本。在文本插入文本框之前会触发textInput事件。

> 键盘事件与鼠标事件一样，都支持相同的修改键。而且，键盘事件的事件对象中也有shiftKey、ctrlKey、altKey和metaKey属性。IE不支持metaKey。

#### 1. 键码

在发生keydown和keyup事件时，event对象的keyCode属性中会包含一个代码，与键盘上一个特定的键对应。对数字字母字符键，keyCode属性的值与ASCII码中对应小写字母或数字的编码相同。因此，数字键7的keyCode值为55，而字母A键的keyCode值为65——与Shift键的状态无关。DOM和IE的event对象都支持keyCode属性。

所有非字符键的键码：

| 键                     | 键 码  | 键            | 键 码  |
| --------------------- | ---- | ------------ | ---- |
| 退格（Backspace）         | 8    | 数字小键盘1       | 97   |
| 制表（Tab）               | 9    | 数字小键盘2       | 98   |
| 回车（Enter）             | 13   | 数字小键盘3       | 99   |
| 上档（Shift）             | 16   | 数字小键盘4       | 100  |
| 控制（Ctrl）              | 17   | 数字小键盘5       | 101  |
| Alt                   | 18   | 数字小键盘6       | 102  |
| 暂停/中断（Pause/Break）    | 19   | 数字小键盘7       | 103  |
| 大写锁定（Caps Lock）       | 20   | 数字小键盘8       | 104  |
| 退出（Esc）               | 27   | 数字小键盘9       | 105  |
| 上翻页（Page Up）          | 33   | 数字小键盘+       | 107  |
| 下翻页（Page Down）        | 34   | 数字小键盘及大键盘上的- | 109  |
| 结尾（End）               | 35   | 数字小键盘 .      | 110  |
| 开头（Home）              | 36   | 数字小键盘/       | 111  |
| 左箭头（Left Arrow）       | 37   | F1           | 112  |
| 上箭头（Up Arrow）         | 38   | F2           | 113  |
| 右箭头（Right Arrow）      | 39   | F3           | 114  |
| 下箭头（Down Arrow）       | 40   | F4           | 115  |
| 插入（Ins）               | 45   | F5           | 116  |
| 删除（Del）               | 46   | F6           | 117  |
| 左Windows键             | 91   | F7           | 118  |
| 右Windows键             | 92   | F8           | 119  |
| 上下文菜单键                | 93   | F9           | 120  |
| 数字小键盘0                | 96   | F10          | 121  |
| F11                   | 122  | 正斜杠          | 191  |
| F12                   | 123  | 沉音符（`）       | 192  |
| 数字锁（Num Lock）         | 144  | 等于           | 61   |
| 滚动锁（Scroll Lock）      | 145  | 左方括号         | 219  |
| 分号（IE/Safari/Chrome中） | 186  | 反斜杠（\）       | 220  |
| 分号（Opera/FF中）         | 59   | 右方括号         | 221  |
| 小于                    | 188  | 单引号          | 222  |
| 大于                    | 190  |              |      |

特殊情况：在Firefox和Opera中，按分号键时keyCode值为59，也就是ASCII中分号的编码；但IE和Safari返回186，即键盘中按键的键码。

#### 2. 字符编码

IE9、Firefox、Chrome和Safari的event对象都支持一个charCode属性，这个属性只有在发生keypress事件时才包含值，而且这个值是按下的那个键所代表字符的ASCII编码。此时的keyCode通常等于0或者也可能等于所按键的键码。IE8及之前版本和Opera则是在keyCode中保存字符的ASCII编码。

在取得了字符编码之后，就可以使用String.fromCharCode()将其转换成实际的字符。

#### 3. DOM3级变化

DOM3级事件中的键盘事件，不再包含charCode属性，而是包含两个新属性：key和char。

key属性是为了取代keyCode而新增的，它的值是一个字符串。在按下某个字符键时，key的值就是相应的文本字符（如“k”或“M”）；在按下非字符键时， key的值是相应键的名（如“Shift”或“Down”）。而char属性在按下字符键时的行为与key相同，但在按下非字符键时值为null。

IE9支持key属性，但不支持char属性。Safari 5和Chrome支持名为keyIdentifier的属性，在按下非字符键（例如Shift）的情况下与key的值相同。对于字符键，keyIdentifier返回一个格式类似“U+0000”的字符串，表示Unicode值。

由于存在跨浏览器问题，因此本书不推荐使用key、keyIdentifier或char。

DOM3级事件还添加了一个名为location的属性，这是一个数值，表示按下了什么位置上的键：0表示默认键盘，1表示左侧位置（例如左位的Alt键），2表示右侧位置（例如右侧的Shift键），3表示数字小键盘，4表示移动设备键盘（也就是虚拟键盘），5表示手柄（如任天堂Wii控制器）。IE9支持这个属性。Safari和Chrome支持名为keyLocation的等价属性，但即有bug——值始终是0，除非按下了数字键盘（此时，值 为3）；否则，不会是1、2、4、5。 

支持location的浏览器也不多。不推荐使用。

最后是给event对象添加了getModifierState()方法。这个方法接收一个参数，即等于Shift、Control、AltGraph或Meta的字符串，表示要检测的修改键。如果指定的修改键是活动的（也就是处于被按下的状态），这个方法返回true，否则返回false。IE9是唯一支持getModifierState()方法的浏览器。

#### 4. textInput事件

“DOM3级事件”规范中引入textInput

当用户在可编辑区域中输入字符时，就会触发这个事件。这个用于替代keypress的textInput事件的行为稍有不同。区别之一就是任何可以获得焦点的元素都可以触发keypress事件，但只有可编辑区域才能触发textInput事件。区别之二是textInput事件只会在用户按下能够输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发（例如退格键）。

它的event对象中还包含一个data属性，这个属性的值就是用户输入的字符（而非字符编码）（能区分大小写）。

event对象上还有一个属性，叫inputMethod，表示把文本输入到文本框中的方式。

- 0，表示浏览器不确定是怎么输入的。
- 1，表示是使用键盘输入的。
- 2，表示文本是粘贴进来的。
- 3，表示文本是拖放进来的。
- 4，表示文本是使用IME输入的。
- 5，表示文本是通过在表单中选择某一项输入的。
- 6，表示文本是通过手写输入的（比如使用手写笔）。
- 7，表示文本是通过语音输入的。
- 8，表示文本是通过几种方法组合输入的。
- 9，表示文本是通过脚本输入的。

支持textInput属性的浏览器有IE9+、Safari和Chrome。只有IE支持inputMethod属性。

#### 5. 设备中的键盘事件

### 13.4.5 复合事件

DOM3级事件中新添加，用于处理IME 的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。ME通常需要同时按住多个键，但最终只输入一个字符。复合事件就是针对检测和处理这种输入而设计的。有以下三种复合事件。

- compositionstart：在IME的文本复合系统打开时触发，表示要开始输入了。
- compositionupdate：在向输入字段中插入新字符时触发。
- compositionend：在IME的文本复合系统关闭时触发，表示返回正常键盘输入状态。

复合事件比文本事件的事件对象多一个属性data，其中包含以下几个值中的一个：

- 如果在compositionstart事件发生时访问，包含正在编辑的文本（例如，已经选中的需要马上替换的文本）；
- 如果在compositionupdate事件发生时访问，包含正插入的新字符；
- 如果在compositionend事件发生时访问，包含此次输入会话中插入的所有字符。

IE9+是到2011年唯一支持复合事件的浏览器。

要确定浏览器是否支持复合事件，可以使用以下代码：

```javascript
var isSupported = document.implementation.hasFeature("CompositionEvent", "3.0"); 
```

### 13.4.6 变动事件

DOM2级的变动（mutation）事件能在DOM中的某一部分发生变化时给出提示。

DOM2级定义了如下变动事件。

- DOMSubtreeModified：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。
- DOMNodeInserted：在一个节点作为子节点被插入到另一个节点中时触发。
- DOMNodeRemoved：在节点从其父节点中被移除时触发。
- DOMNodeInsertedIntoDocument：在一个节点被直接插入文档或通过子树间接插入文档之后触发。这个事件在DOMNodeInserted之后触发。
- DOMNodeRemovedFromDocument：在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMNodeRemoved之后触发。
- DOMAttrModified：在特性被修改之后触发。
- DOMCharacterDataModified：在文本节点的值发生变化时触发。

使用下列代码可以检测出浏览器是否支持变动事件：

```javascript
var isSupported = document.implementation.hasFeature("MutationEvents", "2.0"); 
```

IE8及更早版本不支持任何变动事件。下表列出了不同浏览器对不同变动事件的支持情况。

| 事 件                | Opera 9+ | Firefox 3+ | Safari 3+及Chrome | IE9+ |
| ------------------ | -------- | ---------- | ---------------- | ---- |
| DOMSubtreeModified | －        | 支持         | 支持               | 支持   |
| DOMNodeInserted    | 支持       | 支持         | 支持               | 支持   |
| DOMNodeRemoved     | 支持       | 支持         | 支持               | 支持   |

#### 1. 删除节点

在使用removeChild()或replaceChild()从DOM中删除节点时，首先会触发DOMNodeRemoved事件。这个事件的目标（event.target）是被删除的节点，而event.relatedNode属性中包含着对目标节点父节点的引用。

如果被移除的节点包含子节点，那么在其所有子节点以及这个被移除的节点上会相继触发DOMNodeRemovedFromDocument事件。但这个事件不会冒泡

紧随其后触发的是DOMSubtreeModified事件。这个事件的目标是被移除节点的父节点；此时的event对象也不会提供与事件相关的其他信息。

#### 2. 插入节点

在使用appendChild()、replaceChild()或insertBefore()向DOM中插入节点时，首先会触发DOMNodeInserted事件。这个事件的目标是被插入的节点，而event.relatedNode属性中包含一个对父节点的引用。在这个事件触发时，节点已经被插入到了新的父节点中。这个事件是冒泡的。

紧接着，会在新插入的节点上面触发DOMNodeInsertedIntoDocument事件。这个事件不冒泡，因此必须在插入节点之前为它添加这个事件处理程序。这个事件的目标是被插入的节点，除此之外event对象中不包含其他信息。

最后一个触发的事件是DOMSubtreeModified，触发于新插入节点的父节点。

### 13.4.7 HTML5事件

#### 1. contextmenu事件

上下文菜单：即通过单击鼠标右键可以调出上下文菜单。

contextmenu事件，用以表示何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单。

contextmenu事件是冒泡的。

这个事件的目标是发生用户操作的元素。

在所有浏览器中都可以取消这个事件：
在兼容DOM的浏览器中，使用event.preventDefalut()；在IE中，将event.returnValue的值
设置为false。

 因为contextmenu事件属于鼠标事件，所以其事件对象中包含与光标位置有关的所有属性。

通常使用contextmenu事件来显示自定义的上下文菜单，而使用onclick事件处理程序来隐藏该菜单。

支持contextmenu事件的浏览器有IE、Firefox、Safari、Chrome和Opera 11+。

#### 2.beforeunload事件

beforeunload事件是为了让开发人员有可能在页面卸载前阻止这一操作。

显示的消息会告知用户页面行将被卸载，询问用户是否真的要关闭页面，还是希望继续留下来

为了显示这个弹出对话框，必须将event.returnValue 的值设置为要显示给用户的字符串（对IE及Fiefox而言），同时作为函数的值返回（对Safari和Chrome而言）

IE和Firefox、Safari和Chrome都支持beforeunload事件，也都会弹出这个对话框询问用户是否真想离开。Opera 11及之前的版本不支持beforeunload事件。

#### 3. DOMContentLoaded事件

DOMContentLoaded事件则在形成完整的DOM树之后就会触发，不理会图像、JavaScript 文件、CSS文件或其他资源是否已经下载完毕。

与load 事件不同，DOMContentLoaded 支持在页面下载的早期添加事件处理程序

要处理DOMContentLoaded事件，可以为document或window添加相应的事件处理程序

DOMContentLoaded事件对象不会提供任何额外的信息（其target属性是document）。

IE9+、Firefox、Chrome、Safari 3.1+和Opera 9+都支持DOMContentLoaded事件，通常这个事件既可以添加事件处理程序，也可以执行其他DOM操作。

这个事件始终都会在load事件之前触发。对于不支持DOMContentLoaded的浏览器，我们建议在页面加载期间设置一个时间为0毫秒的超时调用，实际意思就是：“在当前JavaScript处理完成后立即运行这个函数。”

#### 4. readystatechange事件

readystatechange事件目的是提供与文档或元素的加载状态有关的信息

支持readystatechange事件的每个对象都有一个readyState属性，可能包含下列5个值中的一个。

- uninitialized（未初始化）：对象存在但尚未初始化。
- loading（正在加载）：对象正在加载数据。
- loaded（加载完毕）：对象加载数据完成。
- interactive（交互）：可以操作对象了，但还没有完全加载。
- complete（完成）：对象已经加载完毕。

这个事件的event对象不会提供任何信息，也没有目标对象。

在与load事件一起使用时，无法预测两个事件触发的先后顺序。在包含较多或较大的外部资源的页面中，会在load事件触发之前先进入交互阶段；而在包含较少或较小的外部资源的页面中，则很难说readystatechange 事件会发生在load事件前面。

交互阶段可能会早于也可能会晚于完成阶段出现，无法确保顺序。在包含较多外部资源的页面中，交互阶段更有可能早于完成阶段出现；而在页面中包含较少外部资源的情况下， 完成阶段先于交互阶段出现的可能性更大。因此，为了尽可能抢到先机，有必要同时检测交互和完成阶段

支持readystatechange事件的浏览器有IE、Firfox 4+和Opera。

`<script>`（在IE和Opera中）和`<link>`（仅IE中）元素也会触发readystatechange事件，可以用来确定外部的JavaScript和CSS文件是否已经加载完成。基于元素触发的readystatechange 事件也存在同样的问题，即readyState 属性无论等于"loaded"还是"complete"都可以表示资源已经可用。有时候，readyState会停在"loaded"阶段而永远不会“完成”；有时候，又会跳过"loaded"阶段而直接“完成”。于是，还需要像对待document一样采取相同的编码方式。最重要的是要一并检测readyState的两个状态，并在调用了一次事件处理程序后就将其移除。

#### 5. pageshow和pagehide事件

Firefox和Opera有一个特性，名叫“往返缓存”（back-forward cache，或bfcache），可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。

这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。如果页面位于bfcache中，那么再次打开该页面时就不会触发load事件。

Firefox提供了一些新事件给bfcache的行为：

第一个事件就是pageshow，这个事件在页面显示时触发，无论该页面是否来自bfcache。在重新加载的页面中，pageshow会在load事件触发后触发；而对于bfcache中的页面，pageshow会在页面状态完全恢复的那一刻触发。

注意的是，虽然这个事件的目标是document，但必须将其事件处理程序添加到window。

pageshow事件的event对象还包含一个名为persisted的布尔值属性。如果页面被保存在了bfcache中，则这个属性的值为true；否则，这个属性的值为false。

与pageshow事件对应的是pagehide事件，该事件会在浏览器卸载页面的时候触发，而且是在unload事件之前触发。与pageshow事件一样，pagehide在document上面触发，但其事件处理程序必须要添加到window对象。

对于pageshow事件，如果页面是从bfcache中加载的，那么persisted的值就是true；对于pagehide事件，如果页面在卸载之后会被保存在bfcache中，那么persisted的值也会被设置为true。

支持pageshow和pagehide事件的浏览器有Firefox、Safari 5+、Chrome和Opera。IE9及之前版本不支持这两个事件。

> 指定了onunload事件处理程序的页面会被自动排除在bfcache之外，即使事件处理程序是空的。原因在于，onunload最常用于撤销在onload中所执行的操作，而跳过onload后再次显示页面很可能就会导致页面不正常

#### 6. hashchange事件

HTML5新增了hashchange事件，以便在URL的参数列表（及URL中“#”号后面的所有字符串）发生变化时通知开发人员。之所以新增这个事件，是因为在Ajax应用中，开发人员经常要利用URL参数列表来保存状态或导航信息。

hashchange事件处理程序添加给window对象，然后URL参数列表只要变化就会调用它。此时的event对象应该额外包含两个属性：oldURL和newURL。这两个属性分别保存着参数列表变化前后的完整URL。

支持hashchange事件的浏览器有IE8+、Firefox 3.6+、Safari 5+、Chrome和Opera 10.6+。在这些浏览器中，只有Firefox 6+、Chrome和Opera支持oldURL和newURL属性。为此，最好是使用location对象来确定当前的参数列表。

使用以下代码可以检测浏览器是否支持hashchange事件：

```javascript
var isSupported = ("onhashchange" in window) && (document.documentMode === 
undefined || document.documentMode > 7); 
//如果IE8是在IE7文档模式下运行，即使功能无效它也会返回true。所以要做兼容性
```

### 13.4.8 设备事件

#### 1. orientationchange事件

orientationchange事件用于确定用户何时将设备由横向查看模式切换为纵向查看模式。

移动Safari的window.orientation属性中可能包含3个值：0表示肖像模式，90表示向左旋转的横向模式（“主屏幕”按钮在右侧），-90表示向右旋转的横向模式（“主屏幕”按钮在左侧）。相关文档中还提到一个值，即180表示iPhone头朝下；但这种模式至今尚未得到支持。

所有iOS设备都支持orientationchange事件和window.orientation属性。

> 由于可以将orientationchange 看成window 事件，所以也可以通过指定`<body>`元素的onorientationchange特性来指定事件处理程序。

#### 2. MozOrientation事件

Firefox 3.6为检测设备的方向引入了一个名为MozOrientation的新事件。（前缀Moz表示这是特定于浏览器开发商的事件，不是标准事件。）当设备的加速计检测到设备方向改变时，就会触发这个事件。该事件只能提供一个平面的方向变化。

```javascript
EventUtil.addHandler(window, "MozOrientation", function(event){ 
	//响应事件
}); 
```

此时的event对象包含三个属性：x、y和z。这几个属性的值都介于1到-1之间，表示不同坐标轴上的方向。在静止状态下，x值为0，y值为0，z值为1（表示设备处于竖直状态）。如果设备向右倾斜，x值会减小；反之，向左倾斜，x值会增大。类似地，如果设备向远离用户的方向倾斜，y值会减小，向接近用户的方向倾斜，y值会增大。z轴检测垂直加速度度，1表示静止不动，在设备移动时值会减小。（失重状态下值为0。）

只有带加速计的设备才支持MozOrientation事件

#### 3. deviceorientation事件

deviceorientation事件的意图是告诉开发人员设备在空间中朝向哪儿，而不是如何移动。

触发deviceorientation事件时，事件对象中包含着每个轴相对于设备静止状态下发生变化的信息。事件对象包含以下5个属性。

- alpha：在围绕z轴旋转时（即左右旋转时），y轴的度数差；是一个介于0到360之间的浮点数。
- beta：在 围 绕x轴旋转时（即前后旋转时），z轴的度数差；是一个介于180到180之间的浮点数。
- gamma：在围绕y轴旋转时（即扭转设备时），z轴的度数差；是一个介于90到90之间的浮点数。
- absolute：布尔值，表示设备是否返回一个绝对值。
- compassCalibrated：布尔值，表示设备的指南针是否校准过。

支持deviceorientation事件的浏览器有iOS 4.2+中的Safari、Chrome和Android版WebKit。

#### 4. devicemotion事件

DeviceOrientation Event规范还定义了一个devicemotion事件。这个事件是要告诉开发人员设备什么时候移动，而不仅仅是设备方向如何改变。

触发devicemotion事件时，事件对象包含以下属性。

- acceleration：一个包含x、y和z属性的对象，在不考虑重力的情况下，告诉你在每个方向上的加速度。


- accelerationIncludingGravity：一个包含x、y和z属性的对象，在考虑z轴自然重力加速度的情况下，告诉你在每个方向上的加速度。


- interval：以毫秒表示的时间值，必须在另一个devicemotion事件触发前传入。这个值在每个事件中应该是一个常量。


- rotationRate：一个包含表示方向的alpha、beta和gamma属性的对象。

只有iOS 4.2+中的Safari、Chrome和Android版WebKit实现了devicemotion事件。

### 13.4.9 触摸与手势事件

#### 1. 触摸事件

有以下几个触摸事件。

- touchstart：当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。
- touchmove：当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用preventDefault()可以阻止滚动。


- touchend：当手指从屏幕上移开时触发。
- touchcancel：当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明。

上面这几个事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但它们却
是以兼容DOM的方式实现的。因此，每个触摸事件的event对象都提供了在鼠标事件中常见的属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey和metaKey。

触摸事件还包含下列三个用于跟踪触摸的属性。

- touches：表示当前跟踪的触摸操作的Touch对象的数组。
- targetTouchs：特定于事件目标的Touch对象的数组。
- changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。

每个Touch对象包含下列属性。

- clientX：触摸目标在视口中的x坐标。
- clientY：触摸目标在视口中的y坐标。
- identifier：标识触摸的唯一ID。
- pageX：触摸目标在页面中的x坐标。
- pageY：触摸目标在页面中的y坐标。
- screenX：触摸目标在屏幕中的x坐标。
- screenY：触摸目标在屏幕中的y坐标。
- target：触摸的DOM节点目标。

在触摸屏幕上的元素时，这些事件（包括鼠标事件）发生的顺序如下：

1. touchstart 
2. mouseover 
3. mousemove（一次）
4. mousedown 
5. mouseup 
6. click 
7. touchend 

支持触摸事件的浏览器包括iOS版Safari、Android版WebKit、bada版Dolfin、OS6+中的BlackBerry WebKit、Opera Mobile 10.1+和LG专有OS中的Phantom浏览器。目前只有iOS版Safari支持多点触摸。桌面版Firefox 6+和Chrome也支持触摸事件。

#### 2. 手势事件

有三个手势事件

- gesturestart：当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发。
- gesturechange：当触摸屏幕的任何一个手指的位置发生变化时触发。
- gestureend：当任何一个手指从屏幕上面移开时触发。

每个手势事件的event 对象都包含着标准的鼠标事件属性：bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey和metaKey。此外，还包含两个额外的属性：rotation和scale。其中，rotation属性表示手指变化引起的旋转角度，负值表示逆时针旋转，正值表示顺时针旋转（该值从0开始）。而scale属性表示两个手指间距离的变化情况（例如向内收缩会缩短距离）；这个值从1开始，并随距离拉大而增长，随距离缩短而减小。

> 触摸事件也会返回rotation和scale属性，但这两个属性只会在两个手指与屏幕保持接触时才会发生变化。

## 13.5 内存和性能

### 13.5.1 事件委托

对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。

事件目标是被单击的列表项，故而可以通过检测id属性来决定采取适当的操作。这种技术需要占用的内存更少。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术。

可以考虑为document对象添加一个事件处理程序，这样做与采取传统的做法相比具有如下优点。

- document对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序（无需等待DOMContentLoaded或load事件）。换句话说，只要可单击的元素呈现在页面上，就可以立即具备适当的功能。


- 在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的DOM引用更少，所花的时间也更少。


- 整个页面占用的内存空间更少，能够提升整体性能。

最适合采用事件委托技术的事件包括click、mousedown、mouseup、keydown、keyup和keypress。

### 13.5.2 移除事件处理程序

内存中留有那些过时不用的“空事件处理程序”（dangling event handler），也是造成Web应用程序内存与性能问题的主要原因。

在两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有事件处理程序的元素时。这可能是通过纯粹的DOM操作，例如使用removeChild()和replaceChild()方法，但更多地是发生在使用innerHTML替换页面中某一部分的时候。如果带有事件处理程序的元素被innerHTML删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。如果你知道某个元素即将被移除，那么最好手工移除事件处理程序

注意，在事件处理程序中删除按钮也能阻止事件冒泡。目标元素在文档中是事件冒泡的前提。

采用事件委托也有助于解决这个问题。如果事先知道将来有可能使用innerHTML换掉页面中的某一部分，那么就可以不直接把事件处理程序添加到该部分的元素。而通过把事件处理程序指定给较高层次的元素，同样能够处理该区域中的事件。

导致“空事件处理程序”的另一种情况，就是卸载页面的时候。

IE8及更早版本在这种情况下依然是问题最多的浏览器。如果在页面被卸载之前没有清理干净事件处理程序，那它们就会滞留在内存中。一般来说，最好的做法是在页面卸载之前，先通过onunload事件处理程序移除所有事件处理程序。事件委托技术再次表现出它的优势——需要跟踪的事件处理程序越少，移除它们就越容易。

> 不要忘了，使用onunload事件处理程序意味着页面不会被缓存在bfcache中。如果你在意这个问题，那么就只能在IE中通过onunload来移除事件处理程序了。

## 13.6 模拟事件

DOM2级规范为此规定了模拟特定事件的方式，IE9、Opera、Firefox、Chrome和Safari都支持这种方式。IE有它自己模拟事件的方式。

### 13.6.1 DOM中的事件模拟

可以在document对象上使用createEvent()方法创建event对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。在DOM2级中，所有这些字符串都使用英文复数形式，而在DOM3级中都变成了单数。这个字符串可以是下列几字符串之一。

- UIEvents：一般化的UI事件。鼠标事件和键盘事件都继承自UI事件。DOM3级中是UIEvent。
- MouseEvents：一般化的鼠标事件。DOM3级中是MouseEvent。
- MutationEvents：一般化的DOM变动事件。DOM3级中是MutationEvent。
- HTMLEvents：一般化的HTML事件。没有对应的DOM3级事件（HTML事件被分散到其他类别中）。

IE9是目前唯一支持DOM3级键盘事件的浏览器。

在创建了event对象之后，还需要使用与事件有关的信息对其进行初始化。每种类型的event对象都有一个特殊的方法，为它传入适当的数据就可以初始化该event对象。不同类型的这个方法的名字也不相同，具体要取决于createEvent()中使用的参数。

模拟事件的最后一步就是触发事件。这一步需要使用dispatchEvent()方法，所有支持事件的DOM节点都支持这个方法。调用dispatchEvent()方法时，需要传入一个参数，即表示要触发事件的event对象。

#### 1. 模拟鼠标事件

创建鼠标事件对象的方法是为createEvent()传入字符串"MouseEvents"。返回的对象有一个名为initMouseEvent()方法，用于指定与该鼠标事件有关的信息。这个方法接收15个参数，分别与鼠标事件中每个典型的属性一一对应；这些参数的含义如下。

- type（字符串）：表示要触发的事件类型，例如"click"。
- bubbles（布尔值）：表示事件是否应该冒泡。为精确地模拟鼠标事件，应该把这个参数设置为true。
- cancelable（布尔值）：表示事件是否可以取消。为精确地模拟鼠标事件，应该把这个参数设置为true。
- view（AbstractView）：与事件关联的视图。这个参数几乎总是要设置为document.defaultView。
- detail（整数）：与事件有关的详细信息。这个值一般只有事件处理程序使用，但通常都设置为0。
- screenX（整数）：事件相对于屏幕的X坐标。
- screenY（整数）：事件相对于屏幕的Y坐标。
- clientX（整数）：事件相对于视口的X坐标。
- clientY（整数）：事件想对于视口的Y坐标。
- ctrlKey（布尔值）：表示是否按下了Ctrl键。默认值为false。
- altKey（布尔值）：表示是否按下了Alt键。默认值为false。
- shiftKey（布尔值）：表示是否按下了Shift键。默认值为false。
- metaKey（布尔值）：表示是否按下了Meta键。默认值为false。
- button（整数）：表示按下了哪一个鼠标键。默认值为0。
- relatedTarget（对象）：表示与事件相关的对象。这个参数只在模拟mouseover或mouseout时使用。

前4个参数对正确地激发事件至关重要。当把event对象传给dispatchEvent()方法时，这个对象的target属性会自动设置。

#### 2. 模拟键盘事件

DOM3级规定，调用createEvent()并传入"KeyboardEvent"就可以创建一个键盘事件。返回的事件对象会包含一个initKeyEvent()方法，这个方法接收下列参数。

- type（字符串）：表示要触发的事件类型，如"keydown"。
- bubbles（布尔值）：表示事件是否应该冒泡。为精确模拟鼠标事件，应该设置为true。
- cancelable（布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为true。
- view（AbstractView）：与事件关联的视图。这个参数几乎总是要设置为document. defaultView。
- key（布尔值）：表示按下的键的键码。
- location（整数）：表示按下了哪里的键。0表示默认的主键盘，1表示左，2表示右，3表示数字键盘，4表示移动设备（即虚拟键盘），5表示手柄。
- modifiers（字符串）：空格分隔的修改键列表，如"Shift"。
- repeat（整数）：在一行中按了这个键多少次。

由于DOM3级不提倡使用keypress事件，因此只能利用这种技术来模拟keydown和keyup事件。

```javascript
//模拟的是按住Shift 的同时又按下A键

//以DOM3级方式创建事件对象
if (document.implementation.hasFeature("KeyboardEvents", "3.0")){ 
	event = document.createEvent("KeyboardEvent"); 
	//初始化事件对象
	event.initKeyboardEvent("keydown", true, true, document.defaultView, "a", 
                        0, "Shift", 0); 
} 
//触发事件
textbox.dispatchEvent(event); 
```

在Firefox中，调用createEvent()并传入"KeyEvents"就可以创建一个键盘事件。返回的事件对象会包含一个initKeyEvent()方法，这个方法接受下列10个参数。

- type（字符串）：表示要触发的事件类型，如"keydown"。
- bubbles（布尔值）：表示事件是否应该冒泡。为精确模拟鼠标事件，应该设置为true。
- cancelable（布尔值）：表示事件是否可以取消。为精确模拟鼠标事件，应该设置为true。
- view（AbstractView）：与事件关联的视图。这个参数几乎总是要设置为document.defaultView。
- ctrlKey（布尔值）：表示是否按下了Ctrl键。默认值为false。
- altKey（布尔值）：表示是否按下了Alt键。默认值为false。
- shiftKey（布尔值）：表示是否按下了Shift键。默认值为false。
- metaKey（布尔值）：表示是否按下了Meta键。默认值为false。
- keyCode（整数）：被按下或释放的键的键码。这个参数对keydown和keyup事件有用，默认值为0。
- charCode（整数）：通过按键生成的字符的ASCII编码。这个参数对keypress事件有用，默认值为0。

将创建的event对象传入到dispatchEvent()方法就可以触发键盘事件

必须要使用通用事件，而不能使用UI事件，因为UI事件不允许向event对象中再添加新属性（Safari除外）。

#### 3. 模拟其他事件

可以使用createEvent("MutationEvents")创建一个包含initMutationEvent()方法的变动事件对象。这个方法接受的参数包括：type、bubbles、cancelable、relatedNode、preValue、newValue、attrName和attrChange。

要模拟HTML事件，同样需要先创建一个event对象——通过createEvent("HTMLEvents")，然后再使用这个对象的initEvent()方法来初始化它即可

> 浏览器中很少使用变动事件和HTML事件，因为使用它们会受到一些限制。

#### 4. 自定义DOM事件

定义事件不是由DOM原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件，可以调用createEvent("CustomEvent")。返回的对象有一个名为initCustomEvent()的方法，接收如下4个参数。

- type（字符串）：触发的事件类型，例如"keydown"。
- bubbles（布尔值）：表示事件是否应该冒泡。
- cancelable（布尔值）：表示事件是否可以取消。
- detail（对象）：任意值，保存在event对象的detail属性中。

支持自定义DOM事件的浏览器有IE9+和Firefox 6+。

#### 13.6.2 IE中的事件模拟

用document.createEventObject()方法可以在IE中创建event对象。但与DOM方式不同的是，这个方法不接受参数，结果会返回一个通用的event对象。

然后，你必须手工为这个对象添加所有必要的信息（没有方法来辅助完成这一步骤）。

最后一步就是在目标上调用fireEvent()方法，这个方法接受两个参数：事件处理程序的名称和event 对象。在调用fireEvent()方法时，会自动为event对象添加srcElement和type属性；其他属性则都是必须通过手工添加的。换句话说，模拟任何IE支持的事件都采用相同的模式。

注意，这里可以为对象随意添加属性，不会有任何限制——即使添加的属性IE8及更早版本并不支持也无所谓。在此添加的属性对事件没有什么影响，因为只有事件处理程序才会用到它们。

## 13.7小结

在使用事件时，需要考虑如下一些内存与性能方面的问题。

- 有必要限制一个页面中事件处理程序的数量，数量太多会导致占用大量内存，而且也会让用户感觉页面反应不够灵敏。
- 建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量。
- 建议在浏览器卸载页面之前移除页面中的所有事件处理程序。



# 第14章 表单脚本

## 14.1 表单的基础知识

在HTML中，表单是由`<form>`元素来表示的，而在JavaScript中，表单对应的则是HTMLFormElement类型。

HTMLFormElement区别HTMLElement独有的属性和方法：

- acceptCharset：服务器能够处理的字符集；等价于HTML中的accept-charset特性。
- action：接受请求的URL；等价于HTML中的action特性。
- elements：表单中所有控件的集合（HTMLCollection）。
- enctype：请求的编码类型；等价于HTML中的enctype特性。
- length：表单中控件的数量。
- method：要发送的HTTP请求类型，通常是"get"或"post"；等价于HTML的method特性。
- name：表单的名称；等价于HTML的name特性。
- reset()：将所有表单域重置为默认值。
- submit()：提交表单。
- target：用于发送请求和接收响应的窗口名称；等价于HTML的target特性。

取得`<form>`元素引用的方式：

最常见的方式就是将它看成与其他元素一样，并为其添加id特性，然后再像下面这样使用getElementById()方法找到它

其次，通过document.forms可以取得页面中所有的表单。在这个集合中，可以通过数值索引或name值来取得特定的表单

在较早的浏览器或者那些支持向后兼容的浏览器中，也会把每个设置了name特性的表单作为属性保存在document对象中。例如，通过document.form2可以访问到名为"form2"的表单。不过，我们不推荐使用这种方式：一是容易出错，二是将来的浏览器可能会不支持。

### 14.1.1 提交表单

用户单击提交按钮或图像按钮时，就会提交表单。

使用`<input>`或`<button>`都可以定义提交按钮，只要将其type特性的值设置为"submit"即可，而图像按钮则是通过将`<input>`的type特性值设置为"image"来定义的。

调用prevetnDefault()方法阻止了表单提交。

在JavaScript中，以编程方式调用submit()方法也可以提交表单。而且，这种方式无需表单包含提交按钮，任何时候都可以正常提交表单。

提交表单时可能出现的最大问题，就是重复提交表单。在解决这一问题的办法有两个：在第一次提交表单后就禁用提交按钮，或者利用onsubmit事件处理程序取消后续的表单提交操作。

### 14.1.2 重置表单

在用使用type特性值为"reset"的`<input>`或`<button>`都可以创建重置按钮

在重置表单时，所有表单字段都会恢复到页面刚加载完毕时的初始值。如果某个字段的初始值为空，就会恢复为空；而带有默认值的字段，也会恢复为默认值。

可以在触发reset事件时取消重置操作。

也可以通过JavaScript来重置表单

> 事实上，重置表单的需求很少见。更常见的做法是提供一个取消按钮，让用户能够回到前一个页面。

### 14.1.3 表单字段

可以使用原生DOM方法访问表单元素。

每个表单都有elements属性，该属性是表单中所有表单元素（字段）的集合。这个elements集合是一个有序列表，其中包含着表单中的所有字段。每个表单字段在elements集合中的顺序，与它们出现在标记中的顺序相同，可以按照位置和name特性来访问它们。

如果有多个表单控件都在使用一个name），那么就会返回以该name 命名的一个NodeList。

也可以通过访问表单的属性来访问元素。但应该尽可能使用elements，通过表单属性访问元素只是为了与旧浏览器向后兼容而保留的一种过渡方式。

#### 1.  共有的表单字段属性

除了`<fieldset>`元素之外，所有表单字段都拥有相同的一组属性。

表单字段共有的属性如下。

- disabled：布尔值，表示当前字段是否被禁用。
- form：指向当前字段所属表单的指针；只读。
- name：当前字段的名称。
- readOnly：布尔值，表示当前字段是否只读。
- tabIndex：表示当前字段的切换（tab）序号。
- type：当前字段的类型。
- value：当前字段将被提交给服务器的值。对文件字段来说，这个属性是只读的，包含着文件在计算机中的路径。

除了form属性之外，可以通过JavaScript动态修改其他任何属性。

例如，很多用户可能会重复单击表单的提交按钮。最常见的解决方案，就是在第一次单击后就禁用提交按钮。只要侦听submit事件，并在该事件生时禁用提交按钮即可。

注意，不能通过onclick事件处理程序来实现这个功能，原因是不同浏览器之间存在“时差”：有的浏览器会在触发表单的submit事件之前触发click事件，而有的浏览器则相反。对于先触发click事件的浏览器，意味着会在提交发生之前禁用按钮，结果永远都不会提交表单。

除了`<fieldset>`之外，所有表单字段都有type属性。对于`<input>`元素，这个值等于HTML特性type的值。对于其他元素，这个type属性的值如下表所列。

| 说 明      | HTML示例                                 | type属性的值          |
| -------- | -------------------------------------- | ----------------- |
| 单选列表     | `<select>`...`</select>`               | "select-one"      |
| 多选列表     | `<select multiple>`...`</select>`      | "select-multiple" |
| 自定义按钮    | `<button>`...`</button>`               | "submit"          |
| 自定义非提交按钮 | `<button type="button">`...`</button>` | "button"          |
| 自定义重置按钮  | `<button type="reset">`...`</buton>`   | "reset"           |
| 自定义提交按钮  | `<button type="submit">`...`</buton>`  | "submit"          |

此外，`<input>`和`<button>`元素的type属性是可以动态修改的，而`<select>`元素的type属性则是只读的。

#### 2. 共有的表单字段方法

每个表单字段都有两个方法：focus()和blur()。

focus()方法用于将浏览器的焦点设置到表单字段，即激活表单字段，使其可以响应键盘事件。

HTML5为表单字段新增了一个autofocus属性。在支持这个属性的浏览器中，只要设置这个属性，不用JavaScript就能自动把焦点移动到相应字段。

autofocus是一个布尔值属性，在不支持的浏览器中，它的值将是空字符串。

支持autofocus属性的浏览器有Firefox 4+、Safari 5+、Chrome和Opera 9.6。

在默认情况下，只有表单字段可以获得焦点。对于其他元素而言，如果先将其tabIndex属性设置为1, 然后再调用focus()方法，也可以让这些元素获得焦点。

只有Opera不支持这种技术。

调用blur()方法时，并不会把焦点转移到某个特定的元素上；仅仅是将焦点从调用这个方法的元素上面移走而已。

#### 3. 共有的表单字段事件

所有表单字段都支持下列3个事件。

- blur：当前字段失去焦点时触发。
- change：对于`<input>`和`<textarea>`元素，在它们失去焦点且value 值改变时触发；对于`<select>`元素，在其选项改变时触发。
- focus：当前字段获得焦点时触发。

change事件在不同表单控件中触发的次数会有所不同。对于`<input>`和`<textarea>`元素，当它们从获得焦点到失去焦点且value值改变时，才会触发change事件。对于`<select>`元素，只要用户选择了不同的选项，就会触发change事件；

focus和blur事件来以某种方式改变用户界面，要么是向用户给出视觉提示，要么是向界面中添加额外的功能；change事件则经常用于验证用户在字段中输入的数据。

> 关于blur和change事件的关系，并没有严格的规定。在某些浏览器中，blur事件会先于change事件发生；而在其他浏览器中，则恰好相反。为此，不能假定这两个事件总会以某种顺序依次触发，这一点要特别注意。

## 14.2 文本框脚本

在HTML中，有两种方式来表现文本框：一种是使用`<input>`元素的单行文本框，另一种是使用`<textarea>`的多行文本框。

要表现文本框，必须将`<input>`元素的type特性设置为"text"。而通过设置size特性，可以指定文本框中能够显示的字符数。通过value特性，可以设置文本框的初始值，而maxlength特性则用于指定文本框可以接受的最大字符数。

相对而言，`<textarea>`元素则始终会呈现为一个多行文本框。要指定文本框的大小，可以使用rows和cols特性。其中，rows特性指定的是文本框的字符行数，而cols特性指定的是文本框的字符列数（类似于`<inpu>`元素的size 特性）。与`<input>`元素不同，`<textarea>`的初始值必须要放在`<textarea>`和`</textarea>`之间 

另一个与`<input>`的区别在于，不能在HTML中给`<textarea>`指定最大字符数。

建议使用value属性读取或设置文本框的值，不建议使用标准的DOM方法。即不要使用setAttribute()设置`<input>`元素的value特性，也不要去修改`<textarea>`元素的第一个子节点。原因很简单：对value属性所作的修改，不一定会反映在DOM中。

### 14.2.1 选择文本

上述两种文本框都支持select()方法，这个方法用于选择文本框中的所有文本。在调用select()  方法时，大多数浏览器（Opera除外）都会将焦点设置到文本框中。这个方法不接受参数，可以在任何时候被调用。   

在文本框获得焦点时选择其所有文本，这是一种非常常见的做法，特别是在文本框包含默认值的时候。因为这样做可以让用户不必一个一个地删除文本。

#### 1. 选择（select）事件

在选择了文本框中的文本时，就会触发select事件。

在IE9+、Opera、Firefox、Chrome和Safari中，只有用户选择了文本（而且要释放鼠标），才会触发select事件。而在IE8及更早版本中，只要用户选择了一个字母（不必释放鼠标），就会触发select事件。另外，在调用select()方法时也会触发select事件。

#### 2. 取得选择的文本

虽然通过select事件我们可以知道用户什么时候选择了文本，但仍然不知道用户选择了什么文本。

HTML5规范采取的办法是添加两个属性：selectionStart和selectionEnd。这两个属性中保存的是基于0的数值，表示所选择文本的范围（即文本选区开头和结尾的偏移量）。

```javascript
function getSelectedText(textbox){ 
	return textbox.value.substring(textbox.selectionStart, textbox.selectionEnd); 
} 
```

IE8及之前版本不支持这两个属性，有一个document.selection对象，其中保存着用户在整个文档范围内选择的文本信息；也就是说，无法确定用户选择的是页面中哪个部位的文本。不过，在与select事件一起使用的时候，可以假定是用户选择了文本框中的文本，因而触发了该事件。要取得选择的文本，首先必须创建一个范围，然后再将文本从其中提取出来

```javascript
function getSelectedText(textbox){ 
    if (typeof textbox.selectionStart == "number"){ 
    		return textbox.value.substring(textbox.selectionStart, 
    			textbox.selectionEnd); 
    } else if (document.selection){ 
   	 return document.selection.createRange().text; 
    } 
} 
```

注意，调用document.selection时，不需要考虑textbox参数。

#### 3. 选择部分文本

HTML5也为选择文本框中的部分文本提供了解决方案，即setSelectionRange()方法。这个方法接收两个参数：要选择的第一个字符的索引和要选择的最后一个字符之后的字符的索引（类似于substring()方法的两个参数）。

要看到选择的文本，必须在调用setSelectionRange()之前或之后立即将焦点设置到文本框。

IE8及更早版本支持使用范围选择部分文本。要选择文本框中的部分文本，必须首先使用IE在所有文本框上提供的createTextRange()方法创建一个范围，并将其放在恰当的位置上。然后，再使用moveStart()和moveEnd()这两个范围方法将范围移动到位。不过，在调用这两个方法以前，还必须使用collapse()将范围折叠到文本框的开始位置。此时，moveStart()将范围的起点和终点移动到了相同的位置，只要再给moveEnd()传入要选择的字符总数即可。最后一步，就是使用范围的select()方法选择文本

### 14.2.2 过滤输入

#### 1. 屏蔽字符

响应向文本框中插入字符操作的是keypress事件。因此，可以通过阻止这个事件的默认行为来屏蔽此类字符。

如果只想屏蔽特定的字符，则需要检测keypress事件对应的字符编码，然后再决定如何响应。

如果只想屏蔽特定的字符，则需要检测keypress事件对应的字符编码，然后再决定如何响应。

虽然理论上只应该在用户按下字符键时才触发keypress事件，但有些浏览器也会对其他键触发此事件。这意味着，仅考虑到屏蔽不是数值的字符还不够，还要避免屏蔽这些极为常用和必要的键。为了让代码更通用，只要不屏蔽那些字符编码小于10的键即可。

除此之外，还有一个问题需要处理：复制、粘贴及其他操作还要用到Ctrl键。

```javascript
EventUtil.addHandler(textbox, "keypress", function(event){ 
    event = EventUtil.getEvent(event); 
    var target = EventUtil.getTarget(event); 
    var charCode = EventUtil.getCharCode(event); 
    if (!/\d/.test(String.fromCharCode(charCode)) && charCode > 9 && 
    			!event.ctrlKey){ 
    	EventUtil.preventDefault(event); 
    } 
}); 
```

#### 2. 操作剪贴板

Opera不支持通过JavaScript访问剪贴板。

HTML 5把剪贴板事件纳入了规范。下列就是6个剪贴板事件。

- beforecopy：在发生复制操作前触发。
- copy：在发生复制操作时触发。
- beforecut：在发生剪切操作前触发。
- cut：在发生剪切操作时触发。
- beforepaste：在发生粘贴操作前触发。
- paste：在发生粘贴操作时触发。

在Safari、Chrome和Firefox中，beforecopy、beforecut和beforepaste事件只会在显示针对文本框的上下文菜单（预期将发生剪贴板事件）的情况下触发。但是，IE则会在触发copy、cut和paste事件之前先行触发这些事件。至于copy、cut和paste事件，只要是在上下文菜单中选择了相应选项，或者使用了相应的键盘组合键，所有浏览器都会触发它们。

在实际的事件发生之前，通过beforecopy、beforecut和beforepaste事件可以在向剪贴板发送数据，或者从剪贴板取得数据之前修改数据。不过，取消这些事件并不会取消对剪贴板的操作——只有取消copy、cut和paste事件，才能阻止相应操作发生。

要访问剪贴板中的数据，可以使用clipboardData对象：在IE中，这个对象是window对象的属性；而在Firefox 4+、Safari和Chrome中，这个对象是相应event对象的属性。但是，在Firefox、Safari和Chorme中，只有在处理剪贴板事件期间clipboardData对象才有效，这是为了防止对剪贴板的未授权访问；在IE中，则可以随时访问clipboardData对象。

clipboardData对象有三个方法：getData()、setData()和clearData()。其中，getData()用于从剪贴板中取得数据，它接受一个参数，即要取得的数据的格式。在IE中，有两种数据格式："text"和"URL"。在Firefox、Safari和Chrome中，这个参数是一种MIME类型；不过，可以用"text"代表"text/plain"。

setData()方法的第一个参数也是数据类型，第二个参数是要放在剪贴板中的文本。对于第一个参数，IE 照样支持"text"和"URL"，而Safari和Chrome仍然只支持MIME类型。但是，与getData()方法不同的是，Safari和Chrome的setData()方法不能识别"text"类型。

在需要确保粘贴到文本框中的文本中包含某些字符，或者符合某种格式要求时，能够访问剪贴板是非常有用的。

Firefox、Safari和Chrome只允许在onpaste事件处理程序中访问getData()方法。

由于并非所有浏览器都支持访问剪贴板，所以更简单的做法是屏蔽一或多个剪贴板操作。在支持copy、cut和paste事件的浏览器中（IE、Safari、Chrome和Firefox 3及更高版本），很容易阻止这些事件的默认行为。在Opera中，则需要阻止那些会触发这些事件的按键操作，同时还要阻止在文本框中显示上下文菜单。

### 14.2.3 自动切换焦点

通常，在自动切换焦点之前，必须知道用户已经输入了既定长度的数据

### 14.2.4 HTML5约束验证API

只有在某些情况下表单字段才能进行自动验证。具体来说，就是要在HTML标记中为特定的字段指定一些约束，然后浏览器才会自动执行表单验证。

#### 1. 必填字段

第一种情况是在表单字段中指定了required属性

```javascript
<input type="text" name="username"required>
```

任何标注有required的字段，在提交表单时都不能空着。这个属性适用于`<input>`、`<textarea>`和`<select>`字段（Opera 11及之前版本还不支持`<select>`的required属性）

使用下面这行代码可以测试浏览器是否支持required属性。

```javascript
var isRequiredSupported = "required" in document.createElement("input"); 
```

对于空着的必填字段，不同浏览器有不同的处理方式。Firefox 4和Opera 11会阻止表单提交并在相应字段下方弹出帮助框，而Safari（5之前）和Chrome（9之前）则什么也不做，而且也不阻止表单提交。

#### 2. 其他输入类型

HTML5为`<input>`元素的type属性又增加了几个值。

其中，"email"和"url"是两个得到支持最多的类型，各浏览器也都为它们增加了定制的验证机制。顾名思义，"email"类型要求输入的文本必须符合电子邮件地址的模式，而"url"类型要求输入的文本必须符合URL的模式。

设置特定的输入类型并不能阻止用户输入无效的值，只是应用某些默认的验证而已。

#### 3. 数值范围

这几个元素都要求填写某种基于数字的值："number"、"range"、"datetime"、"datetime-local"、"date"、"month"、"week"，还有"time"。浏览器对这几个类型的支持情况并不好

对所有这些数值类型的输入元素，可以指定min属性（最小的可能值）、max属性（最大的可能值）和step属性（从min到max的两个刻度间的差值）。

在不同的浏览器中，可能会也可能不会看到能够自动递增和递减的数值调节按钮（向上和向下按钮）。

还有两个方法：stepUp()和stepDown()，都接收一个可选的参数：要在当前值基础上加上或减去的数值。（默认是加或减1。）这两个方法还没有得到任何浏览器支持

#### 4. 输入模式

HTML5为文本字段新增了pattern属性。这个属性的值是一个正则表达式，用于匹配文本框中的值。

注意，模式的开头和末尾不用加^和$符号（假定已经有了）。这两个符号表示输入的值必须从头到尾都与模式匹配。

与其他输入类型相似，指定pattern也不能阻止用户输入无效的文本。

使用以下代码可以检测浏览器是否支持pattern属性。

```javascript
var isPatternSupported = "pattern" in document.createElement("input"); 
```

#### 5. 检测有效性

使用checkValidity()方法可以检测表单中的某个字段是否有效。所有表单字段都有这个方法，如果字段的值有效，这个方法返回true，否则返回false。字段的值是否有效的判断依据是本节前面介绍过的那些约束。换句话说，必填字段中如果没有值就是无效的，而字段中的值与pattern属性不匹配也是无效的。

要检测整个表单是否有效，可以在表单自身调用checkValidity()方法。如果所有表单字段都有效，这个方法返回true；即使有一个字段无效，这个方法也会返回false。

validity属性则会告诉你为什么字段有效或无效。这个对象中包含一系列属性，每个属性会返回一个布尔值。

- customError ：如果设置了setCustomValidity()，则为true，否则返回false。
- patternMismatch：如果值与指定的pattern属性不匹配，返回true。
- rangeOverflow：如果值比max值大，返回true。
- rangeUnderflow：如果值比min值小，返回true。
- stepMisMatch：如果min和max之间的步长值不合理，返回true。
- tooLong：如果值的长度超过了maxlength属性指定的长度，返回true。有的浏览器（如Firefox 4）会自动约束字符数量，因此这个值可能永远都返回false。
- typeMismatch：如果值不是"mail"或"url"要求的格式，返回true。
- valid：如果这里的其他属性都是false，返回true。checkValidity()也要求相同的值。
- valueMissing：如果标注为required的字段中没有值，返回true。

#### 6. 禁用验证

通过设置novalidate属性，可以告诉表单不进行验证。

```html
<form method="post" action="signup.php"novalidate> 
	<!--这里插入表单元素--> 
</form> 
```

在JavaScript中使用noValidate属性可以取得或设置这个值，如果这个属性存在，值为true，如果不存在，值为false。

如果一个表单中有多个提交按钮，为了指定点击某个提交按钮不必验证表单，可以在相应的按钮上添加formnovalidate属性。使用JavaScript也可以设置这个属性。

## 14.3 选择框脚本

选择框是通过`<select>`和`<option>`元素创建的。除了所有表单字段共有的属性和方法外，HTMLSelectElement类型还提供了下列属性和方法。

- add(newOption, relOption)：向控件中插入新<option>元素，其位置在相关项（relOption）之前。
- multiple：布尔值，表示是否允许多项选择；等价于HTML中的multiple特性。
- options：控件中所有<option>元素的HTMLCollection。
- remove(index)：移除给定位置的选项。
- selectedIndex：基于0的选中项的索引，如果没有选中项，则值为-1。对于支持多选的控件，只保存选中项中第一项的索引。
- size：选择框中可见的行数；等价于HTML中的size特性。

选择框的type属性不是"select-one"，就是"select-multiple"，这取决于HTML代码中有没有multiple特性。选择框的value属性由当前选中项决定，相应规则如下。

- 如果没有选中的项，则选择框的value属性保存空字符串。
- 如果有一个选中项，而且该项的value特性已经在HTML中指定，则选择框的value属性等于选中项的value特性。即使value特性的值是空字符串，也同样遵循此条规则。
- 如果有一个选中项，但该项的value特性在HTML中未指定，则选择框的value属性等于该项的文本。
- 如果有多个选中项，则选择框的value属性将依据前两条规则取得第一个选中项的值。

在DOM中，每个`<option>`元素都有一个HTMLOptionElement 对象表示。为便于访问数据，HTMLOptionElement对象添加了下列属性：

- index：当前选项在options集合中的索引。
- label：当前选项的标签；等价于HTML中的label特性。
- selected：布尔值，表示当前选项是否被选中。将这个属性设置为true可以选中当前选项。
- text：选项的文本。
- value：选项的值（等价于HTML中的value特性）。

在操作选项时，我们建议最好是使用特定于选项的属性，因为所有浏览器都支持这些属性。不推荐使用标准DOM技术修改`<option>`元素的文本或者值。

选择框的change事件与其他表单字段的change事件触发的条件不一样。其他表单字段的change 事件是在值被修改且焦点离开当前字段时触发，而选择框的change事件只要选中了选项就会触发。

> 不同浏览器下，选项的value属性返回什么值也存在差别。但是，在所有浏览器中，value属性始终等于value特性。在未指定value特性的情况下，IE8会返回空字符串，而IE9+、Safari、Firefox、Chrome和Opera则会返回与text特性相同的值。

### 14.3.1 选择选项

对于只允许选择一项的选择框，访问选中项的最简单方式，就是使用选择框的selectedIndex属性

对于可以选择多项的选择框，selectedfIndex 属性就好像只允许选择一项一样。设置selectedIndex会导致取消以前的所有选项并选择指定的那一项，而读取selectedIndex则只会返回选中项中第一项的索引值。

另一种选择选项的方式，就是取得对某一项的引用，然后将其selected属性设置为true。

在允许多选的选择框中设置选项的selected属性，不会取消对其他选中项的选择，因而可以动态选中任意多个项。但是，如果是在单选选择框中，修改某个选项的selected属性则会取消对其他选项的选择。需要注意的是，将selected属性设置为false对单选选择框没有影响。

### 14.3.2 添加选项

添加选项的方式有很多，第一种方式就是使用如下所示的DOM方法。

```javascript
var newOption = document.createElement("option"); 
newOption.appendChild(document.createTextNode("Option text")); 
newOption.setAttribute("value", "Option value"); 
selectbox.appendChild(newOption); 
```

第二种方式是使用Option构造函数来创建新选项。Option构造函数接受两个参数：文本（text）和值（value）；第二个参数可选。虽然这个构造函数会创建一个Object的实例，但兼容DOM的浏览器会返回一个`<option>`元素。

```javascript
var newOption = new Option("Option text", "Option value"); 
selectbox.appendChild(newOption); //在IE8及之前版本中有问题
```

第三种添加新选项的方式是使用选择框的add()方法。DOM规定这个方法接受两个参数：要添加的新选项和将位于新选项之后的选项。如果想在列表的最后添加一个选项，应该将第二个参数设置为null。在IE对add()方法的实现中，第二个参数是可选的，而且如果指定，该参数必须是新选项之后选项的索引。兼容DOM的浏览器要求必须指定第二个参数。这时候，为第二个参数传入undefined，就可以在所有浏览器中都将新选项插入到列表最后了。

### 14.3.3 移除选项

首先，可以使用DOM的removeChild()方法，为其传入要移除的选项

```javascript
selectbox.removeChild(selectbox.options[0]); //移除第一个选项
```

其次，可以使用选择框的remove()方法。这个方法接受一个参数，即要移除选项的索引

```javascript
selectbox.remove(0); //移除第一个选项
```

最后一种方式，就是将相应选项设置为null。

```javascript
selectbox.options[0] = null; //移除第一个选项
```

### 14.3.4 移动和重排选项

使用DOM的appendChild()方法，就可以将第一个选择框中的选项直接移动到第二个选择框中。如果为appendChild()方法传入一个文档中已有的元素，那么就会先从该元素的父节点中移除它，再把它添加到指定的位置。

移动选项与移除选项有一个共同之处，即会重置每一个选项的index属性。

重排选项次序最好的方式仍然是使用DOM方法。要将选择框中的某一项移动到特定位置，最合适的DOM方法就是insertBefore()；appendChild()方法只适用于将选项添加到选择框的最后。

> IE7存在一个页面重绘问题，有时候会导致使用DOM方法重排的选项不能马上正确显示。

## 14.4 表单序列化

在JavaScript中，可以利用表单字段的type属性，连同name和value属性一起实现对表单的序列化。

在表单提交期间，浏览器是怎样将数据发送给服务器的。

- 对表单字段的名称和值进行URL编码，使用和号（&）分隔。
- 不发送禁用的表单字段。
- 只发送勾选的复选框和单选按钮。
- 不发送type为"reset"和"button"的按钮。
- 多选选择框中的每个选中的值单独一个条目。
- 在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。也包括type为"image"的`<input>`元素。
- `<select>`元素的值，就是选中的`<option>`元素的value特性的值。如果`<option>`元素没有value特性，则是`<option>`元素的文本值。

在表单序列化过程中，一般不包含任何按钮字段，因为结果字符串很可能是通过其他方式提交的。除此之外的其他上述规则都应该遵循。

## 14.5 富文本编辑

富文本编辑，又称为WYSIWYG（What You See Is What You Get，所见即所得）。

虽然也没有规范，已经出现了事实标准。浏览器都会支持。

这一技术的本质，就是在页面中嵌入一个包含空HTML页面的iframe。通过设置designMode属性，这个空白的HTML页面可以被编辑，而编辑对象则是该页面<body>元素的HTML代码。designMode属性有两个可能的值："off"（默认值）和"on"。在设置为"on"时，整个文档都会变得可以编辑（显示插入符号），然后就可以像使用字处理软件一样，通过键盘将文本内容加粗、变成斜体，等等。

### 14.5.1使用contenteditable属性

另一种编辑富文本内容的方式是使用名为contenteditable的特殊属性。
可以把contenteditable属性应用给页面中的任何元素，然后用户立即就可以编辑该元素。

通过在这个元素上设置contenteditable属性，也能打开或关闭编辑模式。
contenteditable属性有三个可能的值："true"表示打开、"false"表示关闭，"inherit"表示从父元素那里继承（因为可以在contenteditable元素中创建或删除元素）。

支持contenteditable属性的元素有IE、Firefox、Chrome、Safari和Opera。在移动设备上，支持contenteditable属性的浏览器有iOS 5+中的Safari和Android 3+中的WebKit。

### 14.5.2 操作富文本

与富文本编辑器交互的主要方式，就是使用document.execCommand()。
这个方法可以对文档执行预定义的命令，而且可以应用大多数格式。可以为document.execCommand()方法传递3个参数：要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值和执行命令必须的一个值（如果不需要值，则传递null）。为了确保跨浏览器的兼容性，第二个参数应该始终设置为false，因为Firefox会在该参数为true时抛出错误。

不同浏览器支持的预定义命令也不一样。下表列出了那些被支持最多的命令。

| 命 令                  | 值（第三个参数）                | 说 明                                   |
| -------------------- | ----------------------- | ------------------------------------- |
| backcolor            | 颜色字符串                   | 设置文档的背景颜色                             |
| bold                 | null                    | 将选择的文本转换为粗体                           |
| copy                 | null                    | 将选择的文本复制到剪贴板                          |
| createlink           | URL字符串                  | 将选择的文本转换成一个链接，指向指定的URL                |
| cut                  | null                    | 将选择的文本剪切到剪贴板                          |
| delete               | null                    | 删除选择的文本                               |
| fontname             | 字体名称                    | 将选择的文本修改为指定字体                         |
| fontsize             | 1～7                     | 将选择的文本修改为指定字体大小                       |
| forecolor            | 颜色字符串                   | 将选择的文本修改为指定的颜色                        |
| formatblock          | 要包围当前文本块的HTML标签；如`<h1>` | 使用指定的HTML标签来格式化选择的文本块                 |
| indent               | null                    | 缩进文本                                  |
| inserthorizontalrule | null                    | 在插入字符处插入一个`<hr>`元素                    |
| insertimage          | 图像的URL                  | 在插入字符处插入一个图像                          |
| insertorderedlist    | null                    | 在插入字符处插入一个`<ol>`元素                    |
| insertunorderedlist  | null                    | 在插入字符处插入一个`<ul>`元素                    |
| insertparagraph      | null                    | 在插入字符处插入一个`<p>`元素                     |
| italic               | null                    | 将选择的文本转换成斜体                           |
| justifycenter        | null                    | 将插入光标所在文本块居中对齐                        |
| justifyleft          | null                    | 将插入光标所在文本块左对齐                         |
| outdent              | null                    | 凸排文本（减少缩进）                            |
| paste                | null                    | 将剪贴板中的文本粘贴到选择的文本                      |
| removeformat         | null                    | 移除插入光标所在文本块的块级格式。这是撤销formatblock命令的操作 |
| selectall            | null                    | 选择文档中的所有文本                            |
| underline            | null                    | 为选择的文本添加下划线                           |
| unlink               | null                    | 移除文本的链接。这是撤销createlink命令的操作           |

与剪贴板有关的命令在不同浏览器中的差异极大。Opera根本没有实现任何剪贴板命令，而Firefox在默认情况下会禁用它们（必须修改用户的首选项来启用它们）。Safari和Chrome实现了cut和copy，但没有实现paste。不过，即使不能通过document.execCommand()来执行这些命令，但却可以通过相应的快捷键来实现同样的操作。

可以在任何时候使用这些命令来修改富文本区域的外观，同样的方法也适用于页面中contenteditable属性为"true"的区块，只要把对框架的引用替换成当前窗口的document对象即可。

需要注意的是，虽然所有浏览器都支持这些命令，但这些命令所产生的HTML仍然有很大不同。

还有一些与命令相关的方法。第一个方法就是queryCommandEnabled()，可以用它来检测是否可以对当前选择的文本，或者当前插入字符所在位置执行某个命令。
这个方法接收一个参数，即要检测的命令。如果当前编辑区域允许执行传入的命令，这个方法返回true，否则返回false。

queryCommandState()方法用于确定是否已将指定命令应用到了选择的文本。

queryCommandValue()方法用于取得执行命令时传入的值。通过这个方法可以确定某个命令是怎样应用到选择的文本的，可以据以确定再对其应用后续命令是否合适。

### 14.5.3 富文本选区

在富文本编辑器中，使用框架（iframe）的getSelection()方法，可以确定实际选择的文本。这个方法是window对象和document对象的属性，调用它会返回一个表示当前选择文本的Selection对象。

Selection对象属性：

- anchorNode：选区起点所在的节点。
- anchorOffset：在到达选区起点位置之前跳过的anchorNode中的字符数量。
- focusNode：选区终点所在的节点。
- focusOffset：focusNode中包含在选区之内的字符数量。
- isCollapsed：布尔值，表示选区的起点和终点是否重合。
- rangeCount：选区中包含的DOM范围的数量。

Selection 对象的方法：

- addRange(range)：将指定的DOM范围添加到选区中。
- collapse(node, offset)：将选区折叠到指定节点中的相应的文本偏移位置。


- collapseToEnd()：将选区折叠到终点位置。
- collapseToStart()：将选区折叠到起点位置。
- containsNode(node)：确定指定的节点是否包含在选区中。
- deleteFromDocument()：从文档中删除选区中的文本，与document.execCommand("delete", false, null)命令的结果相同。
- extend(node, offset)：通过将focusNode和focusOffset移动到指定的值来扩展选区。
- getRangeAt(index)：返回索引对应的选区中的DOM范围。
- removeAllRanges()：从选区中移除所有DOM范围。实际上，这样会移除选区，因为选区中至少要有一个范围。
- reomveRange(range)：从选区中移除指定的DOM范围。
- selectAllChildren(node)：清除选区并选择指定节点的所有子节点。
- toString()：返回选区所包含的文本内容。

HTML5将getSelection()方法纳入了标准。由于历史原因，在Firefox 3.6+中调用document.getSelection()会返回一个字符串。为此，可以在Firefox 3.6+中改作调用window.getSelection()，从而返回selection对象。Firefox 8修复了document.getSelection()的bug，能返回与window.getSelection()相同的值。

IE8及更早的版本不支持DOM范围，但我们可以通过它支持的selection对象操作选择的文本。IE中的selection对象是document的属性。

### 14.5.4 表单与富文本

从技术上说，富文本编辑器并不属于表单。换句话说，富文本编辑器中的HTML不会被自动提交给服务器，而需要我们手工来提取并提交HTML。为此，通常可以添加一个隐藏的表单字段，让它的值等于从iframe中提取出的HTML。

## 14.6小结

本章介绍的几个概念

- 可以使用一些标准或非标准的方法选择文本框中的全部或部分文本。
- 大多数浏览器都采用了Firefox操作选择文本的方式，但IE仍然坚持自己的实现。
- 在文本框的内容变化时，可以通过侦听键盘事件以及检测插入的字符，来允许或禁止用户输入某些字符。

除Opera之外的所有浏览器都支持剪贴板事件，包括copy、cut和paste。其他浏览器在实现剪贴板事件时也可以分为几种不同的情况。

- IE、Firefox、Chrome和Safari允许通过JavaScript访问剪贴板中的数据，而Opera不允许这种访问方式。
- 即使是IE、Chrome和Safari，它们各自的实现方式也不相同。
- Firefox、Safari和Chrome只允许在paste事件发生时读取剪贴板数据，而IE没有这个限制。
- Firefox、Safari和Chrome只允许在发生剪贴板事件时访问与剪贴板相关的信息，而IE允许在任何时候访问相关信息。

选择框也是经常要通过JavaScript来控制的一个表单字段。

富文本编辑功能是通过一个包含空HTML文档的iframe 元素来实现的。通过将空文档的designMode属性设置为"on"，就可以将该页面转换为可编辑状态，此时其表现如同字处理软件。另外，也可以将某个元素设置为contenteditable。JavaScript通过使用execCommand()方法也可以实现相同的一些功能。另外，使用queryCommandEnabled()、queryCommandState()和queryCommandValue()方法则可以取得有关文本选区的信息。由于以这种方式构建的富文本编辑器并不是一个表单字段，因此在将其内容提交给服务器之前，必须将iframe或contenteditable元素中的HTML复制到一个表单字段中。



# 第15章 使用 Canvas 绘图

## 15.1 基本用法

- 要使用`<canvas>`元素，必须先设置其width和height属性，指定可以绘图的区域大小。出现在开始和结束标签中的内容是后备信息，如果浏览器不支持`<canvas>`元素，就会显示这些信息。

- 在使用`<canvas>`元素之前，首先要检测getContext()方法是否存在，这一步非常重要。有些浏览器会为HTML规范之外的元素创建默认的HTML元素对象。在这种情况下，即使变量中保存着一个有效的元素引用，也检测不到getContext()方法。

- 使用toDataURL()方法，可以导出在`<canvas>`元素上绘制的图像。这个方法接受一个参数，即图像的MIME类型格式，而且适合用于创建图像的任何上下文。

  > 默认情况下，浏览器会将图像编码为PNG格式（除非另行指定）。Firefox和Opera也支持基于"image/jpeg"参数的JPEG编码格式。由于这个方法是后来才追加的，所以支持`<canvas>`的浏览器也是在较新的版本中才加入了对它的支持，比如IE9、Firefox 3.5和Opera 10。

  > 如果绘制到画布上的图像源自不同的域，toDataURL()方法会抛出错误。

## 15.2 2D上下文

- 默认情况下，width和height表示水平和垂直两个方向上可用的像素数目。

### 15.2.1 填充和描边

- 2D上下文的两种基本绘图操作是填充和描边。
- 操作的结果取决于两个属性：fillStyle和strokeStyle。
  - 这两个属性的值可以是字符串、渐变对象或模式对象，而且它们的默认值都是"#000000"。如果为它们指定表示颜色的字符串值，可以使用CSS中指定颜色值的任何格式，包括颜色名、十六进制码、rgb、rgba、hsl或hsla。

### 15.2.2 绘制矩形

- 方法包括fillRect()、strokeRect()和clearRect()。

  - 这三个方法都能接收4个参数：矩形的x坐标、矩形的y坐标、矩形宽度和矩形高度。这些参数的单位都是像素。

  > 描边线条的宽度由lineWidth属性控制，该属性的值可以是任意整数。另外，通过lineCap 属性可以控制线条末端的形状是平头、圆头还是方头（"butt"、"round"或"square"），通过lineJoin属性可以控制线条相交的方式是圆交、斜交还是斜接（"round"、"bevel"或"miter"）。

### 15.2.3 绘制路径

- 要绘制路径，首先必须调用beginPath()方法，表示要开始绘制新路径。
- 再通过调用下列方法来实际地绘制路径：
  - arc(x,y,radius,startAngle,endAngle, counterclockwise)
    - 最后一个参数表示startAngle和endAngle是否按逆时针方向计算，值为false表示按顺时针方向计算。
  - arcTo(x1, y1, x2, y2, radius)
  - bezierCurveTo(c1x, c1y, c2x, c2y, x, y)
  - lineTo(x, y)
  - moveTo(x, y)
  - quadraticCurveTo(cx, cy, x, y)
  - rect(x, y, width, height)
- 如果想绘制一条连接到路径起点的线条，可以调用closePath()。如果路径已经完成，你想用fillStyle填充它，可以调用fill()方法。另外，还可以调用stroke()方法对路径描边，描边使用的是strokeStyle。最后还可以调用clip()，这个方法可以在路径上创建一个剪切区域。
- isPointInPath()的方法，接收x和y坐标作为参数，用于在路径被关闭之前确定画布上的某一点是否位于路径上

### 15.2.4  绘制文本

- 绘制文本主要有两个方法：fillText()和strokeText()。
  - 两个方法都可以接收4个参数：要绘制的文本字符串、x坐标、y坐标和可选的最大像素宽度。
  - 都以下列3个属性为基础：
    - font：表示文本样式、大小及字体，用CSS中指定字体的格式来指定
    - textAlign：表示文本对齐方式。可能的值有"start"、"end"、"left"、"right"和"center"。建议使用"start"和"end"，不要使用"left"和"right"，因为前两者的意思更稳妥，能同时适合从左到右和从右到左显示（阅读）的语言。
    - textBaseline：表示文本的基线。可能的值有"top"、"hanging"、"middle"、"alphabetic"、"ideographic"和"bottom"。
- 2D上下文提供了辅助确定文本大小的方法measureText()。
  - 这个方法接收一个参数，即要绘制的文本；返回一个TextMetrics对象。
  - 返回的对象目前只有一个width属性，但将来还会增加更多度量属性。
  - measureText()方法利用font、textAlign和textBaseline的当前值计算指定文本的大小。
- fillText和strokeText()方法都可以接收第四个参数，也就是文本的最大像素宽度。不过，这个可选的参数尚未得到所有浏览器支持（最早支持它的是Firefox 4）。提供这个参数后，调用fillText()或strokeText()时如果传入的字符串大于最大宽度，则绘制的文本字符的高度正确，但宽度会收缩以适应最大宽度。

### 15.2.5 变换

- 修改变换矩阵方法：

  - rotate(angle)：围绕原点旋转图像angle弧度。

  - scale(scaleX, scaleY)：缩放图像，在x方向乘以scaleX，在y方向乘以scaleY。scaleX和scaleY的默认值都是1.0。

  - translate(x, y)：将坐标原点移动到(x,y)。执行这个变换之后，坐标(0,0)会变成之前由(x,y)表示的点。

  - transform(m1*1, m1*2, m2*1, m2*2, dx, dy)：直接修改变换矩阵，方式是乘以如下矩阵:

    ​

  - setTransform(m1*1, m1*2, m2*1, m2*2, dx, dy)：将变换矩阵重置为默认状态，然后再调用transform()。

- 有两个方法可以跟踪上下文的状态变化。如果你知道将来还要返回某组属性与变换的组合，可以调用save()方法。调用这个方法后，当时的所有设置都会进入一个栈结构，得以妥善保管。然后可以对上下文进行其他修改。等想要回到之前保存的设置时，可以调用restore()方法，在保存设置的栈结构中向前返回一级，恢复之前的状态。连续调用save()可以把更多设置保存到栈结构中，之后再连续调用restore()则可以一级一级返回。

  > 需要注意的是，save()方法保存的只是对绘图上下文的设置和变换，不会保存绘图上下文的内容。

### 15.2.6 绘制图像

- drawImage()方法 : 把一幅图像绘制到画布上

  - 最简单的调用方式是传入一个HTML <img>元素，以及绘制该图像的起点的x和y坐标。
  - 如果你想改变绘制后图像的大小，可以再多传入两个参数，分别表示目标宽度和目标高度。通过这种方式来缩放图像并不影响上下文的变换矩阵。
  - 还可以选择把图像中的某个区域绘制到上下文中。drawImage()方法的这种调用方式总共需要传入9个参数：要绘制的图像、源图像的x坐标、源图像的y坐标、源图像的宽度、源图像的高度、目标图像的x坐标、目标图像的y坐标、目标图像的宽度、目标图像的高度。
  - 除了给drawImage()方法传入HTML <img>元素外，还可以传入另一个<canvas>元素作为其第一个参数。这样，就可以把另一个画布内容绘制到当前画布上。

- 操作的结果可以通过toDataURL()方法获得.不过，有一个例外，即图像不能来自其他域。如果图像来自其他域，调用 toDataURL()会抛出一个错误。

  > toDataURL()是Canvas对象的方法，不是上下文对象的方法。

### 15.2.7阴影

- 2D上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影
  - shadowColor：用CSS颜色格式表示的阴影颜色，默认为黑色。
  - shadowOffsetX：形状或路径x轴方向的阴影偏移量，默认为0。
  - shadowOffsetY：形状或路径y轴方向的阴影偏移量，默认为0。
  - shadowBlur：模糊的像素数，默认0，即不模糊。
- 不同浏览器对阴影的支持有一些差异。IE9、Firefox 4和Opera 11的行为最为规范，其他浏览器多多少少会有一些奇怪的现象，甚至根本不支持阴影。

### 15.2.8渐变

- 要创建一个新的线性渐变，可以调用createLinearGradient()方法。
  - 这个方法接收4个参数：起点的x坐标、起点的y坐标、终点的x 坐标、终点的y 坐标。
  - 调用这个方法后，它就会创建一个指定大小的渐变，并返回CanvasGradient对象的实例。
- 创建了渐变对象后，下一步就是使用addColorStop()方法来指定色标。
  - 这个方法接收两个参数：色标位置和CSS颜色值。色标位置是一个0（开始的颜色）到1（结束的颜色）之间的数字。
- 由于渐变不重复，所以矩形的大部分区域都是黑色。确保渐变与形状对齐非常重要，有时候可以考虑使用函数来确保坐标合适。
- 要创建径向渐变（或放射渐变），可以使用createRadialGradient()方法。
  - 这个方法接收6个参数，对应着两个圆的圆心和半径。前三个参数指定的是起点圆的原心（x和y）及半径，后三个参数指定的是终点圆的原心（x和y）及半径。
  - 圆柱、圆锥、同心圆

### 15.2.9模式

- 模式其实就是重复的图像，可以用来填充或描边图形。创建一个新模式，可以调用createPattern()方法并传入两个参数：
  - 一个HTML <img>元素和一个表示如何重复图像的字符串。
  - 第二个参数的值与CSS的background-repeat属性值相同，包括"repeat"、"repeat-x"、"repeat-y"和"no-repeat"。
- 模式与渐变一样，都是从画布的原点(0,0)开始的。将填充样式（fillStyle）设置为模式对象，只表示在某个特定的区域内显示重复的图像，而不是要从某个位置开始绘制重复的图像。
- createPattern()方法的第一个参数也可以是一个<video>元素，或者另一个<canvas>元素。

### 15.2.10 使用图像数据

- 2D上下文的一个明显的长处就是，可以通过getImageData()取得原始图像数据。
  - 这个方法接收4个参数：要取得其数据的画面区域的x和y坐标以及该区域的像素宽度和高度。
  - 返回的每个ImageData对象都有三个属性：width、height和data。
    - 其中data属性是一个数组，保存着图像中每一个像素的数据。在data数组中，每一个像素用4个元素来保存，分别表示红、绿、蓝和透明度值。
    - 因此，第一个像素的数据就保存在数组的第0到第3个元素中
    - 通过修改图像数据，可以创建一个简单的灰阶过滤器等。
- 只有在画布“干净”的情况下（即图像并非来自其他域），才可以取得图像数据。如果画布“不干净”，那么访问图像数据时会导致JavaScript错误。

### 15.2.11合成

- globalAlpha是一个介于0和1之间的值（包括0和1），用于指定所有绘制的透明度。默认值为0。如果所有后续操作都要基于相同的透明度，就可以先把globalAlpha设置为适当值，然后绘制，最后再把它设置回默认值0。
- globalCompositionOperation表示后绘制的图形怎样与先绘制的图形结合。这个属性的值是字符串，可能的值如下：
  - source-over（默认值）：后绘制的图形位于先绘制的图形上方。
  - source-in：后绘制的图形与先绘制的图形重叠的部分可见，两者其他部分完全透明。
  - source-out：后绘制的图形与先绘制的图形不重叠的部分可见，先绘制的图形完全透明。
  - source-atop：后绘制的图形与先绘制的图形重叠的部分可见，先绘制图形不受影响。
  - destination-over：后绘制的图形位于先绘制的图形下方，只有之前透明像素下的部分才可见。
  - destination-in：后绘制的图形位于先绘制的图形下方，两者不重叠的部分完全透明。
  - destination-out：后绘制的图形擦除与先绘制的图形重叠的部分。
  - destination-atop：后绘制的图形位于先绘制的图形下方，在两者不重叠的地方，先绘制的图形会变透明。
  - lighter：后绘制的图形与先绘制的图形重叠部分的值相加，使该部分变亮。
  - copy：后绘制的图形完全替代与之重叠的先绘制图形。
  - xor：后绘制的图形与先绘制的图形重叠的部分执行“异或”操作。
- 在使用globalCompositionOperation的情况下，一定要多测试一些浏览器。因为不同浏览器对这个属性的实现仍然存在较大的差别。Safari和Chrome在这方面还有问题

## 15.3  WebGL

- WebGL是针对Canvas的3D上下文。与其他Web技术不同，WebGL并不是W3C制定的标准，而是由Khronos Group制定的。

### 15.3.1 类型化数组

- WebGL涉及的复杂计算需要提前知道数值的精度，而标准的JavaScript数值无法满足需要。为此，WebGL引入了一个概念，叫类型化数组（typed arrays）。
- 类型化数组的核心就是一个名为ArrayBuffer的类型。每个ArrayBuffer对象表示的只是内存中指定的字节数，但不会指定这些字节用于保存什么类型的数据。通过ArrayBuffer所能做的，就是为了将来使用而分配一定数量的字节。
- 创建了ArrayBuffer 对象后，能够通过该对象获得的信息只有它包含的字节数，方法是访问其 byteLength属性

#### 1. 视图

- 使用ArrayBuffer（数组缓冲器类型）的一种特别的方式就是用它来创建数组缓冲器视图。其中，最常见的视图是DataView，通过它可以选择ArrayBuffer中一小段字节。为此，可以在创建DataView实例的时候传入一个ArrayBuffer、一个可选的字节偏移量（从该字节开始选择）和一个可选的要选择的字节数。

- 实例化之后，DataView 对象会把字节偏移量以及字节长度信息分别保存在byteOffset 和byteLength属性中。

- 读取和写入DataView的时候，要根据实际操作的数据类型，选择相应的getter和setter方法。

  | 数据类型     | getter                              | setter                                   |
  | -------- | ----------------------------------- | ---------------------------------------- |
  | 有符号8位整数  | getInt8(byteOffset)                 | setInt8(byteOffset, value)               |
  | 无符号8位整数  | getUint8(byteOffset)                | setUint8(byteOffset, value)              |
  | 有符号16位整数 | getInt16(byteOffset,littleEndian)   | setInt16(byteOffset,value,littleEndian)  |
  | 无符号16位整数 | getUint16(byteOffset,littleEndian)  | setUint16(byteOffset,value,littleEndian) |
  | 有符号32位整数 | getInt32(byteOffset,littleEndian)   | setInt32(byteOffset,value,littleEndian)  |
  | 无符号32位整数 | getUint32(byteOffset,littleEndian)  | setUint32(byteOffset,value,littleEndian) |
  | 32位浮点数   | getFloat32(byteOffset,littleEndian) | setFloat32(byteOffset,value,littleEndian) |
  | 64位浮点数   | getFloat64(byteOffset,littleEndian) | setFloat64(byteOffset,value,littleEndian) |

  - 所有这些方法的第一个参数都是一个字节偏移量，表示要从哪个字节开始读取或写入。不要忘了，要保存有些数据类型的数据，可能需要不止1B。

    view.setUint16(2, 50);//不能从字节1开始，因为16位整数要用2B

  - 用于读写16位或更大数值的方法都有一个可选的参数littleEndian。这个参数是一个布尔值，表示读写数值时是否采用小端字节序（即将数据的最低有效位保存在低内存地址中），而不是大端字节序（即将数据的最低有效位保存在高内存地址中）。如果你也不确定应该使用哪种字节序，那不用管它，就采用默认的大端字节序方式保存即可。

1. #### 类型化视图

- 类型化视图一般也被称为类型化数组。类型化视图也分几种，而且它们都继承了DataView。
  - Int8Array：表示8位二补整数。
  - Uint8Array：表示8位无符号整数。
  - Int16Array：表示16位二补整数。
  - Uint16Array：表示16位无符号整数。
  - Int32Array：表示32位二补整数。
  - Uint32Array：表示32位无符号整数。
  - Float32Array：表示32位IEEE浮点值。
  - Float64Array：表示64位IEEE浮点值。
- 由于这些视图都继承自DataView，因而可以使用相同的构造函数参数来实例化。第一个参数是要使ArrayBuffer对象，第二个参数是作为起点的字节偏移量（默认为0），第三个参数是要包含的字节数。三个参数中只有第一个是必需的。
- 每个视图构造函数都有一个名为BYTES_PER_ELEMENT的属性，表示类型化数组的每个元素需要多少字节。因此，Uint8Array.BYTES_PER_ELEMENT就是1，而Float32Array.BYTES_PER_ELEMENT则为4。可以利用这个属性来辅助初始化。
- 类型化视图的目的在于简化对二进制数据的操作。除了前面看到的优点之外，创建类型化视图还可以不用首先创建ArrayBuffer对象。只要传入希望数组保存的元素数，相应的构造函数就可以自动创建一个包含足够字节数的ArrayBuffer对象
- 另外，也可以把常规数组转换为类型化视图，只要把常规数组传入类型化视图的构造函数即可这是用默认值来初始化类型化视图的最佳方式，也是WebGL项目中最常用的方式。
- 数据类型不匹配时不会抛出错误，所以你必须自己保证所赋的值不会超过相应元素的字节限制。
- 类型化视图还有一个方法，即subarray()，使用这个方法可以基于底层数组缓冲器的子集创建一个新视图。这个方法接收两个参数：开始元素的索引和可选的结束元素的索引。返回的类型与调用该方法的视图类型相同。
- 通过大视图创建小视图的主要好处就是，在操作大数组中的一部分元素时，无需担心意外修改了其他元素。

### 15.3.2 WebGL上下文

- 目前，在支持的浏览器中，WebGL的名字叫"experimental-webgl"，这是因为WebGL规范仍然未制定完成。制定完成后，这个上下文的名字就会变成简单的"webgl"。如果浏览器不支持WebGL，那么取得该上下文时会返回null。
- 一般都把WebGL上下文对象命名为gl。
- 通过给getContext()传递第二个参数，可以为WebGL上下文设置一些选项。这个参数本身是一个对象，可以包含下列属性。
  - alpha：值为true，表示为上下文创建一个Alpha通道缓冲区；默认值为true。
  - depth：值为true，表示可以使用16位深缓冲区；默认值为true。
  - stencil：值为true，表示可以使用8位模板缓冲区；默认值为false。
  - antialias：值为true，表示将使用默认机制执行抗锯齿操作；默认值为true。
  - premultipliedAlpha：值为true，表示绘图缓冲区有预乘Alpha值；默认值为true。
  - preserveDrawingBuffer：值 为true，表示在绘图完成后保留绘图缓冲区；默认值为false。建议确实有必要的情况下再开启这个值，因为可能影响性能。

#### 1. 常量

- 常量在OpenGL中都带前缀GL*。在WebGL中，保存在上下文对象中的这些常量都没有GL*前缀。WebGL以这种方式支持大多数OpenGL常量（有一部分常量是不支持的）。

#### 2. 方法命名

- 如果某方法可以接收不同类型及不同数量的参数，看方法名的后缀就可以知道。方法名的后缀会包含参数个数（1到4）和接收的数据类型（f表示浮点数，i表示整数）。
- 有很多方法接收数组参数而非一个个单独的参数。这样的方法其名字中会包含字母v（即vector，矢量）。

#### 3. 准备绘图

- 在实际操作WebGL上下文之前，一般都要使用某种实色清除<canvas>,首先必须使用clearColor()方法来指定要使用的颜色值，该方法接收4个参数：红、绿、蓝和透明度。每个参数必须是一个0到1之间的数值，表示每种分量在最终颜色中的强度。

- ​

  ``

  ​

  ​

  ​

  ​

  ```
  gl.clearColor(0,0,0,1); //black 
  ```

  ```
  gl.clear(gl.COLOR_BUFFER_BIT);
  ```

  ​

  > 把清理颜色缓冲区的值设置为黑色，然后调用了clear()方法，这个方法与OpenGL中的glClear()等价。传入的参数gl.COLOR_BUFFER_BIT告诉WebGL使用之前定义的颜色来填充相应区域。一般来说，都要先清理缓冲区，然后再执行其他绘图操作。

#### 4. 视口与坐标

- 默认情况下，视口可以使用整个<canvas>区域。要改变视口大小，可以调用viewport()方法并传入4个参数：（视口相对于<canvas>元素的）x坐标、y坐标、宽度和高度。
- 视口坐标与我们通常熟悉的网页坐标不一样。视口坐标的原点(0,0)在<canvas>元素的左下角，x轴和y轴的正方向分别是向右和向上，可以定义为(width1, height1)
- 视口内部的坐标系与定义视口的坐标系也不一样。在视口内部，坐标原点(0,0)是视口的中心
- 如果在视口内部绘图时使用视口外部的坐标，结果可能会被视口剪切。

#### 5. 缓冲区

- 顶点信息保存在JavaScript的类型化数组中，使用之前必须转换到WebGL的缓冲区。
- 要创建缓冲区，可以调用gl.createBuffer()，然后使用gl.bindBuffer()绑定到WebGL上下文。
- gl.bufferData()的最后一个参数用于指定使用缓冲区的方式，取值范围是如下几个常量。
  - gl.STATIC_DRAW：数据只加载一次，在多次绘图中使用。
  - gl.STREAM_DRAW：数据只加载一次，在几次绘图中使用。
  - gl.DYNAMIC_DRAW：数据动态改变，在多次绘图中使用。
- 如果不是非常有经验的OpenGL程序员，多数情况下将缓冲区使用方式设置为gl.STATIC_DRAW即可。
- 在包含缓冲区的页面重载之前，缓冲区始终保留在内存中。如果你不想要某个缓冲区了，可以直接调用gl.deleteBuffer()释放内存：

#### 6. 错误

- JavaScript与WebGL之间的一个最大的区别在于，WebGL操作一般不会抛出错误。为了知道是否有错误发生，必须在调用某个可能出错的方法后，手工调用gl.getError()方法。这个方法返回一个表示错误类型的常量。可能的错误常量如下。
  - gl.NO_ERROR：上一次操作没有发生错误（值为0）。
  - gl.INVALID_ENUM：应该给方法传入WebGL常量，但却传错了参数。
  - gl.INVALID_VALUE：在需要无符号数的地方传入了负值。
  - gl.INVALID_OPERATION：在当前状态下不能完成操作。
  - gl.OUT_OF_MEMORY：没有足够的内存完成操作。
  - gl.CONTEXT_LOST_WEBGL：由于外部事件（如设备断电）干扰丢失了当前WebGL上下文。

####  7. 着色器

- 着色器（shader）是OpenGL中的另一个概念。WebGL中有两种着色器：顶点着色器和片段（或像素）着色器。
  - 顶点着色器用于将3D顶点转换为需要渲染的2D点。
  - 片段着色器用于准确计算要绘制的每个像素的颜色。
- 这些着色器是使用GLSL（OpenGL Shading Language，OpenGL着色语言）写的，GLSL是一种与C和JavaScript完全不同的语言。

#### 8. 编写着色器

- GLSL是一种类C语言，专门用于编写OpenGL着色器。
- 每个着色器都有一个main()方法，该方法在绘图期间会重复执行。为着色器传递数据的方式有两种：Attribute和Uniform。通过Attribute可以向顶点着色器中传入顶点信息，通过Uniform可以向任何着色器传入常量值。Attribute和Uniform在main()方法外部定义，分别使用关键字attribute 和uniform。在这两个值类型关键字之后，是数据类型和变量名。

#### 9. 编写着色器程序

- 浏览器不能理解GLSL程序，因此必须准备好字符串形式的GLSL程序，以便编译并链接到着色器程序。为便于使用，通常是把着色器包含在页面的<script>标签内，并为该标签指定一个自定义的type属性。
- 然后，可以通过text属性提取出<script>元素的内容
- 复杂一些的WebGL应用可能会通过Ajax（详见第21章）动态加载着色器。而使用着色器的关键是要有字符串形式的GLSL程序。
- 取得了GLSL字符串之后，接下来就是创建着色器对象。要创建着色器对象，可以调用gl.createShader()方法并传入要创建的着色器类型（gl.VERTEX_SHADER或gl.FRAGMENT_SHADER）。编译着色器使用的是gl.compileShader()。
- 然后把对象链接到着色器程序中（gl.attachShader）。最后调用gl.linkProgram()则把两个着色器封装到了变量program中。链接完程序之后，就可以通过gl.useProgram()方法通知WebGL使用这个程序了。
- 调用gl.useProgram()方法后，所有后续的绘图操作都将使用这个程序。

#### 10. 为着色器传入值

- 对于Uniform变量，可以使用gl.getUniformLocation()，这个方法返回一个对象，表示Uniform变量在内存中的位置。然后可以基于变量的位置来赋值。
- 对于顶点着色器中的Attribute变量，也是差不多的赋值过程。要找到Attribute变量在内存中的位置，可以调用gl.getAttribLocation()。取得了位置之后，然后又通过gl.enableVertexAttribArray()启用它。最后一行创建了指针，指向由gl.bindBuffer()指定的缓冲区，并将其保存在aVertexPosition中，以便顶点着色器使用。

#### 11. 调试着色器和程序

- 与WebGL中的其他操作一样，着色器操作也可能会失败，而且也是静默失败。如果你想知道着色器或程序执行中是否发生了错误，必须亲自询问WebGL上下文。

- 对于着色器，可以在操作之后调用gl.getShaderParameter()，取得着色器的编译状态：

  ​

  ```

  ```

  ​

  ​

  ​

  ​

  ```
  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
  ```

  ```
      alert(gl.getShaderInfoLog(vertexShader));
  ```

  ```
  }
  ```

  ​

- 程序也可能会执行失败，因此也有类似的方法——gl.getProgramParameter()，可以用来检测执行状态。最常见的程序失败发生在链接过程中，要检测链接错误，可以使用下列代码。

  ​

  ```

  ```

  ​

  ​

  ​

  ​

  ```
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)){
  ```

  ```
      alert(gl.getProgramInfoLog(program));
  ```

  ```
  }
  ```

  ​

- 与gl.getShaderParameter()类似，gl.getProgramParameter()返回true表示链接成功，返回false表示链接失败。同样，也有一个gl.getProgramInfoLog()方法，用于捕获程序失败的消息。

#### 12. 绘图

- WebGL只能绘制三种形状：点、线和三角。
- 执行绘图操作要调用gl.drawArrays()或gl.drawElements()方法，前者用于数组缓冲区，后者用于元素数组缓冲区。它们的第一个参数都是一个常量，表示要绘制的形状。可取值的常量范围包括以下这些：
  - gl.POINTS：将每个顶点当成一个点来绘制。
  - gl.LINES：将数组当成一系列顶点，在这些顶点间画线。每个顶点既是起点也是终点，因此数组中必须包含偶数个顶点才能完成绘制。
  - gl.LINE_LOOP：将数组当成一系列顶点，在这些顶点间画线。线条从第一个顶点到第二个顶点，再从第二个顶点到第三个顶点，依此类推，直至最后一个顶点。然后再从最后一个顶点到第一个顶点画一条线。结果就是一个形状的轮廓。
  - gl.LINE_STRIP：除了不画最后一个顶点与第一个顶点之间的线之外，其他与gl.LINE_LOOP相同。
  - gl.TRIANGLES：将数组当成一系列顶点，在这些顶点间绘制三角形。除非明确指定，每个三角形都单独绘制，不与其他三角形共享顶点。
  - gl.TRIANGLES_STRIP：除了将前三个顶点之后的顶点当作第三个顶点与前两个顶点共同构成一个新三角形外，其他都与gl.TRIANGLES相同。
  - gl. TRIANGLES_FAN：除了将前三个顶点之后的顶点当作第三个顶点与前一个顶点及第一个顶点共同构成一个新三角形外，其他都与gl.TRIANGLES相同。
- gl.drawArrays()方法接收上面列出的常量中的一个作为第一个参数，接收数组缓冲区中的起始索引作为第二个参数，接收数组缓冲区中包含的顶点数（点的集合数）作为第三个参数。

#### 13. 纹理

- WebGL的纹理可以使用DOM中的图像。要创建一个新纹理，可以调用gl.createTexture()，然后再将一幅图像绑定到该纹理。

- 如果图像尚未加载到内存中，可能需要创建一个Image对象的实例，以便动态加载图像。图像加载完成之前，纹理不会初始化，因此，必须在load事件触发后才能设置纹理。

- 与在OpenGL中创建纹理的步骤最大的差异是使用gl.pixelStore1()设置像素存储格式。gl.UNPACK_FLIP_Y_WEBGL是WebGL独有的常量，在加载Web中的图像时，多数情况下都必须使用这个常量。这主要是因为GIF、JPEG和PNG图像与WebGL使用的坐标系不一样，如果没有这个标志，解析图像时就会发生混乱。

- 用作纹理的图像必须与包含页面来自同一个域，或者是保存在启用了CORS（Cross-Origin Resource Sharing，跨域资源共享）的服务器上。

  > 图像、加载到<video>元素中的视频，甚至其他<canvas>元素都可以用作纹理。跨域资源限制同样适用于视频

#### 14. 读取像素

- 通过WebGL上下文也能读取像素值。读取像素值的方法readPixels()与OpenGL中的同名方法只有一点不同，即最后一个参数必须是类型化数组。像素信息是从帧缓冲区读取的，然后保存在类型化数组中。
- readPixels()方法的参数有：x、y、宽度、高度、图像格式、数据类型和类型化数组。
  - 前4个参数指定读取哪个区域中的像素。
  - 图像格式参数几乎总是gl.RGBA。
  - 数据类型参数用于指定保存在类型化数组中的数据的类型，但有以下限制。
    - 如果类型是gl.UNSIGNED_BYTE，则类型化数组必须是Uint8Array。
    - 如果类型是gl.UNSIGNED_SHORT*5*6*5、gl.UNSIGNED_SHORT*4*4*4*4 或 gl.UNSIGNED* SHORT*5*5*5*1，则类型化数组必须是Uint16Array。
- 如果想在绘制发生后读取像素数据，那在初始化WebGL上下文时必须传入适当的preserveDrawingBuffer选项。设置这个标志的意思是让帧缓冲区在下一次绘制之前，保留其最后的状态。这个选项会导致性能损失，因此能不用最好不要用。

### 15.3.3支持

- Firefox 4+和Chrome都实现了WebGL API。Safari 5.1也实现了WebGL，但默认是禁用的。
- WebGL比较特别的地方在于，某个浏览器的某个版本实现了它，并不一定意味着就真能使用它。某个浏览器支持WebGL，至少意味着两件事：首先，浏览器本身必须实现了WebGL API；其次，计算机必须升级显示驱动程序。从稳妥的角度考虑，在使用WebGL之前，最好检测其是否得到了支持，而不是只检测特定的浏览器版本。
- 可以说，WebGL目前只适合实验性地学习，不适合真正开发和应用。

### 15.4 小结



# 第16章 HTML5脚本编程

## 16.1 跨文档消息传递

跨文档消息传送（cross-document messaging），有时候简称为XDM，指的是在来自不同域的页面间
传递消息。

XDM的核心是postMessage()方法。对于XDM而言，传递的对象是包含在当前页面中的`<iframe>`元素，或者由当前页面弹出的窗口。

postMessage()方法接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方。

```javascript
//注意：所有支持XDM的浏览器也支持iframe的contentWindow属性
var iframeWindow = document.getElementById("myframe").contentWindow; 
iframeWindow.postMessage("A secret", "http://www.wrox.com"); 
```

接收到XDM消息时，会触发window对象的message事件。这个事件是以异步形式触发的，因此从发送消息到接收消息（触发接收窗口的message事件）可能要经过一段时间的延迟。

触发message事件后，传递给onmessage处理程序的事件对象包含以下三方面的重要信息。

- data：作为postMessage()第一个参数传入的字符串数据。
- origin：发送消息的文档所在的域，例如"http://www.wrox.com"。
- source：发送消息的文档的window对象的代理。这个代理对象主要用于在发送上一条消息的窗口中调用postMessage()方法。如果发送消息的窗口来自同一个域，那这个对象就是window。

接收到消息后验证发送窗口的来源的基本的检测模式如下：

```javascript
EventUtil.addHandler(window, "message", function(event){ 
	//确保发送消息的域是已知的域
	if (event.origin == "http://www.wrox.com"){ 
        //处理接收到的数据
        processMessage(event.data); 
    	//可选：向来源窗口发送回执
    	event.source.postMessage("Received!", "http://p2p.wrox.com"); 
    } 
}); 
```

注意：event.source大多数情况下只是window对象的代理，并非实际的window对象。换句话说，不能通过这个代理对象访问window对象的其他任何信息。

XDM还有一些怪异之处：postMessage()的第一个参数最早是作为“永远都是字符串”来实现的。如果你想传入结构化的数据，最佳选择是先在要传入的数据上调用JSON.stringify()，通过postMessage()传入得到的字符串，然后再在onmessage事件处理程序中调用JSON.parse()。

支持XDM的浏览器有IE8+、Firefox 3.5+、Safari 4+、Opera、Chrome、iOS版Safari及Android版
WebKit。

## 16.2 原生拖放

### 16.2.1 拖放事件

拖动某元素时，将依次触发下列事件：

1. dragstart 
2. drag 
3. dragend 

按下鼠标键并开始移动鼠标时，会在被拖放的元素上触发dragstart事件。拖动开始时，可以通过ondragstart事件处理程序来运行JavaScript代码。

触发dragstart事件后，随即会触发drag事件，而且在元素被拖动期间会持续触发该事件。这
个事件与mousemove事件相似，在鼠标移动过程中，mousemove事件也会持续发生。

当拖动停止时（无论是把元素放到了有效的放置目标，还是放到了无效的放置目标上），会触发dragend事件。

当某个元素被拖动到一个有效的放置目标上时，下列事件会依次发生：

1. dragenter 
2. dragover 
3. dragleave或drop

只要有元素被拖动到放置目标上，就会触发dragenter事件（类似于mouseover事件）。

紧随其后的是dragover事件，而且在被拖动的元素还在放置目标的范围内移动时，就会持续触发该事件。

如果元素被拖出了放置目标，dragover事件不再发生，但会触发dragleave事件（类似于mouseout
事件）。如果元素被放到了放置目标中，则会触发drop事件而不是dragleave事件。

### 16.2.2 自定义放置目标

有些元素默认是不允许放置的。可以把任何元素变成有效的放置目标，方法是重写dragenter和dragover事件的默认行为。

```javascript
var droptarget = document.getElementById("droptarget"); 
EventUtil.addHandler(droptarget, "dragover", function(event){ 
	EventUtil.preventDefault(event); 
}); 
EventUtil.addHandler(droptarget, "dragenter", function(event){ 
	EventUtil.preventDefault(event); 
}); 
```

在Firefox 3.5+中，放置事件的默认行为是打开被放到放置目标上的URL。因此，为了让Firefox支持正常的拖放，还要取消drop事件的默认行为，阻止它打开URL：

```javascript
EventUtil.addHandler(droptarget, "drop", function(event){ 
	EventUtil.preventDefault(event); 
}); 
```

### 16.2.3 dataTransfer对象

dataTransfer对象，它是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据。

目前，HTML5规范草案也收入了dataTransfer对象。

dataTransfer对象有两个主要方法：getData()和setData()。

setData()方法的第一个参数，也是getData()方法唯一的一个参数，是一个字符串，表示保存的数据类型，取值为"text"或"URL"

IE只定义了"text"和"URL"两种有效的数据类型，而HTML5则对此加以扩展，允许指定各种MIME类型。考虑到向后兼容，HTML5也支持"text"和"URL"，但这两种类型会被映射为"text/plain"和"text/uri-list"。

实际上，dataTransfer对象可以为每种MIME类型都保存一个值。不过，保存在dataTransfer对象中的数据只能在drop事件处理程序中读取。如果在ondrop处理程序中没有读到数据，那就是dataTransfer对象已经被销毁，数据也丢失了。

在拖动文本框中的文本时，浏览器会调用setData()方法，将拖动的文本以"text"格式保存在dataTransfer对象中。类似地，在拖放链接或图像时，会调用setData()方法并保存URL。可以在dragstart事件处理程序中调用setData()

将数据保存为文本和保存为URL是有区别的。如果将数据保存为文本格式，那么数据不会得到任
何特殊处理。而如果将数据保存为URL，浏览器会将其当成网页中的链接。

Firefox 在其第5 个版本之前不能正确地将"url"和"text"映射为"text/uri-list"和"text/plain"。但是却能把"Text"（T大写）映射为"text/plain"。

### 16.2.4 dropEffect与effectAllowed

dropEffect属性可以知道被拖动的元素能够执行哪种放置行为。有下列4个可能的值。

- "none"：不能把拖动的元素放在这里。这是除文本框之外所有元素的默认值。
- "move"：应该把拖动的元素移动到放置目标。
- "copy"：应该把拖动的元素复制到放置目标。
- "link"：表示放置目标会打开拖动的元素（但拖动的元素必须是一个链接，有URL）。

浏览器只能帮你改变光标的样式，而其他的都要靠你自己来实现。要使用dropEffect属性，必须在ondragenter事件处理程序中针对放置目标来设置它。

dropEffect属性只有搭配effectAllowed属性才有用。effectAllowed属性表示允许拖动元素的哪种dropEffect，effectAllowed属性可能的值如下。

- "uninitialized"：没有给被拖动的元素设置任何放置行为。
- "none"：被拖动的元素不能有任何行为。
- "copy"：只允许值为"copy"的dropEffect。
- "link"：只允许值为"link"的dropEffect。
- "move"：只允许值为"move"的dropEffect。
- "copyLink"：允许值为"copy"和"link"的dropEffect。
- "copyMove"：允许值为"copy"和"move"的dropEffect。
- "linkMove"：允许值为"link"和"move"的dropEffect。
- "all"：允许任意dropEffect。

必须在ondragstart事件处理程序中设置effectAllowed属性。

> Firefox 5及之前的版本在处理effectAllowed属性时有一个问题，即如果你在代码中设置了这个属性的值，那不一定会触发drop事件

### 16.2.5 可拖动

HTML5为所有HTML元素规定了一个draggable属性，表示元素是否可以拖动。图像和链接的draggable属性自动被设置成了true，而其他元素这个属性的默认值都是false。要想让其他元素可拖动，或者让图像或链接不能拖动，都可以设置这个属性。

支持draggable属性的浏览器有IE 10+、Firefox 4+、Safari 5+和Chrome。为了让Firefox支持可拖动属性，还必须添加一个ondragstart事件处理程序，并在dataTransfer对象中保存一些信息。

> 在IE9及更早版本中，通过mousedown事件处理程序调用dragDrop()能够让任何元素可拖动。而在Safari 4及之前版本中，必须额外给相应元素设置CSS样式–khtml-user-drag: element。

### 16.2.6 其他成员

HTML5规范规定dataTransfer对象还包含下列方法和属性。

- addElement(element)：为拖动操作添加一个元素。添加这个元素只影响数据（即增加作为拖动源而响应回调的对象），不会影响拖动操作时页面元素的外观。在写作本书时，只有Firefox 3.5+实现了这个方法。


- clearData(format)：清除以特定格式保存的数据。实现这个方法的浏览器有IE、Fireforx 3.5+、Chrome和Safari 4+。


- setDragImage(element, x, y)：指定一幅图像，当拖动发生时，显示在光标下方。这个方法接收的三个参数分别是要显示的HTML元素和光标在图像中的x、y坐标。其中，HTML元素可以是一幅图像，也可以是其他元素。是图像则显示图像，是其他元素则显示渲染后的元素。实现这个方法的浏览器有Firefox 3.5+、Safari 4+和Chrome。
- types：当前保存的数据类型。这是一个类似数组的集合，以"text"这样的字符串形式保存着数据类型。实现这个属性的浏览器有IE10+、Firefox 3.5+和Chrome。

## 16.3 媒体元素

HTML5新增了两个与媒体相关的标签:`<audio>`和`<video>`。

使用这两个元素时，至少要在标签中包含src属性，指向要加载的媒体文件。还可以设置width和height属性以指定视频播放器的大小，而为poster属性指定图像的URI可以在加载视频内容期间显示一幅图像。另外，如果标签中有controls属性，则意味着浏览器应该显示UI控件，以便用户直接操作媒体。位于开始和结束标签之间的任何内容都将作为后备内容，在浏览器不支持这两个媒体元素的情况下显示。

并非所有浏览器都支持所有媒体格式,为此，不用在标签中指定src属性，而是要使用一或多个`<source>`元素

### 16.3.1 属性

`<video>`和`<audio>`元素都提供了完善的JavaScript接口

| 属 性                 | 数据类型 | 说 明                                      |
| ------------------- | ---- | ---------------------------------------- |
| autoplay            | 布尔值  | 取得或设置autoplay标志                          |
| buffered            | 时间范围 | 表示已下载的缓冲的时间范围的对象                         |
| bufferedBytes       | 字节范围 | 表示已下载的缓冲的字节范围的对象                         |
| bufferingRate       | 整数   | 下载过程中每秒钟平均接收到的位数                         |
| bufferingThrottled  | 布尔值  | 表示浏览器是否对缓冲进行了节流                          |
| controls            | 布尔值  | 取得或设置controls属性，用于显示或隐藏浏览器内置的控件          |
| currentLoop         | 整数   | 媒体文件已经循环的次数                              |
| currentSrc          | 字符串  | 当前播放的媒体文件的URL                            |
| currentTime         | 浮点数  | 已经播放的秒数                                  |
| defaultPlaybackRate | 浮点数  | 取得或设置默认的播放速度。默认值为1.0秒                    |
| duration            | 浮点数  | 媒体的总播放时间（秒数）                             |
| ended               | 布尔值  | 表示媒体文件是否播放完成                             |
| loop                | 布尔值  | 取得或设置媒体文件在播放完成后是否再从头开始播放                 |
| muted               | 布尔值  | 取得或设置媒体文件是否静音                            |
| networkState        | 整数   | 表示当前媒体的网络连接状态：0表示空，1表示正在加载，2表示正在加载元数据，3表示已经加载了第一帧，4表示加载完成 |
| paused              | 布尔值  | 表示播放器是否暂停                                |
| playbackRate        | 浮点数  | 取得或设置当前的播放速度。用户可以改变这个值，让媒体播放速度变快或变慢，这与defaultPlaybackRate只能由开发人员修改的defaultPlaybackRate不同 |
| played              | 时间范围 | 到目前为止已经播放的时间范围                           |
| readyState          | 整数   | 表示媒体是否已经就绪（可以播放了）。0表示数据不可用，1表示可以显示当前帧，2表示可以开始播放，3表示媒体可以从头到尾播放 |
| seekable            | 时间范围 | 可以搜索的时间范围                                |
| seeking             | 布尔值  | 表示播放器是否正移动到媒体文件中的新位置                     |
| src                 | 字符串  | 媒体文件的来源。任何时候都可以重写这个属性                    |
| start               | 浮点数  | 取得或设置媒体文件中开始播放的位置，以秒表示                   |
| totalBytes          | 整数   | 当前资源所需的总字节数                              |
| videoHeight         | 整数   | 返回视频（不一定是元素）的高度。只适用于`<video>`            |
| videoWidth          | 整数   | 返回视频（不一定是元素）的宽度。只适用于`<video>`            |
| volume              | 浮点数  | 取得或设置当前音量，值为0.0到1.0                      |

### 16.3.2 事件

| 事 件                 | 触发时机                                    |
| ------------------- | --------------------------------------- |
| abort               | 下载中断                                    |
| canplay             | 可以播放时；readyState值为2                     |
| canplaythrough      | 播放可继续，而且应该不会中断；readyState值为3            |
| canshowcurrentframe | 当前帧已经下载完成；readyState值为1                 |
| dataunavailable     | 因为没有数据而不能播放；readyState值为0               |
| durationchange      | duration属性的值改变                          |
| emptied             | 网络连接关闭                                  |
| empty               | 发生错误阻止了媒体下载                             |
| ended               | 媒体已播放到末尾，播放停止                           |
| error               | 下载期间发生网络错误                              |
| load                | 所有媒体已加载完成。这个事件可能会被废弃，建议使用canplaythrough |
| loadeddata          | 媒体的第一帧已加载完成                             |
| loadedmetadata      | 媒体的元数据已加载完成                             |
| loadstart           | 下载已开始                                   |
| pause               | 播放已暂停                                   |
| play                | 媒体已接收到指令开始播放                            |
| playing             | 媒体已实际开始播放                               |
| progress            | 正在下载                                    |
| ratechange          | 播放媒体的速度改变                               |
| seeked              | 搜索结束                                    |
| seeking             | 正移动到新位置                                 |
| stalled             | 浏览器尝试下载，但未接收到数据                         |
| timeupdate          | currentTime被以不合理或意外的方式更新                |
| volumechange        | volume属性值或muted属性值已改变                   |
| waiting             | 播放暂停，等待下载更多数据                           |

### 16.3.3 自定义媒体播放器

### 16.3.4 检测编解码器的支持情况

#### canPlayType()

检测浏览器是否支持某种格式和编解码器
该方法接收一种格式/编解码器字符串，返回"probably"、"maybe"或""（ 空字符串）。
空字符串是假值,而"probably"和"maybe"都是真值
注意，编解码器必须用引号引起来才行。

已得到支持的音频格式和编解码器:

| 音 频    | 字  符  串                       | 支持的浏览器                          |
| ------ | ----------------------------- | ------------------------------- |
| AAC    | audio/mp4; codecs="mp4a.40.2" | IE9+、Safari 4+、iOS版Safari       |
| MP3    | audio/mpeg                    | IE9+、Chrome                     |
| Vorbis | audio/ogg; codecs="vorbis"    | Firefox 3.5+、Chrome、Opera 10.5+ |
| WAV    | audio/wav; codecs="1"         | Firefox 3.5+、Opera 10.5+、Chrome |

已得到支持的视频格式和编解码器。

| 视 频    | 字  符  串                                  | 支持的浏览器                                   |
| ------ | ---------------------------------------- | ---------------------------------------- |
| H.264  | video/mp4; codecs="avc1.42E01E, mp4a.40.2" | IE9+、Safari 4+、iOS版Safari、Android版WebKit |
| Theora | video/ogg; codecs="theora"               | Firefox 3.5+、Opera 10.5、Chrome           |
| WebM   | video/webm; codecs="vp8, vorbis"         | Firefox 4+、Opera 10.6、Chrome             |

### 16.3.5  Audio类型

Audio与Image很相似，但Audio不用像Image那样必须插入到文档中。只要创建一个新实例，并传入音频源文件即可。

创建新的Audio实例即可开始下载指定的文件。下载完成后，调用play()就可以播放音频。

## 16.4 历史状态管理

通过hashchange事件，可以知道URL的参数什么时候发生了变化，即什么时候该有所反应。而
通过状态管理API，能够在不加载新页面的情况下改变浏览器的URL。为此，需要使用
history.pushState()方法，该方法可以接收三个参数：状态对象、新状态的标题和可选的相对URL。

执行pushState()方法后，新的状态信息就会被加入历史状态栈，而浏览器地址栏也会变成新的相对URL。但是，浏览器并不会真的向服务器发送请求。第二个参数目前还没有浏览器实现，因此完全可以只传入一个空字符串，或者一个短标题也可以。而第一个参数则应该尽可能提供初始化页面状态所需的各种信息。

因为pushState()会创建新的历史状态，所以你会发现“后退”按钮也能使用了。按下“后退”按钮，会触发window对象的popstate事件。popstate事件的事件对象有一个state属性，这个属性就包含着当初以第一个参数传递给pushState()的状态对象。

得到这个状态对象后，必须把页面重置为状态对象中的数据表示的状态。记住，浏览器加载的第一个页面没有状态，因此单击“后退”按钮返回浏览器加载的第一个页面时，event.state值为null。

要更新当前状态，可以调用replaceState()，传入的参数与pushState()的前两个参数相同。调用这个方法不会在历史状态栈中创建新状态，只会重写当前状态。

支持HTML5历史状态管理的浏览器有Firefox 4+、Safari 5+、Opera 11.5+和Chrome。

> 在使用HTML5的状态管理机制时，请确保使用pushState()创造的每一个“假”URL，在Web服务器上都有一个真的、实际存在的URL与之对应。否则，单击“刷新”按钮会导致404错误。

## 16.5 小结

- 跨文档消息传递API能够让我们在不降低同源策略安全性的前提下，在来自不同域的文档间传递消息。
- 原生拖放功能让我们可以方便地指定某个元素可拖动，并在操作系统要放置时做出响应。还可以创建自定义的可拖动元素及放置目标。


- 新的媒体元素`<audio>`和`<video>`拥有自己的与音频和视频交互的API。并非所有浏览器支持所有的媒体格式，因此应该使用canPlayType()检查浏览器是否支持特定的格式。


- 历史状态管理让我们不必卸载当前页面即可修改浏览器的历史状态栈。有了这种机制，用户就可以通过“后退”和“前进”按钮在页面状态间切换，而这些状态完全由JavaScript进行控制。



# 第17章 错误处理与调试

## 17.1 浏览器报告的错误

### 17.1.1 IE 

### 17.1.2 Firefox 

### 17.1.3 Safari

### 17.1.4 Opera

### 17.1.5 Chrome 

## 17.2 错误处理

### 17.2.1 try-catch语句

出错对象中包含的实际信息会因浏览器而异，但共同的是有一个保存着错误消息的message属性。ECMA-262还规定了一个保存错误类型的name属性；

IE添加了与message属性完全相同的description属性，还添加了保存着内部错误数量的number属性。Firefox添加了fileName、lineNumber和stack（包含栈跟踪信息）属性。Safari添加了line（表示行号）、sourceId（表示内部错误代码）和sourceURL属性

#### 1. finally子句

finally子句一经使用，其代码无论如何都会执行。只要代码中包含finally子句，那么无论try还是catch语句块中的return语句都将被忽略。

IE7及更早版本中有一个bug：除非有catch子句，否则finally中的代码永远不会执行。

#### 2. 错误类型

ECMA-262定义了下列7种错误类型：

- Error 
- EvalError 
- RangeError 
- ReferenceError 
- SyntaxError 
- TypeError 
- URIError 

Error是基类型，主要目的是供开发人员抛出自定义错误。

EvalError在使用eval()函数而发生异常时被抛出。简单地说，如果没有把eval()当成函数调用，就会抛出错误

RangeError类型的错误会在数值超出相应范围时触发。

ReferenceError，在访问不存在的变量时会发生这种错误

SyntaxError，把语法错误的JavaScript字符串传入eval()函数时，就会导致此类错误。

TypeError，在变量中保存着意外的类型时，或者在访问不存在的方法时，都会导致这种错误。最常发生类型错误的情况，就是传递给函数的参数事先未经检查，结果传入类型与预期类型不相符。

URIError，在使用encodeURI()或decodeURI()，而URI格式不正确时

要想知道错误的类型，可以在try-catch语句的catch语句中使用instanceof操作符。

#### 3. 合理使用try-catch

### 17.2.2 抛出错误

throw操作符，用于随时抛出自定义错误。
抛出错误时，必须要给throw操作符指定一个值，这个值是什么类型，没有要求。
在遇到throw操作符时，代码会立即停止执行。仅当有try-catch语句捕获到被抛出的值时，代码才会继续执行。

在创建自定义错误消息时最常用的错误类型是Error、RangeError、ReferenceError和TypeError。

利用原型链还可以通过继承Error来创建自定义错误类型。此时 ，需要为新创建的错误类型指定name和message属性。

> IE只有在抛出Error对象的时候才会显示自定义错误消息。对于其他类型，它都无一例外地显示"exception thrown and not caught"（抛出了异常，且未被捕获）。

#### 1. 抛出错误的时机

#### 2. 抛出错误与使用try-catch

捕获错误的目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。

### 17.2.3 错误（error）事件

任何没有通过try-catch处理的错误都会触发window对象的error事件。

在任何Web浏览器中，onerror事件处理程序都不会创建event对象，但它可以接收三个参数：错误消息、错误所在的URL和行号。

> 浏览器在使用这个事件处理错误时的方式有明显不同。在IE中，即使发生error事件，代码仍然会正常执行；所有变量和数据都将得到保留，因此能在onerror事件处理程序中访问它们。但在Firefox中，常规代码会停止执行，事件发生之前的所有变量和数据都将被销毁，因此几乎就无法判断错误了。

图像也支持error事件。只要图像的src特性中的URL不能返回可以被识别的图像格式，就会触发error事件。

### 17.2.4 处理错误的策略

### 17.2.5 常见的错误类型

一般来说，需要关注三种错误：

- 类型转换错误
- 数据类型错误
- 通信错误

#### 1. 类型转换错误

建议使用全等（===）和不全等（!==）操作符，以避免类型转换。

在流控制语句中使用非布尔值，是极为常见的一个错误来源。

#### 2. 数据类型错误

在将预料之外的值传递给函数的情况下，最容易发生数据类型错误。

一个常见的错误就是将参数与null值进行比较。与null进行比较只能确保相应的值不是null和undefined。

另一种错误的做法，就是只针对要使用的某一个特性执行特性检测。在确切知道应该传入什么类型的情况下，最好是使用instanceof来检测其数据类型

大体上来说，基本类型的值应该使用typeof来检测，而对象的值则应该使用instanceof来检测。

#### 3. 通信错误

第一种通信错误与格式不正确的URL或发送的数据有关。最常见的问题是在将数据发送给服务器之前，没有使用encodeURIComponent()对数据进行编码。

在服务器响应的数据不正确时，也会发生通信错误。

### 17.2.6 区分致命错误和非致命错误

对于非致命错误，可以根据下列一或多个条件来确定：

- 不影响用户的主要任务；
- 只影响页面的一部分；
- 可以恢复；
- 重复相同操作可以消除错误。

致命错误，可以通过以下一或多个条件来确定：

- 应用程序根本无法继续运行；
- 错误明显影响到了用户的主要操作；
- 会导致其他连带错误。

### 17.2.7 把错误记录到服务器

可使用Image对象来从查询字符串中取得数据，然后再将数据写入错误日志中。

## 17.3 调试技术

### 17.3.1 将消息记录到控制台

对IE8、Firefox、Chrome和Safari来说，则可以通过console对象向JavaScript控制台中写入消息，这个对象具有下列方法。

- error(message)：将错误消息记录到控制台
- info(message)：将信息性消息记录到控制台
- log(message)：将一般消息记录到控制台
- warn(message)：将警告消息记录到控制台

Opera 10.5之前的版本中，JavaScript控制台可以通过opera.postError()方法来访问。这个方法接受一个参数，即要写入到控制台中的参数

还有一种方案是使用LiveConnect，也就是在JavaScript中运行Java代码。Firefox、Safari和Opera都支持LiveConnect，因此可以操作Java控制台。

### 17.3.2 将消息记录到当前页面

另一种输出调试消息的方式，就是在页面中开辟一小块区域，用以显示消息。

这种技术在不支持JavaScript控制台的IE7及更早版本或其他浏览器中十分有用。

### 17.3.3 抛出错误

对于大型应用程序来说，自定义的错误通常都使用assert()函数抛出。这个函数接受两个参数，一个是求值结果应该为true的条件，另一个是条件为false时要抛出的错误。

可以用这个assert()函数代替某些函数中需要调试的if语句，以便输出错误消息。

## 17.4 常见的IE错误

### 17.4.1 操作终止

在IE8之前的版本中，存在操作终止。发生错误时，会出现一个模态对话框，告诉你“操作终止。”

要避免这个问题，可以等到目标元素加载完毕后再对它进行操作，或者使用其他操作方法。

### 17.4.2 无效字符

在JavaScript文件中存在无效字符时，IE会抛出无效字符（invalid character）错误。

其他浏览器对无效字符做出的反应与IE类似，Firefox会抛出非法字符（illegal character）错误，Safari会报告发生了语法错误，而Opera则会报告发生了ReferenceError（引用错误），因为它会将无效字符解释为未定义的标识符。

### 17.4.3 未找到成员

IE中的未找到成员错误，就是由于垃圾收集例程配合错误所直接导致的。

具体来说，如果在对象被销毁之后，又给该对象赋值，就会导致未找到成员错误。而导致这个错误的，一定是COM对象。发生这个错误的最常见情形是使用event对象的时候。IE中的event对象是window的属性，该对象在事件发生时创建，在最后一个事件处理程序执行完毕后销毁。

### 17.4.4 未知运行时错误

当使用innerHTML或outerHTML以下列方式指定HTML时，就会发生未知运行时错误（Unknown 
runtime error）：一是把块元素插入到行内元素时，二是访问表格任意部分（<table>、<tbody>等）的
任意属性时。

### 17.4.5 语法错误

### 17.4.6 系统无法找到指定资源

在使用JavaScript请求某个资源URL，而该URL的长度超过了IE对URL最长不能超过2083个字符的限制时，就会发生这个错误。

## 17.5 小结

下面是几种避免浏览器响应JavaScript错误的方法。

- 在可能发生错误的地方使用try-catch语句，这样你还有机会以适当的方式对错误给出响应，而不必沿用浏览器处理错误的机制。
- 使用window.onerror事件处理程序，这种方式可以接受try-catch不能处理的所有错误（仅限于IE、Firefox和Chrome）。

另外，对任何Web应用程序都应该分析可能的错误来源，并制定处理错误的方案。

- 首先，必须要明确什么是致命错误，什么是非致命错误。
- 其次，再分析代码，以判断最可能发生的错误。JavaScript中发生错误的主要原因如下。
  - 类型转换
  - 未充分检测数据类型
  - 发送给服务器或从服务器接收到的数据有错误



# 第18章 JavaScript 与 XML

## 18.1 浏览器对XML DOM的支持

### 18.1.1 DOM2级核心

DOM2级在document.implementation中引入了createDocument()方法。IE9+、Firefox、Opera、Chrome和Safari都支持这个方法。

```javascript
var xmldom = document.implementation.createDocument(namespaceUri, root, doctype);
var xmldom = document.implementation.createDocument("", "root", null);
```

在通过JavaScript处理XML时，通常只使用参数root，因为这个参数指定的是XML DOM文档元素的标签名。而namespaceUri参数则很少用到，原因是在JavaScrip中管理命名空间比较困难。最后，doctype参数用得就更少了。

要检测浏览器是否支持DOM2级XML，可以使用下面这行代码：

```javascript
var hasXmlDom = document.implementation.hasFeature("XML", "2.0"); 
```

### 18.1.2 DOMParser类型

在解析XML之前，首先必须创建一个DOMParser 的实例，然后再调用parseFromString()方法。这个方法接受两个参数：要解析的XML字符串和内容类型（内容类型始终都应该是"text/xml"）。返回的值是一个Document的实例。

DOMParser只能解析格式良好的XML，因而不能把HTML解析为HTML文档。在发生解析错误时，仍然会从parseFromString()中返回一个Document 对象，但这个对象的文档元素是`<parsererror>`，而文档元素的内容是对解析错误的描述。

Firefox和Opera都会返回这种格式的文档。Safari和Chrome返回的文档也包含<parsererror>元素，
但该元素会出现在发生解析错误的地方。IE9 会在调用parseFromString()的地方抛出一个解析错误。

### 18.1.3 XMLSerializer类型

XMLSerializer：将DOM文档序列化为XML字符串。

Firefox、IE9+、Opera、Chrome和Safari都支持了XMLSerializer。

要序列化DOM文档，首先必须创建XMLSerializer的实例，然后将文档传入其serializeToString ()方法

> 如果将非DOM对象传入serializeToString()，会导致错误发生。

### 18.1.4 IE8及之前版本中的XML

要创建一个XML文档的实例，也要使用ActiveXObject构造函数并为其传入一个表示XML文档版本的字符串。有6种不同的XML文档版本可以供选择。

- Microsoft.XmlDom：最初随同IE发布；不建议使用。
- MSXML2.DOMDocument：为方便脚本处理而更新的版本，建议仅在特殊情况下作为后备版本使用。
- MSXML2.DOMDocument.3.0：为了在JavaScript中使用，这是最低的建议版本。
- MSXML2.DOMDocument.4.0：在通过脚本处理时并不可靠，使用这个版本可能导致安全警告。
- MSXML2.DOMDocument.5.0：在通过脚本处理时并不可靠，使用这个版本同样可能导致安全警告。
- MSXML2.DOMDocument.6.0：通过脚本能够可靠处理的最新版本。

在这6个版本中，微软只推荐使用MSXML2.DOMDocument.6.0或MSXML2.DOMDocument.3.0；前者是最新最可靠的版本，而后者则是大多数Windows操作系统都支持的版本。

要解析XML字符串，首先必须创建一个DOM文档，然后调用loadXML()方法。新创建的XML文档完全是一个空文档，因而不能对其执行任何操作。为loadXML()方法传入的XML字符串经解析之后会被填充到DOM文档中。

如果解析过程中出错，可以在parseError属性中找到错误消息。这个属性本身是一个包含多个属性的对象，每个属性都保存着有关解析错误的某一方面信息。

- errorCode：错误类型的数值编码；在没有发生错误时值为0。
- filePos：文件中导致错误发生的位置。
- line：发生错误的行。
- linepos：发生错误的行中的字符。
- reason：对错误的文本解释。
- srcText：导致错误的代码。
- url：导致错误的文件的URL（如果有这个文件的话）。

parseError的valueOf()方法返回errorCode的值。错误类型的数值编码可能是正值，也可能是负值，因此我们只需检测它是不是等于0。

#### 1. 序列化XML 

IE将序列化XML的能力内置在了DOM文档中。每个DOM节点都有一个xml属性，其中保存着表示该节点的XML字符串。

#### 2. 加载XML文件

与DOM3级中的功能类似，要加载的XML文档必须与页面中运行的JavaScript代码来自同一台服务器。同样与DOM3级规范类似，加载文档的方式也可以分为同步和异步两种。要指定加载文档的方式，可以设置async属性，true表示异步，false表示同步（默认值为true）。

在确定了加载XML文档的方式后，调用load()可以启动下载过程。这个方法接受一个参数，即要加载的XML文件的URL。在同步方式下，调用load()后可以立即检测解析错误并执行相关的XML处理

在异步加载XML文件的情况下，需要为XML DOM文档的onreadystatechange事件指定处理程序。有4个就绪状态。
​	1：DOM正在加载数据。
​	2：DOM已经加载完数据。
​	3：DOM已经可以使用，但某些部分可能还无法访问。
​	4：DOM已经完全可以使用。

在事件处理程序内部，还必须注意要使用XML文档变量的名称（xmldom），不能使用this对象。原因是ActiveX控件为预防安全问题不允许使用this对象。

> 虽然可以通过XML DOM文档对象加载XML文件，但公认的还是使用XMLHttpRequest对象比较好。

### 18.1.5 跨浏览器处理XML

## 18.2 浏览器对XPath的支持

### 18.2.1 DOM3级XPath

要确定某浏览器是否支持DOM3级XPath：

```javascript
var supportsXPath = document.implementation.hasFeature("XPath", "3.0")
```

#### XPathEvaluator

用于在特定的上下文中对XPath表达式求值。这个类型有下列3个方法。

- createExpression(expression, nsresolver)：将XPath表达式及相应的命名空间信息转换成一个XPathExpression，这是查询的编译版。在多次使用同一个查询时很有用。
- createNSResolver(node)：根据node的命名空间信息创建一个新的XPathNSResolver对象。在基于使用命名空间的XML文档求值时，需要使用XPathNSResolver对象。
- evaluate(expression, context, nsresolver, type, result)：在给定的上下文中，基于特定的命名空间信息来对XPath表达式求值。剩下的参数指定如何返回结果。

evaluate()是最常用的。这个方法接收5个参数：XPath表达式、上下文节点、命名空间求解器、返回结果的类型和保存结果的XPathResult对象（通常是null，因为结果也会以函数值的形式返回）。其中，第三个参数（命名空间求解器）只在XML代码中使用了XML命名空间时有必要指定；如果XML代码中没有使用命名空间，则这个参数应该指定为null。第四个参数（返回结果的类型）的取值范围是下列常量之一。

- XPathResult.ANY_TYPE：返回与XPath表达式匹配的数据类型。
- XPathResult.NUMBER_TYPE：返回数值。
- XPathResult.STRING_TYPE：返回字符串值。
- XPathResult.BOOLEAN_TYPE：返回布尔值。
- XPathResult.UNORDERED_NODE_ITERATOR_TYPE：返回匹配的节点集合，但集合中节点的次序不一定与它们在文档中的次序一致。
- XPathResult.ORDERED_NODE_ITERATOR_TYPE：返回匹配的节点集合，集合中节点的次序与它们在文档中的次序一致。这是最常用的结果类型。
- XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE：返回节点集合的快照，由于是在文档外部捕获节点，因此对文档的后续操作不会影响到这个节点集合。集合中节点的次序不一定与它们在文档中的次序一致。
- XPathResult.ORDERED_NODE_SNAPSHOT_TYPE：返回节点集合的快照，由于是在文档外部捕获节点，因此对文档的后续操作不会影响到这个节点集合。集合中节点的次序与它们在文档中的次序一致。
- XPathResult.ANY_UNORDERED_NODE_TYPE：返回匹配的节点集合，但集合中节点的次序不一定与它们在文档中的次序一致。
- XPathResult.FIRST_ORDERED_NODE_TYPE：返回只包含一个节点的节点集合，包含的这个节点就是文档中第一个匹配的节点。

如果指定的是快照结果类型（不管是次序一致还是次序不一致的），就必须使用snapshotItem()方法和snapshotLength属性

#### 1. 单节点结果

指定常量XPathResult.FIRST_ORDERED_NODE_TYPE会返回第一个匹配的节点，可以通过结果的singleNodeValue属性来访问该节点。

#### 2. 简单类型结果

XPathResult的布尔值、数值和字符串类型分别会通过booleanValue、numberValue和stringValue属性返回一个值。

对于布尔值类型，如果至少有一个节点与XPath表达式匹配，则求值结果返回true，否则返回false。

对于数值类型，必须在XPath表达式参数的位置上指定一个能够返回数值的XPath函数

对于字符串类型，evaluate()方法会查找与XPath表达式匹配的第一个节点，然后返回其第一个子节点的值（实际上是假设第一个子节点为文本节点）。如果没有匹配的节点，结果就是一个空字符串。

#### 3. 默认类型结果

要确定返回的是什么结果类型，可以检测结果的resultType属性

#### 4. 命名空间支持

对于利用了命名空间的XML文档，XPathEvaluator必须知道命名空间信息，然后才能正确地进行求值。

处理命名空间的第一种方法是通过createNSResolver()来创建XPathNSResolver对象。这个方法接受一个参数，即文档中包含命名空间定义的节点。

处理命名空间的第二种方法就是定义一个函数，让它接收一个命名空间前缀，返回关联的URI

### 18.2.2 IE中的XPath 

IE对XPath的支持是内置在基于ActiveX的XML DOM文档对象中的，没有使用DOMParser返回的DOM对象。因此，为了在IE9及之前的版本中使用XPath，必须使用基于ActiveX的实现。

这个接口在每个节点上额外定义了两个的方法：selectSingleNode()和selectNodes()。

selectSingleNode()方法接受一个XPath模式，在找到匹配节点时返回第一个匹配的节点，如果没有找到匹配的节点就返回null。

selectNodes()也接收一个XPath模式作为参数，但它返回与模式匹配的所有节点的NodeList（如果没有匹配的节点，则返回一个包含零项的NodeList）。

#### IE对命名空间的支持

要在IE中处理包含命名空间的XPath表达式，你必须知道自己使用的命名空间，并按照下列格式创建一个字符串：

```xml
"xmlns:prefix1='uri1' xmlns:prefix2='uri2' xmlns:prefix3='uri3'"
```

传入到XML DOM文档对象的特殊方法setProperty()中，这个方法接收两个参数：要设置的属性名和属性值。

### 18.2.3 跨浏览器使用XPath 

要在其他使用DOM3级XPath对象的浏览器中，重新创建selectSingleNode()和selectNodes()方法。

selectSingleNode()，它接收三个参数：上下文节点、XPath表达式和可选的命名空间对象。

命名空间对象应该是下面这种字面量的形式。

```xml
{ 
prefix1: "uri1", 
prefix2: "uri2", 
prefix3: "uri3" 
} 
```

selectNodes()函数,接收与selectSingleNode()相同的三个参数

为了求得最佳的浏览器兼容性，我们建议在JavaScript中使用XPath时，只考虑使用这两个方法。

## 18.3 浏览器对XSLT的支持

XSLT是与XML相关的一种技术，它利用XPath将文档从一种表现形式转换成另一种表现形式。

XSLT没有正式的API，在正式的DOM规范中也没有它的位置。

### 18.3.1 IE中的XSLT

IE对XSLT的支持也是通过ActiveX对象实现的。

从MSXML 3.0（即IE6.0）时代起，IE就支持通过JavaScript实现完整的XSLT 1.0操作。IE9中通过DOMParser创建的DOM文档不能使用XSLT。

#### 1. 简单的XSLT转换

使用XSLT样式表转换XML文档的最简单方式，就是将它们分别加到一个DOM文档中，然后再使用transformNode()方法。

transformNode()方法：存在于文档的所有节点中，它接受一个参数，即包含XSLT样式表的文档。调用transformNode()方法会返回一个包含转换信息的字符串。

如果不是在文档元素上调用transformNode()，那么转换就会从调用节点上面开始。不过，XSLT样式表则始终都可以针对调用节点所在的整个XML文档，而无需更换。

#### 2. 复杂的XSLT转换

第一步是要把XSLT样式表加载到一个线程安全的XML文档中。而这可以通过使用ActiveX对象MSXML2.FreeThreadedDOMDocument来做到。

除了签名不同之外，线程安全的XML DOM文档与常规XML DOM文档的使用仍然是一样的

在创建并加载了自由线程的DOM文档之后，必须将它指定给一个XSL模板，这也是一个ActiveX对象。

在创建了XSL处理器之后，必须将要转换的节点指定给input属性。这个值可以是一个文档，也可以是文档中的任何节点。然后，调用transform()方法即可执行转换并将结果作为字符串保存在output属性中。

> XSL模板对象的3.0和6.0版本存在显著的差别。在3.0版本中，必须给input属性指定一个完整的文档；如果指定的是节点，就会导致错误。而在6.0版本中，则可以为input属性指定文档中的任何节点。

XSLT样式表可以接受传入的参数，并将其用作局部变量。

addParameter()方法接收两个参数：要设置的参数名称（与在`<xsl:param>`的name特性中指定的一样）和要指定的值（多数情况下是字符串，但也可以是数值或布尔值）。

XSL处理器能够设置一种操作模式。在XSLT中，可以使用mode特性为模板定义一种模式。在定义了模式后，如果没有将`<xsl:apply-templates>`与匹配的mode特性一起使用，就不会运行该模板。

setStartMode()方法只接受一个参数，即要为处理器设置的模式。与addParameter()一样，设置模式也必须在调用transform()之前进行。

如果你打算使用同一个样式表进行多次转换，可以在每次转换之后重置处理器。调用reset()方法后，就会清除原先的输入和输出属性、启动模式及其他指定的参数。

### 18.3.2 XSLTProcessor类型

非IE实现：

与IE的实现类似，第一步也是加载两个DOM文档，一个基于XML，另一个基于XSLT。

然后，创建一个新XSLTProcessor对象，并使用importStylesheet()方法为其指定一个XSLT。

最后一步就是执行转换。这一步有两种不同的方式，如果想返回一个完整的DOM文档，可以调用transformToDocument()。而通过调用transformToFragment()则可以得到一个文档片段对象。一般来说，使用transformToFragment()的唯一理由，就是你还想把返回的结果添加到另一个DOM文档中。

在使用transformToDocument()时，只要传入XML DOM，就可以将结果作为一个完全不同的DOM文档来使用。

transformToFragment()方法接收两个参数：要转换的XML DOM和应该拥有结果片段的文档。换句话说，如果你想将返回的片段插入到页面中，只要将document作为第二个参数即可。

当输出格式为"text"时调用transformToDocument()，仍然会返回一个完整的XML文档，但这个文档的内容在不同浏览器中却不一样。使用transformToFragment()方法可以解决这个问题，这个方法返回的是只包含一个子节点的文档片段，而子节点中包含着结果文本。

#### 1. 使用参数

XSLTProcessor也支持使用setParameter()来设置XSLT的参数，这个方法接收三个参数：命名空间URI、参数的内部名称和要设置的值。通常，命名空间URI都是null，而内部名称就是参数的名称。另外，必须在调用transformToDocument()或transformToFragment()之前调用这个方法。

还有两个不常用的与参数有关的方法，getParameter()和removeParameter()，分别用于取得和移除当前参数的值。这两个方法都要接受命名空间参数（同样，通常是null）和参数的内部名称。

#### 2. 重置处理器

重置处理器时要调用reset()方法，这个方法会从处理器中移除所有参数和样式表。然后，你就可以再次调用importStylesheet()，以加载不同的XSLT样式表

### 18.3.3  跨浏览器使用XSLT

跨浏览器兼容性最好的XSLT转换技术，只能是返回结果字符串。为此在IE中只需在上下文节点上调用transformNode()即可，而在其他浏览器中则需要序列化transformToDocument()操作的结果。

## 18.4 小结

IE采取了下列方式。

- 通过ActiveX对象来支持处理XML，而相同的对象也可以用来构建桌面应用程序。
- Windows携带了MSXML库，JavaScript能够访问这个库。
- 这个库中包含对基本XML解析和序列化的支持，同时也支持XPath和XSLT等技术。

Firefox为处理XML的解析和序列化，实现了两个新类型。

- DOMParser类型比较简单，其对象可以将XML字符串解析为DOM文档。
- XMLSerializer类型执行相反的操作，即将DOM文档序列化为XML字符串。

DOM3级引入了一个针对XPath API的规范，该规范已经由Firefox、Safari、Chrome和Opera实现。这些API可以让JavaScript基于DOM文档运行任何XPath查询，并且能够返回任何数据的结果。IE以自己的方式实现了对XPath的支持；具体来说，就是两个方法：selectSingleNode()和selectNodes()。

与XML相关的最后一种技术是XSLT，Firefox为通过JavaScript处理转换创建了XSLTProcessor类型；IE则针对XSLT提供了自己的方案，一个是简单的transformNode()方法，另一个是较为复杂的模板/处理器手段。



# 第19章 E4X 

E4X本身不是一门语言，它只是ECMAScript语言的可选扩展。

尽管浏览器实现这个扩展标准的步伐非常缓慢，但Firefox 1.5及更高版本则支持几乎全部E4X标准。

## 19.1 E4X的类型

E4X定义了如下几个新的全局类型。

- XML：XML结构中的任何一个独立的部分。
- XMLList：XML对象的集合。
- Namespace：命名空间前缀与命名空间URI之间的映射。
- QName：由内部名称和命名空间URI组成的一个限定名。

### 19.1.1 XML类型

XML类型继承自Object类型，因此它也继承了所有对象默认的所有属性和方法。

创建XML对象的方式

```javascript
//方式1
var x = new XML(); 
var x = new XML("<employee position=\"Software Engineer\"><name>Nicholas " + 
"Zakas</name></employee>"); 
//方式2
var x = new XML(xmldom);
//方式3
var employee = <employee position="Software Engineer"> 
<name>Nicholas C. Zakas</name> 
</employee>; 
```

> Firefox对E4X的实现不支持解析XML的开头代码（prolog）。无论<?xml version="1.0" ?>出现在传递给XML构造函数的文本中，还是出现在XML字面量中，都会导致语法错误。

XML类型的toXMLString()方法会返回XML对象及其子节点的XML字符串表示。

XML类型的toString()方法则会基于不同XML对象的内容返回不同的字符串。如果内容简单（纯文本），则返回文本；否则，toString()方法与toXMLString()方法返回的字符串一样。

### 19.1.2 XMLList类型

显式地创建一个XMLList对象

```javascript
//方式1
var list = new XMLList(); 
//方式2
var list = new XMLList("<item/><item/>"); 
//方式3
var list = <item/> + <item/> ;
var list = <><item/><item/></>; 
```

可以使用方括号语法及位置来访问每个元素

每个XMLList对象都有length()方法，用于返回对象中包含的元素数量。注意，length()是方法，不是属性。这一点是故意与数组和NodeList相区别的。

E4X有意模糊XML和XMLList类型之间的区别，这一点很值得关注。为了减少两者之间的区别，每个XML对象也同样有一个length()方法和一个由[0]引用的属性（返回XML对象自身）。

XMLList 对象的toString()和toXMLString()方法返回相同的字符串值，也就是将其包含的
XML对象序列化之后再拼接起来的结果。

### 19.1.3 Namespace类型

通常，Namespace对象是用来映射命名空间前缀和命名空间URI的，不过有时候并不需要前缀。

创建Namespace对象

```javascript
var ns = new Namespace();
```

传入URI或前缀加URI, 可以初始化Namespace对象

```javascript
var ns = new Namespace("http://www.wrox.com/"); 
var wrox = new Namespace("wrox", "http://www.wrox.com/");
```

可使用prefix和uri属性来取得Namespace对象中的信息

在没有给Namespace对象指定前缀的情况下，prefix属性会返回undefined。要想创建默认的命名空间，应该将前缀设置为空字符串。

如果XML字面量中包含命名空间，或者通过XML构造函数解析的XML字符串中包含命名空间信息，那么就会自动创建Namespace对象。然后，就可以通过前缀和namespace()方法来取得对Namespace对象的引用。

Namespace对象的toString()方法始终会返回命名空间URI。

### 19.1.4 QName类型

QName类型表现的是XML对象的限定名，即命名空间与内部名称的组合。向QName构造函数中传入名称或Namespace对象和名称，可以手工创建新的QName对象

可以访问它的两个属性：uri和localName。其中，uri属性返回在创建对象时指定的命名空间的URI（如果未指定命名空间，则返回空字符串），而localName属性返回限定名中的内部名称

这两个属性是只读的，如果你想修改它们的值，会导致错误发生。QName对象重写了toString()方法，会以uri::localName形式返回一个字符串

在解析XML结构时，会为表示相应元素或特性的XML对象自动创建QName对象。

使用setName()方法并传入一个新QName对象，可以修改XML对象的限定名

## 19.2 一般用法

在将XML对象、元素、特性和文本集合到一个层次化对象之后，就可以使用点号加特性或标签名的方式来访问其中不同的层次和结构。

如果你不确定子元素的内部名称，或者你想访问所有子元素，不管其名称是什么，也可以像下面这样使用星号（*）。

```javascript
var allChildren = employees.*; //返回所有子元素，不管其名称是什么
```

child()方法。将属性名或索引值传递给child()方法，会得到相同的值。

children()方法始终返回所有子元素。

elements()的行为与child()类似，区别仅在于它只返回表示元素的XML对象。

要删除子元素，可以使用delete操作符

### 19.2.1 访问特性

访问特性也可以使用点语法,为了区分特性名与子元素的标签名，必须在名称前面加上一个@字符。这是从XPath中借鉴的语法；XPath也是使用@来区分特性和标签的名称。

要取得特性的名称，可以使用对象的name()方法。

可使用child()方法来访问特性，只要传入带有@前缀的特性的名称即可。由于访问XML对象的属性时也可以使用child()，因此必须使用@字符来区分标签名和特性名。

使用attribute()方法并传入特性名，可以只访问XML对象的特性。不需要传入带@字符的特性名。

要取得XML或XMLList对象中的所有特性，可以使用attributes()方法。这个方法会返回一个表示所有特性的XMLList对象。使用这个方法与使用@*的结果相同

在E4X中修改特性的值与修改属性的值一样非常简单，只要像下面这样为特性指定一个新值。也可以用来添加新特性

修改的特性会在内部反映出来，换句话说，此后再序列化XML对象，就会使用新的特性值。

由于特性与其他ECMAScript属性类似，因此也可以使用delete操作符来删除特性

### 19.2.2 其他节点类型

在默认情况上，E4X不会解析注释或处理指令，因此这些部分不会出现在最终的对象层次中。如果想让解析器解析这些部分，可以像下面这样设置XML构造函数的下列两个属性。

```javascript
XML.ignoreComments = false; 
XML.ignoreProcessingInstructions = false; 
```

使用nodeKind()方法可以得到XML对象表示的类型，该访问可能会返回"text"、"element"、"comment"、"processing-instruction"或"attribute"。

不能在包含多个XML对象的XMLList上调用nodeKind()方法；否则，会抛出一个错误。

可以只取得特定类型的节点，而这就要用到下列方法。

-  attributes()：返回XML对象的所有特性。
-  comments()：返回XML对象的所有子注释节点。
-  elements(tagName)：返回XML对象的所有子元素。可以通过提供元素的tagName（标签名）来过滤想要返回的结果。


- processingInstructions(name)：返回XML对象的所有处理指令。可以通过提供处理指令的name（名称）来过滤想要返回的结果。


- text()：返回XML对象的所有文本子节点。

上述方法都返回一个包含适当XML对象的XMLList。

使用hasSimpleContent()和hasComplexContent()方法，可以确定XML对象中是只包含文本，还是包含更复杂的内容。如果XML对象中只包含子文本节点，则前一个方法会返回true；如果XML对象的子节点中有任何非文本节点，则后一个方法返回true。

### 19.2.3 查询

引用不表现XML 结构中某一部分的属性仍然会返回XMLList；只不过这个XMLList中什么也不会包含。

使用两个点，则可以进一步扩展查询的深度，查询到所有后代节点。要想取得特定标签的元素，需要将星号替换成实际的标签名

```javascript
var allDescendants = employees..*; //取得<employees/>的所有后代节点
```

同样的查询可以使用descendants()方法来完成。在不给这个方法传递参数的情况下，它会返回所有后代节点（与使用..*相同），而传递一个名称作为参数则可以限制结果。

同样的查询可以取得所有后代元素中的所有特性

除了访问后代元素之外，还可以指定查询的条件。

```javascript
var salespeople = employees.employee.(@position == "Salesperson"); 
```

同样的语法也可以用于修改XML结构中的某一部分。

```javascript
employees.employee.(@position == "Salesperson")[0].@position= "Senior Salesperson"; 
```

注意，圆括号中的表达式会返回一个包含结果的XMLList，而方括号返回其中的一项

使用parent()方法能够在XML结构中上溯，这个方法会返回一个XML对象，表示当前XML对象的父元素。如果在XMLList上调用parent()方法，则会返回列表中所有对象的公共父元素。

### 19.2.4 构建和操作XML 

可以在字面量中嵌入JavaScript变量，语法是使用花括号（{}）。

E4X也支持使用标准的JavaScript语法来构建完整的XML结构。

- E4XappendChild(child)：将给定的child作为子节点添加到XMLList的末尾。
- copy()：返回XML对象副本。
- insertChildAfter(refNode, child)：将child作为子节点插入到XMLList中refNode的后面。
- insertChildBefore(refNode, child)：将child作为子节点插入到XMLList中refNode的前面。
- prependChild(child)：将给定的child作为子节点添加到XMLList的开始位置。
- replace(propertyName, value)：用value值替换名为propertyName的属性，这个属性可能是一个元素，也可能是一个特性。
- setChildren(children)：用children替换当前所有的子元素，children可以是XML对象，也可是XMLList对象。类似DOM的方法：

### 19.2.5 解析和序列化

与XML解析相关的设置有如下三个。

- ignoreComments：表示解析器应该忽略标记中的注释。默认设置为true。
- ignoreProcessingInstructions：表示解析器应该忽略标记中的处理指令。默认设置为true。
- ignoreWhitespace：表示解析器应该忽略元素间的空格，而不是创建表现这些空格的文本节点。默认设置为true。

与XML数据序列化相关的设置有如下两个。这两个设置将影响到toString()和toXMLString()的输出。

- prettyIndent：表示在序列化XML时，每次缩进的空格数量。默认值为2。
- prettyPrinting：表示应该以方便人类认读的方式输出XML，即每个元素重起一行，而且子元素都要缩进。默认设置为true。

以上五个设置都保存在settings对象中，通过XML构造函数的settings()方法可以取得这个对象

使用defaultSettings()方法则可以取得一个包含默认设置的对象

### 19.2.6 命名空间

使用namspace()方法可以取得与特定前缀对应的Namespace对象。而通过使用setNamespace()并传入Namespace对象，也可以为给定元素设置命名空间。

如果只想添加一个命名空间声明，而不想改变元素，可以使用addNamespace()方法并传入Namespace对象

调用removeNamespace()方法并传入Namespace对象，可以移除表示特定命名空间前缀和URI的命名空间声明；注意，必须传入丝毫不差的表示命名空间的Namespace对象。

有两个方法可以返回与节点相关的Namespace 对象的数组：namespaceDeclarations()和
inScopeNamespaces()。前者返回在给定节点上声明的所有命名空间的数组，后者返回位于给定节点作用域中（即包括在节点自身和祖先元素中声明的）所有命名空间的数组。

使用双冒号（::）也可以基于Namespace对象来查询XML结构中具有特定命名空间的元素。注意，这里使用的是JavaScript变量，而不是命名空间前缀。

可以为某个作用域中的所有XML对象设置默认命名空间。为此，要使用default xml namespace语句，并将一个Namespace对象或一个命名空间URI作为值赋给它。

```javascript
default xml namespace = "http://www.wrox.com/";
```

注：在局部作用域中设置默认命名空间并不会改变全局作用域中的默认XML命名空间

## 19.3 其他变化

E4X引入了for-each-in循环，以便迭代遍历每一个属性并返回属性的值

虽然for-each-in循环是在E4X中定义的，但这个语句也可以用于常规的数组和对象

对于数组，for-each-in循环会返回数组中的每一项。对于非XML对象，这个循环返回对象每个属性的值。

E4X还添加了一个全局函数，名叫isXMLName()。这个函数接受一个字符串，并在这个字符串是元素或特性的有效内部名称的情况下返回true。在使用未知字符串构建XML数据结构时，这个函数可以为开发人员提供方便。

E4X对标准ECMAScript的最后一个修改是typeof操作符。在对XML对象或XMLList对象使用这个操作符时，typeof返回字符串"xml"。但在对其他对象使用这个操作符时，返回的都是"object"

## 19.4 全面启用E4X 

Firefox在默认情况下只启用E4X中与其他代码能够相安无事的那些特性。要想完整地启用E4X，需要将`<script>`标签的type 特性设置为"text/javascript;e4x=1"

## 19.5 小结

E4X具有下列特征。

- 与DOM不同，E4X只用一个类型来表示XML中的各种节点。
- XML对象中封装了对所有节点都有用的数据和行为。为表现多个节点的集合，这个规范定义了XMLList类型。


- 另外两个类型，Namespace和QName，分别表现命名空间和限定名。

E4X还修改了标准了的ECMAScript语法

- 使用两个点（..）表示要匹配所有后代元素，使用@字符表示应该返回一或多个特性。
- 星号字符（*）是一个通配符，可以匹配任意类型的节点。
- 所有这些查询都可以通过一组执行相同操作的方法来实现。


# 第20章 JSON

## 20.1 语法

- **简单值**：使用和JavaScript相同的语法，JSON不支持JavaScript中的特殊值undefined
- **对象**
- **数组**

### 20.1.1 简单值

- JSON字符串必须使用双引号(单引号会导致语法错误)

### 20.1.2 对象

JSON对象两个地方和JavaScript不一样：首先是没有声明变量(JSON没有变量的概念)，其次是没有末尾的分号。

JSON对象的属性名任何时候都必须加双引号。

### 20.1.3 数组

## 20.2 解析与序列化

### 20.2.1 JSON对象

早期的JSON解析器基本就是使用JavaScript的eval()函数。

对于较早版本的浏览器，可以使用一个shim。

默认情况下，JSON.stringify()输出的字符串不包含任何空字符串或缩进

将JSON字符串直接传递给JSON.parse()就可以得到相应的JavaScript值

### 20.2.2 序列化选项

JSON.stringify()还能接收两个参数：

第一个参数是个过滤器，可以是一个数组或一个函数

第二个参数是一个选项，表示是否在JSON字符串中保留缩进

#### 1.过滤结果

如果过滤参数是数组，那么关于黄只包含数组中列出的属性

如果第二个参数是函数，传入的函数接收两个参数，属性(键)名和属性值。

如果函数返回了undefined，那么相应的属性会被忽略

#### 2.字符串缩进

JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的是每个级别缩进的空格数。

只要传入有效的控制缩进的参数值，结果字符串就会包含换行符。（只缩进不换行意义不大）最大缩进空格数位10，所有大于10的值都会自动转换为10

如果缩进参数是一个字符串而非数值，则这个字符串将在JSON字符串中被用作缩进字符（不再使用空格）

缩进字符串最长不能超过10个字符长，如果字符串长度超过了10个，结果中将只出现前10个字符。

#### 3.toJSON()方法

原生Date对象有一个toJSON()方法，能将JavaScript的Date对象自动转换成ISO 8601日期字符串。

JSON.stringify()序列化顺序如下：

1. 如果存在toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，按默认顺序执行序列化。
2. 如果提供第二个参数，应用这个函数过滤器，传入函数过滤器的值是第一步返回的值
3. 对第2步返回的每个值进行相应的序列化
4. 如果提供第三个参数，执行相应的格式化

### 20.2.3 解析选项

JSON.parse()方法可接收一个参数，该参数是一个函数称为还原函数，它接受两个参数：一个键和一个值，而且都需要返回一个值

如果在还原函数中返回undefined，则表示要从结果中删除相应的键，如果返回其他值，则将该值插入结果中。

## 20.3 小结



# 第21章 Ajax与Comet

## 21.1 XMLHttpRequest对象

IE5会遇到三种不同版本的XHR对象:MSXML2XMLHttp、MSXML2.XMLHttp.3.0 和 MXSML2.XMLHttp.6.0

IE7+、Firefox、Opera、Chrome 和 Safari 都支持原生的 XHR 对象，在这些浏览器中创建 XHR 对象要像下面这样使用 XMLHttpRequest 构造函数。

```javascript
var xhr = new XMLHttpRequest();
```

### 21.1.1 XHR的用法

##### open()方法

接受3个参数：要发送的请求类型("get"、"post"等)、请求的 URL 和表示是否异步发送请求的布尔值

```javascript
xhr.open("get", "example.php", false);
```

注：

1. URL是相对于执行代码的当前页面。也可以使用绝对路径

2. 调用open()方法并不会真正发送请求 ，而是只启动一个请求以备发送

   > 只能向同一个域中使用相同端口和协议的 URL 发送请求。如果 URL 与启动请求的页面有任何差别，都会引发安全错误。 		

##### send()方法

接受一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送的数据，则必须传入null

##### 响应

在收到响应后，响应数据会自动填充XHR对象的属性，相关属性如下：

- responseText：作为响应主体被返回的文本
- responseXML：如果响应的内容类型是"text/xml"或"application/xml"，这个属性中将保存包含着响应数据的XML DOM文档。
- status：响应HTTP状态
- statusText：HTTP状态的说明

收到响应后，第一步是检查status属性，一般讲200状态代码座位成功标志，此时responseText属性的内容已就绪，而在内容类型正确的情况下，responseXML应能访问。此外304状态代码表示请求的资源并没有被修改。可以直接使用浏览器中缓存的版本。

> 有的浏览器会错误地报告 204 状态代码。IE 中 XHR 的 ActiveX 版本会将 204 设置为 1223，而 IE 中原生的 XHR 则会将 204 规范化为 200。Opera 会在取得 204 时报告 status 的值为 0。	

##### 异步请求

可检测XHR对象的readyState属性，该属性表示请求／响应过程的当前活动阶段。

- 0 ：未初始化。尚未调用open()方法
- 1 ：启动。已经调用open() 方法，但尚未调用 send() 方法
- 2 ：发送。已调用send() 方法，但未接收到响应。
- 3 ：接收。已经接收到部分响应数据。
- 4 ：完成。已经接收到全部响应数据，而且已经可以在客户端使用。

只要readyState属性值由一个值变成另一个值，都会触发一次readystatechange事件。

abort()

在接收响应之前可以调用abort()方法，XHR对象会停止触发事件，而且再也不允许访问任何与响应有关的对象属性。在终止请求后，还应该对XHR对象进行解引用操作。由于内存原因，不建议重用XHR对象。

### 21.1.2 HTTP头部信息

默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息。 

- Accept:浏览器能够处理的内容类型。
-  Accept-Charset:浏览器能够显示的字符集。
-  Accept-Encoding:浏览器能够处理的压缩编码。 
-  Accept-Language:浏览器当前设置的语言。
-  Connection:浏览器与服务器之间连接的类型。
-  Cookie:当前页面设置的任何 Cookie。
-  Host:发出请求的页面所在的域 。
-  Referer:发出请求的页面的 URI。注意，HTTP 规范将这个头部字段拼写错了，而为保证与规范一致，也只能将错就错了。(这个英文单词的正确拼法应该是 referrer。)
-  User-Agent:浏览器的用户代理字符串。

使用 setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接受两个参数:头部字段 的名称和头部字段的值。要成功发送请求头部信息，必须在调用 open()方法之后且调用 send()方法 之前调用 setRequestHeader()

调用 XHR 对象的 getResponseHeader()方法并传入头部字段名称，可以取得相应的响应头部信息。

调用 getAllResponseHeaders()方法则可以取得一个包含所有头部信息的长字符串。

### 21.1.3 GET请求

GET 是最常见的请求类型，最常用于向服务器查询某些信息。

对 XHR 而言，位于传入 open()方法的 URL 末尾的查询字符串必须经过正确的编码才行。

查询字符串中每个参数的名称和值都必须使用 encodeURIComponent()进行编码，然后才能放到 URL 的末尾;而且所有名-值对儿都必须由和号(&)分隔

### 21.1.4 POST请求

POST 请求，通常用于向服务器发送应该被保存的数据。		
发送 POST 请求的第二步就是向 send()方法中传入某些数据。

> 与 GET 请求相比，POST 请求消耗的资源会更多一些。从性能角度来看，以发送相同的数据计，GET 请求的速度最多可达到 POST 请求的两倍。

## 21.2 XMLHttpRequest 2 级

### 21.2.1 FormData

FormData 为序列化表单以及创建与表单格式相同的数据(用于通过 XHR 传输)提供了便利。

示例代码：

```javascript
var data = new FormData();
data.append("name", "Nicholas");
```

append()方法接收两个参数:键和值，分别对应表单字段的名字和字段中包含的值。

可以用表单元素的数据预先向其中填入键值对儿:

```javascript
var data = new FormData(document.forms[0]);
```

创建了 FormData 的实例后，可以将它直接传给 XHR 的 send()方法

使用 FormData 的方便之处体现在不必明确地在 XHR 对象上设置请求头部。XHR 对象能够识别传入的数据类型是 FormData 的实例，并配置适当的头部信息。

支持 FormData 的浏览器有 Firefox 4+、Safari 5+、Chrome 和 Android 3+版 WebKit。

### 21.2.2 超时设定

IE8+ 为 XHR 对象添加了一个 timeout 属性，表示请求在等待响应多少毫秒之后就终止。

在给timeout 设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发 timeout 事件，进而会调用 ontimeout 事件处理程序。

### 21.2.3 overrideMimeType()方法

Firefox 最早引入了 overrideMimeType()方法，用于重写 XHR 响应的 MIME 类型。

调用 overrideMimeType()必须在send()方法之前，才能保证重写响应的 MIME 类型。

支持 overrideMimeType()方法的浏览器有 Firefox、Safari 4+、Opera 10.5 和 Chrome。

## 21.3 进度事件

Progress Events 规范有以下 6 个进度事件。

-  loadstart:在接收到响应数据的第一个字节时触发。
-  progress:在接收响应期间持续不断地触发。
-  error:在请求发生错误时触发。
-  abort:在因为调用 abort()方法而终止连接时触发。
-  load:在接收到完整的响应数据时触发。
-  loadend:在通信完成或者触发 error、abort 或 load 事件后触发。

每个请求都从触发 loadstart 事件开始，接下来是一或多个 progress 事件，然后触发 error、abort 或 load 事件中的一个，最后以触发 loadend 事件结束。

支持前 5 个事件的浏览器有 Firefox 3.5+、Safari 4+、Chrome、iOS 版 Safari 和 Android 版 WebKit。Opera(从第 11 版开始)、IE 8+只支持 load 事件。目前还没有浏览器支持 loadend 事件。

### 21.3.1 load事件

onload 事件处理程序会接收到一个 event 对象，其 target 属性就指向 XHR 对象实例，因而可以访问到 XHR 对象的所有方法和属性。然而，并非所有浏览器都为这个事件实现了适当的事件对象。

Firefox、Opera、Chrome 和 Safari 都支持 load事件。

### 21.3.2 progress事件

Mozilla 对 XHR 的另一个革新是添加了 progress 事件，这个事件会在浏览器接收新数据期间周期性地触发。

 onprogress 事件处理程序会接收到一个 event 对象，其 target 属性是 XHR 对象，但包含着三个额外的属性:lengthComputable、position 和 totalSize。其中，lengthComputable是一个表示进度信息是否可用的布尔值，position 表示已经接收的字节数，totalSize 表示根据Content-Length 响应头部确定的预期字节数。有了这些信息，我们就可以为用户创建一个进度指示器。

## 21.4 跨源资源共享

默认情况下，XHR对象只能访问与包含它的页面位于同一域的资源

CORS (Cross-Origin Resource Sharing，跨源资源共享)是W3C的一个工作草案，定义了在必须访问跨源资源时。浏览器和服务器应该如何沟通。CORS背后的基本思想，是使用自定义的HTTP头部让浏览器和服务器进行沟通。从而决定请求或响应应该是成功还是失败。
比如一个简单使用GET或POST发送的请求，没有自定义头部，需要一个额外的origin，其中包含 请求页面的源信息。如果服务器认可这个请求。就在Access-Control-Allow-Origin头部中发回相同的源信息（如果是公共资源，可以回发"*"）。如果没有这个头部或源信息不匹配，浏览器就会驳回请求。注意，请求和响应都不包含cookie信息。

### 21.4.1 IE对CORS的实现

IE8引入XDR（XDoaminRequest）类型。

XDR与XHR之间不同：

- cookie 不会随请求发送，也不会随响应返回
- 只能设置请求头部信息中的Content-Type字段。
- 不能访问响应头部信息。
- 只支持GET和POST请求。

这些变化使CSRF (Cross-Site Request Forgery, 跨站点请求伪造) 和 XSS (Cross-Site Scripting, 跨站点脚本)的问题得到缓解。被请求的资源可以根据它认可的任意数据来决定是否设置Access-Control-Allow-Origin头部。

XDR对象的open()方法只接收两个参数：请求的类型和URL。			
所有XDR请求都是异步的，请求返回后会调用load事件，响应数据会保存在responseText属性中。

只要有响应就触发load事件，如果失败就触发error事件。没有办法确定响应的状态代码，只能指定一个onerror事件处理程序。
在请求返回前调用abort()方法可以终止请求。			
XDR对象也支持timeout属性和ontimeout事件处理程序。

为支持POST请求，XDR对象提供了contentType属性，用来表示发送数据的格式。这个属性是通过对象影响头部信息的唯一方式。			

### 21.4.2 其他浏览器对CORS的实现

与IE中的XDR对象不同，通过跨域XHR对象可以访问status和statusText属性，而且还支持同步请求。

跨域XHR对象也有一些限制：

- 不能使用setRequestHeader() 设置自定义头部
- 不能发送和接收cookie
- 调用getAllResponseHeaders()方法总会返回空字符串

对于本地资源，最好使用相对URL，在访问远程资源时再使用绝对URL，避免出现限制访问头部或本地cookie信息等问题。

### 21.4.3 Preflighted Requests

在使用下列高级选项来发送请求时，就会向服务器发送一个Preflight请求，这种请求使用OPTIONS方法，发送下列头部：

- Origin：与简单的请求相同
- Access-Control-Request-Method：请求自身使用的方法
- Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号隔离

服务器通过在响应中发送如下头部与浏览器进行沟通：

- Access-Control-Allow-Origin：与简单的请求相同
- Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔
- Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔
- Access-Control-Max-Age：应该将这个Preflight请求缓存多长时间（以秒表示）

支持Preflight请求的浏览器包括Firefox3.5+、Safari 4+和Chrome。IE10及更早版本都不支持。

### 21.4.4 带凭据的请求

默认情况下跨域请求不提供凭据（cookie、HTTP认证及客户端SSL证明等）。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据，如果服务器接受凭据的请求，会用下面的HTTP头部来响应：

```
Access-Control-Allow-Credentials：true
```

服务器还可以在Preflight响应中发送这个HTTP头部

支持withCredentials属性的浏览器有：FireFox3.5+、Safari 4+盒Chrome。IE10及以下不支持。

### 21.4.5 跨浏览器的CROS

检测是否存在withCredentials属性和XDomainRequest对象是否存在，可以兼顾所有浏览器。

## 21.5 其他跨域技术

### 21.5.1 图像Ping

使用`<img>`标签。

动态创建图像经常用于图像Ping。图像Ping是与服务器进行简单的、单向的跨域通信的一种方式。

请求的数据是通过查询字符串形式发送的，而响应是任意内容，通常是像素图或204响应。通过图像Ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应式什么时候接收到的。

图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。有两个主要缺点：一是只能发送GET请求，二是无法访问服务器的响应文本。	

### 21.5.2 JSONP

JSONP是JSON with padding （填充式JSON 或 参数式JSON）的简写。

JSONP由两部分组成：回调函数和数据。

通过查询字符串来制定JSONP服务的回调参数是很常见的。

JSONP通过动态`<script>`元素使用，使用时可以为src属性指定一个跨域URL。这里的`<script>`和`<img>相似都有能力不受限制地从其他域加载资源。

与图像Ping相比，优点在于能够直接访问响应文本，支持双向通信。

存在两点不足：一是JSONP是从其他域中加载代码执行，可能存在一些恶意代码。二是要确JSONP是否失败不容易，虽然H5给`<script>`增加了onerror事件处理程序，但是开目前还没有得到任何浏览器支持。

### 21.5.3 Comet

Comet（称为“服务器推送”）。

有两种方式实现Comet：长轮询和流。

长轮询：页面发送一个到服务器的请求，然后服务器一直保持连接打开，然后服务器一直保持连接打开，知道有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一个过程在页面打开期间一直持续不断。

流：它在页面的整个生存周期内只使用一个HTTP连接。具体就是浏览器向服务器发送一个请求，服务器保持连接打开，然后周期性地向浏览器发送数据。

在Firefox、Safari、Opera和Chrome中，通过侦听readystatechange事件及检测readyState的值是否为3，就可以利用XHR对象实现HTTP流。而当readyState值为4时，就执行finish回调函数。

### 21.5.4 服务器发送事件

SSE（Server-Sent Events，服务器发送事件）是围绕只读Comet交互推出的API。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的MIME类型必须是text/event-stream，而且是浏览器中的JavaScript API能解析格式输出。SSE支持短轮训、长轮询和HTTP流，而且能在断开连接时自动确定何时重新连接。

支持SSE的浏览器有 FireFox 6+、Safari 5+、Opera 11+、Chrome

#### 1.SSE API

要预定新的事件流，首先要创建一个新的EventSource对象，并传进一个入口点。

注意，传入的URL必须与创建对象的页面同源（相同URL模式、域和端口）。EventSource的实例有一个readyState属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭了连接。

另外，有三个事件：

- open：在建立连接时触发
- message：在从服务器接收到新事件时触发
- error：在无法建立连接时触发

服务器发回的数据以字符串形式保存在event.data中。可在onmessage事件处理程序中打印出。

默认情况下，EventSource对象会保持和服务器的活动连接。如果连接断开会重新连接。这意味着SSE适合长轮询和HTTP流。

close()方法可以强制断开连接并不重连。

#### 2.事件流

服务器事件会通过一个持久的HTTP响应发送，这个响应的MIME类型为 text／eventstream。响应的格式时纯文本。

最简单的情况时美俄个数据项都带前缀data，对于多个连续的以 data: 开头的数据行，作为多段数据处理，每个值之间以一个换行符分隔。直邮包含 data： 数据行后面有空行时，才会触发message事件。因此服务器上生成事件流时不能忘了多添加这一行。（隔行的形式）

通过 id: 前缀可以给特定的事件指定一个关联的ID，这个ID位于 data: 行前面货后面皆可。

设置了ID后，EventSource对象会跟踪上一次触发的事件，如果连接断开，会向服务器发送一个包含名为Last-Event-ID的特殊HTTP头部的请求，以便服务器知道下一次该触发哪个事件。这种机制可以保证多个事件流中以正确的顺序收到连接的数据段。

### 21.5.5 Web Sockets

目标是在一个单独的持久连接上提供全双工、双向通信。

在JavaScript中创建了Web Socket后，会有一个HTTP请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为Web Socket协议。

未加密的连接是 ws://；加密的连接是 wss://。

目前支持web scokets的浏览器有Firefox6+、Safari5+、Chrome

#### 1.Web Sockets API

要创建Web Socket，先实例一个对象病传入URL

```javascript
var socket = new WebSocket("ws://www.example.com/server.php");
```

注意：必须给WebSocket构造函数传入绝对的URL，同源策略对Web Sockets不适用。因此可以通过它打开到任何站点的连接。

WebSocket也有一个表示当前状态的readyState属性：

- WebSocket.OPENING(0)：正在建立连接
- WebSocket.OPEN(1)：已经建立连接
- WebSocket.CLOSING(2)：正在关闭连接
- WebSocket.CLOSE(3)：已经关闭连接

WebSocket没有readyStatechange事件，readyState状态始终从0开始。

要关闭连接，调用close()方法。调用close之后，readyState值立即变成2，关闭后变为3

#### 2.发送和接收数据

要向服务器发送数据，使用send()方法

Web Sockets只能发送纯文本数据，对于复杂的数据结构，需要进行序列化。

当服务器往客户端发消息。WebSocket对象就会触发message事件。也是将返回的数据保存在event.data中。

#### 3.其他事件

- open：在成功建立连接时触发
- error：在发生错误时触发，连接不能持续
- close：在连接关闭时触发

WebSocket对象不支持DOM2级事件侦听器。

在三个事件中，只有close事件的event对象有额外信息。这个事件的事件对象有三个额外属性：wasClean、code和reason。其中waseClean是一个bool值，表示连接是否已经明确地关闭；code是服务器返回的数值状态码；而reason是一个字符串，包含服务器发回的消息。

### 21.5.6 SSE与Web Sockets

考虑使用SSE还是Web Sockets：

- 是否有自由度创建和维护Web Sockets服务器
- 到底需不需要双向通信

## 21.6 安全

对于未被授权系统有权访问某个资源的情况。称为CSRF(Cross-Site Request Forgery，跨站点请求伪造)。

为确保通过XHR访问的URL安全，通行的做法就是验证发送请求者是否有权限访问相应的资源，有如下方式：

- 要求以SSL连接来访问可以通过XHR请求的资源
- 要求每一次请求都要附带经过相应算法计算得到的验证码

注意，以下措施对防范CSRF无效：

- 要求发送POST而不是GET请求——很容易改变
- 检查来源URL以确定是否可信——来源记录很容易伪造
- 基于cookie信息进行验证——很容易伪造

> open方法可以带上用户名和密码，这种做法很不安全。

## 21.7 小结

关于Ajax：

- 负责Ajax运作的核心对象是XMKLHttpRequest(XHR)对象
- XHR对象由微软在IE5引入，用于通过JavaScript从服务器获取XML数据
- FIrefox等浏览器都实现相同特性，使XHR称为Web的一个事实标准
- 虽然实现存在差异，XHR对象的基本用法相对规范。

同源策略是对XHR的一个主要约束，它为通信设置“相同的域、相同的端口、相同的协议”这一限制。

解决方案叫做CORS（Cross-Origin Resource Sharing，跨源资源共享），IE8通过XDomainRequest对象支持，其他浏览器通过XHR对象原生支持。图像Ping和JSONP是另外两种跨域通信的技术，但不如CORS稳妥。

Comet是对Ajax的扩展。实现的手段主要有两个：长轮询和HTTP流。所有浏览器都支持长轮询，部分浏览器原生支持HTTP流。SSE（Server-Sent Events，服务器发送事件）是一种实现Comet交互的浏览器API，既支持长轮询又支持HTTP流。

Web Sockets是一种鱼服务器进行全双工、双向通信的信道。



# 第22章 高级技巧

## 22.1 高级函数

### 22.1.1 安全的类型检测

测试某个值是不是原生函数或正则表达式：

```javascript
function isFunction(value){ 
	return Object.prototype.toString.call(value) == "[object Function]"; 
} 
function isRegExp(value){ 
	return Object.prototype.toString.call(value) == "[object RegExp]"; 
}
```

> 请注意，Object.prototpye.toString()本身也可能会被修改。本节讨论的技巧假设Object.prototpye.toString()是未被修改过的原生版本。

### 22.1.2 作用域安全的构造函数

由于this对象是在运行时绑定的，所以直接调用Person()，this会映射到全局对象window上，导致错误对象属性的意外增加。

```javascript
var person = Person("Nicholas", 29, "Software Engineer"); 
alert(window.name); //"Nicholas" 
```

#### 作用域安全的构造函数

作用域安全的构造函数在进行任何更改前，首先确认this对象是正确类型的实例。如果不是，那
么会创建新的实例并返回。

实现这个模式后，你就锁定了可以调用构造函数的环境。如果你使用构造函数窃取模式的继承且不使用原型链，那么这个继承很可能被破坏。

如果构造函数窃取结合使用原型链或者寄生组合则可以解决这个问题。

### 22.1.3 惰性载入函数

惰性载入表示函数执行的分支仅会发生一次。

有两种实现惰性载入的方式，第一种就是在函数被调用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另外一个按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行的分支了。

第二种实现惰性载入的方式是在声明函数时就指定适当的函数。这样，第一次调用函数时就不会损失性能了，而在代码首次加载时会损失一点性能。

### 22.1.4 函数绑定

函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数。

该技巧常常和回调函数与事件处理程序一起使用，以便在将函数作为变量传递的同时保留代码执行环境。

一个简单的bind()函数接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，
并且将所有参数原封不动传递过去。语法如下：

```javascript
function bind(fn, context){ 
  	return function(){ 
  		return fn.apply(context, arguments); 
  	}; 
}
```

注意这里使用的arguments对象是内部函数的，而非bind()的。

ECMAScript 5为所有函数定义了一个原生的bind()方法，进一步简单了操作。换句话说，不用再自己定义bind()函数了，而是可以直接在函数上调用这个方法。原生的bind()方法与前面介绍的自定义bind()方法类似，都是要传入作为this值的对象。支持原生bind()方法的浏览器有IE9+、Firefox 4+和Chrome。

只要是将某个函数指针以值的形式进行传递，同时该函数必须在特定环境中执行，被绑定函数的效用就突显出来了。它们主要用于事件处理程序以及setTimeout() 和setInterval()。然而，被绑定函数与普通函数相比有更多的开销。

### 22.1.5 函数柯里化

函数柯里化（function currying） ，它用于创建已经设置好了一个或多个参数的函数。

函数柯里化的基本方法和函数绑定是一样的：使用一个闭包返回一个函数。两者的区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数。

柯里化函数通常由以下步骤动态创建：调用另一个函数并为它传入要柯里化的函数和必要参数。

创建柯里化函数的通用方式：

```javascript
function curry(fn){ 
    var args = Array.prototype.slice.call(arguments, 1); 
    return function(){ 
        var innerArgs = Array.prototype.slice.call(arguments); 
        var finalArgs = args.concat(innerArgs); 
        return fn.apply(null, finalArgs); 
    }; 
} 
```

函数柯里化还常常作为函数绑定的一部分包含在其中，构造出更为复杂的bind()函数。

ECMAScript 5的bind()方法也实现函数柯里化，只要在this的值之后再传入另一个参数即可。

JavaScript中的柯里化函数和绑定函数提供了强大的动态函数创建功能。使用bind()还是curry()要根据是否需要object对象响应来决定。

## 22.2 防篡改对象

注意：一旦把对象定义为防篡改，就无法撤销了。

### 22.2.1 不可扩展对象

使用Object.preventExtensions()方法，不能再给对象添加属性和方法。虽然不能给对象添加新成员，但已有的成员则丝毫不受影响。仍然还可以修改和删除已有的成员。

使用Object.istExtensible()方法还可以确定对象是否可以扩展。

### 22.2.2 密封的对象

密封对象不可扩展，而且已有成员的[[Configurable]]特性将被设置为false。这就意味着不能删除属性和方法，因为不能使用Object.defineProperty()把数据属性修改为访问器属性，或者相反。属性值是可以修改的。

要密封对象，可以使用Object.seal()方法。

使用Object.isSealed()方法可以确定对象是否被密封了。因为被密封的对象不可扩展，所以用Object.isExtensible()检测密封的对象也会返回false。

### 22.2.3 冻结的对象

最严格的防篡改级别是冻结对象（frozen object）。冻结的对象既不可扩展，又是密封的，而且对象数据属性的[[Writable]]特性会被设置为false。如果定义[[Set]]函数，访问器属性仍然是可写的。

ECMAScript 5定义的Object.freeze()方法可以用来冻结对象。

Object.isFrozen()方法用于检测冻结对象。因为冻结对象既是密封的又是不可扩展的，所以用Object.isExtensible()和Object.isSealed()检测冻结对象将分别返回false和true。

## 22.3 高级定时器

关于定时器要记住的最重要的事情是，指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。

实际上Firefox中定时器的实现还能让你确定定时器过了多久才执行，这需传递一个实际执行的时间与指定的间隔的差值。

### 22.3.1 重复的定时器

当使用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。

这种重复定时器的规则有两个问题：(1) 某些间隔会被跳过；(2) 多个定时器的代码执行之间的间隔可能会比预期的小。

为了避免setInterval()的重复定时器的这2个缺点，你可以用如下模式使用链式setTimeout()调用。这个模式主要用于重复定时器

```javascript
setTimeout(function(){ 
	//处理中
	setTimeout(arguments.callee, interval); 
}, interval); 
```

### 22.3.2 Yielding Processes

运行在浏览器中的JavaScript都被分配了一个确定数量的资源。JavaScript被严格限制了，以防止恶意的Web程序员把用户的计算机搞挂了。其中一个限制是长时间运行脚本的制约，如果代码运行超过特定的时间或者特定语句数量就不让它继续执行。如果代码达到了这个限制，会弹出一个浏览器错误的对话框，定时器是绕开此限制的方法之一。

脚本长时间运行的问题通常是由两个原因之一造成的：过长的、过深嵌套的函数调用或者是进行大量处理的循环。

在展开该循环之前，你需要回答以下两个重要的问题。

- 该处理是否必须同步完成？如果这个数据的处理会造成其他运行的阻塞，那么最好不要改动它。不过，如果你对这个问题的回答确定为“否”，那么将某些处理推迟到以后是个不错的备选项。
- 数据是否必须按顺序完成？通常，数组只是对项目的组合和迭代的一种简便的方法而无所谓顺序。如果项目的顺序不是非常重要，那么可能可以将某些处理推迟到以后。

对于上述两个问题，你的回答都是“否”，可以采用数组分块（array chunking）的技术，小块小块地处理数组，通常每次一小块。基本的思路是为要处理的项目创建一个队列，然后使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。基本的模式如下：

```javascript
setTimeout(function(){ 
    //取出下一个条目并处理
    var item = array.shift(); 
    process(item); 
    //若还有条目，再设置另一个定时器
    if(array.length > 0){ 
    	setTimeout(arguments.callee, 100); 
    } 
}, 100);
```

数组分块的重要性在于它可以将多个项目的处理在执行队列上分开，在每个项目处理之后，给予其他的浏览器处理机会运行，这样就可能避免长时间运行脚本的错误。

> 一旦某个函数需要花50ms以上的时间完成，那么最好看看能否将任务分割为一系列可以使用定时器的小任务。

### 22.3.3 函数节流

函数节流背后的基本思想是指，某些代码不可以在没有间断的情况连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。以下是该模式的基本形式：

```javascript
var processor = { 
    timeoutId: null, 
    
  	//实际进行处理的方法
    performProcessing: function(){ 
    	//实际执行的代码
    }, 
    //初始处理调用的方法
    process: function(){ 
    	clearTimeout(this.timeoutId); 
    	var that = this; 
    	this.timeoutId = setTimeout(function(){ 
    		that.performProcessing(); 
    	}, 100); 
    } 
}; 
//尝试开始执行
processor.process();
```

由于setTimeout()中用到的函数的环境总是window，所以有必要保存this的引用以方便以后使用。

这个模式可以使用throttle()函数来简化，这个函数可以自动进行定时器的设置和清除：

```javascript
function throttle(method, context) { 
    clearTimeout(method.tId); 
    method.tId= setTimeout(function(){ 
    	method.call(context); 
    }, 100); 
}
```

throttle()函数接受两个参数：要执行的函数以及在哪个作用域中执行。

只要代码是周期性执行的，都应该使用节流，但是你不能控制请求执行的速率。

## 22.4 自定义事件

事件是一种叫做观察者的设计模式，这是一种创建松散耦合代码的技术。观察者模式由两类对象组成：主体和观察者。主体负责发布事件，同时观察者通过订阅这些事件来观察该主体。该模式的一个关键概念是主体并不知道观察者的任何事情，也就是说它可以独自存在并正常运作即使观察者不存在。从另一方面来说，观察者知道主体并能注册事件的回调函数（事件处理程序）。涉及DOM上时，DOM元素便是主体，你的事件处理代码便是观察者。

实现此功能的基本模式可以如下定义：

```javascript
function EventTarget(){ 
	this.handlers = {}; 
}

EventTarget.prototype = { 
    constructor: EventTarget, 
    addHandler: function(type, handler){ 
        if (typeof this.handlers[type] == "undefined"){ 
        	this.handlers[type] = []; 
        } 
    	this.handlers[type].push(handler); 
    }, 
    fire: function(event){ 
        if (!event.target){ 
        	event.target = this; 
        } 
        if (this.handlers[event.type] instanceof Array){ 
            var handlers = this.handlers[event.type]; 
            for (var i=0, len=handlers.length; i < len; i++){ 
            	handlers[i](event); 
            } 
    } 
}, 
removeHandler: function(type, handler){ 
    if (this.handlers[type] instanceof Array){ 
        var handlers = this.handlers[type]; 
        for (var i=0, len=handlers.length; i < len; i++){ 
            if (handlers[i] === handler){ 
            	break; 
            } 
    	} 
    	handlers.splice(i, 1);
      	} 
    } 
}; 
```

addHandler()方法接受两个参数：事件类型和用于处理该事件的函数。

如果要触发一个事件，要调用fire()函数。该方法接受一个单独的参数，是一个至少包含type属性的对象。

removeHandler()方法接受两个参数：事件类型和用于处理该事件的函数。

因为这种功能是封装在一种自定义类型中的，其他对象可以继承EventTarget并获得这个行为

## 22.5拖放

“鼠标拖尾”的经典网页技巧。

鼠标拖尾是一个或者多个图片在页面上跟着鼠标指针移动。 单元素鼠标拖尾的基本代码需要为文档设置一个onmousemove事件处理程序，它总是将指定元素移动到鼠标指针的位置

### 22.5.1 修缮拖动功能

上述例子当鼠标开始移动的时候，元素好像是突然跳了一下。理想情况是，这个动作应该看上去好像这个元素是被指针“拾起”的，也就是说当在拖动元素的时候，用户点击的那一点就是指针应该保持的位置

### 22.5.2 添加自定义事件

拖放功能还不能真正应用起来，除非能知道什么时候拖动开始了。

## 22.6小结

- 可以创建作用域安全的构造函数，确保在缺少new操作符时调用构造函数不会改变错误的环境对象。


- 可以使用惰性载入函数，将任何代码分支推迟到第一次调用函数的时候。
- 函数绑定可以让你创建始终在指定环境中运行的函数，同时函数柯里化可以让你创建已经填了某些参数的函数。
- 将绑定和柯里化组合起来，就能够给你一种在任意环境中以任意参数执行任意函数的方法。

ECMAScript 5允许通过以下几种方式来创建防篡改对象。

- 不可扩展的对象，不允许给对象添加新的属性或方法。
- 密封的对象，也是不可扩展的对象，不允许删除已有的属性和方法。
- 冻结的对象，也是密封的对象，不允许重写对象的成员。

JavaScript中可以使用setTimeout()和setInterval()如下创建定时器。

- 定时器代码是放在一个等待区域，直到时间间隔到了之后，此时将代码添加到JavaScript的处理队列中，等待下一次JavaScript进程空闲时被执行。
- 每次一段代码执行结束之后，都会有一小段空闲时间进行其他浏览器处理。
- 这种行为意味着，可以使用定时器将长时间运行的脚本切分为一小块一小块可以在以后运行的代码段。这种做法有助于Web应用对用户交互有更积极的响应。

JavaScript中经常以事件的形式应用观察者模式。使用自定义事件有助于将不同部分的代码相互之间解耦，让维护更加容易，并减少引入错误的机会。

拖放对于桌面和Web应用都是一个非常流行的用户界面范例



# 第23章 离线应用与客户端存储

开发离线Web应用需要几个步骤。首先是确保应用知道设备是否能上网。然后，应用还必须能访问一定的资源（图像、JavaScript、CSS等）。最后，必须有一块本地空间用于保存数据，无论能否上网都不妨碍读写。

## 23.1 离线检测

HTML5定义了一个navigator.onLine属性，这个属性值为true表示设备能上网，值为false表示设备离线。这个属性的关键是浏览器必须知道设备能否访问网络，从而返回正确的值。
实际应用中，navigator.onLine 在不同浏览器间还有些小的差异。

- IE6+和Safari 5+能够正确检测到网络已断开，并将navigator.onLine的值转换为false。
- Firefox 3+和Opera 10.6+支持navigator.onLine属性，但你必须手工选中菜单项“文件 →Web开发人员（设置）→ 脱机工作”才能让浏览器正常工作。

HTML5还定义了两个事件：online和offline。当网络从离线变为在线或者从在线变为离线时，分别触发这两个事件。这两个事件在window对象上触发。

为了检测应用是否离线，在页面加载后，最好先通过navigator.onLine取得初始的状态。然后，就是通过上述两个事件来确定网络连接状态是否变化。当上述事件触发时，navigator.onLine 属性的值也会改变，不过必须要手工轮询这个属性才能检测到网络状态的变化。

支持离线检测的浏览器有IE 6+ （只支持navigator.onLine属性）、Firefox 3、Safari 4、Opera 10.6、Chrome、iOS 3.2版Safari和Android版WebKit。

## 23.2 应用缓存

HTML5的应用缓存（application cache），或者简称为appcache，是专门为开发离线Web应用而设计
的。Appcache就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载和缓存的资源。

要将描述文件与页面关联起来，可以在`<html>`中的manifest属性中指定这个文件的路径。这个文件的MIME类型必须是text/cache-manifest

有相应的JavaScript API让你知道应用缓存都在做什么。这个API的核心是applicationCache对象，这个对象有一个status属性，属性的值是常量，表示应用缓存的如下当前状态。

- 0：无缓存，即没有与页面相关的应用缓存。
- 1：闲置，即应用缓存未得到更新。
- 2：检查中，即正在下载描述文件并检查更新。
- 3：下载中，即应用缓存正在下载描述文件中指定的资源。
- 4：更新完成，即应用缓存已经更新了资源，而且所有资源都已下载完毕，可以通过swapCache()来使用了。
- 5：废弃，即应用缓存的描述文件已经不存在了，因此页面无法再访问应用缓存。

应用缓存还有很多相关的事件，表示其状态的改变：

- checking：在浏览器为应用缓存查找更新时触发。
- error：在检查更新或下载资源期间发生错误时触发。
- noupdate：在检查描述文件发现文件无变化时触发。
- downloading：在开始下载应用缓存资源时触发。
- progress：在文件下载应用缓存的过程中持续不断地触发。
- updateready：在页面新的应用缓存下载完毕且可以通过swapCache()使用时触发。
- cached：在应用缓存完整可用时触发。

一般来讲，这些事件会随着页面加载按上述顺序依次触发。不过，通过调用update()方法也可以手工干预，让应用缓存为检查更新而触发上述事件。

```javascript
applicationCache.update(); 
```

update()一经调用，应用缓存就会去检查描述文件是否更新（触发checking事件），然后就像页面刚刚加载一样，继续执行后续操作。如果触发了cached事件，就说明应用缓存已经准备就绪，不会再发生其他操作了。如果触发了updateready事件，则说明新版本的应用缓存已经可用，而此时需要调用swapCache()来启用新应用缓存。

```javascript
EventUtil.addHandler(applicationCache, "updateready", function(){ 
	applicationCache.swapCache(); 
}); 
```

支持HTML5应用缓存的浏览器有Firefox 3+、Safari 4+、Opera 10.6、Chrome、iOS 3.2+版Safari及Android版WebKit。在Firefox 4及之前版本中调用swapCache()会抛出错误。

## 23.3 数据存储

### 23.3.1 Cookie 

cookie标准要求服务器对任意HTTP请求发送Set-Cookie HTTP头作为响应的一部分，其中包含会话信息。发送回服务器的额外信息可以用于唯一验证客户来自于发送的哪个请求。

#### 1. 限制

cookie在性质上是绑定在特定的域名下的。当设定了一个cookie后，再给创建它的域名发送请求时，都会包含这个cookie。这个限制确保了储存在cookie中的信息只能让批准的接受者访问，而无法被其他域访问。
由于cookie是存在客户端计算机上的，还加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间。每个域的cookie总数是有限的，不过浏览器之间各有不同。

- IE6 以及更低版本限制每个域名最多20个cookie。
- IE7和之后版本每个域名最多50个。IE7最初是支持每个域名最大20个cookie，之后被微软的一个补丁所更新。
- Firefox限制每个域最多50个cookie。
- Opera限制每个域最多30个cookie。
- Safari和Chrome对于每个域的cookie数量限制没有硬性规定。

当超过单个域名限制之后还要再设置cookie，浏览器就会清除以前设置的cookie。IE和Opera会删除最近最少使用过的（LRU，Least Recently Used）cookie，腾出空间给新设置的cookie。Firefox看上去好像是随机决定要清除哪个cookie，所以考虑cookie限制非常重要，以免出现不可预期的后果。

浏览器中对于cookie的尺寸也有限制。大多数浏览器都有大约4096B（加减1）的长度限制。

#### 2. cookie的构成

cookie由浏览器保存的以下几块信息构成。

- 名称：一个唯一确定cookie的名称。cookie名称不区分大小写。实践中最好将cookie名称看作是区分大小写的，因为某些服务器会这样处理cookie。cookie的名称必须是经过URL编码的。
- 值：储存在cookie中的字符串值。值必须被URL编码。
- 域：cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域，也可以不包含它。如果没有明确设定，那么这个域会被认作来自设置cookie的那个域。
- 路径：对于指定域中的那个路径，应该向服务器发送cookie。
- 失效时间：表示cookie何时应该被删除的时间戳（也就是，何时应该停止向服务器发送这个cookie）。默认情况下，浏览器会话结束时即将所有cookie删除；不过也可以自己设置删除时间。这个值是个GMT格式的日期（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定应该删除cookie的准确时间。如果设置的失效日期是个以前的时间，则cookie会被立刻删除。
- 安全标志：指定后，cookie只有在使用SSL连接的时候才发送到服务器。例如，cookie信息只能发送给 https://www.wrox.com，而http://www.wrox.com的请求则不能发送cookie。

每一段信息都作为 Set-Cookie 头的一部分，使用分号加空格分隔每一段。

secure标志是cookie中唯一一个非名值对儿的部分，直接包含一个secure单词。

尤其要注意，域、路径、失效时间和secure标志都是服务器给浏览器的指示，以指定何时应该发送cookie。这些参数并不会作为发送到服务器的cookie信息的一部分，只有名值对儿才会被发送。

#### 3. JavaScript中的cookie 

BOM的document. cookie属性。这个属性的独特之处在于它会因为使用它的方式不同而表现出不同的行为：

当用来获取属性值时，document.cookie返回当前页面可用的（根据cookie的域、路径、失效时间和安全设置）所有cookie的字符串，一系列由分号隔开的名值对儿。所有名字和值都是经过URL编码的，所以必须使用decodeURIComponent()来解码。

当用于设置值的时候，document.cookie属性可以设置为一个新的cookie字符串。这个cookie字符串会被解释并添加到现有的cookie集合中。设置document.cookie并不会覆盖cookie，除非设置的cookie的名称已经存在。设置cookie的格式和Set-Cookie头中使用的格式一样。

基本的cookie操作有三种：读取、写入和删除。它们在CookieUtil对象中如下表示:
CookieUtil.get()方法根据cookie的名字获取相应的值。该值使用decodeURIComponent()进行解码并最后返回。如果没有发现cookie，则返回null。

CookieUtil.set()方法在页面上设置一个cookie，接收如下几个参数：cookie的名称，cookie的值，可选的用于指定cookie何时应被删除的Date对象，cookie的可选的URL路径，可选的域，以及可选的表示是否要添加secure标志的布尔值。参数是按照它们的使用频率排列的，只有头两个是必需的。在这个方法中，名称和值都使用encodeURIComponent()进行了URL编码，并检查其他选项。如果expires参数是Date对象，那么会使用Date对象的toGMTString()方法正确格式化Date对象，并添加到expires选项上。方法的其他部分就是构造cookie字符串并将其设置到document.cookie中。

CookieUtil.unset()方法可以删除cookie。它接收4个参数：要删除的cookie的名称、可选的路径参数、可选的域参数和可选的安全参数。这些参数加上空字符串并设置失效时间为1970年1月1日（初始化为0ms的Date对象的值），传给CookieUtil.set。这样就能确保删除cookie。

#### 4. 子cookie 

为了绕开浏览器的单域名下的cookie数限制，使用了一种称为子cookie（subcookie）的概念。

子cookie是存放在单个cookie中的更小段的数据。也就是使用cookie值来存储多个名称值对儿。子cookie最常见的的格式如下所示。

```
name=name1=value1&name2=value2&name3=value3&name4=value4&name5=value5 
```

子cookie一般也以查询字符串的格式进行格式化。

获取子cookie的方法有两个：get()和getAll()。其中get()获取单个子cookie的值，getAll()获取所有子cookie并将它们放入一个对象中返回。get(方法接收两个参数：cookie的名字和子cookie的名字。

SubCookieUtil.getAll()方法和CookieUtil.get()在解析cookie值的方式上非常相似。区别在于cookie的值并非立即解码，而是先根据&字符将子cookie分割出来放在一个数组中，每一个子cookie再根据等于号分割，这样在parts数组中的前一部分便是子cookie名，后一部分则是子cookie的值。

这两个项目都要使用decodeURIComponent()来解码，然后放入result对象中，最后作为方法的返回值。如果cookie不存在，则返回null。

要设置子cookie，也有两种方法：set()和setAll()。
这里的set()方法接收7个参数：cookie名称、子cookie名称、子cookie值、可选的cookie失效日期或时间的Date对象、可选的cookie路径、可选的cookie域和可选的布尔secure标志。所有的可选参数都是作用于cookie本身而非子cookie。为了在同一个cookie中存储多个子cookie，路径、域和secure标志必须一致；针对整个cookie的失效日期则可以在任何一个单独的子cookie写入的时候同时设置。在这个方法中，第一步是获取指定cookie名称对应的所有子cookie。逻辑或操作符“||”用于当getAll()返回null时将subcookies设置为一个新对象。然后，在subcookies对象上设置好子cookie值并传给setAll()。

setAll()方法接收6个参数：cookie名称、包含所有子cookie的对象以及和set()中一样的4个可选参数。这个方法使用for-in循环遍历第二个参数中的属性。

普通cookie可以通过将失效时间设置为过去的时间的方法来删除，但是子cookie不能这样做。为了删除一个子cookie，首先必须获取包含在某个cookie中的所有子cookie，然后仅删除需要删除的那个cookie，然后再将余下的子cookie的值保存为cookie的值。

unset()方法用于删除某个cookie中的单个子cookie而不影响其他的；而unsetAll()方法则等同于CookieUtil.unset()，用于删除整个cookie。

#### 5. 关于cookie的思考

还有一类cookie被称为“HTTP专有cookie”。HTTP专有cookie可以从浏览器或者服务器设置，但是只能从服务器端读取，因为JavaScript无法获取HTTP专有cookie的值。

在cookie中存储大量信息会影响到特定域的请求性能，最好还是尽可能在cookie中少存储信息，以避免影响性能。

一定不要在cookie中存储重要和敏感的数据。

### 23.3.2 IE用户数据

在IE5.0中，微软通过一个自定义行为引入了持久化用户数据的概念。用户数据允许每个文档最多128KB数据，每个域名最多1MB数据。要使用持久化用户数据，首先必须如下所示，使用CSS在某个元素上指定userData行为：

```html
<div style="behavior:url(#default#userData)" id="dataStore"></div>
```

一旦该元素使用了userData行为，那么就可以使用setAttribute()方法在上面保存数据了。

为了将数据提交到浏览器缓存中，还必须调用save()方法并告诉它要保存到的数据空间的名字。数据空间名字可以完全任意，仅用于区分不同的数据集。

下一次页面载入之后，可以使用load()方法指定同样的数据空间名称来获取数据。只有到载入确切完成之后数据方能使用。如果getAttribute()调用了不存在的名称或者是尚未载入的名程，则返回null。

removeAttribute()方法明确指定要删除某元素数据，只要指定属性名称。删除之后，必须调用save()来提交更改。

对IE用户数据的访问限制和对cookie的限制类似。要访问某个数据空间，脚本运行的页面必须来自同一个域名，在同一个路径下，并使用与进行存储的脚本同样的协议。和cookie不同的是，你无法将用户数据访问限制扩展到更多的客户。还有一点不同，用户数据默认是可以跨越会话持久存在的，同时也不会过期；数据需要通过removeAttribute()方法专门进行删除以释放空间。和cookie一样，IE用户数据并非安全的，所以不能存放敏感信息。

### 23.3.3 Web存储机制

Web Storage的目的是克服由cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。

Web Storage的两个主要目标是：

- 提供一种在cookie之外存储会话数据的途径；
- 提供一种存储大量可以跨会话存在的数据的机制。

最初的Web Storage规范包含了两种对象的定义：sessionStorage和globalStorage。这两个对象在支持的浏览器中都是以windows对象属性的形式存在的，支持这两个属性的浏览器包括IE8+、Firefox 3.5+、Chrome 4+和Opera 10.5+。

#### 1. Storage类型

Storage类型提供最大的存储空间（因浏览器而异）来存储名值对儿。

Storage的实例有如下方法。

- clear()： 删除所有值；Firefox中没有实现 。
- getItem(name)：根据指定的名字name获取对应的值。
- key(index)：获得index位置处的值的名字。
- removeItem(name)：删除由name指定的名值对儿。
- setItem(name, value)：为指定的name设置一个对应的值。

getItem()、removeItem()和setItem()方法可以直接调用，也可通过Storage对象间接调用。可以通过点语法或者方括号语法访问属性来读取值，建议使用方法而不是属性来访问数据，以免某个键会意外重写该对象上已经存在的成员。

可以使用length属性来判断有多少名值对儿存放在Storage对象中。但无法判断对象中所有数据的大小，不过IE8提供了一个remainingSpace属性，用于获取还可以使用的存储空间的字节数。

Storage类型只能存储字符串。非字符串的数据在存储之前会被转换成字符串。

#### 2. sessionStorage对象

sessionStorage对象存储特定于某个会话的数据，也就是该数据只保持到浏览器关闭。存储在sessionStorage中的数据可以跨越页面刷新而存在，同时如果浏览器支持，浏览器崩溃并重启之后依然可用（Firefox和WebKit都支持，IE则不行）。

因为seesionStorage对象绑定于某个服务器会话，所以当文件在本地运行的时候是不可用的。存储在sessionStorage中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。

可以使用setItem()或者直接设置新的属性来存储数据。

不同浏览器写入数据方面略有不同。Firefox和WebKit实现了同步写入，所以添加到存储空间中的数据是立刻被提交的。而IE 的实现则是异步写入数据，所以在设置数据和将数据实际写入磁盘之间可能有一些延迟。

在IE8中可以强制把数据写入磁盘：在设置新数据之前使用begin()方法，并且在所有设置完成之后调用commit()方法。调用begin()是为了确保在这段代码执行的时候不会发生其他磁盘写入操作。

sessionStorage中有数据时，可以使用getItem()或者通过直接访问属性名来获取数据。

可以通过结合length属性和key()方法来迭代sessionStorage中的值。它是这样遍历sessionStorage中的名值对儿的：首先通过key()方法获取指定位置上的名字，然后再通过getItem()找出对应该名字的值。

还可以使用for-in循环来迭代sessionStorage中的值。此时不会返回任何内置方法或length属性。

要从sessionStorage 中删除数据，可以使用delete 操作符删除对象属性，也可调用removeItem()方法。

在撰写本书时，delete操作符在WebKit中无法删除数据，removeItem()则可以在各种支持的浏览器中正确运行。

sessionStorage对象应该主要用于仅针对会话的小段数据的存储。如果需要跨越会话存储数据，那么globalStorage或者localStorage更为合适。

#### 3. globalStorage对象

globalStorage对象对象的目的是跨越会话存储数据，但有特定的访问限制。要使用globalStorage，首先要指定哪些域可以访问该数据。可以通过方括号标记使用属性来实现

当使用globalStorage的时候一定要指定一个域名。对globalStorage空间的访问，是依据发起请求的页面的域名、协议和端口来限制的。\

如果你事先不能确定域名，那么使用location.host作为属性名比较安全。

如果不使用removeItem()或者delete 删除，或者用户未清除浏览器缓存，存储在globalStorage属性中的数据会一直保留在磁盘上。这让globalStorage非常适合在客户端存储文档或者长期保存用户偏好设置。

#### 4. localStorage对象

localStorage 对象在修订过的HTML 5规范中作为持久保存客户端数据的方案取代了globalStorage。与globalStorage不同，localStorage规则事先就设定好了。

要访问同一个localStorage对象，页面必须来自同一个域名（子域名无效），使用同一种协议，在同一个端口上。这相当于globalStorage[location.host]。

localStorage是Storage的实例。

存储在localStorage中的数据和存储在globalStorage中的数据一样，都遵循相同的规则：数据保留到通过JavaScript删除或者是用户清除浏览器缓存。

#### 5. storage事件

对Storage对象进行任何修改，都会在文档上触发storage事件。当通过属性或setItem()方法保存数据，使用delete操作符或removeItem()删除数据，或者调用clear()方法时，都会发生该事件。这个事件的event对象有以下属性。

- domain：发生变化的存储空间的域名。
- key：设置或者删除的键名。
- newValue：如果是设置值，则是新值；如果是删除键，则是null。
- oldValue：键被更改之前的值。

在这四个属性中，IE8 和Firefox只实现了domain属性。在撰写本书的时候，WebKit尚不支持storage事件

无论对sessionStorage、globalStorage还是localStorage进行操作，都会触发storage事件，但不作区分。

#### 6. 限制

Web Storage限制因浏览器而异。

一般来说，对存储空间大小的限制都是以每个来源（协议、域和端口）为单位的。换句话说，每个来源都有固定大小的空间用于保存自己的数据。

对sessionStorage的限制也是因浏览器而异。

### 23.3.4 IndexedDB 

Indexed Database API，或者简称为IndexedDB，是在浏览器中保存结构化数据的一种数据库。

IndexedDB是为了替代目前已被废弃的Web SQL Database API而出现的。IndexedDB的思想是创建一套API，方便保存和读取JavaScript对象，同时还支持查询及搜索。

IndexedDB设计的操作完全是异步进行的。差不多每一次IndexedDB操作，都需要注册onerror或onsuccess事件处理程序，以确保适当地处理结果。

在得到完整支持的情况下，IndexedDB将是一个作为API宿主的全局对象。由于API仍然可能有
变化，浏览器也都使用提供商前缀。

```javascript
var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB || 
window.webkitIndexedDB; 
```

#### 1. 数据库

IndexedDB最大的特色是使用对象保存数据，而不是使用表来保存数据。

使用IndexedDB的第一步是打开它，即把要打开的数据库名传给indexDB.open()。如果传入的数据库已经存在，就会发送一个打开它的请求；如果传入的数据库还不存在，就会发送一个创建并打开它的请求。总之，调用indexDB.open()会返回一个IDBRequest对象，在这个对象上可以添加onerror和onsuccess事件处理程序。在这两个事件处理程序中，event.target都指向request对象，因此它们可以互换使用。如果响应的是onsuccess事件处理程序，那么event.target.result中将有一个数据库实例对象（IDBDatabase），这个对象会保存在database变量中。如果发生了错误，那event.target.errorCode中将保存一个错误码，表示问题的性质。以下就是可能的错误码（这个错误码适合所有操作）。

- IDBDatabaseException.UNKNOWN_ERR(1)：意外错误，无法归类。
- IDBDatabaseException.NON_TRANSIENT_ERR(2)：操作不合法。
- IDBDatabaseException.NOT_FOUND_ERR(3)：未发现要操作的数据库。
- IDBDatabaseException.CONSTRAINT_ERR(4)：违反了数据库约束。
- IDBDatabaseException.DATA_ERR(5)：提供给事务的数据不能满足要求。
- IDBDatabaseException.NOT_ALLOWED_ERR(6)：操作不合法。
- IDBDatabaseException.TRANSACTION_INACTIVE_ERR(7)：试图重用已完成的事务。
- IDBDatabaseException.ABORT_ERR(8)：请求中断，未成功。
- IDBDatabaseException.READ_ONLY_ERR(9)：试图在只读模式下写入或修改数据。
- IDBDatabaseException.TIMEOUT_ERR(10)：在有效时间内未完成操作。
- IDBDatabaseException.QUOTA_ERR(11)：磁盘空间不足。

默认情况下，IndexedDB数据库是没有版本号的，最好一开始就为数据库指定一个版本号。为此，可以调用setVersion()方法，传入以字符串形式表示的版本号。同样，调用这个方法也会返回一个请求对象，需要你再指定事件处理程序。

#### 2. 对象存储空间

```javascript
var user = { 
  username: "007", 
  firstName: "James", 
  lastName: "Bond", 
  password: "foo" 
}; 

var store = db.createObjectStore("users", { keyPath: "username" }); 
```

keyPath属性，就是空间中将要保存的对象的一个属性，而这个属性将作为存储空间的键来使用。

接下来可以使用add()或put()方法来向其中添加数据。这两个方法都接收一个参数，即要保存的对象，然后这个对象就会被保存到存储空间中。这两个方法的区别在空间中已经包含键值相同的对象时会体现出来。在这种情况下，add()会返回错误，而put()则会重写原有对象。

每次调用add()或put()都会创建一个新的针对这个对象存储空间的更新请求。如果想验证请求是否成功完成，可以把返回的请求对象保存在一个变量中，然后再指定onerror或onsuccess事件处理程序。

#### 3. 事务

在数据库对象上调用transaction()方法可以创建事务。任何时候，只要想读取或修改数据，都要通过事务来组织所有操作。

如果没有参数，就只能通过事务来读取数据库中保存的对象。最常见的方式是传入要访问的一或多个对象存储空间。如果要访问多个对象存储空间，也可以在第一个参数的位置上传入字符串数组。

```javascript
var transaction = db.transaction(["users", "anotherStore"]); 
```

这些事务都是以只读方式访问数据。要修改访问方式，必须在创建事务时传入第二个参数，这个参数表示访问模式，用IDBTransaction接口定义的如下常量表示：READ_ONLY（0）表示只读，READ_WRITE（1）表示读写，VERSION_CHANGE（2）表示改变。IE10+和Firefox 4+实现的是
IDBTransaction，但在Chrome中则叫webkitIDBTransaction：

```javascript
var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction; 
var transaction = db.transaction("users", IDBTransaction.READ_WRITE); 
```

取得了事务的索引后，使用objectStore()方法并传入存储空间的名称，就可以访问特定的存储空间。然后，可以像以前一样使用add()和put()方法，使用get()可以取得值，使用delete()可以删除对象，而使用clear()则可以删除所有对象。get()和delete()方法都接收一个对象键作为参数，而所有这5个方法都会返回一个新的请求对象。

注意，通过oncomplete事件的事件对象（event）访问不到get()请求返回的任何数据。必须在相应请求的onsuccess事件处理程序中才能访问到数据。

#### 4. 使用游标查询

使用事务可以直接通过已知的键检索单个对象。而在需要检索多个对象的情况下，则需要在事务内部创建游标。游标就是一指向结果集的指针。与传统数据库查询不同，游标并不提前收集结果。游标指针会先指向结果中的第一项，在接到查找下一项的指令时，才会指向下一项。

在对象存储空间上调用openCursor()方法可以创建游标。与IndexedDB 中的其他操作一样，openCursor()方法返回的是一个请求对象，因此必须为该对象指定onsuccess和onerror事件处理程序。

在onsuccess事件处理程序执行时，可以通过event.target.result取得存储空间中的下一个对象。在结果集中有下一项时，这个属性中保存一个IDBCursor的实例，在没有下一项时，这个属性的值为null。IDBCursor的实例有以下几个属性。

- direction：数值，表示游标移动的方向。默认值为IDBCursor.NEXT（0），表示下一项。IDBCursor.NEXT_NO_DUPLICATE（1）表示下一个不重复的项，DBCursor.PREV（2）表示前一项，而IDBCursor.PREV_NO_DUPLICATE表示前一个不重复的项。
- key：对象的键。
- value：实际的对象。
- primaryKey：游标使用的键。可能是对象键，也可能是索引键。

使用游标可以更新个别的记录。调用update()方法可以用指定的对象更新当前游标的value。与其他操作一样，调用update()方法也会创建一个新请求

此时，如果调用delete()方法，就会删除相应的记录。调用delete()也返回一个请求。

如果当前事务没有修改对象存储空间的权限，update()和delete()会抛出错误。

默认情况下，每个游标只发起一次请求。要想发起另一次请求，必须调用下面的一个方法。

- continue(key)：移动到结果集中的下一项。参数key是可选的，不指定这个参数，游标移动到下一项；指定这个参数，游标会移动到指定键的位置。
- advance(count)：向前移动count指定的项数。

#### 5. 键范围

键范围（key range）为使用游标增添了一些灵活性。键范围由IDBKeyRange的实例表示。支持标准IDBKeyRange类型的浏览器有IE10+和Firefox 4+，Chrome中的名字叫webkitIDBKeyRange。

```javascript
var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange; 
```

有四种定义键范围的方式。

第一种是使用only()方法，传入你想要取得的对象的键。

第二种lowerBound定义键范围的方式是指定结果集的下界。下界表示游标开始的位置。如果你想忽略当前键的对象，从它的下一个对象开始，那么可以传入第二个参数true

第三种定义键范围的方式是指定结果集的上界，也就是指定游标不能超越哪个键。指定上界使用
upperRange()方法。如果你不想包含键为指定值的对象，同样，传入第二个参数true

第四种定义键范围的方式是同时指定上、下界，使用bound()方法。这个方法可以接收4个参数：表示下界的键、表示上界的键、可选的表示是否跳过下界的布尔值和可选的表示是否跳过上界的布尔值。

#### 6. 设定游标方向

openCursor()可以接收两个参数。第一个参数就是IDBKeyRange的实例，第二个是表示方向的数值常量。作为第二个参数的常量是IDBCursor中的常量。

正常情况下，游标都是从存储空间的第一项开始，调用continue()或advance()前进到最后一项。游标的默认方向值是IDBCursor.NEXT。

如果对象存储空间中有重复的项，可传入IDBCursor.NEXT_NO_DUPLICATE作为第二个参数

可以创建一个游标，让它在对象存储空间中向后移动，即从最后一个对象开始，逐个迭代，直至第一个对象。此时，要传入的常量是IDBCursor.PREV和IDBCursor.PREV_NO_DUPLICATE。

使用IDBCursor.PREV或IDBCursor.PREV_NO_DUPLICATE打开游标时，每次调用continue()或advance()，都会在存储空间中向后而不是向前移动游标。

#### 7.  索引

对于某些数据，可能需要为一个对象存储空间指定多个键。

要创建索引，首先引用对象存储空间，然后调用createIndex()方法：
createIndex()的第一个参数是索引的名字，第二个参数是索引的属性的名字，第三个参数是一个包含unique属性的选项（options）对象。这个选项通常都必须指定，因为它表示键在所有记录中是否唯一。

createIndex()的返回值是IDBIndex的实例。在对象存储空间上调用index()方法也能返回同一个实例。

索引其实与对象存储空间很相似。在索引上调用openCursor()方法也可以创建新的游标，除了将来会把索引键而非主键保存在event.result.key 属性中之外，这个游标与在对象存储空间上调用openCursor()返回的游标完全一样。

在索引上也能创建一个特殊的只返回每条记录主键的游标，那就要调用openKeyCursor()方法。这个方法接收的参数与openCursor()相同。而最大的不同在于，这种情况下event.result.key中仍然保存着索引键，而event.result.value中保存的则是主键，而不再是整个对象。

使用get()方法能够从索引中取得一个对象，只要传入相应的索引键；这个方法也将返回一个请求。

要根据给定的索引键取得主键，可以使用getKey()方法。这个方法也会创建一个新的请求，但event.result.value等于主键的值，而不是包含整个对象。

任何时候，通过IDBIndex对象的下列属性都可以取得有关索引的相关信息。

- name：索引的名字。
- keyPath：传入createIndex()中的属性路径。
- objectStore：索引的对象存储空间。
- unique：表示索引键是否唯一的布尔值。

另外，通过对象存储对象的indexName属性可以访问到为该空间建立的所有索引。

在对象存储空间上调用deleteIndex()方法并传入索引的名字可以删除索引。因为删除索引不会影响对象存储空间中的数据，所以这个操作没有任何回调函数。

#### 8. 并发问题

如果浏览器的两个不同的标签页打开了同一个页面，那么一个页面试图更新另一个页面尚未准备就绪的数据库的问题就有可能发生。

因此，只有当浏览器中仅有一个标签页使用数据库的情况下，调用setVersion()才能完成操作。刚打开数据库时，要记着指定onversionchange事件处理程序。当同一个来源的另一个标签页调用setVersion()时，就会执行这个回调函数。处理这个事件的最佳方式是立即关闭数据库，从而保证版本更新顺利完成。

调用setVersion()时，指定请求的onblocked事件处理程序也很重要。在想要更新数据库的版本但另一个标签页已经打开数据库的情况下，就会触发这个事件处理程序。此时，最好先通知用户关闭其他标签页，然后再重新调用setVersion()。

#### 9. 限制

首先，IndexedDB数据库只能由同源（相同协议、域名和端口）页面操作，因此不能跨域共享信息。

其次，每个来源的数据库占用的磁盘空间也有限制。

Firefox还有另外一个限制，即不允许本地文件访问IndexedDB。Chrome没有这个限制。

## 23.4 小结

#### Cookie

- 在JavaScript中通过document.cookie可以访问cookie。
- cookie的限制使其可以存储少量数据，然而对于大量数据效率很低。

#### 用户数据

- 一旦应用后，该元素便可以从一个命名数据空间中载入数据，然后可以通过getAttribute()、setAttribute()和removeAttribute()方法访问。
- 数据必须明确使用save()方法保存到命名数据空间中，以便能在会话之间持久化数据。

#### Web Storage

定义了两种用于存储数据的对象：sessionStorage和localStorage。前者严格用于在一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除；后者用于跨会话持久化数据并遵循跨域安全策略。

#### IndexedDB

一种类似SQL数据库的结构化数据存储机制。但它的数据不是保存在表中，而是保存在对象存储空中。创建对象存储空间时，需要定义一个键，然后就可以添加数据。可以使用游标在对象存储空间中查询特定的对象。而索引则是为了提高查询速度而基于特定的属性创建的。



# 第24章 最佳实践

## 24.1 可维护性

### 24.1.1 什么是可维护的代码

可维护的代码遵循以下特点。

- 可理解性——其他人可以接手代码并理解它的意图和一般途径，而无需原开发人员的完整解释。
- 直观性——代码中的东西一看就能明白，不管其操作过程多么复杂。
- 可适应性——代码以一种数据上的变化不要求完全重写的方法撰写。
- 可扩展性——在代码架构上已考虑到在未来允许对核心功能进行扩展。
- 可调试性——当有地方出错时，代码可以给予你足够的信息来尽可能直接地确定问题所在。

### 24.1.2 代码约定

#### 1. 可读性

可读性的大部分内容都是和代码的缩进相关的。

可读性的另一方面是注释。一般而言，有如下一些地方需要进行注释。

- 函数和方法——每个函数或方法都应该包含一个注释，描述其目的和用于完成任务所可能使用的算法。陈述事先的假设也非常重要，如参数代表什么，函数是否有返回值。
- 大段代码——用于完成单个任务的多行代码应该在前面放一个描述任务的注释。
- 复杂的算法——如果使用了一种独特的方式解决某个问题，则要在注释中解释你是如何做的。
- Hack——因为存在浏览器差异，JavaScript代码一般会包含一些hack。不要假设其他人在看代码的时候能够理解hack所要应付的浏览器问题。如果因为某种浏览器无法使用普通的方法，所以你需要用一些不同的方法，那么请将这些信息放在注释中。

#### 2. 变量和函数命名

命名的一般规则如下所示。

- 变量名应为名词如car或person。
- 函数名应该以动词开始，如getName()。返回布尔类型值的函数一般以is 开头，如isEnable()。
- 变量和函数都应使用合乎逻辑的名字，不要担心长度。长度问题可以通过后处理和压缩来缓解。

#### 3. 变量类型透明

有三种表示变量数据类型的方式。

第一种方式是初始化。当定义了一个变量后，它应该被初始化为一个值，来暗示它将来应该如何应用。缺点是它无法用于函数声明中的函数参数。

第二种方法是使用匈牙利标记法来指定变量类型。匈牙利标记法在变量名之前加上一个或多个字符来表示数据类型。这个标记法在脚本语言中很流行，曾经很长时间也是JavaScript 所推崇的方式。JavaScript 中最传统的匈牙利标记法是用单个字符表示基本类型："o"代表对象，"s"代表字符串，"i"代表整数，"f"代表浮点数，"b"代表布尔型。它的缺点是让代码某种程度上难以阅读，阻碍了没有用它时代码的直观性和句子式的特质。

最后一种指定变量类型的方式是使用类型注释。类型注释放在变量名右边，但是在初始化前面。这种方式是在变量旁边放一段指定类型的注释类型注释的缺点是你不能用多行注释一次注释大块的代码，因为类型注释也是多行注释，两者会冲突。

### 24.1.3 松散耦合

只要应用的某个部分过分依赖于另一部分，代码就是耦合过紧，难于维护。

#### 1. 解耦HTML/JavaScript

一种最常见的耦合类型是HTML/JavaScript耦合。直接写在HTML中的JavaScript，使用包含内联代码的`<script>`元素或者是使用HTML属性来分配事件处理程序，都是过于紧密的耦合。也应该避免在JavaScript中创建大量HTML。

HTML呈现应该尽可能与JavaScript保持分离。当JavaScript用于插入数据时，尽量不要直接插入标记。一般可以在页面中直接包含并隐藏标记，然后等到整个页面渲染好之后，就可以用JavaScript显示该标记，而非生成它。

另一种方法是进行Ajax请求并获取更多要显示的HTML，这个方法可以让同样的渲染层（PHP、JSP、Ruby等等）来输出标记，而不是直接嵌在JavaScript中。

难度：更改行为只需要在JavaScript文件中进行，而更改标记则只要在渲染文件中。

#### 2. 解耦CSS/JavaScript

另一个Web层则是CSS，它主要负责页面的显示。

通过只修改某个元素的CSS类，就可以让大部分样式信息严格保留在CSS中。JavaScript可以更改样式类，但并不会直接影响到元素的样式。只要应用了正确的类，那么任何显示问题都可以直接追溯到CSS而非JavaScript。

第二类紧密耦合仅会在IE中出现（但运行于标准模式下的IE8不会出现），它可以在CSS中通过表达式嵌入JavaScript

#### 3. 解耦应用逻辑／事件处理程序

较好的方法是将应用逻辑和事件处理程序相分离，这样两者分别处理各自的东西。一个事件处理程序应该从事件对象中提取相关信息，并将这些信息传送到处理应用逻辑的某个方法中。

从事件处理程序中分离应用逻辑有几个好处。首先，可以让你更容易更改触发特定过程的事件。如果最开始由鼠标点击事件触发过程，但现在按键也要进行同样处理，这种更改就很容易。

其次，可以在不附加到事件的情况下测试代码，使其更易创建单元测试或者是自动化应用流程。

应用和业务逻辑之间松散耦合的几条原则：

- 勿将event对象传给其他方法；只传来自event对象中所需的数据；
- 任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行；
- 任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑。

### 24.1.4 编程实践

#### 1. 尊重对象所有权

尊重对象所有权，它的意思是你不能修改不属于你的对象。简单地说，如果你不负责创建或维护某个对象、它的对象或者它的方法，那么你就不能对它们进行修改。更具体地说：

- 不要为实例或原型添加属性；
- 不要为实例或原型添加方法；
- 不要重定义已存在的方法。

可以通过以下方式为对象创建新的功能：

- 创建包含所需功能的新对象，并用它与相关对象进行交互；
- 创建自定义类型，继承需要进行修改的类型。然后可以为自定义类型添加额外功能。

#### 2. 避免全局量

尽可能避免全局变量和函数。最多创建一个全局变量，让其他对象和函数存在其中。

单一的全局量的延伸便是命名空间的概念，由YUI（Yahoo! User Interface）库普及。命名空间包括
创建一个用于放置功能的对象。在YUI的2.x版本中，有若干用于追加功能的命名空间。比如：

- YAHOO.util.Dom —— 处理DOM的方法；
- YAHOO.util.Event —— 与事件交互的方法；
- YAHOO.lang —— 用于底层语言特性的方法。

对于YUI，单一的全局对象YAHOO作为一个容器，其中定义了其他对象。用这种方式将功能组合在一起的对象，叫做命名空间。整个YUI库便是构建在这个概念上的，让它能够在同一个页面上与其他的JavaScript库共存。

#### 3. 避免与null进行比较

现实中，与null比较很少适合情况而被使用。必须按照所期望的对值进行检查，而非按照不被期望的那些。

如果看到了与null比较的代码，尝试使用以下技术替换：

- 如果值应为一个引用类型，使用instanceof操作符检查其构造函数；
- 如果值应为一个基本类型，使用typeof检查其类型；
- 如果是希望对象包含某个特定的方法名，则使用typeof操作符确保指定名字的方法存在于对象上。

代码中的null比较越少，就越容易确定代码的目的，并消除不必要的错误。

#### 4. 使用常量

可以通过将数据抽取出来变成单独定义的常量的方式，将应用逻辑与数据修改隔离开来。

关键在于将数据和使用它的逻辑进行分离。要注意的值的类型如下所示。

- 重复值——任何在多处用到的值都应抽取为一个常量。这就限制了当一个值变了而另一个没变的时候会造成的错误。这也包含了CSS类名。
- 用户界面字符串 —— 任何用于显示给用户的字符串，都应被抽取出来以方便国际化。
- URLs —— 在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL。
- 任意可能会更改的值 —— 每当你在用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化。如果答案是“是”，那么这个值就应该被提取出来作为一个常量。

## 24.2 性能

JavaScript最初是一个解释型语言，执行速度要比编译型语言慢得多。主流浏览器陆续实现了JavaScript的编译执行。

### 24.2.1 注意作用域

#### 1. 避免全局查找

可能优化脚本性能最重要的就是注意全局查找。使用全局变量和函数肯定要比局部的开销更大，因为要涉及作用域链上的查找。

将在一个函数中会用到多次的全局对象存储为局部变量总是没错的。

#### 2. 避免with语句

with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度。

必须使用with语句的情况很少，因为它主要用于消除额外的字符。在大多数情况下，可以用局部变量完成相同的事情而不引入新的作用域。

### 24.2.2 选择正确方法

#### 1. 避免不必要的属性查找

使用变量和数组要比访问对象上的属性更有效率，后者是一个O(n)操作。对象上的任何属性查找都要比访问变量或者数组花费更长时间，因为必须在原型链中对拥有该名称的属性进行一次搜索。简而言之，属性查找越多，执行时间就越长。

注意获取单个值的多重属性查找。一旦多次用到对象属性，应该将其存储在局部变量中。第一次访问该值会是O(n)，然而后续的访问都会是O(1)，就会节省很多。

一般来讲，只要能减少算法的复杂度，就要尽可能减少。尽可能多地使用局部变量将属性查找替换为值查找。进一步讲，如果即可以用数字化的数组位置进行访问，也可以使用命名属性，那么使用数字置。

#### 2. 优化循环

一个循环的基本优化步骤：

- 减值迭代——大多数循环使用一个从0开始、增加到某个特定值的迭代器。在很多情况下，从最大值开始，在循环中不断减值的迭代器更加高效。
- 简化终止条件——由于每次循环过程都会计算终止条件，所以必须保证它尽可能快。也就是说避免属性查找或其他O(n)的操作。
- 简化循环体——循环体是执行最多的，所以要确保其被最大限度地优化。确保没有某些可以被很容易移出循环的密集计算。
- 使用后测试循环——最常用for循环和while循环都是前测试循环。而如do-while这种后测试循环，可以避免最初终止条件的计算，因此运行更快。

记住使用“后测试”循环时必须确保要处理的值至少有一个。空数组会导致多余的一次循环而“前测试”循环则可以避免。

#### 3.  展开循环

当循环的次数是确定的，消除循环并使用多次函数调用往往更快 。

如果循环中的迭代次数不能事先确定，那可以考虑使用一种叫做Duff装置的技术。这个技术是以其创建者Tom Duff命名的，他最早在C语言中使用这项技术。Duff装置的基本概念是通过计算迭代的次数是否为8的倍数将一个循环展开为一系列语句。Duff装置的实现是通过将values数组中元素个数除以8来计算出循环需要进行多少次迭代的。首次执行该循环时，会检查StartAt变量看有需要多少额外调用。

由Andrew B. King 所著的Speed Up Your Site提出了一个更快的Duff装置技术，将do-while循环分成2个单独的循环。

针对大数据集使用展开循环可以节省很多时间，但对于小数据集，额外的开销则可能得不偿失

#### 4. 避免双重解释

当使用eval()函数或者是Function构造函数以及使用setTimeout()传一个字符串参数时都会发生这种情况。

这些都要解析包含了JavaScript代码的字符串。这个操作是不能在初始的解析过程中完成的，因为代码是包含在字符串中的，也就是说在JavaScript代码运行的同时必须新启动一个解析器来解析新的代码。实例化一个新的解析器有不容忽视的开销，所以这种代码要比直接解析慢得多。

只有极少的情况下eval()是绝对必须的，所以尽可能避免使用。对于Function构造函数，完全可以直接写成一般的函数，调用setTimeout()可以传入函数作为第一个参数。

如果要提高代码性能，尽可能避免出现需要按照JavaScript解释的字符串。

#### 5. 性能的其他注意事项

- 原生方法较快——只要有可能，使用原生方法而不是自己用JavaScript重写一个。原生方法是用诸如C/C++之类的编译型语言写出来的，所以要比JavaScript的快很多很多。JavaScript中最容易被忘记的就是可以在Math对象中找到的复杂的数学运算；
- Switch语句较快 —— 如果有一系列复杂的if-else语句，可以转换成单个switch语句则可以得到更快的代码。还可以通过将case语句按照最可能的到最不可能的顺序进行组织，来进一步优化switch语句。
- 位运算符较快 —— 当进行数学运算的时候，位运算操作要比任何布尔运算或者算数运算快。选择性地用位运算替换算数运算可以极大提升复杂计算的性能。

### 24.2.3 最小化语句数

完成多个操作的单个语句要比完成单个操作的多个语句快。所以，就要找出可以组合在一起的语句，以减少脚本整体的执行时间。这里有几个可以参考的模式。

#### 1. 多个变量声明

#### 2. 插入迭代值

当使用迭代值（也就是在不同的位置进行增加或减少的值）的时候，尽可能合并语句。

#### 3. 使用数组和对象字面量

使用构造函数总是要用到更多的语句来插入元素或者定义属性，而字面量可以将这些操作在一个语句中完成。

只要有可能，尽量使用数组和对象的字面量表达方式来消除不必要的语句。

在IE6和更早版本中使用字面量有微小的性能惩罚。不过这些问题在IE7中已经解决。

### 24.2.4优化DOM交互

#### 1. 最小化现场更新

一旦你需要访问的DOM部分是已经显示的页面的一部分，那么你就是在进行一个现场更新。每一个更改，不管是插入单个字符，还是移除整个片段，都有一个性能惩罚，因为浏览器要重新计算无数尺寸以进行更新。现场更新进行得越多，代码完成执行所花的时间就越长；完成一个操作所需的现场更新越少，代码就越快。

要修正这个性能瓶颈，需要减少现场更新的数量。一般有2种方法。第一种是将列表从页面上移除，最后进行更新，最后再将列表插回到同样的位置。这个方法不是非常理想，因为在每次页面更新的时候它会不必要的闪烁。第二个方法是使用文档片段(createDocumentFragment)来构建DOM结构，接着将其添加到List元素中。这个方式避免了现场更新和页面闪烁问题。

当给appendChild()传入文档片段时，只有片段中的子节点被添加到目标，片段本身不会被添加。

一旦需要更新DOM，请考虑使用文档片段来构建DOM结构，然后再将其添加到现存的文档中。

#### 2. 使用 innerHTML

有两种在页面上创建DOM节点的方法：使用诸如createElement()和appendChild()之类的DOM方法，以及使用innerHTML。对于大的DOM更改，使用innerHTML要比使用标准DOM方法创建同样的DOM结构快得多。

当把innerHTML设置为某个值时，后台会创建一个HTML解析器，然后使用内部的DOM调用来创建DOM结构，而非基于JavaScript的DOM调用。由于内部方法是编译好的而非解释执行的，所以执行快得多。

#### 3. 使用事件代理

页面上的事件处理程序的数量和页面响应用户交互的速度之间有个负相关。为了减轻这种惩罚，最好使用事件代理。

事件代理，用到了事件冒泡。任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理。使用这个知识，就可以将事件处理程序附加到更高层的地方负责多个目标的事件处理。如果可能，在文档级别附加事件处理程序，这样可以处理整个页面的事件。

#### 4. 注意HTMLCollection

HTMLCollection对象对于Web应用的性能而言是巨大的损害。任何时候要访问HTMLCollection，不管它是一个属性还是一个方法，都是在文档上进行一个查询，这个查询开销很昂贵。最小化访问HTMLCollection的次数可以极大地改进脚本的性能。

优化HTMLCollection访问最重要的地方就是循环了。

发生以下情况时会返回HTMLCollection对象：

- 进行了对getElementsByTagName() 的调用；
- 获取了元素的 childNodes 属性；
- 获取了元素的 attributes 属性；
- 访问了特殊的集合，如document.forms、document.images等。

### 24.3部署

24.3.1 构建过程

写的代码不应该原封不动地放入浏览器中：

- 知识产权问题 —— 如果把带有完整注释的代码放到线上，那别人就更容易知道你的意图，对它再利用，并且可能找到安全漏洞。
- 文件大小 —— 书写代码要保证容易阅读，才能更好地维护，但是这对于性能是不利的。浏览器并不能从额外的空白字符或者是冗长的函数名和变量名中获得什么好处。
- 代码组织 —— 组织代码要考虑到可维护性并不一定是传送给浏览器的最好方式。

构建过程始于在源控制中定义用于存储文件的逻辑结构。最好避免使用一个文件存放所有JavaScript，遵循以下面向对象语言中的典型模式：将每个对象或自定义类型分别放入其单独的文件中。

将代码分离成多个文件只是为了提高可维护性，并非为了部署。要进行部署的时候，需要将这些源代码合并为一个或几个归并文件。

推荐Web应用中尽可能使用最少的JavaScript文件，是因为HTTP请求是Web中的主要性能瓶颈之一。记住通过`<script>`标记引用JavaScript文件是一个阻塞操作，当代码下载并运行的时候会停止其他所有的下载。因此，尽量从逻辑上将JavaScript代码分组成部署文件。

Ant由于其简便的文件处理能力而非常适合JavaScript编译系统。

### 24.3.2验证

大多数开发人员还是要在浏览器中运行代码以检查其语法。这种方法有一些问题。首先，验证过程难以自动化或者在不同系统间直接移植。其次，除了语法错误外，很多问题只有在执行代码的时候才会遇到，这给错误留下了空间；

JSLint 可以查找JavaScript 代码中的语法错误以及常见的编码错误。它可以发掘的一些潜在问题如下：

- eval()的使用；
- 未声明变量的使用；
- 遗漏的分号；
- 不恰当的换行；
- 错误的逗号使用；
- 语句周围遗漏的括号；
- switch分支语句中遗漏的break；
- 重复声明的变量；
- with的使用；
- 错误使用的等号（替代了双等号或三等号）；
- 无法到达的代码。

可以使用Ant将JSLint作为构建过程的一部分运行

### 24.3.3压缩

JavaScript文件压缩其实是两个东西：代码长度和配重（Wire weight）。代码长度指的是浏览器所需解析的字节数，配重指的是实际从服务器传送到浏览器的字节数。

#### 1. 文件压缩

因为JavaScript并非编译为字节码，而是按照源代码传送的，代码文件通常包含浏览器执行所不需要的额外的信息和格式。

压缩器一般进行如下一些步骤：

- 删除额外的空白（包括换行）；
- 删除所有注释；
- 缩短变量名。

最优秀的（有争议的）是YUI 压缩器。YUI压缩器使用了Rhino JavaScript解析器将JavaScript代码令牌化。然后使用这个令牌流创建代码不包含空白和注释的优化版本。与一般的基于表达式的压缩器不同的地方在于，YUI压缩可以确保不引入任何语法错误，并可以安全地缩短局部变量名。

#### 2. HTTP压缩

所有的五大Web浏览器都支持对所接收的资源进行客户端解压缩。一个指定了文件使用了给定格式进行了压缩的HTTP头包含在了服务器响应中。对于Apache Web服务器，有两个模块可以进行HTTP压缩：mod_gzip（Apache1.3.x）和mod_deflate（Apache 2.0.x）。

对于mod_gzip，可以给httpd.conf文件或者是.htaccess文件添加以下代码启用对JavaScript的自动压缩：

```
#告诉mod_zip要包含任何以.js结尾的文件
mod_gzip_item_include file \.js$ 
```

对于mod_deflate，可以类似添加一行代码以保证JavaScript文件在被发送之前已被压缩。将以下这一行代码添加到httpd.conf文件或者是.htaccess文件中：

```
#告诉mod_deflate要包含所有的JavaScript文件
AddOutputFilterByType DEFLATE application/x-javascript 
```

注意这一行代码用到了响应的MIME类型来确定是否对其进行压缩。记住虽然`<script>`的type属性用的是text/javascript，但是JavaScript文件一般还是用application/x-javascript作为其服务的MIME类型。

mod_gzip和mod_deflate都可以节省大约70%的JavaScript 文件大小。这很大程度上是因为JavaScript都是文本文件，因此可以非常有效地进行压缩。

## 24.4 小结

JavaScript中的可维护性部分涉及到下面的代码约定。

- 来自其他语言中的代码约定可以用于决定何时进行注释，以及如何进行缩进，不过JavaScript需要针对其松散类型的性质创造一些特殊的约定。
- 由于JavaScript 必须与HTML和CSS共存，所以让各自完全定义其自己的目的非常重要：JavaScript应该定义行为，HTML应该定义内容，CSS应该定义外观。
- 这些职责的混淆会导致难以调试的错误和维护上的问题。

关于性能

- JavaScript执行所花费的时间直接影响到整个Web页面的性能，所以其重要性是不能忽略的。
- 针对基于C的语言的很多性能的建议也适用于JavaScript，如有关循环性能和使用switch语句替代if语句。
- 还有一个要记住的重要事情，即DOM交互开销很大，所以需要限制DOM操作的次数。

部署

- 为了协助部署，推荐设置一个可以将JavaScript合并为较少文件（理想情况是一个）的构建过程。
- 有了构建过程也可以对源代码自动运行额外的处理和过滤。例如，你可以运行JavaScript验证器来确保没有语法错误或者是代码没有潜在的问题。
- 在部署前推荐使用压缩器将文件尽可能变小。
- 和HTTP压缩一起使用可以让JavaScript文件尽可能小，因此对整体页面性能的影响也会最小。



# 第25章 新兴的 API

## 25.1 requestAnimationFrame()

计时器和循环间隔一直都是JavaScript动画的最核心技术。

Firefox 4最早为JavaScript动画添加了一个新API，即mozRequestAnimationFrame()。这个方法会告诉浏览器：有一个动画开始了。进而浏览器就可以确定重绘的最佳方式。

### 25.1.1 早期动画循环

创建动画的典型方式是使用setInterval()方法来控制所有动画。

大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于17ms。

### 25.1.2 循环间隔的问题

没有办法确保浏览器按时绘制下一帧。浏览器使用的计时器的精度进一步恶化了问题。具体地说，浏览器使用的计时器并非精确到毫秒级别。以下是几个浏览器的计时器精度。

- IE8及更早版本的计时器精度为15.625ms。
- IE9及更晚版本的计时器精度为4ms。
- Firefox和Safari的计时器精度大约为10ms。
- Chrome的计时器精度为4ms。

### 25.1.3 mozRequestAnimationFrame

Mozilla的Robert O’Callahan指出，CSS变换和动画的优势在于浏览器知道动画什么时候开始，因此会计算出正确的循环间隔，在恰当的时候刷新UI。而对于JavaScript动画，浏览器无从知晓什么时候开始。因此他的方案就是创造一个新方法mozRequestAnimationFrame()，通过它告诉浏览器某些JavaScript代码将要执行动画。

mozRequestAnimationFrame()方法接收一个参数，即在重绘屏幕前调用的一个函数。这个函数负责改变下一次重绘时的DOM样式。

目前来看，mozRequestAnimationFrame()解决了浏览器不知道JavaScript动画什么时候开始、不知道最佳循环间隔时间的问题。

代码到底什么时候执行的问题：mozRequestAnimationFrame()函数也会接收一个参数，它是一个时间码（从1970年1月1日起至今的毫秒数），表示下一次重绘的实际发生时间。注意，这一点很重要：mozRequestAnimationFrame()会根据这个时间码设定将来的某个时刻进行重绘，而根据这个时间码，你也能知道那个时刻是什么时间。然后，再优化动画效果就有了依据。

要知道距离上一次重绘已经过去了多长时间，可以查询mozAnimationStartTime，其中包含上一次重绘的时间码。用传入回调函数的时间码减去这个时间码，就能计算出在屏幕上重绘下一组变化之前要经过多长时间。

### 25.1.4 webkitRequestAnimationFrame与msRequestAnimationFrame

基于mozRequestAnimationFrame()，Chrome和IE10+也都给出了自己的实现，分别叫webkit- RequestAnimationFrame()和msRequestAnimationFrame()。这两个版本与Mozilla的版本有两个方面的微小差异。首先，不会给回调函数传递时间码，因此你无法知道下一次重绘将发生在什么时间。其次，Chrome又增加了第二个可选的参数，即将要发生变化的DOM元素。知道了重绘将发生在页面中哪个特定元素的区域内，就可以将重绘限定在该区域中。

Chrome又提供了另一个方法webkitCancelAnimationFrame()，用于取消之前计划执行的重绘操作。以上模式利用已有的功能创建了一个动画循环，大致计算出了两次重绘的时间间隔。(使用Date())

目前，W3C已经着手起草requestAnimationFrame()API，而且作为Web Performance Group的一部分，Mozilla和Google正共同参与该标准草案的制定工作。

## 25.2  Page Visibility API

Page Visibility API（页面可见性API）就是为了让开发人员知道页面是否对用户可见而推出的。

这个API本身非常简单，由以下三部分组成。

- document.hidden：表示页面是否隐藏的布尔值。页面隐藏包括页面在后台标签页中或者浏览器最小化。
- document.visibilityState：表示下列4个可能状态的值。
- 页面在后台标签页中或浏览器最小化。
- 页面在前台标签页中。
- 实际的页面已经隐藏，但用户可以看到页面的预览（就像在Windows 7中，用户把鼠标移动到任务栏的图标上，就可以显示浏览器中当前页面的预览）。
- 页面在屏幕外执行预渲染处理。
- visibilitychange事件：当文档从可见变为不可见或从不可见变为可见时，触发该事件。

在编写本书时，只有IE10和Chrome支持Page Visibility API。IE的版本是在每个属性或事件前面加上ms前缀，而Chrome则是加上webkit前缀。

在不支持该API的浏览器中会提示页面未隐藏。这是Page Visibility API有意设计的结果，目的是为了向后兼容。

为了在页面从可见变为不可见或从不可见变为可见时收到通知，可以侦听visibilitychange事件。在IE中，这个事件叫msvisibilitychange，而在Chrome中这个事件叫webkitvisibilitychange

API的这一部分已经相对稳定，因此在实际的Web开发中也可以使用。

关于这一API的实现，差异最大的是document.visibilityState 属性。
IE10 的document.msVisibilityState是一个表示如下4种状态的数字值。

- document.MS_PAGE_HIDDEN(0) 
- document.MS_PAGE_VISIBLE(1) 
- document.MS_PAGE_PREVIEW(2) 
- document.MS_PAGE_PRERENDER(3) 

在Chrome中，document.webkitVisibilityState可能是下列3个字符串值：

- "hidden"
- "visible"
- "prerender"

由于存在以上差异，所以建议大家先不要完全依赖带前缀的document.visibilityState，最好只使用document.hidden属性。

## 25.3  Geolocation API

地理定位API得到了广泛支持。

Geolocation API在浏览器中的实现是navigator.geolocation对象，这个对象包含3个方法。

第一个方法是getCurrentPosition()，调用这个方法就会触发请求用户共享地理定位信息的对话框。这个方法接收3个参数：成功回调函数、可选的失败回调函数和可选的选项对象。

第二个参数是成功回调函数，接收到一个Position对象参数，该对象有两个属性：coords和timestamp

coords对象中将包含下列与位置相关的信息。

- latitude：以十进制度数表示的纬度。
- longitude：以十进制度数表示的经度。
- accuracy：经、纬度坐标的精度，以米为单位。

有些浏览器还可能会在coords对象中提供如下属性。

- altitude：以米为单位的海拔高度，如果没有相关数据则值为null。
- altitudeAccuracy：海拔高度的精度，以米为单位，数值越大越不精确。
- heading：指南针的方向，0°表示正北，值为NaN表示没有检测到数据。
- speed：速度，即每秒移动多少米，如果没有相关数据则值为null。

在实际开发中，latitude和longitude是大多数Web应用最常用到的属性。

第二个参数是失败回调函数，在被调用的时候也会接收到一个参数。这个参数是一个对象，包含两个属性：message和code。其中，message属性中保存着给人看的文本消息，解释为什么会出错，而code属性中保存着一个数值，表示错误的类型：用户拒绝共享（1）、位置无效（2）或者超时（3）。实际开发中，大多数Web应用只会将错误消息保存到日志文件中，而不一定会因此修改用户界面。

getCurrentPosition()的第三个参数是一个选项对象，用于设定信息的类型。可以设置的选项有三个：enableHighAccuracy是一个布尔值，表示必须尽可能使用最准确的位置信息；timeout是以毫秒数表示的等待位置信息的最长时间；maximumAge表示上一次取得的坐标信息的有效时间，以毫秒表示，如果时间到则重新取得新坐标信息。这三个选项都是可选的，可以单独设置，也可以与其他选项一起设置。除非确实需要非常精确的信息，否则建议保持enableHighAccuracy的false值（默认值）。将这个选项设置为true需要更长的时候，而且在移动设备上还会导致消耗更多电量。类似地，如果不需要频繁更新用户的位置信息，那么可以将maximumAge设置为Infinity，从而始终都使用上一次的坐标信息。

跟踪用户的位置，可以使用另一个方法watchPosition()。这个方法接收的参数与getCurrentPosition()方法完全相同。实际上，watchPosition()与定时调用getCurrentPosition()的效果相同。在第一次调用watchPosition()方法后，会取得当前位置，执行成功回调或者错误回调。然后，watchPosition()就地等待系统发出位置已改变的信号（它不会自己轮询位置）。

调用watchPosition()会返回一个数值标识符，用于跟踪监控的操作。基于这个返回值可以取消监控操作，只要将其传递给clearWatch()方法即可（与使用setTimeout()和clearTimeout()类似）。

支持地理定位的浏览器有IE9+、Firefox 3.5+、Opera 10.6+、Safari 5+、Chrome、iOS版Safari、Android版WebKit。

## 25.4  File API

2000年以前，处理文件的唯一方式就是在表单中加入`<input type="file">`字段，仅此而已。

File API（文件API）的宗旨是为Web开发人员提供一种安全的方式，以便在客户端访问用户计算机中的文件，并更好地对这些文件执行操作。支持File API的浏览器有IE10+、Firefox 4+、Safari 5.0.5+、Opera 11.1+和Chrome。

HTML5在DOM中为文件输入元素添加了一个files集合。在通过文件输入字段选择了一或多个文件时，files集合中将包含一组File对象，每个File对象对应着一个文件。每个File对象都有下列只读属性。

- name：本地文件系统中的文件名。
- size：文件的字节大小。
- type：字符串，文件的MIME类型。
- lastModifiedDate：字符串，文件上一次被修改的时间（只有Chrome实现了这个属性）。

### 25.4.1 FileReader类型

FileReader类型实现的是一种异步文件读取机制。可以把FileReader想象成XMLHttpRequest，区别只是它读取的是文件系统，而不是远程服务器。为了读取文件中的数据，FileReader提供了如下几个方法。

- readAsText(file,encoding)：以纯文本形式读取文件，将读取到的文本保存在result属性中。第二个参数用于指定编码类型，是可选的。
- readAsDataURL(file)：读取文件并将文件以数据URI的形式保存在result属性中。
- readAsBinaryString(file)：读取文件并将一个字符串保存在result属性中，字符串中的每个字符表示一字节。
- readAsArrayBuffer(file)：读取文件并将一个包含文件内容的ArrayBuffer 保存在result属性中。

由于读取过程是异步的，因此FileReader 也提供了几个事件。其中最有用的三个事件是progress、error和load，分别表示是否又读取了新数据、是否发生了错误以及是否已经读完了整个文件。

每过50ms左右，就会触发一次progress事件，通过事件对象可以获得与XHR的progress事件相同的信息（属性）：lengthComputable、loaded和total。另外，尽管可能没有包含全部数据，但每次progress事件中都可以通过FileReader的result属性读取到文件内容。

由于种种原因无法读取文件，就会触发error事件。触发error事件时，相关的信息将保存到FileReader的error属性中。这个属性中将保存一个对象，该对象只有一个属性code，即错误码。这个错误码是1表示未找到文件，是2表示安全性错误，是3表示读取中断，是4表示文件不可读，是5表示编码错误。

文件成功加载后会触发load事件；如果发生了error事件，就不会发生load事件。

如果想中断读取过程，可以调用abort()方法，这样就会触发abort事件。在触发load、error或abort事件后，会触发另一个事件loadend。loadend事件发生就意味着已经读取完整个文件，或者读取时发生了错误，或者读取过程被中断。

实现File API的所有浏览器都支持readAsText()和readAsDataURL()方法。但IE10 PR 2并未实现readAsBinaryString()和readAsArrayBuffer()方法。

### 25.4.2 读取部分内容

File对象还支持一个slice()方法，这个方法在Firefox中的实现叫mozSlice()，在Chrome中的实现叫webkitSlice()，Safari的5.1及之前版本不支持这个方法。

slice()方法接收两个参数：起始字节及要读取的字节数。这个方法返回一个Blob的实例，Blob是File类型的父类型。Blob类型有一个size属性和一个type属性，而且它也支持slice()方法，以便进一步切割数据。通过FileReader也可以从Blob中读取数据。

只读取文件的一部分可以节省时间，非常适合只关注数据中某个特定部分（如文件头部）的情况。

### 25.4.3对象URL

对象URL也被称为blob URL，指的是引用保存在File或Blob中数据的URL。

使用对象URL的好处是可以不必把文件内容读取到JavaScript中而直接使用文件内容。为此，只要在需要文件内容的地方提供对象URL即可。

要创建对象URL，可以使用window.URL.createObjectURL()方法，并传入File或Blob对象。这个方法在Chrome中的实现叫window.webkitURL.createObjectURL()

这个函数的返回值是一个字符串，指向一块内存的地址。因为这个字符串是URL，所以在DOM中也能使用。直接把对象URL放在<img>标签中，就省去了把数据先读到JavaScript中的麻烦。另一方面，`<img>`标签则会找到相应的内存地址，直接读取数据并将图像显示在页面中。

如果不再需要相应的数据，最好释放它占用的内容。但只要有代码在引用对象URL，内存就不会释放。要手工释放内存，可以把对象URL传给window.URL.revokeOjbectURL()（在Chrome中是window.webkitURL.revokeObjectURL()）。

支持对象URL的浏览器有IE10+、Firefox 4和Chrome。

### 25.4.4 读取拖放的文件

从桌面上把文件拖放到浏览器中也会触发drop事件。而且可以在event.dataTransfer.files中读取到被放置的文件，当然此时它是一个File对象，与通过文件输入字段取得的File对象一样。

与之前展示的拖放示例一样，这里也必须取消dragenter、dragover和drop的默认行为。在drop事件中，可以通过event.dataTransfer.files读取文件信息。

### 25.4.5使用XHR上传文件

把文件内容放到send()方法中，再通过POST请求，的确很容易就能实现上传。但这样做传递的是文件内容，因而服务器端必须收集提交的内容，然后再把它们保存到另一个文件中。其实，更好的做法是以表单提交的方式来上传文件。

这样使用FormData类型就很容易做到了。首先，要创建一个FormData对象，通过它调用append()方法并传入相应的File对象作为参数。然后，再把FormData对象传递给XHR的send()方法。

支持以FormData方式上传文件的浏览器有Firefox 4+、Safari 5+和Chrome。

## 25.5  Web计时

度量页面性能指标的唯一方式，就是提高代码复杂程度和巧妙地使用JavaScript的Date对象。Web Timing API改变了这个局面，让开发人员通过JavaScript就能使用浏览器内部的度量结果，通过直接读取这些信息可以做任何想做的分析。Web Timing API实际上已经成为了W3C的建议标准，只不过目前支持它的浏览器还不够多。

Web计时机制的核心是window.performance对象。对页面的所有度量信息，包括那些规范中已经定义的和将来才能确定的，都包含在这个对象里面。

performance.navigation属性也是一个对象，包含着与页面导航有关的多个属性：

- redirectCount：页面加载前的重定向次数。
- type：数值常量，表示刚刚发生的导航类型。
  - performance.navigation.TYPE_NAVIGATE (0)：页面第一次加载。
  - performance.navigation.TYPE_RELOAD (1)：页面重载过。
  - performance.navigation.TYPE_BACK_FORWARD (2)：页面是通过“后退”或“前进”按钮打开的。

performance.timing属性也是一个对象，但这个对象的属性都是时间戳（从软件纪元开始经过的毫秒数），不同的事件会产生不同的时间值。

- navigationStart：开始导航到当前页面的时间。
- unloadEventStart：前一个页面的unload事件开始的时间。但只有在前一个页面与当前页面来自同一个域时这个属性才会有值；否则，值为0。
- unloadEventEnd：前一个页面的unload事件结束的时间。但只有在前一个页面与当前页面来自同一个域时这个属性才会有值；否则，值为0。
- redirectStart：到当前页面的重定向开始的时间。但只有在重定向的页面来自同一个域时这个属性才会有值；否则，值为0。
- redirectEnd：到当前页面的重定向结束的时间。但只有在重定向的页面来自同一个域时这个属性才会有值；否则，值为0。
- fetchStart：开始通过HTTP GET取得页面的时间。
- domainLookupStart：开始查询当前页面DNS的时间。
- domainLookupEnd：查询当前页面DNS结束的时间。
- connectStart：浏览器尝试连接服务器的时间。
- connectEnd：浏览器成功连接到服务器的时间。
- secureConnectionStart：浏览器尝试以SSL方式连接服务器的时间。不使用SSL方式连接时，这个属性的值为0。
- requestStart：浏览器开始请求页面的时间。
- responseStart：浏览器接收到页面第一字节的时间。
- responseEnd：浏览器接收到页面所有内容的时间。
- domLoading：document.readyState变为"loading"的时间。
- domInteractive：document.readyState变为"interactive"的时间。
- domContentLoadedEventStart：发生DOMContentLoaded事件的时间。
- domContentLoadedEventEnd：DOMContentLoaded 事件已经发生且执行完所有事件处理程序的时间。
- domComplete：document.readyState变为"complete"的时间。
- loadEventStart：发生load事件的时间。
- loadEventEnd：load事件已经发生且执行完所有事件处理程序的时间。

支持Web Timing API的浏览器有IE10+和Chrome。

## 25.6  Web Workers

## 25.6  Web Workers

长时间运行的JavaScript进程会导致浏览器冻结用户界面，让人感觉屏幕“冻结”了。Web Workers规范通过让JavaScript在后台运行解决了这个问题。

目前支持Web Workers的浏览器有IE10+、Firefox 3.5+、Safari 4+、Opera 10.6+、Chrome和iOS版的Safari。

### 25.6.1使用Worker

实例化Worker对象并传入要执行的JavaScript文件名就可以创建一个新的Web Worker。

```javascript
var worker = new Worker("stufftodo.js"); 
```

只有Worker接收到消息才会实际执行文件中的代码。要给Worker传递消息，可以使用postMessage()方法：

```javascript
worker.postMessage(“start! ");
```

消息内容可以是任何能够被序列化的值，不过与XDM不同的是，在所有支持的浏览器中，postMessage()都能接收对象参数（Safari 4是支持Web Workers的浏览器中最后一个只支持字符串参数的）。

一般来说，可以序列化为JSON结构的任何值都可以作为参数传递给postMessage()。换句话说，这就意味着传入的值是被复制到Worker中，而非直接传过去的（与XDM类似）。

Worker是通过message和error事件与页面通信的。这里的message事件与XDM中的message事件行为相同，来自Worker的数据保存在event.data中。Worker返回的数据也可以是任何能够被序列化的值

Worker不能完成给定的任务时会触发error事件。具体来说，Worker内部的JavaScript在执行过程中只要遇到错误，就会触发error事件。发生error事件时，事件对象中包含三个属性：filename、lineno和message，分别表示发生错误的文件名、代码行号和完整的错误消息。

建议始终都要使用onerror事件处理程序

只要调用terminate()方法就可以停止Worker的工作。而且，Worker中的代码会立即停止执行，后续的所有过程都不会再发生（包括error和message事件也不会再触发）。

```javascript
worker.terminate(); //立即停止Worker的工作
```

### 25.6.2 Worker全局作用域

关于Web Worker，最重要的是要知道它所执行的JavaScript代码完全在另一个作用域中，与当前网页中的代码不共享作用域。在Web Worker中，同样有一个全局对象和其他对象以及方法。但是，Web 
Worker中的代码不能访问DOM，也无法通过任何方式影响页面的外观。

Web Worker中的全局对象是worker对象本身。也就是说，在这个特殊的全局作用域中，this和self引用的都是worker对象。为便于处理数据，Web Worker本身也是一个最小化的运行环境。

- 最小化的navigator对象，包括onLine、appName、appVersion、userAgent和platform属性；
- 只读的location对象；
- setTimeout()、setInterval()、clearTimeout()和clearInterval()方法；
- XMLHttpRequest构造函数。

为了处理来自页面的数据，同样也需要创建一个onmessage事件处理程序。传递消息就是页面是Worker相互之间通信的方式。在Worker中调用postMessage()会以异步方式触发页面中Worker实例的message事件。

在Worker内部，调用close()方法也可以停止工作。Worker停止工作后就不会再有事件发生了。

### 25.6.3 包含其他脚本

Worker的全局作用域提供添加其他脚本功能，即我们可以调用importScripts()方法。这个方法接收一个或多个指向JavaScript文件的URL。每个加载过程都是异步进行的，因此所有脚本加载并执行之后，importScripts()才会执行。

这些脚本是在Worker的全局作用域中执行，如果脚本中包含与页面有关的JavaScript代码，那么脚本可能无法正确运行。请记住，Worker中的脚本一般都具有特殊的用途，不会像页面中的脚本那么功能宽泛。

### 25.6.4 Web Workers的未来

Web Workers规范还在继续制定和改进之中。本节所讨论的Worker目前被称为“专用Worker”
（dedicated worker），因为它们是专门为某个特定的页面服务的，不能在页面间共享。

该规范的另外一个概念是“共享Worker”（shared worker），这种Worker可以在浏览器的多个标签中打开的同一个页面间共享。该规范尚未完稿。

## 25.7 小结

从技术规范角度讲，这批API不属于HTML5，但从整体上可以称它们为HTML5 JavaScript API。这些API的标准有不少虽然还在制定当中，但已经得到了浏览器的广泛支持。

- requestAnimationFrame()：是一个着眼于优化JavaScript动画的API，能够在动画运行期间发出信号。通过这种机制，浏览器就能够自动优化屏幕重绘操作。
- Page Visibility API：让开发人员知道用户什么时候正在看着页面，而什么时候页面是隐藏的。
- Geolocation API：在得到许可的情况下，可以确定用户所在的位置。在移动Web应用中，这个API非常重要而且常用。


- File API：可以读取文件内容，用于显示、处理和上传。与HTML5的拖放功能结合，很容易就能创造出拖放上传功能。


- Web Timing：给出了页面加载和渲染过程的很多信息，对性能优化非常有价值。
- Web Workers：可以运行异步JavaScript代码，避免阻塞用户界面。在执行复杂计算和数据处理的时候，这个API非常有用




# 附录A ECMAScript Harmony

虽然到2011年的时候，Harmony，也就是未来的ECMAScript 6，还没有全部制定完成，但其中的几个部分已经尘埃落定。本附录所要介绍的就是那些将来肯定能进入最终规范的部分。在将来的实现中，这些内容的细节有可能与你在这里看到的不一样。

> 该内容暂不关注，直接看已出的ES6



# 附录B 严格模式

支持严格模式的浏览器包括IE10+、Firefox 4+、Safari 5.1+和Chrome。

## B.1 选择使用

要选择进入严格模式，可以使用严格模式的编译指示（pragma），实际上就是一个不会赋给任何变量的字符串：
"use strict"; 



```
"use strict"; 
```

这种语法（从ECMAScript 3开始支持）可以向后兼容那些不支持严格模式的JavaScript引擎。

这种语法（从ECMAScript 3开始支持）可以向后兼容那些不支持严格模式的JavaScript引擎。

如果是在全局作用域中（函数外部）给出这个编译指示，则整个脚本都将使用严格模式。

可以只在函数中打开严格模式

## B.2 变量

首先，不允许意外创建全局变量。在严格模式下，如果给一个没有声明的变量赋值，那代码在执行时就会抛出ReferenceError。

其次，不能对变量调用delete操作符。非严格模式允许这样操作，但会静默失败（返回false）。而在严格模式下，删除变量也会导致错误。

严格模式下对变量名也有限制。特别地，不能使用implements、interface、let、package、private、protected、public、static和yield作为变量名。这些都是保留字。在严格模式下，用以上标识符作为变量名会导致语法错误。

## B.3 对象

在下列情形下操作对象的属性会导致错误：

- 为只读属性赋值会抛出TypeError；
- 对不可配置的（nonconfigurable）的属性使用delete操作符会抛出TypeError；
- 为不可扩展的（nonextensible）的对象添加属性会抛出TypeError。

使用对象的另一个限制与通过对象字面量声明对象有关。在使用对象字面量时，属性名必须唯一。

## B.4 函数

首先，严格模式要求命名函数的参数必须唯一。

```javascript
function sum (num, num){ 
	//do something 
} 	
```

在非严格模式下，这个函数声明不会抛出错误。通过参数名只能访问第二个参数，要访问第一个参
数必须通过arguments对象。

在严格模式下，arguments对象的行为也有所不同。在非严格模式下，修改命名参数的值也会反映到arguments对象中，而严格模式下这两个值是完全独立的。

```javascript
//修改命名参数的值
//非严格模式：修改会反映到arguments中
//严格模式：修改不会反映到arguments中

function showValue(value){ 
    value = "Foo"; 
    alert(value); //"Foo" 
    alert(arguments[0]); //非严格模式："Foo" 
    //严格模式："Hi" 
} 

showValue("Hi");
```

另一个变化是淘汰了arguments.callee和arguments.caller。在非严格模式下，这两个属性一个引用函数本身，一个引用调用函数。而在严格模式下，访问哪个属性都会抛出TypeError。

与变量类似，严格模式对函数名也做出了限制，不允许用implements、interface、let、package、
private、protected、public、static和yield作为函数名。

对函数的最后一点限制，就是只能在脚本的顶级和在函数内部声明函数。也就是说，在if语句中声明函数会导致语法错

## B.5 eval()

eval()函数在严格模式下也得到了提升。最大的变化就是它在包含上下文中不再创建变量或函数。

可以在eval()中声明变量和函数，但这些变量或函数只能在被求值的特殊作用域中有效，随后就将被销毁。

## B.6 eval与arguments

严格模式已经明确禁止使用eval和arguments作为标识符，也不允许读写它们的值。

在非严格模式下，可以重写eval，也可以给arguments赋值。但在严格模式下，这样做会导致语法错误。不能将它们用作标识符，意味着以下几种使用方式都会抛出语法错误：

- 使用var声明；
- 赋予另一个值；
- 尝试修改包含的值，如使用++；
- 用作函数名；
- 用作命名的函数参数；
- 在try-catch语句中用作例外名。

## B.7 抑制this

JavaScript 中一个最大的安全问题，也是最容易让人迷茫的地方，就是在某些情况下如何抑制this
的值。在非严格模式下使用函数的apply()或call()方法时，null或undefined值会被转换为全局对象。而在严格模式下，函数的this值始终是指定的值，无论指定的是什么值。

## B.8 其他变化

首先是抛弃了with语句。非严格模式下的with语句能够改变解析标识符的路径，但在严格模式下，with被简化掉了。因此，在严格模式下使用with会导致语法错误。

严格模式也去掉了JavaScript中的八进制字面量。以0开头的八进制字面量过去经常会导致很多错误。在严格模式下，八进制字面量已经成为无效的语法了。ECMAScript 5也修改了严格模式下parseInt()的行为。如今，八进制字面量在严格模式下会被当作以0开头的十进制字面量。



# 附录C JavaScript库

## C.1 通用库

### C.1.1 YUI 

开源JavaScript与CSS库，以一种组件方式设计的。这个库不只有一个文件；它包含了很多文件，提供各种不同的配置，让你可以按需载入。涵盖了JavaScript的所有方面，从基本的工具及帮助函数到完善的浏览器部件。

### C.1.2 Prototype

Prototype是类驱动的，旨在为JavaScript提供类定义和继承。

### C.1.3 Dojo Toolkit

Dojo Toolkit开源库基于一种包系统建模，一组功能组成一个包，可以按需载入。Dojo提供了范围广泛的选项和配置，几乎涵盖了你要用JavaScript做的任何事情。

### C.1.4 MooTools 

MooTools是一个为了精简和优化而设计的开源库，它为内置JavaScript对象添加了各种方法，以通过接近的接口提供新功能，或者直接提供新的对象。

### C.1.5 jQuery

jQuery是一个给JavaScript提供了函数式编程接口的开源库。其核心是构建于CSS选择器上的，用来操作DOM元素。通过链式调用，jQuery代码看上去更像是对于应该发生什么的描述而不是JavaScript代码。这种代码风格在设计师和原型制作人中非常流行。

### C.1.6 MochiKit 

MochKit是一个由一些小工具组成的开源库，它以完善的文档和完整的测试见长，拥有大量API及相关范例文档以及数百个测试来确保质量。

### C.1.7 Underscore.js 

Underscore.js并不是一个通用的库，其文档称Underscore.js是对jQuery的补充，提供了操作对象、数组、函数和其他JavaScript数据类型的更多的低级功能。

## C.2 互联网应用

互联网应用库是针对于简化完整的Web应用开发而设计的。它们并不提供应用问题的小块组件，
而是提供了快速应用开发的整个概念框架。

### C.2.1 Backbone.js

Backbone.js是构建于Underscore.js基础之上的一个迷你MVC开源库，它针对单页应用进行优化，让你能够随着应用状态变化方便地更新页面的任意部分。

### C.2.2 Rico

Rico提供了Ajax、动画、样式以及部件的工具。

### C.2.3 qooxdoo 

旨在为整个互联网应用开发周期提供帮助的开源库。qooxdoo实现了它自己的类和接口，用于创建类似于传统面向对象语言的编程模型。这个库包含了一个完整的GUI工具包以及用于简化前端构建过程的编译器。

## C.3 动画和特效

### C.3.1 script.aculo.us

script.aculo.us是Prototype的“同伴”，它提供了出色特效的简单使用方式，使用的东西不超过是CSS和DOM。Prototype必须在使用script.aculo.us之前载入。script.aculo.us是最流行的特效库之一

### C.3.2 moo.fx

moo.fx开源动画库是设计在Prototype或者MooTools之上运行的。它的目标是尽可能小（最新的版
本是3KB)，并支持开发人员用尽可能少的代码创建动画。MooTools是默认包含moo.fx的，但也可以单独下载用于Prototype中。

### C.3.3 Lightbox

Lightbox是一个用于在任意页面上创建图像浮动层的JavaScript 库，依赖于Prototype和script.aculo.us 来实现它的视觉特效。基本的理念是让用户在一个浮动层中浏览一个或者一系列图像，而不必离开当前页面。Lightbox浮动层无论是外观还是过渡效果都可以自定义。

## C.4 加密

### C.4.1 JavaScript MD5

该开源库实现了MD4、MD5以及SHA-1安全散列函数。

### C.4.2 JavaScrypt

该JavaScript库实现了MD5和AES（256位）加密算法。



# 附录D  JavaScript工具

## D.1校验器

### D.1.1 JSLint 

它通过跨浏览器问题的最小共同点检查，能够从核心层次上检查语法错误。（它遵循最严格的规则来确保代码到处都能运行。）你可以启用Crockford对于代码风格的警告，包括代码格式、未声明的全局变量的使用以及其他更多警告。尽管JSLint是用JavaScript写的，但是通过基于Java的Rhino解释器，它可以在命令行中运行，或者通过WScript或者其他JavaScript解释器。

### D.1.2 JSHint 

JSHint是JSLint的一个分支，为应用规则提供了更多的自定义功能。与JSLint类似，它首先检查语法错误，然后检查有问题的编码模式。JSLint的每一项检查JSHint都有，但开发人员可以更好地控制应用什么规则。与JSLint一样，JSHint也能使用Rhino在命令行中运行。

### D.1.3 JavaScript Lint

一个基于C的JavaScript校验器。它使用了SpiderMonkey（即Firefox所用的JavaScript解释器）来分析代码并查找语法错误。这个工具包含大量选项，可以启用额外关于编码风格的警告，以及未声明的变量和不可到达的代码警告。

## D.2压缩器

#### D.2.1 JSMin

基于C的压缩器，进行最基本的JavaScript压缩。它主要是移除空白和注释，确保最终的代码依然可以被顺利执行。

### D.2.2 Dojo ShrinkSafe

它使用了Rhino JavaScript解释器首先将JavaScript代码解析为记号流，然后用它们来安全压缩代码。和JSMin一样，ShrinkSafe移除多余的空白符（不包括换行）和注释，但是还更进一步将局部变量替换为两个字符长的变量名。最后可以比JSMin产生更小输出，而没有引入语法错误的风险。

### D.2.3 YUI Compressor

YUI Compressor利用了Rhino解释器将JavaScript代码解析为记号流，并移除注释和空白字符并替换变量名。与ShrinkSafe不同，YUI Compressor还移除换行并进行一些细微的优化进一步节省字节数。一般来说，YUI Compressor处理过的文件要小于JSMin或者ShrinkSafe处理过的文件。

## D.3 单元测试

TDD（Test-driven development，测试驱动开发）是一种以单元测试为核心的软件开发过程。

### D.3.1 JsUnit 

最早的JavaScript单元测试框架，不绑定于任何特定的JavaScript库。JsUnit是Java知名的JUnit测试框架的移植。测试在页面中运行，并可以设置为自动测试并将结果提交到服务器。

### D.3.2 YUI Test 

YUI Test不仅可以用于测试使用YUI的代码，也可以测试网站或者应用中的任何代码。YUI Test包含了简单和复杂的断言，以及一种模拟简单的鼠标和键盘事件的方法。

### D.3.3 DOH 

DOH（Dojo Object Harness）在发布给大家使用之前，最初是作为Dojo内部的单元测试工具出现的。

### D.3.4 qUnit

qUnit是为测试jQuery而开发的一个单元测试框架。jQuery本身的确使用qUnit进行各项测试。除此之外，qUnit与jQuery并没有绑定关系，也可以用它来测试所有JavaScript代码。qUnit的特点是简单易用，一般开发人员很容易上手。

## D.4 文档生成器

### D.4.1 JsDoc Toolkit 

它要求你在代码中输入类似Javadoc的注释，然后处理这些注释并输出为HTML文件。你可以自定义HTML的格式，这需使用预定义的JsDoc模板或者创建自己的模版。

### D.4.2 YUI Doc

YUI Doc是YUI的文档生成器。该生成器以Python书写，所以它要求安装有Python运行时环境。YUI Doc可以输出集成了属性和方法搜索（用YUI的自动完成挂件实现的）的HTML文件。和JsDoc
一样，YUI Doc要求源代码中使用类似Javadoc的注释。默认的HTML可以通过修改默认的HTML模板文件和相关的样式表来更改。

## D.5 安全执行环境

### D.5.1 ADsafe

ADsafe是JavaScript的子集，这个子集被认为可以被第三方脚本安全访问。对于用ADsafe运行的代码，页面必须包含ADsafe JavaScript库并标记为ADsafe挂件格式。因此，代码可以在任何页面上安全执行。

### D.5.2 Caja 

Caja用一种独特的方式来确保JavaScript的安全执行。类似于ADsafe，Caja定义了JavaScript的一个可以用安全方式使用的子集。Caja继而可以清理JavaScript代码并验证它只按照预期的方式运行。作为该项目的一部分，有一种叫做Cajita的语言，它是JavaScript功能的一种更小的子集。