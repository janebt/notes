# 第1章 JavaScript是什么 #
## 1.1 历史简述 ##
## 1.2 JavaScript实现 ##
- 组成:
  核心(ECMAScript)
  文档对象模型(DOM)
  浏览器对象模型(BOM)

### 1.2.1 ECMAScript ###
- ECMAScript仅仅是一个描述，定义了脚本语言的所有属性、方法和对象。其他语言可以实现ECMAScript作为功能的基准。
- 每个浏览器都有自己的ECMAScript接口实现，然后这个实现又被扩展。

##### 1.ECMAScript的版本 #####
##### 2.什么是ECMAScript兼容 #####
一个脚本语言必须满足下列四项原则(e.g. ECMA-262):

- 按照ECMA-262中描述的支持所有的“类型、值、对象、属性、函数和程序语法及语义”
- 支持Unicode字符标准
- 可以增加没有在ECMA-262中指定的“额外的类型、值、对象、属性和函数”，
- 可以支持没有在ECMA-262中定义的“程序和正则表达式语法”

#### 3.Web浏览器中的ECMAScript支持 ####

### 1.2.2 文档对象模型DOM ###
- DOM（文档对象模型）是HTML和XML的API。DOM把整个页面规划成由节点层次构成的文档。DOM通过创建树来表示文档。

##### 1. 为什么要使用DOM  #####

##### 2. DOM级别 #####
- DOM Level1：DOM Core + DOM HTML。前者提供基于XML的文档结构图，后者添加HTML专用的对象和方法扩展DOM Core。目标只有规划文档结构。
- DOM Level2：引入几种DOM新模块：
  DOM视图————描述跟踪文档的各种视图(即CSS样式化之前和CSS样式化之后的文档)的接口
  DOM事件————描述事件的接口
  DOM样式————描述处理基于CSS样式的接口
  DOM遍历和范围————描述遍历和操作文档树的接口
- DOM Level3：引入了以统一的方式载入和保存文档的方法以及验证文档的方法。

##### 3.其他DOM #####
##### 4.Web浏览器中的DOM支持 #####

### 1.2.3 浏览器对象模型（BOM） ###
- 从根本上讲，BOM只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的JavaScript扩展算作BOM的一部分。

## 1.3 JavaScript版本

## 1.4 小结 ##



# 第2章 在 HTML 中使用 JavaScript 

## 2.1 <script>元素

HTML 4.01为\<script>定义了下列6个属性。

-  async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。
-  charset：可选。表示通过src属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。
-  defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。IE7及更早版本对嵌入脚本也支持这个属性。
-  language：已废弃。原来用于表示编写代码使用的脚本语言（如JavaScript、JavaScript1.2或VBScript）。大多数浏览器会忽略这个属性，因此也没有必要再用了。
-  src：可选。表示包含要执行代码的外部文件。
-  type：可选。可以看成是language的替代属性；表示编写代码使用的脚本语言的内容类型（也称为MIME类型）。考虑到约定俗成和最大限度的浏览器兼容性，目前type 属性的值依旧还是text/javascript。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为text/javascript。


1. 需要注意的是，带有src属性的\<script>元素不应该在其\<script>和\</script>标签之间再包含额外的JavaScript代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。
2. 无论如何包含代码，只要不存在defer和async属性，浏览器都会按照\<script>元素在页面中出现的先后顺序对它们依次进行解析。

### 2.1.1 标签的位置

- 在文档的\<head>元素中包含所有JavaScript文件，意味着必须等到全部JavaScript代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到\<body>标签时才开始呈现内容）。
- 现代Web应用程序一般都把全部JavaScript引用放在\<body>元素中页面内容的后面

### 2.1.2 延迟脚本

- HTML 4.01为\<script>标签定义了defer属性。这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在\<script>元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。
- 在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在DOMContentLoaded事件触发前执行，因此最好只包含一个延迟脚本。
- defer属性只适用于外部脚本文件。这一点在HTML5中已经明确规定，因此支持HTML5的实现会忽略给嵌入脚本设置的defer属性。
- IE4～IE7还支持对嵌入脚本的defer属性，但IE8及之后版本则完全支持HTML5规定的行为。把延迟脚本放在页面底部仍然是最佳选择。
- 在XHTML文档中，要把defer属性设置为defer="defer"。

### 2.1.3 异步脚本

- async只适用于外部脚本文件，并告诉浏览器立即下载文件。但与defer不同的是，标记为async的脚本并不保证按照指定它们的先后顺序执行。

- 建议异步脚本不要在加载期间修改DOM。
- 异步脚本一定会在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。支持异步脚本的浏览器有Firefox 3.6、Safari 5和Chrome。
- XHTML文档中，要把async属性设置为async="async

### 2.1.4 在XHTML中的用法

- 可扩展超文本标记语言，即XHTML（Extensible HyperText Markup Language），是将HTML作为XML的应用而重新定义的一个标准。


- 避免在XHTML中出现类似语法错误的方法有两个。
  1. 用相应的HTML实体（<）替换代码中所有的小于号（<）
  2. 用一个CData片段来包含JavaScript代码。在XHTML（XML）中，CData片段是文档中的一个特殊区域，这个区域中可以包含不需要解析的任意格式的文本内容。


- 在将页面的MIME类型指定为"application/xhtml+xml"的情况下会触发XHTML模式。并不是所有浏览器都支持以这种方式提供XHTML文档。

### 2.1.5 不推荐使用的语法

- Netscape与Mosaic协商并提出了一个解决方案，让不支持\<script>元素的浏览器能够隐藏嵌入的JavaScript代码。这个方案就是把JavaScript代码包含在一个HTML注释中

## 2.2 嵌入代码与外部文件

- 在HTML中嵌入JavaScript代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含JavaScript代码。
  - 可维护性：遍及不同HTML页面的JavaScript会造成维护问题。
  - 可缓存：浏览器能够根据具体的设置缓存链接的所有外部JavaScript文件。
  - 适应未来：通过外部文件来包含JavaScript无须使用前面提到XHTML或注释hack。

## 2.3 文档模式

- IE5.5 引入了文档模式的概念,最初的两种文档模式是：混杂模式（quirks mode）和标准模式。
- IE又提出一种所谓的准标准模式（almost standards mode）


- 如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。


- 对于标准模式，可以通过使用下面任何一种文档类型来开启：

  ```
  <!-- HTML 4.01 严格型--> 
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" 
  "http://www.w3.org/TR/html4/strict.dtd"> 

  <!-- XHTML 1.0 严格型--> 
  <!DOCTYPE html PUBLIC 
  "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"> 

  <!-- HTML 5 --> 
  <!DOCTYPE html> 
  ```


- 对于准标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发.e.g.

  ```
  <!-- HTML 4.01 过渡型--> 
  <!DOCTYPE HTML PUBLIC 
  "-//W3C//DTD HTML 4.01 Transitional//EN" 
  "http://www.w3.org/TR/html4/loose.dtd"> 

  <!-- HTML 4.01 框架集型--> 
  <!DOCTYPE HTML PUBLIC 
  "-//W3C//DTD HTML 4.01 Frameset//EN" 
  "http://www.w3.org/TR/html4/frameset.dtd"> 

  <!-- XHTML 1.0 过渡型--> 
  <!DOCTYPE html PUBLIC 
  "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 

  <!-- XHTML 1.0 框架集型--> 
  <!DOCTYPE html PUBLIC 
  "-//W3C//DTD XHTML 1.0 Frameset//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"> 
  ```

## 2.4 <noscript>元素

- 用以在不支持JavaScript 的浏览器中显示替代的内容。
- 这个元素可以包含能够出现在档\<body>中的任何HTML元素——\<script>元素除外。
- 包含在\<noscript>元素中的内容只有在下列情况下才会显示出来：
  - 浏览器不支持脚本；
  - 浏览器支持脚本，但脚本被禁用。

## 2.5小结

-  在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。
-  所有\<script>元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用defer 和async 属性的情况下，只有在解析完前面\<script>元素中的代码之后，才会开始解析后面\<script>元素中的代码。
-  由于浏览器会先解析完不使用defer属性的\<script>元素中的代码，然后再解析后面的内容，所以一般应该把\<script>元素放在页面最后，即主要内容后面，\</body>标签前面。
-  使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。
-  使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。

# 第3章 基本概念 #

## 3.1 语法 ##
### 3.1.1 区分大小写

### 3.1.2 标识符

- 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其他字符可以是字母、下划线、美元符号或数字。
- 按照惯例，ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写

### 3.1.3 注释

### 3.1.4 严格模式

- 严格模式是为JavaScript定义了一种不同的解析与执行模型。在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。


- 要在整个脚本中启用严格模式，可以在顶部添加如下代码：

  ```
  "use strict"; 
  ```


- 严格模式下，JavaScript 的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支持严格模式的浏览器包括IE10+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。

### 3.1.5 语句

## 3.2 关键字和保留字

- 保留字某种意义是为将来的关键字保留的单词。


- 第5版把在非严格模式下运行时的保留字缩减为下列这些：

  class	 enum	 extends		super 

  const	 export	 import 

- 在严格模式下，第5版还对以下保留字施加了限制：

  implements		package		public 

  interface 		private 		static 

  let 				protected 	yield 

## 3.3 变量 ##
- 在严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。

PS：

- 变量应遵循一条著名的命名规则:
  Gamel标记法————首字母小写，接下来单词大写开头
  Pascal标记法————首字母大写，接下来单词大写开头
  匈牙利类型标记法————在Pascal标记法的变量前附加一个小写字母（或小写字母序列），说明类型。

  ```
  类型					前缀
  数组					a
  布尔型				b
  浮点型（数字）		f
  函数					fn
  整型（数字）			i
  对象					o
  正则表达式			re
  字符串				s
  变型（可以是任何类型）	v
  ```

- ECMAScript的解释程序遇到未声明过的标识符时，用该变量名创建一个全局变量，并将其初始化成指定的值。

## 3.4 数据类型

- ECMAScript中有5种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。还有1种复杂数据类型——Object，Object本质上是由一组无序的名值对组成的

### 3.4.1 typeof操作符

- 对变量或值调用typeof返回：undefined、boolen、number、string、object（引用类型Object或空类型）、function
- 注意，typeof是一个操作符而不是函数，圆括号尽管可以使用，但不是必需的。
- 有些时候，typeof操作符会返回一些令人迷惑但技术上却正确的值。比如，调用typeof null会返回"object"，因为特殊值null被认为是一个空的对象引用。Safari 5及之前版本、Chrome 7及之前版本在对正则表达式调用typeof操作符时会返回"function"，而其他浏览器在这种情况下会返回"object"。
- 从技术角度讲，函数在ECMAScript中是对象，不是一种数据类型。然而，函数也
  确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。

### 3.4.2 Undefined类型

- 当声明的变量未初始化时，默认值是undefined。
- 对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型（对未经声明的变量调用delete不会导致错误，但这样做没什么实际意义，而且在严格模式下确实会导致错误）。
- 注意，undefined并不同于未定义的值，但typeof运算符并不真正区分这两种值,都会返回undefined值。
- 当函数无明确返回值时，返回值也是undefined

### 3.4.3 Null类型

- 从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回"object"的原因
- 值undefined实际是从值null派生来的，因此两者相等
- 两者含义不同，undefined是声明了变量但未初始化，null表示尚未存在的对象。如果函数或方法要返回对象，返回通常是null。
- 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用
- 只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。

### 3.4.4 Boolean类型

- 有两个值true和false

- 即使false不等于0,0也可以转换成false

- 需要注意的是，Boolean类型的字面值true和false是区分大小写的。

- 可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。

  | 数据类型      | 换为true的值            | 转换为false的值 |
  | --------- | ------------------- | ---------- |
  | Boolean   | true                | false      |
  | String    | 任何非空字符串             | ""（空字符串）   |
  | Number    | 任何非零数字值（包括无穷大）      | 0和NaN      |
  | Object    | 任何对象                | null       |
  | Undefined | N/A（not applicable） | undefined  |

### 3.4.5 Number类型

- 使用IEEE754格式来表示整数和浮点数值
- 整数可以代表8进制（0开头）和16进制（0x开头），返回的结果都是十进制结果。
- 八进制字面量在严格模式下是无效的，会导致支持的JavaScript引擎抛出错误。

#### 1.浮点数值

- 浮点数必须包括小数点和小数点后的一位数字。
- ECMAScript会不失时机地将浮点数值转换为整数值。
- 浮点变量在计算前，真正存储的是字符串。
- 指数:e表示法（即科学计数法）e.g.3.2e7,3-e7
- 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。

#### 2.数值范围

几个特殊值也是Number类型:

- Number.MAX_VALUE和Number.MIN_VALUE，它们定义乐乐Number值集合的外边界。不过计算生成的值可以不在其间。


- 当生成数大于Number.MAX_VALUE，被赋值Number.POSITIVE_INFINITY,同样也有Number.NEGATIVE_INFINITY。可以调用isFinit()方法，确保该数不是无穷大。


- 访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正Infinity 的值。

#### 3.NaN

- NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。
- 任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。
- NaN与任何值都不相等，包括NaN本身。
- isNaN()函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试将这个值转换为数值。

#### 4.数值转换

- 有3个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。

##### Number()函数的转换规则：

- 如果是Boolean值，true和false将分别被转换为1和0。
- 如果是数字值，只是简单的传入和返回。
- 如果是null值，返回0。
- 如果是undefined，返回NaN。


- 如果是字符串，遵循下列规则：
  - 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值
  - 如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值（同样，也会忽略前导零）
  - 如果字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值
  - 如果字符串是空的（不包含任何字符），则将其转换为0；
  - 如果字符串中包含除上述格式之外的字符，则将其转换为NaN。


- 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。

##### parseInt()

- parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN；也就是说，用parseInt()转换空字符串会返回NaN（Number()对空字符返回0）。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。
- 如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式
- 在使用parseInt()解析像八进制字面量的字符串时，ECMAScript 3和5存在分歧。e.g.在ECMAScript 5 JavaScript引擎中，parseInt()已经不具有解析八进制值的能力，因此前导的零会被认为无效
- 为了消除在使用parseInt()函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。

##### parseFloat()

- 除了第一个小数点有效之外，parseFloat()与parseInt()的第二个区别在于它始终都会忽略前导的零。
- parseFloat()只解析十进制值，十六进制格式的字符串则始终会被转换成0
- 如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。

### 3.4.6 String类型

- 没有固定大小的原始值，用字符串存储0或更多的Unicode字符（由16位整数表示）
- 字面常量由""或’‘声明，两者功能相同。
- isNaN()确实也适用于对象。在基于对象调用isNaN()函数时，会首先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用toString()方法，再测试返回值。而这个过程也是ECMAScript中内置函数和操作符的一般执行流程

#### 1. 字符字面量

#### 2. 字符串的特点

- ECMAScript中的字符串是不可变的。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量

#### 3. 转换为字符串

##### toString()方法

- 数值、布尔值、对象和字符串值（没错，每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有toString()方法。但null和undefined值没有这个方法。


- 在调用数值的toString()方法时，可以传递一个参数：输出数值的基数

##### String()

- 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果
- 如果值是null，则返回"null"
- 如果值是undefined，则返回"undefined"

### 3.4.7 Object类型

- 在ECMAScript中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。（但这不是推荐的做法）


- Object的每个实例都具有下列属性和方法
  -  constructor：保存着用于创建当前对象的函数。
  -  hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定 
  -  isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型。
  -  propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
  -  toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
  -  toString()：返回对象的字符串表示。
  -  valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。


- ECMA-262中对象的行为不一定适用于JavaScript中的其他对象。浏览器环境中的对象，比如BOM和DOM中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。

## 3.5 操作符

### 3.5.1 一元操作符

#### 1. 递增和递减操作符

- 这4个操作符对任何值都适用，遵循下列规则
  -  在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字符串变量变成数值变量。
  -  在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN
            字符串变量变成数值变量。
  -  在应用于布尔值false时，先将其转换为0再执行加减1的操作。布尔值变量变成数值变量。
  -  在应用于布尔值true时，先将其转换为1再执行加减1的操作。布尔值变量变成数值变量。
  -  在应用于浮点数值时，执行加减1的操作。
  -  在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。

#### 2. 一元加和减操作符

- 一元加操作符放在数值前面，对数值不会产生任何影响
- 在对非数值应用一元加操作符时，一元加操作符会像Number()转型函数一样对这个值执行转换。
- 一元减操作符应用于数值时，该值会变成负数
- 当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数

### 3.5.2 位操作符

- ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。


- 负数同样以二进制码存储，但使用的格式是二进制补码。


- 这个转换过程也导致了一个严重的副效应，即在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理。


- 如果对非数值应用位操作符，会先使用Number()函数将该值转换为一个数值（自动完成），然后
  再应用位操作。得到的结果将是一个数值。

#### 1. 按位非（NOT）

- 按位非操作的本质：操作数的负值减1。

#### 2. 按位与（AND）

#### 3. 按位或（OR

#### 4. 按位异或（XOR）

#### 5. 左移

- 左移不会影响操作数的符号位。

#### 6. 有符号的右移

- 符号位的值来填充空位

#### 7. 无符号右移

- 无符号右移是以0来填充空位

### 3.5.3 布尔操作符

#### 1. 逻辑非

- 逻辑非操作符遵循下列规则：
  - 如果操作数是一个对象，返回false；
  - 如果操作数是一个空字符串，返回true；
  - 如果操作数是一个非空字符串，返回false；
  - 如果操作数是数值0，返回true；
  - 如果操作数是任意非0数值（包括Infinity），返回false；
  - 如果操作数是null，返回true；
  - 如果操作数是NaN，返回true；
  - 如果操作数是undefined，返回true。


- 同时使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为

#### 2. 逻辑与

- 遵循规则：
  -  如果第一个操作数是对象，则返回第二个操作数；
  -  如果第二个操作数是对象，则只有在第一个操作数的求值结果为true 的情况下才会返回该对象；
  -  如果两个操作数都是对象，则返回第二个操作数；
  -  如果有一个操作数是null，则返回null；
  -  如果有一个操作数是NaN，则返回NaN；
  -  如果有一个操作数是undefined，则返回undefined。

#### 3. 逻辑或

- 遵循规则：
  - 如果第一个操作数是对象，则返回第一个操作数；
  - 如果第一个操作数的求值结果为false，则返回第二个操作数；
  - 如果两个操作数都是对象，则返回第一个操作数；
  - 如果两个操作数都是null，则返回null；
  - 如果两个操作数都是NaN，则返回NaN；
  - 如果两个操作数都是undefined，则返回undefined。

### 3.5.4 乘性操作符

#### 1. 乘法

- 遵循规则：
  - 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而
    如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；
  - 如果有一个操作数是NaN，则结果是NaN；
  - 如果是Infinity与0相乘，则结果是NaN；
  - 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号； 
  - 如果是Infinity与Infinity相乘，则结果是Infinity；
  - 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

#### 2. 除法

- 遵循规则：
  - 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而
    如果只有一个操作数有符号，那么结果就是负数。如果商超过了ECMAScript数值的表示范围，
    则返回Infinity或-Infinity；
  - 如果有一个操作数是NaN，则结果是NaN；
  - 如果是Infinity被Infinity除，则结果是NaN；
  - 如果是零被零除，则结果是NaN；
  - 如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
  - 如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
  - 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

#### 3.求模

- 遵循规则：
  - 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
  - 如果被除数是无穷大值而除数是有限大的数值，则结果是NaN；
  - 如果被除数是有限大的数值而除数是零，则结果是NaN；
  - 如果是Infinity被Infinity除，则结果是NaN；
  - 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
  - 如果被除数是零，则结果是零；
  - 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

### 3.5.5 加性操作符

#### 1. 加法

- 如果两个操作符都是数值，遵循规则：
  - 如果有一个操作数是NaN，则结果是NaN；
  - 如果是Infinity加Infinity，则结果是Infinity；
  - 如果是-Infinity加-Infinity，则结果是-Infinity；
  - 如果是Infinity加-Infinity，则结果是NaN；
  - 如果是+0加+0，则结果是+0；
  - 如果是0加0，则结果是0；
  - 如果是+0加0，则结果是+0。


- 如果两个操作符都是数值，遵循规则：
  - 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
  - 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。


- 如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。
- 对于undefined和null，则分别调用String()函数并取得字符串"undefined"和"null"。

#### 2. 减法

- 遵循规则：
  - 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；
  - 如果有一个操作数是NaN，则结果是NaN；
  - 如果是Infinity减Infinity，则结果是NaN；
  - 如果是-Infinity减-Infinity，则结果是NaN；
  - 如果是Infinity减-Infinity，则结果是Infinity；
  - 如果是-Infinity减Infinity，则结果是-Infinity；
  - 如果是+0减+0，则结果是+0；
  - 如果是+0减-0，则结果是-0
  - 如果是-0减-0，则结果是+0；
  - 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN；
  - 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

### 3.5.6 关系操作符

- 遵循规则：
  - 如果两个操作数都是数值，则执行数值比较。
  - 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
  - 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
  - 如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较。
  - 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。

### 3.5.7 相等操作符

#### 1. 相等和不相等

- 转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：
  - 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
  - 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
  - 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较


- 遵循规则:
  - null和undefined是相等的。
  - 要比较相等性之前，不能将null和undefined转换成其他任何值。
  - 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN。
  - 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

#### 2. 全等和不全等

- 除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符由3个等于号（===）表示，它只在两个操作数未经转换就相等的情况下返回true


- 由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。

### 3.5.8 条件操作符

### 3.5.9 赋值操作符

- 有符号右移/赋值（>>=）
- 无符号右移/赋值（>>>=）

### 3.5.10 逗号操作符

## 3.6语句

### 3.6.1 if语句

### 3.6.2 do-while语句

### 3.6.3 while语句

### 3.6.4 for语句

### 3.6.5 for-in语句

- for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。

  ```
  for (property in expression) statement
  ```


- ECMAScript对象的属性没有顺序。因此，通过for-in循环输出的属性名的顺序是不可预测的。


- 如果表示要迭代的对象的变量值为null 或undefined，for-in 语句会抛出错误。ECMAScript 5更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined。

### 3.6.6 label语句

### 3.6.7 break和continue语句

### 3.6.8 with语句

- with语句的作用是将代码的作用域设置到一个特定的对象中。


- with语句的语法如下：

  ```
  with (expression) statement; 
  ```


- 定义with语句的目的主要是为了简化多次编写同一个对象的工作


- 在with语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location对象中是否有同名的属性。如果发现了同名属性，则以location对象属性的值作为变量的值。


- 严格模式下不允许使用with语句，否则将视为语法错误。


- 由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。

### 3.6.9 switch语句

- 首先，可以在switch语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。
- 其次，每个case的值不一定是常量，可以是变量，甚至是表达式。


- switch语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串"10"不等于数值10）。

## 3.7 函数

- return语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回undefined值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。


- 严格模式对函数有一些限制：
  -  不能把函数命名为eval或arguments；
  -  不能把参数命名为eval或arguments；
  -  不能出现两个命名参数同名的情况。

### 3.7.1 理解参数

- ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。


- 实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。
- ECMAScript函数的一个重要特点：命名的参数只提供便利，但不是必需的。
- 另外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。但在ECMAScript中，没有这些条条框框，解析器不会验证命名参数。
- 另一个与参数相关的重要方面，就是arguments对象可以与命名参数一起使用
- 没有传递值的命名参数将自动被赋予undefined值。这就跟定义了变量但又没有初始化一样。
- 严格模式对如何使用arguments对象做出了一些限制。首先，有些赋值（直接修改arguments等）会变得无效。其次，重写arguments的值会导致语法错误（代码将不会执行）。
- ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。

### 3.7.2 没有重载

- ECMAScript函数不能像传统意义上那样实现重载。
- ECMAScirpt函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。
- 如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。
- 通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。

## 3.8小结

# 第4章 变量、作用域和内存问题

## 4.1 基本类型和引用类型的值

- 在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。
- 与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。
- 引用类型的值是按引用访问的

### 4.1.1 动态的属性

### 4.1.2 复制变量值

### 4.1.3 传递参数

### 4.1.4 检测类型

- ECMAScript提供了instanceof操作符

  ```
  result= variableinstanceof constructor
  ```


- IE和Firefox中，对正则表达式应用typeof会返回"object"。

## 4.2 执行环境及作用域

- 每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。
- 在Web浏览器中，全局执行环境被认为是window对象
- 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。


- 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。

### 4.2.1 延长作用域链

- 有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。
  - try-catch语句的catch块；
  - with语句。


- 对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。


- 在IE8 及之前版本的JavaScript 实现中，存在一个与标准不一致的地方，即在catch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句的变量对象中。换句话说，即使是在catch块的外部也可以访问到错误对象。IE9修复了这个问题。

### 4.2.2 没有块级作用域

- 在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。在使用for语句时尤其要牢记这一差异，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在
  于循环外部的执行环境中。

#### 1. 声明变量

- 使用var声明的变量会自动被添加到最接近的环境中。

#### 2. 查询标识符

- 搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。

## 4.3 垃圾收集

- 垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，通常有两个策略。

### 4.3.1 标记清除

- 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

### 4.3.2 引用计数

- 引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。
- BOM和DOM中的对象就是使用C++以COM（Component Object Model，组件对象模型）对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。
- 只要在IE中涉及COM对象，就会存在循环引用的问题。


- IE9把BOM和DOM对象都转换成了真正的JavaScript对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。

### 4.3.3 性能问题

- IE的垃圾收集器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象（或数组）字面量和数组元素（slot）或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。


- IE7改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。


- 事实上，在有的浏览器中可以触发垃圾收集过程，但不建议这样做。在IE中，调用window.CollectGarbage()方法会立即执行垃圾收集。在Opera 7及更高版本中，调用window.opera.collect()也会启动垃圾收集例程。

### 4.3.4 管理内存

- 其中最主要的一个问题，就是分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。


- 优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用（dereferencing）。


- 解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收

## 4.4 小结

- 引用类型的值是对象，保存在堆内存中；
- 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符
- 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
- 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；

# 第5章 引用类型 

- 在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。
- 引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。
- 虽然引用类型与类看起来相似，但它们并不是相同的概念。

## 5.1 Object类型

- 创建Object实例的方式有两种。
  - 第一种是使用new操作符后跟Object构造函数
  - 另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。


- 使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象


- 在通过对象字面量定义对象时，实际上不会调用Object构造函数（Firefox 2及更早版本会调用Object构造函数；但Firefox 3之后就不会了）。


- 一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。


- 方括号语法Vs点表示法：
  - 主要优点是可以通过变量来访问属性
  - 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。


- 通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。

## 5.2 Array类型

- 创建数组的基本方式有两种。
  - 第一种是使用Array构造函数
    - 可以给构造函数传递该数量
    - 可以向Array构造函数传递数组中应该包含的项
    - 在使用Array构造函数时也可以省略new操作符
  - 第二种基本方式是使用数组字面量表示法


- 在数组字面量的最后一项添加逗号的结果：在IE中，values会成为一个包含3个项且每项的值分别为1、2和undefined的数组；在其他浏览器中，values会成为一个包含2项且值分别为1和2的数组。在像这种省略值的情况下，IE8及之前版本每一项都将获得undefined值；


- 与对象一样，在使用数组字面量表示法时，也不会调用Array构造函数


- 数组的length属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。再访问就会显示undefined


- 如果将其length属性设置为大于数组项数的值，则新增的每一项都会取得undefined值


- 数组最多可以包含4 294 967 295个项，而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。

### 5.2.1 检测数组

- 对于一个网页，或者一个全局作用域而言，使用instanceof操作符就能得到满意的结果问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。


- Array.isArray()方法，这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。用法如下：

  ```
  if (Array.isArray(value)){ 
  //对数组执行某些操作
  } 
  ```


- 支持Array.isArray()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 10.5+和Chrome。

### 5.2.2 转换方法

- 调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。
- 调用valueOf()返回的还是数组。


- 当调用数组的toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的toLocale- String()方法，而不是toString()方法。


- alert()要接收字符串参数，所以它会在后台调用toString()方法
- 数组继承的toLocaleString()、toString()和valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。


- 如果使用join()方法，则可以使用不同的分隔符来构建这个字符串。join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。


- 如果数组中的某一项的值是null 或者undefined，那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示。

### 5.2.3 栈方法

- push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。
- pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。

### 5.2.4 队列方法

- shift()，它能够移除数组中的第一个项并返回该项，同时将数组长度减1。
- ECMAScript还为数组提供了一个unshift()方法。顾名思义，unshift()与shift()的用途相反：它能在数组前端添加任意个项并返回新数组的长度。


- IE7及更早版本对JavaScript的实现中存在一个偏差，其unshift()方法总是返回undefined而不是数组的新长度。IE8在非兼容模式下会返回正确的长度值。

### 5.2.5 重排序方法

- reverse()方法会反转数组项的顺序。
- 默认情况，sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。因此，这种排序方式在很多情况下都不是最佳方案。

### 5.2.6 操作方法

- concat()方法
  - 可以基于当前数组中的所有项创建一个新数组。
  - 具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。


- slice()方法
  - 它能够基于当前数组中的一或多个项创建一个新数组。
  - slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。
  - 在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。
  - 如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。
  - 注意，slice()方法不会影响原始数组。
  - 如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。
  - 如果结束位置小于起始位置，则返回空数组。


- splice()方法
  - 主要用途是向数组的中部插入项
  - 使用方式：
    - **删除**：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。
    - **插入**：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。
    - **替换**：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起
      始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。
  - 返回一个数组，该数组中包含从原始数组中删除的项

### 5.2.7 位置方法

- indexOf()和lastIndexOf()。
  - 都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。
  - 其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。
  - 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1
  - 在比较第一个参数与数组中的每一项时，会使用全等操作符
  - 支持它们的浏览器包括IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。

### 5.2.8 迭代方法

- 定义了5个迭代方法。
  - 每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值。
  - 传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。
  - 返回值
    - every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true
    - filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。
    - forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
    - map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
    - some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
  - 以上方法都不会修改数组中的包含的值。
  - every()和some()，它们都用于查询数组中的项是否满足某个条件。
  - forEach()本质上与使用for循环迭代数组一样。
  - 支持这些迭代方法的浏览器有IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。

### 5.2.9 归并方法

- reduce()和reduceRight()。
  - 都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。
  - 都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。
  - 支持这两个归并函数的浏览器有IE9+、Firefox 3+、Safari 4+、Opera 10.5和Chrome。

## 5.3 Date类型

- Date类型使用自UTC


- 为了简化传入表示该日期的毫秒数的过程，提供了两个方法：Date.parse()和Date.UTC()。
- Date.parse()
  - Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。
  - ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。美国的浏览器通常都接受下列日期格式：
    - “月/日/年”，如6/13/2004；
    - “英文月名 日,年”，如January 12,2004；
    - “英文星期几 英文月名 日 年 时:分:秒 时区”，如Tue May 25 2004 00:00:00 GMT-0700。
    - ISO 8601 扩展格式YYYY-MM-DDTHH:mm:ss.ss（例如2004-05-25T00:00:00）。只有兼容
      ECMAScript 5的实现支持这种格式。
  - 如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。
  - 不同浏览器中的实现有许多奇怪的行为，有一种倾向是将超出范围的值替换成当前的值，以便生成输出。而Opera则倾向于插入当前月份的当前日期


- Date.UTC()
  - 返回表示日期的毫秒数。
  - Date.UTC()的参数分别是年份、基于0的月份（一月是0，二月是1，以此类推）、月中的哪一天（1到31）、小时数（0到23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0。


- ECMAScript 5添加了Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。
  - 支持Data.now()方法的浏览器包括IE9+、Firefox 3+、Safari 3+、Opera 10.5和Chrome。在不支
    持它的浏览器中，使用+操作符把Data对象转换成字符串，也可以达到同样的目的。

### 5.3.1 继承的方法

- Date类型也重写了toLocaleString()、toString()和valueOf()方法
  - Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息
  - toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。
  - Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。。因此，可以方便使用比较操作符（小于或大于）来比较日期值。

### 5.3.2 日期格式化方法

- 将日期格式化为字符串的方法
  - toDateString()——以特定于实现的格式显示星期几、月、日和年；
  - toTimeString()——以特定于实现的格式显示时、分、秒和时区；
  - toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
  - toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
  - toUTCString()——以特定于实现的格式完整的UTC日期。


-  还有一个名叫toGMTString()的方法，这是一个与toUTCString()等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript推荐现在编写的代码一律使用toUTCString()方法。

### 5.3.3日期/时间组件方法

- UTC日期指的是在没有时区偏差的情况下（将日期转换为GMT时间）的日期值。

| 方 法                    | 说 明                                    |
| :--------------------- | :------------------------------------- |
| getTime()              | 返回表示日期的毫秒数；与valueOf()方法返回的值相同          |
| setTime(毫秒)            | 以毫秒数设置日期，会改变整个日期                       |
| getFullYear()          | 取得4位数的年份（如2007而非仅07）                   |
| getUTCFullYear()       | 返回UTC日期的4位数年份                          |
| setFullYear(年)         | 设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）      |
| setUTCFullYear(年)      | 设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）   |
| getMonth()             | 返回日期中的月份，其中0表示一月，11表示十二月               |
| getUTCMonth()          | 返回UTC日期中的月份，其中0表示一月，11表示十二月            |
| setMonth(月)            | 设置日期的月份。传入的月份值必须大于0，超过11则增加年份          |
| setUTCMonth(月)         | 设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份       |
| getDate()              | 返回日期月份中的天数（1到31）                       |
| getUTCDate()           | 返回UTC日期月份中的天数（1到31）                    |
| setDate(日)             | 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份     |
| setUTCDate(日)          | 设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份  |
| getDay()               | 返回日期中星期的星期几（其中0表示星期日，6表示星期六）           |
| getUTCDay()            | 返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六）        |
| getHours()             | 返回日期中的小时数（0到23）                        |
| getUTCHours()          | 返回UTC日期中的小时数（0到23）                     |
| setHours(时)            | 设置日期中的小时数。传入的值超过了23则增加月份中的天数           |
| setUTCHours(时)         | 设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数        |
| getMinutes()           | 返回日期中的分钟数（0到59）                        |
| getUTCMinutes()        | 返回UTC日期中的分钟数（0到59）                     |
| setMinutes(分)          | 设置日期中的分钟数。传入的值超过59则增加小时数               |
| setUTCMinutes(分)       | 设置UTC日期中的分钟数。传入的值超过59则增加小时数            |
| getSeconds()           | 返回日期中的秒数（0到59）                         |
| getUTCSeconds()        | 返回UTC日期中的秒数（0到59）                      |
| setSeconds(秒)          | 设置日期中的秒数。传入的值超过了59会增加分钟数               |
| setUTCSeconds(秒)       | 设置UTC日期中的秒数。传入的值超过了59会增加分钟数            |
| getMilliseconds()      | 返回日期中的毫秒数                              |
| getUTCMilliseconds()   | 返回UTC日期中的毫秒数                           |
| setMilliseconds(毫秒)    | 设置日期中的毫秒数                              |
| setUTCMilliseconds(毫秒) | 设置UTC日期中的毫秒数                           |
| getTimezoneOffset()    | 返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某 |

## 5.4 RegExp类型

- 语法

  ```
  var expression = /pattern/ flags ;
  ```
  - 模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。
    - g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
    - i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
    - m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。


- 模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：( [ { \ ^ $ | ) ? * + .]} 


- 另一种创建正则表达式的方式是使用RegExp构造函数
  - 它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。
  - 由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此（例如字符\会变成`\\\\`）


- 在ECMAScript 3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例


- ECMAScript 5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例。IE9+、Firefox 4+和Chrome都据此做出了修改。

### 5.4.1 RegExp实例属性

- RegExp属性
  -  global：布尔值，表示是否设置了g标志。
  -  ignoreCase：布尔值，表示是否设置了i标志。
  -  lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。
  -  multiline：布尔值，表示是否设置了m标志。
  -  source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。

### 5.4.2 RegExp实例方法

- 主要方法是exec()，该方法是专门为捕获组而设计的。
  - exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。
  - 返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。
  - 对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不
    设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项
  - IE 的JavaScript 实现在lastIndex 属性上存在偏差，即使在非全局模式下，lastIndex属性每次也会变化。


- 第二个方法是test()
  - 接受一个字符串参数
  - 在模式与该参数匹配的情况下返回true；否则，返回false。
  - test()方法经常被用在if语句中
- RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。即使是通过调用RegExp构造函数创建的。
- 正则表达式的valueOf()方法返回正则表达式本身。


### 5.4.3 RegExp构造函数属性

- RegExp构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。

- 这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。

- 这些属性分别有一个长属性名和一个短属性名（Opera是例外，它不支持短属性名）。

  - | 长属性名         | 短属性名 | 说 明                                 |
    | ------------ | ---- | ----------------------------------- |
    | input        | $_   | 最近一次要匹配的字符串。Opera未实现此属性             |
    | lastMatch    | $&   | 最近一次的匹配项。Opera未实现此属性                |
    | lastParen    | $+   | 最近一次匹配的捕获组。Opera未实现此属性              |
    | leftContext  | $`   | input字符串中lastMatch之前的文本             |
    | multiline    | $*   | 布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性 |
    | rightContext | $'   | Input字符串中lastMatch之后的文本             |

  - 由于这些短属性名大都不是有效的ECMAScript标识符，因此必须通过方括号语法来访问它们

- 还有多达9个用于存储捕获组的构造函数属性。访问这些属性的语法是RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。

### 5.4.4 模式的局限性

- ECMAScript正则表达式不支持的特性
  - 匹配字符串开始和结尾的\A和\Z锚（ 但支持以插入符号（^）和美元符号（$）来匹配字符串的开始和结尾。）
  - 向后查找（lookbehind）（但完全支持向前查找（lookahead）。）
  - 并集和交集类
  - 原子组（atomic grouping）
  - Unicode支持（单个字符除外，如\uFFFF）
  - 命名的捕获组(但支持编号的捕获组。)
  - s（single，单行）和x（free-spacing，无间隔）匹配模式
  - 条件匹配
  - 正则表达式注释

## 5.5 Function类型

- 每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。
- 由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。


- 函数定义的方式:
  - 函数声明语法定义

    ```
    function sum (num1, num2) { 
    return num1 + num2; 
    } 
    ```

  - 函数表达式定义

    ```
    var sum = function(num1, num2){ 
    return num1 + num2; 
    }; 
    ```

  - 使用Function构造函数

    ```
    var sum = new Function("num1", "num2", "return num1 + num2");
    ```

    - Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。
    - 不推荐, 因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串）
    - 利于理解“函数是对象，函数名是指针”的概念

### 5.5.1 没有重载（深入理解）

- 将函数名想象为指针，也有助于理解为什么ECMAScript中没有函数重载的概念。


### 5.5.2 函数声明与函数表达式

- 解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。


- 在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。


- 除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。
- 可以同时使用函数声明和函数表达式，例如var sum = function sum(){}。不过，这种语法在Safari中会导致错误。

### 5.5.3 作为值的函数

- 可将一个函数作为另一个函数的结果返回，这也是极为有用的一种技术。



- 要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。

### 5.5.4 函数内部属性

- 函数内部有两个特殊的对象：arguments和this。
- arguments
  - arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。
    - 可解决递归算法的函数的执行与函数名紧密耦合


- this
  - this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。


- ECMAScript 5也规范化了另一个函数对象的属性：caller。（Opera的早期版本不支持）
  - 这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。


- 当函数在严格模式下运行时，访问arguments.callee 会导致错误。ECMAScript 5还定义了arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清arguments.caller和函数的caller属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。

### 5.5.5 函数属性和方法

- ECMAScript中的函数是对象。每个函数都包含两个属性：length和prototype。


- length
  - 表示函数希望接收的命名参数的个数


- prototype
  - 对于ECMAScript中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。
  - 创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的
  - 在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。


- 每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。
- apply()
  - apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。
  - 在严格模式下，未指定环境对象而调用函数，则this值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this 值将是undefined。
- call()方法
  - call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。
  - 对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来
- 事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。



//---缺了很多东西，sigh



# 第8章 BOM

## 8.1 window

### 8.1.1 全局作用域

- 全局变量（函数）会成为window对象的属性

- 定义全局变量与在window对象上直接定义属性差别：

  - 全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。

    [^原因]: 使用var语句添加的window属性有一个名为[[Configurable\]\]的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete操作符删除。IE8及更早版本在遇到使用delete删除window属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9及更高版本不会抛出错误。

  - 尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在。

- Windows Mobile平台的IE浏览器不允许通过window.property = value之类的形式，直接在window对象上创建新的属性或方法。可是，在全局作用域中声明的所有变量和函数，照样会变成window对象的成员。

### 8.1.2 窗口关系及框架

- 如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象。每个window对象都有一个name属性，其中包含框架的名称。


- top对象始终指向最高（最外）层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。因为对于在一个框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而非最高层的框架。所以最好使用top而非window

- parent（父）对象始终指向当前框架的直接上层框架。在某些情况下，parent有可能等于top；但在没有框架的情况下，parent一定等于top（此时它们都等于window）。

  > 注意，除非最高层窗口是通过window.open()打开的（本章后面将会讨论），否则其window对象的name属性不会包含任何值。

- self对象，它始终指向window；实际上，self和window对象可以互换使用。引入self对象的目的只是为了与top和parent对象对应起来，因此它不格外包含其他值。

  > 在使用框架的情况下，浏览器中会存在多个Global对象。在每个框架中定义的全局变量会自动成为框架中window对象的属性。由于每个window对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。例如，top.Object并不等于top.frames[0].Object。这个问题会影响到对跨框架传递的对象使用instanceof操作符。

### 8.1.3 窗口位置

- 使用screenLeft 和screenTop，无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。

  > IE、Safari、Opera和Chrome都提供了screenLeft 和screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox则在screenX和screenY属性中提供相同的窗口位置信息，Safari和Chrome也同时支持这两个属性。Opera虽然也支持screenX和screenY属性，但与screenLeft和screenTop属性并不对应，因此建议大家不要在Opera中使用它们。

  > 在IE、Opera中，screenLeft和screenTop中保存的是从屏幕左边和上边到由window对象表示的页面可见区域的距离。换句话说，如果window对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即y轴坐标为0，那 么screenTop的值就是位于页面可见区域上方的浏览器工具栏的像素高度。但是，在Chrome、Firefox和Safari中，screenY或screenTop中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y轴坐标为0时返回0

  > Firefox、Safari和Chrome始终返回页面中每个框架的top.screenX 和top.screenY 值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用screenX和screenY每次也都会返回相同的值。而IE和Opera则会给出框架相对于屏幕边界的精确坐标值。

- 使用moveTo()和moveBy()方法倒是有可能将窗口精确地移动到一个新位置。两个方法都接收两个参数，moveTo()接收的是新位置的x和y坐标值，而moveBy()接收的是在水平和垂直方向上移动的像素数。

  > 需要注意的是，这两个方法可能会被浏览器禁用；而且，在Opera和IE 7（及更高版本）中默认就是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window对象使用。

### 8.1.4 窗口大小

- 4个属性：innerWidth、innerHeight、outerWidth和outerHeight。

  - 在IE9+、Safari和Firefox中，outerWidth和outerHeight返回浏览器窗口本身的尺寸（无论是从最外层的window对象还是从某个框架访问）。
  - 在Opera中，这两个属性的值表示页面视图容器的大小。而innerWidth和innerHeight
    则表示该容器中页面视图区的大小（减去边框宽度）。
  - 在Chrome中，outerWidth、outerHeight 与innerWidth、innerHeight返回相同的值，即视口（viewport）大小而非浏览器窗口大小。
  - IE8及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过DOM提供了页面可见区域的相关信息。

- 在IE、Firefox、Safari、Opera和Chrome中，document.documentElement.clientWidth和
  document.documentElement.clientHeight中保存了页面视口的信息。在IE6中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过document.body.clientWidth和document.body. clientHeight取得相同信息。而对于混杂模式下的Chrome，则无论通过document.documentEle- ment还是document.body中的clientWidth和clientHeight属性，都可以取得视口的大小。虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小

- 对于移动设备，window.innerWidth和window.innerHeight保存着可见视口，也就是屏幕上可见页面区域的大小。

  - 移动IE 浏览器不支持这些属性，但通过document.documentElement.clientWidth和document.documentElement.clientHeihgt提供了相同的信息。
  - 在其他移动浏览器中，document.documentElement 度量的是布局视口，即渲染后页面的实际大小（与可见视口不同，可见视口只是整个页面中的一小部分）。移动IE 浏览器把布局视口的信息保存在document.body.clientWidth和document.body.clientHeight中。这些值不会随着页面缩放变化。

- 使用resizeTo()和resizeBy()方法可以调整浏览器窗口的大小。resizeTo()接收浏览器窗口的新宽度和新高度，而resizeBy()接收新窗口与原窗口的宽度和高度之差。

  > 这两个方法与移动窗口位置的方法类似，也有可能被浏览器禁用；而且，在Opera和IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的window对象使用。

### 8.1.5 导航和打开窗口

- window.open()方法
  - 接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。
  - 第二个参数， 可以是已有窗口或框架的名称，也可以是特殊的窗口名称：\_self、\_parent、\_top或\_blank。

1. #### 弹出窗口

   - 如果传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。

   - 第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下表列出了可以出现在这个字符串中的设置选项。

     | 设 置        | 值      | 说 明                                      |
     | ---------- | ------ | ---------------------------------------- |
     | fullscreen | yes或no | 表示浏览器窗口是否最大化。仅限IE                        |
     | height     | 数值     | 表示新窗口的高度。不能小于100height  数值  表示新窗口的高度。不能小于100 |
     | left       | 数值     | 表示新窗口的左坐标。不能是负值                          |
     | location   | yes或no | 表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏可能会隐藏，也可能会被禁用（取决于浏览器） |
     | menubar    | yes或no | 表示是否在浏览器窗口中显示菜单栏。默认值为no                  |
     | resizable  | yes或no | 表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为no           |
     | scrollbars | yes或no | 表示如果内容在视口中显示不下，是否允许滚动。默认值为no             |
     | status     | yes或no | 表示是否在浏览器窗口中显示状态栏。默认值为no                  |
     | toolbar    | yes或no | 表示是否在浏览器窗口中显示工具栏。默认值为no                  |
     | top        | 数值     | 表示新窗口的上坐标。不能是负值                          |
     | width      | 数值     | 表示新窗口的宽度。不能小于100                         |

   > 可以通过逗号分隔的名值对列表来指定,其中，名值对以等号表示（注意，整个特性字符串中不允许出现空格）其中，名值对以等号表示（注意，整个特性字符串中不允许出现空格）

- window.open()方法会返回一个指向新窗口的引用。引用的对象与其他window对象大致相似，但我们可以对其进行更多控制。
- close()方法还可以关闭新打开的窗口。
  - 仅适用于通过window.open()打开的弹出窗口。
  - 对于浏览器的主窗口，如果没有得到用户的允许是不能关闭它的。
  - 弹出窗口倒是可以调用top.close()在不经用户允许的情况下关闭自己。弹出窗口关闭之后，窗口的引用仍然还在，但除了像下面这样检测其closed属性之外，已经没有其他用处了。
  - 新创建的window对象有一个opener属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window对象（top）中有定义，而且指向调用window.open()的窗口或框架。
  - 有些浏览器（如IE8和Chrome）会在独立的进程中运行每个标签页。当一个标签页打开另一个标签页时，如果两个window对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。在Chrome中，将新创建的标签页的opener属性设置为null，即表示在单独的进程中运行新标签页

1. #### 安全限制

   - 对弹出窗口施加了多方面的安全限制
   - 在打开计算机硬盘中的网页时，IE会解除对弹出窗口的某些限制。但是在服务器上执行这些代码会受到对弹出窗口的限制。

2. #### 弹出窗口屏蔽程序

   - 如果是浏览器内置的屏蔽程序阻止的弹出窗口，那么window.open()很可能会返回null
   - 如果是浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误。
   - 因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对window.open()的调用封装在一个try-catch块中，如下所示。

### 8.1.6 间歇调用和超时调用

- 超时调用需要使用window对象的setTimeout()方法，它接受两个参数：要执行的代码和以毫秒
  表示的时间（即在执行代码前需要等待多少毫秒）。由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数。
- setTimeout()的第二个参数告诉JavaScript再过多长时间把当前任务添加到队列中。
- 要取消尚未执行的超时调用计划，可以调用clearTimeout()方法并将相应的超时调用ID作为参数传递给它

> 超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined。

- 设置间歇调用的方法是setInterval()，它接受的参数与setTimeout()相同
- 一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而使用超时调用，则完全可以避免这一点。

### 8.1.7 系统对话框

- alert()、confirm()和prompt()方法
- 这几个方法打开的对话框都是同步和模态的。
- prompt()方法生成的，这是一个“提示”框，用于提示用户输入一些文本。提示框中除了显示OK和Cancel按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。
  - prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。
- Google Chrome浏览器还引入了一种新特性。如果当前脚本在执行过程中会打开两个或多个对话框，那么从第二个对话框开始，每个对话框中都会显示一个复选框，以便用户阻止后续的对话框显示，除非用户刷新页面（见图8-6）。IE9和Firefox 4也实现了它。
- “查找”和“打印”。这两个对话框都是异步显示的，能够将控制权立即交还给脚本。这两个对话框与用户通过浏览器菜单的“查找”和“打印”命令打开的对话框相同。而在JavaScript中则可以像下面这样通过window对象的find()和print()方法打开它们。这两个方法同样不会就用户在对话框中的操作给出任何信息，因此它们的用处有限。Chrome的对话框计数器也不会将它们计算在内。

## 8.2 location对象

- location 对象是很特别的一个对象，因为它既是window 对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。

- location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。

  | 属 性 名    | 例 子                  | 说 明                                      |
  | -------- | -------------------- | ---------------------------------------- |
  | hash     | "#contents"          | 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 |
  | host     | "www.wrox.com:80"    | 返回服务器名称和端口号（如果有）                         |
  | hostname | "www.wrox.com"       | 返回不带端口号的服务器名称                            |
  | href     | "http:/www.wrox.com" | 返回当前加载页面的完整URL。而location对象的              |
  | pathname | "/WileyCDA/"         | 返回URL中的目录和（或）文件名                         |
  | port     | "8080"               | 返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串    |
  | protocol | "http:"              | 返回页面使用的协议。通常是http:或https:                |
  | search   | "?q=javascript"      | 返回URL的查询字符串。这个字符串以问号开头                   |

### 8.2.1 查询字符串参数

- 上面的属性访问URL包含的查询字符串的属性并不方便。尽管location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。因此需要创建函数

### 8.2.2 位置操作

- 使用location对象改变浏览器的位置

  - 使用assign()方法并为其传递一个URL

    ```
    location.assign("http://www.wrox.com");
    ```

  - 如果是将location.href 或 window.location设置为一个URL值，也会以该值调用assign()方法。

    ```
    window.location = "http://www.wrox.com"; 
    location.href = "http://www.wrox.com"; 
    ```

  - 修改location对象的其他属性也可以改变当前加载的页面。

    - 每次修改location的属性（hash除外），页面都会以新URL重新加载。

    > 在IE8、Firefox 1、Safari 2+、Opera 9+和Chrome中，修改hash的值会在浏览器的历史记录中生成一条新记录。在IE的早期版本中，hash属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含hash的URL时才会被更新。

  - 上述任何一种方式修改URL之后，浏览器的历史记录中就会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用replace()方法。

    - 只接受一个参数，即要导航到的URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录。

  - reload() 方法，作用是重新加载当前显示的页面。

    - 如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true。
    - 位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。

## 8.3 navigator对象

- navigator对象，现在已经成为识别客户端浏览器的事实标准。

| 属性或方法                     | 说 明                                      |
| ------------------------- | ---------------------------------------- |
| appCodeName               | 浏览器的名称。通常都是Mozilla，即使在非Mozilla浏览器中也是如此   |
| appMinorVersion           | 次版本信息                                    |
| appName                   | 完整的浏览器名称                                 |
| appVersion                | 浏览器的版本。一般不与实际的浏览器                        |
| buildID                   | 浏览器编译版本                                  |
| cookieEnabled             | 表示cookie是否启用                             |
| cpuClass                  | 客户端计算机中使用的CPU类型（x86、68K、Alpha、PPC或Other） |
| javaEnabled()             | 表示当前浏览器中是否启用了Java                        |
| language                  | 浏览器的主语言                                  |
| mimeTypes                 | 在浏览器中注册的MIME类型数组                         |
| onLine                    | 表示浏览器是否连接到了因特网                           |
| opsProfile                | 似乎早就不用了。查不到相关文档                          |
| oscpu                     | 客户端计算机的操作系统或使用的CPU                       |
| platform                  | 浏览器所在的系统平台                               |
| plugins                   | 浏览器中安装的插件信息的数组                           |
| preference()              | 设置用户的首选项                                 |
| product                   | 产品名称（如 Gecko）                            |
| productSub                | 关于产品的次要信息（如Gecko的版本）                     |
| registerContentHandler()  | 针对特定的MIME类型将一个站点注册为处理程序                  |
| registerProtocolHandler() | 针对特定的协议将一个站点注册为处理程序                      |
| securityPolicy            | 已经废弃。安全策略的名称。为了与Netscape Navigator 4向后兼容而保留下来 |
| systemLanguage            | 操作系统的语言                                  |
| taintEnabled()            | 已经废弃。表示是否允许变量被修改（taint）。为了与Netscape Navigator 3向后兼容而保留下来 |
| userAgent                 | 浏览器的用户代理字符串                              |
| userLanguage              | 操作系统的默认语言                                |
| userProfile               | 借以访问用户个人信息的对象                            |
| vendor                    | 浏览器的品牌                                   |
| vendorSub                 | 有关供应商的次要信息                               |

### 8.3.1 检测插件

- 对于非IE 浏览器，可以使用plugins数组。该数组中的每一项都包含下列属性

  - name：插件的名字。
  - description：插件的描述。
  - filename：插件的文件名。
  - length：插件所处理的MIME类型数量。

  > 每个插件对象本身也是一个MimeType对象的数组，这些对象可以通过方括号语法来访问。每个MimeType对象有4个属性：包含MIME类型描述的description、回指插件对象的enabledPlugin、表示与MIME类型对应的文件扩展名的字符串suffixes（以逗号分隔）和表示完整MIME类型字符串的type。

- 在IE 中检测插件的唯一方式就是使用专有的ActiveXObject类型，并尝试创建一个特定插件的实例。IE是以COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其COM标识符。

> plugins集合有一个名叫refresh()的方法，用于刷新plugins以反映最新安装的插件。这个方法接收一个参数：表示是否应该重新加载页面的一个布尔值。如果将这个值设置为true，则会重新加载包含插件的所有页面；否则，只更新plugins集合，不重新加载页面。

### 8.3.2 注册处理程序

- registerContentHandler()和registerProtocolHandler()方法。HTML5中定义。这两个方法可以让一个站点指明它可以处理特定类型的信息。
- registerContentHandler()方法接收三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名称。
- registerProtocolHandler()方法，它也接收三个参数：要处理的协议（例如，mailto或ftp）、处理该协议的页面的URL和应用程序的名称。

## 8.4 screen对象

- screen对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息

| 属 性                  | 说 明                    |
| -------------------- | ---------------------- |
| availHeight          | 屏幕的像素高度减系统部件高度之后的值（只读） |
| availLeft            | 未被系统部件占用的最左侧的像素值（只读）   |
| availTop             | 未被系统部件占用的最上方的像素值（只读）   |
| availWidth           | 屏幕的像素宽度减系统部件宽度之后的值（只读） |
| bufferDepth          | 读、写用于呈现屏外位图的位数         |
| colorDepth           | 用于表现颜色的位数；多数系统都是32（只读） |
| deviceXDPI           | 屏幕实际的水平DPI（只读）         |
| deviceYDPI           | 屏幕实际的垂直DPI（只读）         |
| fontSmoothingEnabled | 表示是否启用了字体平滑（只读）        |
| height               | 屏幕的像素高度                |
| left                 | 当前屏幕距左边的像素距离           |
| logicalXDPI          | 屏幕逻辑的水平DPI（只读）         |
| logicalYDPI          | 屏幕逻辑的垂直DPI（只读）         |
| pixelDepth           | 屏幕的位深（只读）              |
| top                  | 当前屏幕距上边的像素距离           |
| updateInterval       | 读、写以毫秒表示的屏幕刷新时间间隔      |
| width                | 屏幕的像素宽度                |

## 8.5 history对象

- 使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。
  - 这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。
  - 可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做


- 可以使用两个简写方法back()和forward()来代替go()。
- history对象还有一个length属性，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length等于0。
- 当页面的URL改变时，就会生成一条历史记录。在IE8 及更高版本、Opera、Firefox、Safari 3及更高版本以及Chrome中，这里所说的改变包括URL中hash的变化（因此，设置location.hash会在这些浏览器中生成一条新的历史记录）。

## 8.6 小结



# 第9章 客户端检测

## 9.1 能力检测

- 能力检测的基本模式如下：
  ​

  ```
  if (object.propertyInQuestion){ 
  	//使用object.propertyInQuestion 
  } 
  ```

- 两个重要的概念

  - 先检测达成目的的最常用的特性。
  - 必须测试实际要用到的特性。一个特性存在，不一定意味着另一个特性也存在。

### 9.1.1 更可靠的能力检测

- 能力检测对于想知道某个特性是否会按照适当方式行事（而不仅仅是某个特性存在）非常有用。
- 在可能的情况下，要尽量使用typeof进行能力检测。特别是，宿主对象没有义务让typeof返回合理的值。
  - DOM对象是宿主对象，IE及更早版本中的宿主对象是通过COM而非JScript实现的。因此，document.createElement()函数确实是一个COM对象，所以typeof才会返回"object"。IE9纠正了这个问题，对所有DOM方法都返回"function"。
  - 关于typeof的行为不标准，ActiveX对象（只有IE支持）与其他对象的行为差异很大。
- 目前使用isHostMethod()方法还是比较可靠的，因为它考虑到了浏览器的怪异行为。

```
function isHostMethod(object, property) { 
    var t = typeof object[property]; 
    return t=='function' || 
    (!!(t=='object' && object[property])) || 
    t=='unknown'; 
} 
```

### 9.1.2 能力检测，不是浏览器检测

- 检测某个或某几个特性并不能够确定浏览器。实际上，根据浏览器不同将能力组合起来是更可取的方式。

## 9.2 怪癖检测

- 怪癖检测（quirks detection）的目标是识别浏览器的特殊行为。但与能力检测确认浏览器支持什么能力不同，怪癖检测是想要知道浏览器存在什么缺陷（“怪癖”也就是bug）。

## 9.3 用户代理检测

- 争议最大的一种客户端检测技术叫做用户代理检测。用户代理检测通过检测用户代理字符串来确定实际使用的浏览器。在每一次HTTP请求过程中，用户代理字符串是作为响应首部发送的，而且该字符串可以通过JavaScript的navigator.userAgent属性访问。
- 在服务器端，通过检测用户代理字符串来确定用户使用的浏览器是一种常用而且广为接受的做法。而在客户端，用户代理检测一般被当作一种万不得已才用的做法，其优先级排在能力检测和（或）怪癖检测之后。
- 所谓电子欺骗，就是指浏览器通过在自己的用户代理字符串加入一些错误或误导性信息，来达到欺骗服务器的目的。

9.3.1 用户代理字符串的历史

- HTTP规范（包括1.0和1.1版）明确规定，浏览器应该发送简短的用户代理字符串，指明浏览器的名称和版本号。

#### 1.早期的浏览器

- Netscape在坚持将产品名和版本号作为用户代理字符串开头的基础上，又在后面依次添加了下列信息。
  - 语言：即语言代码，表示应用程序针对哪种语言设计。
  - 平台：即操作系统和（或）平台，表示应用程序的运行环境。
  - 加密类型：即安全加密的类型。可能的值有U（128位加密）、I（40位加密）和N（未加密）。

#### 2.Netscape Navigator 3和Internet Explorer 3

#### 3.Netscape Communicator 4和IE4～IE8

- 增加IE8这个记号有助于分辨浏览器到底是IE7（没有Trident记号），还是运行在兼容模式下的IE8。

#### 4.Gecko

- Gecko是Firefox的呈现引擎。
- 很多时候，检测特定的浏览器还不如搞清楚它是否基于Gecko更重要。

#### 5.WebKit

- 基于WebKit的所有浏览器都将自己标识为Mozilla 5.0，与基于Gecko的浏览器完全一样。
- 一般来说，确定浏览器是否基于WebKit要比确定它是不是Safari更有价值，就像针对Gecko一样。

#### 6.Konqueror

- Konqueror，是一款基于KHTML开源呈现引擎的浏览器。

#### 7.Chrome

- Chrome浏览器以WebKit作为呈现引擎，但使用了不同的JavaScript引擎。

#### 8.Opera

- Opera是主要浏览器中唯一一个使用产品名和版本号来完全彻底地标识自身的浏览器。
- Opera 9以后，出现了两种修改用户代理字符串的方式。
  - 一种方式是将自身标识为另外一个浏览器，如Firefox或者IE。在这种方式下，用户代理字符串就如同Firefox或IE的用户代理字符串一样，只不过末尾追加了字符串Opera及Opera的版本号。
  - 另一种方式，就是把自己装扮成Firefox或IE。在这种隐瞒真实身份的情况下，用户代理字符串实际上与其他浏览器返回的相同——既没有Opera字样，也不包含Opera版本信息。

#### 9.iOS和Android

### 9.3.2 用户代理字符串检测技术

#### 1.识别呈现引擎

- 如前所述，确切知道浏览器的名字和版本号不如确切知道它使用的是什么呈现引擎。

- 要正确地识别呈现引擎，关键是检测顺序要正确。由于用户代理字符串存在诸多不一致的地方，如果检测顺序不对，很可能会导致检测结果不正确。

  - 第一步是识别Opera，因为它的用户代理字符串有可能完全模仿其他浏览器

  > 要识别Opera，必须得检测window.opera对象。Opera 5及更高版本中都有这个对象，用以保存与浏览器相关的标识信息以及与浏览器直接交互。在Opera 7.6及更高版本中，调用version()方法可以返回一个表示浏览器版本的字符串，而这也是确定Opera版本号的最佳方式。
  >
  > 要检测更早版本的Opera，可以直接检查用户代理字符串，因为那些版本还不支持隐瞒身份。

  - 第二位检测的呈现引擎是WebKit

  > 因为WebKit的用户代理字符串中包含"Gecko"和"KHTML"这两个子字符串，所以如果首先检测它们，很可能会得出错误的结论。
  >
  > 不过，WebKit的用户代理字符串中的"AppleWebKit"是独一无二的，因此检测这个字符串最合适。

  - 第三位是KHTML

  > 同样，KHTML的用户代理字符串中也包含"Gecko"，因此在排除KHTML之前，我们无法准确检测基于Gecko的浏览器。KHTML的版本号与WebKit的版本号在用户代理字符串中的格式差不多，因此可以使用类似的正则表达式。此外，由于Konqueror 3.1及更早版本中不包含KHTML的版本，故而就要使用Konqueror的版本来代替。

  - 第四位是Gecko

  > Gecko的版本号位于字符串"rv:"与一个闭括号之间，因此为了提取出这个版本号，正则表达式要查找所有不是闭括号的字符，还要查找字符串"Gecko/"后跟8个数字。

  - 最后要检测的呈现引擎是IE

  > IE的版本号位于字符串"MSIE"的后面、一个分号的前面

#### 2.识别浏览器

- 只有呈现引擎还不能说明存在所需的JavaScript功能。
- 可在代码中又添加了私有变量browser，用于保存每个主要浏览器的属性。
  - 对Opera和IE而言，browser对象中的值等于engine对象中的值。
  - 对Konqueror而言，browser.konq和browser.ver属性分别等于engine.khtml和engine.ver属性。
  - 在检测Firefox的版本时，首先要找到字符串"Firefox/"，然后提取出该字符串后面的数值（即版本号）。

#### 3.识别平台

- 在某些条件下，平台可能是必须关注的问题。
- 与呈现引擎不同，在不能访问操作系统或版本的情况下，平台信息通常是很有限的。对这三个平台而言，浏览器一般只报告Windows版本。
- 在确定平台时，检测navigator.platform要比检测用户代理字符串更简单，后者在不同浏览器中会给出不同的平台信息。而navigator.platform 属性可能的值包括"Win32"、"Win64"、

#### 4.识别Windows操作系统

- 第一步：匹配Windows 95和Windows 98这两个字符串。
- 第二步：Gecko在表示Windows NT时会在末尾添加"4.0"

#### 5.识别移动设备

#### 6.识别游戏系统

### 9.3.3 完整的代码

- 书中包含完整的用户代理字符串检测脚本，包括检测呈现引擎、平台、Windows操作系统、移动设备和游戏系统。

### 9.3.4 使用方法

- 用户代理检测一般适用于下列情形 :
  - 不能直接准确地使用能力检测或怪癖检测。

## 9.4 小结

# 第10章 DOM

- 注意，IE中的所有DOM对象都是以COM对象的形式实的。这意味着IE中的DOM对象与原生JavaScript对象的行为或活动特点并不一致。

## 10.1 节点层次

- 文档节点是每个文档的根节点。
- 文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。
  - 在HTML页面中，文档元素始终都是<html>元素。
  - 在XML中，没有预定义的元素，因此任何元素都可能成为文档元素。
- 每一段标记都可以通过树中的一个节点来表示：HTML元素通过元素节点表示，特性通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12种节点类型，这些类型都继承自一个基类型。

### 10.1.1 Node类型

- DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript 中是作为Node 类型实现的；除了IE 之外，在其他所有浏览器中都可以访问到这个类型。

- JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。

- 每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一：

  - Node.ELEMENT_NODE(1)；
  - Node.ATTRIBUTE_NODE(2)；
  - Node.TEXT_NODE(3)；
  - Node.CDATA_SECTION_NODE(4)；
  - Node.ENTITY_REFERENCE_NODE(5)；
  - Node.ENTITY_NODE(6)；
  - Node.PROCESSING_INSTRUCTION_NODE(7)；
  -  Node.COMMENT_NODE(8)；
  - Node.DOCUMENT_NODE(9)；
  - Node.DOCUMENT_TYPE_NODE(10)；
  - Node.DOCUMENT_FRAGMENT_NODE(11)；
  - Node.NOTATION_NODE(12)。

- 通过比较上面这些常量，可以很容易地确定节点的类型

  ```javascript
  if (someNode.nodeType == 1){ //适用于所有浏览器
  	alert("Node is an element."); 
  } 
  ```

#### 1.nodeName和nodeValue属性

- 这两个属性的值完全取决于节点的类型。在使用这两个值以前，最好是像下面这样先检测一下节点的类型。

#### 2.节点关系

- 每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。
- 请注意，虽然可以通过方括号语法来访问NodeList的值，而且这个对象也有length属性，但它并不是Array的实例。NodeList对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。
- 访问保存在NodeList中的节点——可以通过方括号，也可以使用item()方法。



















