# 第1章 JavaScript是什么 #
## 1.1 历史简述 ##
## 1.2 JavaScript实现 ##
- 组成:
  核心(ECMAScript)
  文档对象模型(DOM)
  浏览器对象模型(BOM)

### 1.2.1 ECMAScript ###
- ECMAScript仅仅是一个描述，定义了脚本语言的所有属性、方法和对象。其他语言可以实现ECMAScript作为功能的基准。
- 每个浏览器都有自己的ECMAScript接口实现，然后这个实现又被扩展。

##### 1.ECMAScript的版本 #####
##### 2.什么是ECMAScript兼容 #####
一个脚本语言必须满足下列四项原则(e.g. ECMA-262):

- 按照ECMA-262中描述的支持所有的“类型、值、对象、属性、函数和程序语法及语义”
- 支持Unicode字符标准
- 可以增加没有在ECMA-262中指定的“额外的类型、值、对象、属性和函数”，
- 可以支持没有在ECMA-262中定义的“程序和正则表达式语法”

#### 3.Web浏览器中的ECMAScript支持 ####

### 1.2.2 文档对象模型DOM ###
- DOM（文档对象模型）是HTML和XML的API。DOM把整个页面规划成由节点层次构成的文档。DOM通过创建树来表示文档。

##### 1. 为什么要使用DOM  #####

##### 2. DOM级别 #####
- DOM Level1：DOM Core + DOM HTML。前者提供基于XML的文档结构图，后者添加HTML专用的对象和方法扩展DOM Core。目标只有规划文档结构。
- DOM Level2：引入几种DOM新模块：
  DOM视图————描述跟踪文档的各种视图(即CSS样式化之前和CSS样式化之后的文档)的接口
  DOM事件————描述事件的接口
  DOM样式————描述处理基于CSS样式的接口
  DOM遍历和范围————描述遍历和操作文档树的接口
- DOM Level3：引入了以统一的方式载入和保存文档的方法以及验证文档的方法。

##### 3.其他DOM #####
##### 4.Web浏览器中的DOM支持 #####

### 1.2.3 浏览器对象模型（BOM） ###
- 从根本上讲，BOM只处理浏览器窗口和框架；但人们习惯上也把所有针对浏览器的JavaScript扩展算作BOM的一部分。

## 1.3 JavaScript版本

## 1.4 小结 ##



# 第2章 在 HTML 中使用 JavaScript 

## 2.1 <script>元素

HTML 4.01为\<script>定义了下列6个属性。

-  async：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。
-  charset：可选。表示通过src属性指定的代码的字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。
-  defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。IE7及更早版本对嵌入脚本也支持这个属性。
-  language：已废弃。原来用于表示编写代码使用的脚本语言（如JavaScript、JavaScript1.2或VBScript）。大多数浏览器会忽略这个属性，因此也没有必要再用了。
-  src：可选。表示包含要执行代码的外部文件。
-  type：可选。可以看成是language的替代属性；表示编写代码使用的脚本语言的内容类型（也称为MIME类型）。考虑到约定俗成和最大限度的浏览器兼容性，目前type 属性的值依旧还是text/javascript。不过，这个属性并不是必需的，如果没有指定这个属性，则其默认值仍为text/javascript。


1. 需要注意的是，带有src属性的\<script>元素不应该在其\<script>和\</script>标签之间再包含额外的JavaScript代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。
2. 无论如何包含代码，只要不存在defer和async属性，浏览器都会按照\<script>元素在页面中出现的先后顺序对它们依次进行解析。

### 2.1.1 标签的位置

- 在文档的\<head>元素中包含所有JavaScript文件，意味着必须等到全部JavaScript代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到\<body>标签时才开始呈现内容）。
- 现代Web应用程序一般都把全部JavaScript引用放在\<body>元素中页面内容的后面

### 2.1.2 延迟脚本

- HTML 4.01为\<script>标签定义了defer属性。这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在\<script>元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。
- 在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在DOMContentLoaded事件触发前执行，因此最好只包含一个延迟脚本。
- defer属性只适用于外部脚本文件。这一点在HTML5中已经明确规定，因此支持HTML5的实现会忽略给嵌入脚本设置的defer属性。
- IE4～IE7还支持对嵌入脚本的defer属性，但IE8及之后版本则完全支持HTML5规定的行为。把延迟脚本放在页面底部仍然是最佳选择。
- 在XHTML文档中，要把defer属性设置为defer="defer"。

### 2.1.3 异步脚本

- async只适用于外部脚本文件，并告诉浏览器立即下载文件。但与defer不同的是，标记为async的脚本并不保证按照指定它们的先后顺序执行。

- 建议异步脚本不要在加载期间修改DOM。
- 异步脚本一定会在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。支持异步脚本的浏览器有Firefox 3.6、Safari 5和Chrome。
- XHTML文档中，要把async属性设置为async="async

### 2.1.4 在XHTML中的用法

- 可扩展超文本标记语言，即XHTML（Extensible HyperText Markup Language），是将HTML作为XML的应用而重新定义的一个标准。


- 避免在XHTML中出现类似语法错误的方法有两个。
  1. 用相应的HTML实体（<）替换代码中所有的小于号（<）
  2. 用一个CData片段来包含JavaScript代码。在XHTML（XML）中，CData片段是文档中的一个特殊区域，这个区域中可以包含不需要解析的任意格式的文本内容。


- 在将页面的MIME类型指定为"application/xhtml+xml"的情况下会触发XHTML模式。并不是所有浏览器都支持以这种方式提供XHTML文档。

### 2.1.5 不推荐使用的语法

- Netscape与Mosaic协商并提出了一个解决方案，让不支持\<script>元素的浏览器能够隐藏嵌入的JavaScript代码。这个方案就是把JavaScript代码包含在一个HTML注释中

## 2.2 嵌入代码与外部文件

- 在HTML中嵌入JavaScript代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含JavaScript代码。
  - 可维护性：遍及不同HTML页面的JavaScript会造成维护问题。
  - 可缓存：浏览器能够根据具体的设置缓存链接的所有外部JavaScript文件。
  - 适应未来：通过外部文件来包含JavaScript无须使用前面提到XHTML或注释hack。

## 2.3 文档模式

- IE5.5 引入了文档模式的概念,最初的两种文档模式是：混杂模式（quirks mode）和标准模式。
- IE又提出一种所谓的准标准模式（almost standards mode）


- 如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。


- 对于标准模式，可以通过使用下面任何一种文档类型来开启：

  ```
  <!-- HTML 4.01 严格型--> 
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" 
  "http://www.w3.org/TR/html4/strict.dtd"> 

  <!-- XHTML 1.0 严格型--> 
  <!DOCTYPE html PUBLIC 
  "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"> 

  <!-- HTML 5 --> 
  <!DOCTYPE html> 
  ```


- 对于准标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发.e.g.

  ```
  <!-- HTML 4.01 过渡型--> 
  <!DOCTYPE HTML PUBLIC 
  "-//W3C//DTD HTML 4.01 Transitional//EN" 
  "http://www.w3.org/TR/html4/loose.dtd"> 

  <!-- HTML 4.01 框架集型--> 
  <!DOCTYPE HTML PUBLIC 
  "-//W3C//DTD HTML 4.01 Frameset//EN" 
  "http://www.w3.org/TR/html4/frameset.dtd"> 

  <!-- XHTML 1.0 过渡型--> 
  <!DOCTYPE html PUBLIC 
  "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 

  <!-- XHTML 1.0 框架集型--> 
  <!DOCTYPE html PUBLIC 
  "-//W3C//DTD XHTML 1.0 Frameset//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"> 
  ```

## 2.4 <noscript>元素

- 用以在不支持JavaScript 的浏览器中显示替代的内容。
- 这个元素可以包含能够出现在档\<body>中的任何HTML元素——\<script>元素除外。
- 包含在\<noscript>元素中的内容只有在下列情况下才会显示出来：
  - 浏览器不支持脚本；
  - 浏览器支持脚本，但脚本被禁用。

## 2.5小结

-  在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。
-  所有\<script>元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用defer 和async 属性的情况下，只有在解析完前面\<script>元素中的代码之后，才会开始解析后面\<script>元素中的代码。
-  由于浏览器会先解析完不使用defer属性的\<script>元素中的代码，然后再解析后面的内容，所以一般应该把\<script>元素放在页面最后，即主要内容后面，\</body>标签前面。
-  使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。
-  使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。

# 第3章 基本概念 #

## 3.1 语法 ##
### 3.1.1 区分大小写

### 3.1.2 标识符

- 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；其他字符可以是字母、下划线、美元符号或数字。
- 按照惯例，ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写

### 3.1.3 注释

### 3.1.4 严格模式

- 严格模式是为JavaScript定义了一种不同的解析与执行模型。在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。


- 要在整个脚本中启用严格模式，可以在顶部添加如下代码：

  ```
  "use strict"; 
  ```


- 严格模式下，JavaScript 的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支持严格模式的浏览器包括IE10+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。

### 3.1.5 语句

## 3.2 关键字和保留字

- 保留字某种意义是为将来的关键字保留的单词。


- 第5版把在非严格模式下运行时的保留字缩减为下列这些：

  class	 enum	 extends		super 

  const	 export	 import 

- 在严格模式下，第5版还对以下保留字施加了限制：

  implements		package		public 

  interface 		private 		static 

  let 				protected 	yield 

## 3.3 变量 ##
- 在严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。

PS：

- 变量应遵循一条著名的命名规则:
  Gamel标记法————首字母小写，接下来单词大写开头
  Pascal标记法————首字母大写，接下来单词大写开头
  匈牙利类型标记法————在Pascal标记法的变量前附加一个小写字母（或小写字母序列），说明类型。

  ```
  类型					前缀
  数组					a
  布尔型				b
  浮点型（数字）		f
  函数					fn
  整型（数字）			i
  对象					o
  正则表达式			re
  字符串				s
  变型（可以是任何类型）	v
  ```

- ECMAScript的解释程序遇到未声明过的标识符时，用该变量名创建一个全局变量，并将其初始化成指定的值。

## 3.4 数据类型

- ECMAScript中有5种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。还有1种复杂数据类型——Object，Object本质上是由一组无序的名值对组成的

### 3.4.1 typeof操作符

- 对变量或值调用typeof返回：undefined、boolen、number、string、object（引用类型Object或空类型）、function
- 注意，typeof是一个操作符而不是函数，圆括号尽管可以使用，但不是必需的。
- 有些时候，typeof操作符会返回一些令人迷惑但技术上却正确的值。比如，调用typeof null会返回"object"，因为特殊值null被认为是一个空的对象引用。Safari 5及之前版本、Chrome 7及之前版本在对正则表达式调用typeof操作符时会返回"function"，而其他浏览器在这种情况下会返回"object"。
- 从技术角度讲，函数在ECMAScript中是对象，不是一种数据类型。然而，函数也
  确实有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。

### 3.4.2 Undefined类型

- 当声明的变量未初始化时，默认值是undefined。
- 对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型（对未经声明的变量调用delete不会导致错误，但这样做没什么实际意义，而且在严格模式下确实会导致错误）。
- 注意，undefined并不同于未定义的值，但typeof运算符并不真正区分这两种值,都会返回undefined值。
- 当函数无明确返回值时，返回值也是undefined

### 3.4.3 Null类型

- 从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回"object"的原因
- 值undefined实际是从值null派生来的，因此两者相等
- 两者含义不同，undefined是声明了变量但未初始化，null表示尚未存在的对象。如果函数或方法要返回对象，返回通常是null。
- 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用
- 只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。

### 3.4.4 Boolean类型

- 有两个值true和false

- 即使false不等于0,0也可以转换成false

- 需要注意的是，Boolean类型的字面值true和false是区分大小写的。

- 可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。

  | 数据类型      | 换为true的值            | 转换为false的值 |
  | --------- | ------------------- | ---------- |
  | Boolean   | true                | false      |
  | String    | 任何非空字符串             | ""（空字符串）   |
  | Number    | 任何非零数字值（包括无穷大）      | 0和NaN      |
  | Object    | 任何对象                | null       |
  | Undefined | N/A（not applicable） | undefined  |

### 3.4.5 Number类型

- 使用IEEE754格式来表示整数和浮点数值
- 整数可以代表8进制（0开头）和16进制（0x开头），返回的结果都是十进制结果。
- 八进制字面量在严格模式下是无效的，会导致支持的JavaScript引擎抛出错误。

#### 1.浮点数值

- 浮点数必须包括小数点和小数点后的一位数字。
- ECMAScript会不失时机地将浮点数值转换为整数值。
- 浮点变量在计算前，真正存储的是字符串。
- 指数:e表示法（即科学计数法）e.g.3.2e7,3-e7
- 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。

#### 2.数值范围

几个特殊值也是Number类型:

- Number.MAX_VALUE和Number.MIN_VALUE，它们定义乐乐Number值集合的外边界。不过计算生成的值可以不在其间。


- 当生成数大于Number.MAX_VALUE，被赋值Number.POSITIVE_INFINITY,同样也有Number.NEGATIVE_INFINITY。可以调用isFinit()方法，确保该数不是无穷大。


- 访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正Infinity 的值。

#### 3.NaN

- NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。
- 任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。
- NaN与任何值都不相等，包括NaN本身。
- isNaN()函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试将这个值转换为数值。

#### 4.数值转换

- 有3个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。

##### Number()函数的转换规则：

- 如果是Boolean值，true和false将分别被转换为1和0。
- 如果是数字值，只是简单的传入和返回。
- 如果是null值，返回0。
- 如果是undefined，返回NaN。


- 如果是字符串，遵循下列规则：
  - 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值
  - 如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值（同样，也会忽略前导零）
  - 如果字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值
  - 如果字符串是空的（不包含任何字符），则将其转换为0；
  - 如果字符串中包含除上述格式之外的字符，则将其转换为NaN。


- 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。

##### parseInt()

- parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN；也就是说，用parseInt()转换空字符串会返回NaN（Number()对空字符返回0）。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。
- 如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式
- 在使用parseInt()解析像八进制字面量的字符串时，ECMAScript 3和5存在分歧。e.g.在ECMAScript 5 JavaScript引擎中，parseInt()已经不具有解析八进制值的能力，因此前导的零会被认为无效
- 为了消除在使用parseInt()函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。

##### parseFloat()

- 除了第一个小数点有效之外，parseFloat()与parseInt()的第二个区别在于它始终都会忽略前导的零。
- parseFloat()只解析十进制值，十六进制格式的字符串则始终会被转换成0
- 如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。

### 3.4.6 String类型

- 没有固定大小的原始值，用字符串存储0或更多的Unicode字符（由16位整数表示）
- 字面常量由""或’‘声明，两者功能相同。
- isNaN()确实也适用于对象。在基于对象调用isNaN()函数时，会首先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用toString()方法，再测试返回值。而这个过程也是ECMAScript中内置函数和操作符的一般执行流程

#### 1. 字符字面量

#### 2. 字符串的特点

- ECMAScript中的字符串是不可变的。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量

#### 3. 转换为字符串

##### toString()方法

- 数值、布尔值、对象和字符串值（没错，每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有toString()方法。但null和undefined值没有这个方法。


- 在调用数值的toString()方法时，可以传递一个参数：输出数值的基数

##### String()

- 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果
- 如果值是null，则返回"null"
- 如果值是undefined，则返回"undefined"

### 3.4.7 Object类型

- 在ECMAScript中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。（但这不是推荐的做法）


- Object的每个实例都具有下列属性和方法
  -  constructor：保存着用于创建当前对象的函数。
  -  hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定 
  -  isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型。
  -  propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
  -  toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
  -  toString()：返回对象的字符串表示。
  -  valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。


- ECMA-262中对象的行为不一定适用于JavaScript中的其他对象。浏览器环境中的对象，比如BOM和DOM中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。

## 3.5 操作符

### 3.5.1 一元操作符

#### 1. 递增和递减操作符

- 这4个操作符对任何值都适用，遵循下列规则
  -  在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字符串变量变成数值变量。
  -  在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN
                 字符串变量变成数值变量。
  -  在应用于布尔值false时，先将其转换为0再执行加减1的操作。布尔值变量变成数值变量。
  -  在应用于布尔值true时，先将其转换为1再执行加减1的操作。布尔值变量变成数值变量。
  -  在应用于浮点数值时，执行加减1的操作。
  -  在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。

#### 2. 一元加和减操作符

- 一元加操作符放在数值前面，对数值不会产生任何影响
- 在对非数值应用一元加操作符时，一元加操作符会像Number()转型函数一样对这个值执行转换。
- 一元减操作符应用于数值时，该值会变成负数
- 当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数

### 3.5.2 位操作符

- ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。


- 负数同样以二进制码存储，但使用的格式是二进制补码。


- 这个转换过程也导致了一个严重的副效应，即在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理。


- 如果对非数值应用位操作符，会先使用Number()函数将该值转换为一个数值（自动完成），然后
  再应用位操作。得到的结果将是一个数值。

#### 1. 按位非（NOT）

- 按位非操作的本质：操作数的负值减1。

#### 2. 按位与（AND）

#### 3. 按位或（OR

#### 4. 按位异或（XOR）

#### 5. 左移

- 左移不会影响操作数的符号位。

#### 6. 有符号的右移

- 符号位的值来填充空位

#### 7. 无符号右移

- 无符号右移是以0来填充空位

### 3.5.3 布尔操作符

#### 1. 逻辑非

- 逻辑非操作符遵循下列规则：
  - 如果操作数是一个对象，返回false；
  - 如果操作数是一个空字符串，返回true；
  - 如果操作数是一个非空字符串，返回false；
  - 如果操作数是数值0，返回true；
  - 如果操作数是任意非0数值（包括Infinity），返回false；
  - 如果操作数是null，返回true；
  - 如果操作数是NaN，返回true；
  - 如果操作数是undefined，返回true。


- 同时使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为

#### 2. 逻辑与

- 遵循规则：
  -  如果第一个操作数是对象，则返回第二个操作数；
  -  如果第二个操作数是对象，则只有在第一个操作数的求值结果为true 的情况下才会返回该对象；
  -  如果两个操作数都是对象，则返回第二个操作数；
  -  如果有一个操作数是null，则返回null；
  -  如果有一个操作数是NaN，则返回NaN；
  -  如果有一个操作数是undefined，则返回undefined。

#### 3. 逻辑或

- 遵循规则：
  - 如果第一个操作数是对象，则返回第一个操作数；
  - 如果第一个操作数的求值结果为false，则返回第二个操作数；
  - 如果两个操作数都是对象，则返回第一个操作数；
  - 如果两个操作数都是null，则返回null；
  - 如果两个操作数都是NaN，则返回NaN；
  - 如果两个操作数都是undefined，则返回undefined。

### 3.5.4 乘性操作符

#### 1. 乘法

- 遵循规则：
  - 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而
    如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；
  - 如果有一个操作数是NaN，则结果是NaN；
  - 如果是Infinity与0相乘，则结果是NaN；
  - 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号； 
  - 如果是Infinity与Infinity相乘，则结果是Infinity；
  - 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

#### 2. 除法

- 遵循规则：
  - 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而
    如果只有一个操作数有符号，那么结果就是负数。如果商超过了ECMAScript数值的表示范围，
    则返回Infinity或-Infinity；
  - 如果有一个操作数是NaN，则结果是NaN；
  - 如果是Infinity被Infinity除，则结果是NaN；
  - 如果是零被零除，则结果是NaN；
  - 如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
  - 如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；
  - 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

#### 3.求模

- 遵循规则：
  - 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
  - 如果被除数是无穷大值而除数是有限大的数值，则结果是NaN；
  - 如果被除数是有限大的数值而除数是零，则结果是NaN；
  - 如果是Infinity被Infinity除，则结果是NaN；
  - 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
  - 如果被除数是零，则结果是零；
  - 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

### 3.5.5 加性操作符

#### 1. 加法

- 如果两个操作符都是数值，遵循规则：
  - 如果有一个操作数是NaN，则结果是NaN；
  - 如果是Infinity加Infinity，则结果是Infinity；
  - 如果是-Infinity加-Infinity，则结果是-Infinity；
  - 如果是Infinity加-Infinity，则结果是NaN；
  - 如果是+0加+0，则结果是+0；
  - 如果是0加0，则结果是0；
  - 如果是+0加0，则结果是+0。


- 如果两个操作符都是数值，遵循规则：
  - 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
  - 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。


- 如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。
- 对于undefined和null，则分别调用String()函数并取得字符串"undefined"和"null"。

#### 2. 减法

- 遵循规则：
  - 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；
  - 如果有一个操作数是NaN，则结果是NaN；
  - 如果是Infinity减Infinity，则结果是NaN；
  - 如果是-Infinity减-Infinity，则结果是NaN；
  - 如果是Infinity减-Infinity，则结果是Infinity；
  - 如果是-Infinity减Infinity，则结果是-Infinity；
  - 如果是+0减+0，则结果是+0；
  - 如果是+0减-0，则结果是-0
  - 如果是-0减-0，则结果是+0；
  - 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN；
  - 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

### 3.5.6 关系操作符

- 遵循规则：
  - 如果两个操作数都是数值，则执行数值比较。
  - 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
  - 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
  - 如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较。
  - 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。

### 3.5.7 相等操作符

#### 1. 相等和不相等

- 转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：
  - 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
  - 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
  - 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较


- 遵循规则:
  - null和undefined是相等的。
  - 要比较相等性之前，不能将null和undefined转换成其他任何值。
  - 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN。
  - 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

#### 2. 全等和不全等

- 除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符由3个等于号（===）表示，它只在两个操作数未经转换就相等的情况下返回true


- 由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。

### 3.5.8 条件操作符

### 3.5.9 赋值操作符

- 有符号右移/赋值（>>=）
- 无符号右移/赋值（>>>=）

### 3.5.10 逗号操作符

## 3.6语句

### 3.6.1 if语句

### 3.6.2 do-while语句

### 3.6.3 while语句

### 3.6.4 for语句

### 3.6.5 for-in语句

- for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。

  ```
  for (property in expression) statement
  ```


- ECMAScript对象的属性没有顺序。因此，通过for-in循环输出的属性名的顺序是不可预测的。


- 如果表示要迭代的对象的变量值为null 或undefined，for-in 语句会抛出错误。ECMAScript 5更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined。

### 3.6.6 label语句

### 3.6.7 break和continue语句

### 3.6.8 with语句

- with语句的作用是将代码的作用域设置到一个特定的对象中。


- with语句的语法如下：

  ```
  with (expression) statement; 
  ```


- 定义with语句的目的主要是为了简化多次编写同一个对象的工作


- 在with语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location对象中是否有同名的属性。如果发现了同名属性，则以location对象属性的值作为变量的值。


- 严格模式下不允许使用with语句，否则将视为语法错误。


- 由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。

### 3.6.9 switch语句

- 首先，可以在switch语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。
- 其次，每个case的值不一定是常量，可以是变量，甚至是表达式。


- switch语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串"10"不等于数值10）。

## 3.7 函数

- return语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回undefined值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。


- 严格模式对函数有一些限制：
  -  不能把函数命名为eval或arguments；
  -  不能把参数命名为eval或arguments；
  -  不能出现两个命名参数同名的情况。

### 3.7.1 理解参数

- ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。


- 实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。
- ECMAScript函数的一个重要特点：命名的参数只提供便利，但不是必需的。
- 另外，在命名参数方面，其他语言可能需要事先创建一个函数签名，而将来的调用必须与该签名一致。但在ECMAScript中，没有这些条条框框，解析器不会验证命名参数。
- 另一个与参数相关的重要方面，就是arguments对象可以与命名参数一起使用
- 没有传递值的命名参数将自动被赋予undefined值。这就跟定义了变量但又没有初始化一样。
- 严格模式对如何使用arguments对象做出了一些限制。首先，有些赋值（直接修改arguments等）会变得无效。其次，重写arguments的值会导致语法错误（代码将不会执行）。
- ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。

### 3.7.2 没有重载

- ECMAScript函数不能像传统意义上那样实现重载。
- ECMAScirpt函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。
- 如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。
- 通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。

## 3.8小结

# 第4章 变量、作用域和内存问题

## 4.1 基本类型和引用类型的值

- 在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。
- 与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。
- 引用类型的值是按引用访问的

### 4.1.1 动态的属性

### 4.1.2 复制变量值

### 4.1.3 传递参数

### 4.1.4 检测类型

- ECMAScript提供了instanceof操作符

  ```
  result= variableinstanceof constructor
  ```


- IE和Firefox中，对正则表达式应用typeof会返回"object"。

## 4.2 执行环境及作用域

- 每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。
- 在Web浏览器中，全局执行环境被认为是window对象
- 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。


- 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。

### 4.2.1 延长作用域链

- 有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。
  - try-catch语句的catch块；
  - with语句。


- 对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。


- 在IE8 及之前版本的JavaScript 实现中，存在一个与标准不一致的地方，即在catch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句的变量对象中。换句话说，即使是在catch块的外部也可以访问到错误对象。IE9修复了这个问题。

### 4.2.2 没有块级作用域

- 在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。在使用for语句时尤其要牢记这一差异，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在
  于循环外部的执行环境中。

#### 1. 声明变量

- 使用var声明的变量会自动被添加到最接近的环境中。

#### 2. 查询标识符

- 搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。

## 4.3 垃圾收集

- 垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，通常有两个策略。

### 4.3.1 标记清除

- 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

### 4.3.2 引用计数

- 引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。
- BOM和DOM中的对象就是使用C++以COM（Component Object Model，组件对象模型）对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。
- 只要在IE中涉及COM对象，就会存在循环引用的问题。


- IE9把BOM和DOM对象都转换成了真正的JavaScript对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。

### 4.3.3 性能问题

- IE的垃圾收集器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象（或数组）字面量和数组元素（slot）或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。


- IE7改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。


- 事实上，在有的浏览器中可以触发垃圾收集过程，但不建议这样做。在IE中，调用window.CollectGarbage()方法会立即执行垃圾收集。在Opera 7及更高版本中，调用window.opera.collect()也会启动垃圾收集例程。

### 4.3.4 管理内存

- 其中最主要的一个问题，就是分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。


- 优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用（dereferencing）。


- 解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收

## 4.4 小结

- 引用类型的值是对象，保存在堆内存中；
- 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符
- 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
- 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；

# 第5章 引用类型 

- 在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。
- 引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。
- 虽然引用类型与类看起来相似，但它们并不是相同的概念。

## 5.1 Object类型

- 创建Object实例的方式有两种。
  - 第一种是使用new操作符后跟Object构造函数
  - 另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。


- 使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象


- 在通过对象字面量定义对象时，实际上不会调用Object构造函数（Firefox 2及更早版本会调用Object构造函数；但Firefox 3之后就不会了）。


- 一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。


- 方括号语法Vs点表示法：
  - 主要优点是可以通过变量来访问属性
  - 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。


- 通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。

## 5.2 Array类型

- 创建数组的基本方式有两种。
  - 第一种是使用Array构造函数
    - 可以给构造函数传递该数量
    - 可以向Array构造函数传递数组中应该包含的项
    - 在使用Array构造函数时也可以省略new操作符
  - 第二种基本方式是使用数组字面量表示法


- 在数组字面量的最后一项添加逗号的结果：在IE中，values会成为一个包含3个项且每项的值分别为1、2和undefined的数组；在其他浏览器中，values会成为一个包含2项且值分别为1和2的数组。在像这种省略值的情况下，IE8及之前版本每一项都将获得undefined值；


- 与对象一样，在使用数组字面量表示法时，也不会调用Array构造函数


- 数组的length属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。再访问就会显示undefined


- 如果将其length属性设置为大于数组项数的值，则新增的每一项都会取得undefined值


- 数组最多可以包含4 294 967 295个项，而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。

### 5.2.1 检测数组

- 对于一个网页，或者一个全局作用域而言，使用instanceof操作符就能得到满意的结果问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。


- Array.isArray()方法，这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。用法如下：

  ```
  if (Array.isArray(value)){ 
  //对数组执行某些操作
  } 
  ```


- 支持Array.isArray()方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 10.5+和Chrome。

### 5.2.2 转换方法

- 调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。
- 调用valueOf()返回的还是数组。


- 当调用数组的toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的toLocale- String()方法，而不是toString()方法。


- alert()要接收字符串参数，所以它会在后台调用toString()方法
- 数组继承的toLocaleString()、toString()和valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。


- 如果使用join()方法，则可以使用不同的分隔符来构建这个字符串。join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。


- 如果数组中的某一项的值是null 或者undefined，那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示。

### 5.2.3 栈方法

- push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。
- pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。

### 5.2.4 队列方法

- shift()，它能够移除数组中的第一个项并返回该项，同时将数组长度减1。
- ECMAScript还为数组提供了一个unshift()方法。顾名思义，unshift()与shift()的用途相反：它能在数组前端添加任意个项并返回新数组的长度。


- IE7及更早版本对JavaScript的实现中存在一个偏差，其unshift()方法总是返回undefined而不是数组的新长度。IE8在非兼容模式下会返回正确的长度值。

### 5.2.5 重排序方法

- reverse()方法会反转数组项的顺序。
- 默认情况，sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。因此，这种排序方式在很多情况下都不是最佳方案。

### 5.2.6 操作方法

- concat()方法
  - 可以基于当前数组中的所有项创建一个新数组。
  - 具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。


- slice()方法
  - 它能够基于当前数组中的一或多个项创建一个新数组。
  - slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。
  - 在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。
  - 如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。
  - 注意，slice()方法不会影响原始数组。
  - 如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。
  - 如果结束位置小于起始位置，则返回空数组。


- splice()方法
  - 主要用途是向数组的中部插入项
  - 使用方式：
    - **删除**：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。
    - **插入**：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。
    - **替换**：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起
      始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。
  - 返回一个数组，该数组中包含从原始数组中删除的项

### 5.2.7 位置方法

- indexOf()和lastIndexOf()。
  - 都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。
  - 其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。
  - 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1
  - 在比较第一个参数与数组中的每一项时，会使用全等操作符
  - 支持它们的浏览器包括IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。

### 5.2.8 迭代方法

- 定义了5个迭代方法。
  - 每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值。
  - 传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。
  - 返回值
    - every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true
    - filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。
    - forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
    - map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
    - some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
  - 以上方法都不会修改数组中的包含的值。
  - every()和some()，它们都用于查询数组中的项是否满足某个条件。
  - forEach()本质上与使用for循环迭代数组一样。
  - 支持这些迭代方法的浏览器有IE9+、Firefox 2+、Safari 3+、Opera 9.5+和Chrome。

### 5.2.9 归并方法

- reduce()和reduceRight()。
  - 都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。
  - 都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。
  - 支持这两个归并函数的浏览器有IE9+、Firefox 3+、Safari 4+、Opera 10.5和Chrome。

## 5.3 Date类型

- Date类型使用自UTC


- 为了简化传入表示该日期的毫秒数的过程，提供了两个方法：Date.parse()和Date.UTC()。
- Date.parse()
  - Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。
  - ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。美国的浏览器通常都接受下列日期格式：
    - “月/日/年”，如6/13/2004；
    - “英文月名 日,年”，如January 12,2004；
    - “英文星期几 英文月名 日 年 时:分:秒 时区”，如Tue May 25 2004 00:00:00 GMT-0700。
    - ISO 8601 扩展格式YYYY-MM-DDTHH:mm:ss.ss（例如2004-05-25T00:00:00）。只有兼容
      ECMAScript 5的实现支持这种格式。
  - 如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。
  - 不同浏览器中的实现有许多奇怪的行为，有一种倾向是将超出范围的值替换成当前的值，以便生成输出。而Opera则倾向于插入当前月份的当前日期


- Date.UTC()
  - 返回表示日期的毫秒数。
  - Date.UTC()的参数分别是年份、基于0的月份（一月是0，二月是1，以此类推）、月中的哪一天（1到31）、小时数（0到23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0。


- ECMAScript 5添加了Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。
  - 支持Data.now()方法的浏览器包括IE9+、Firefox 3+、Safari 3+、Opera 10.5和Chrome。在不支
    持它的浏览器中，使用+操作符把Data对象转换成字符串，也可以达到同样的目的。

### 5.3.1 继承的方法

- Date类型也重写了toLocaleString()、toString()和valueOf()方法
  - Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息
  - toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。
  - Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。。因此，可以方便使用比较操作符（小于或大于）来比较日期值。

### 5.3.2 日期格式化方法

- 将日期格式化为字符串的方法
  - toDateString()——以特定于实现的格式显示星期几、月、日和年；
  - toTimeString()——以特定于实现的格式显示时、分、秒和时区；
  - toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
  - toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
  - toUTCString()——以特定于实现的格式完整的UTC日期。


-  还有一个名叫toGMTString()的方法，这是一个与toUTCString()等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript推荐现在编写的代码一律使用toUTCString()方法。

### 5.3.3日期/时间组件方法

- UTC日期指的是在没有时区偏差的情况下（将日期转换为GMT时间）的日期值。

| 方 法                    | 说 明                                    |
| :--------------------- | :------------------------------------- |
| getTime()              | 返回表示日期的毫秒数；与valueOf()方法返回的值相同          |
| setTime(毫秒)            | 以毫秒数设置日期，会改变整个日期                       |
| getFullYear()          | 取得4位数的年份（如2007而非仅07）                   |
| getUTCFullYear()       | 返回UTC日期的4位数年份                          |
| setFullYear(年)         | 设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）      |
| setUTCFullYear(年)      | 设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）   |
| getMonth()             | 返回日期中的月份，其中0表示一月，11表示十二月               |
| getUTCMonth()          | 返回UTC日期中的月份，其中0表示一月，11表示十二月            |
| setMonth(月)            | 设置日期的月份。传入的月份值必须大于0，超过11则增加年份          |
| setUTCMonth(月)         | 设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份       |
| getDate()              | 返回日期月份中的天数（1到31）                       |
| getUTCDate()           | 返回UTC日期月份中的天数（1到31）                    |
| setDate(日)             | 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份     |
| setUTCDate(日)          | 设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份  |
| getDay()               | 返回日期中星期的星期几（其中0表示星期日，6表示星期六）           |
| getUTCDay()            | 返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六）        |
| getHours()             | 返回日期中的小时数（0到23）                        |
| getUTCHours()          | 返回UTC日期中的小时数（0到23）                     |
| setHours(时)            | 设置日期中的小时数。传入的值超过了23则增加月份中的天数           |
| setUTCHours(时)         | 设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数        |
| getMinutes()           | 返回日期中的分钟数（0到59）                        |
| getUTCMinutes()        | 返回UTC日期中的分钟数（0到59）                     |
| setMinutes(分)          | 设置日期中的分钟数。传入的值超过59则增加小时数               |
| setUTCMinutes(分)       | 设置UTC日期中的分钟数。传入的值超过59则增加小时数            |
| getSeconds()           | 返回日期中的秒数（0到59）                         |
| getUTCSeconds()        | 返回UTC日期中的秒数（0到59）                      |
| setSeconds(秒)          | 设置日期中的秒数。传入的值超过了59会增加分钟数               |
| setUTCSeconds(秒)       | 设置UTC日期中的秒数。传入的值超过了59会增加分钟数            |
| getMilliseconds()      | 返回日期中的毫秒数                              |
| getUTCMilliseconds()   | 返回UTC日期中的毫秒数                           |
| setMilliseconds(毫秒)    | 设置日期中的毫秒数                              |
| setUTCMilliseconds(毫秒) | 设置UTC日期中的毫秒数                           |
| getTimezoneOffset()    | 返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某 |

## 5.4 RegExp类型

- 语法

  ```
  var expression = /pattern/ flags ;
  ```
  - 模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。
    - g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
    - i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
    - m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。


- 模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：( [ { \ ^ $ | ) ? * + .]} 


- 另一种创建正则表达式的方式是使用RegExp构造函数
  - 它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。
  - 由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此（例如字符\会变成`\\\\`）


- 在ECMAScript 3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例


- ECMAScript 5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例。IE9+、Firefox 4+和Chrome都据此做出了修改。

### 5.4.1 RegExp实例属性

- RegExp属性
  -  global：布尔值，表示是否设置了g标志。
  -  ignoreCase：布尔值，表示是否设置了i标志。
  -  lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。
  -  multiline：布尔值，表示是否设置了m标志。
  -  source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。

### 5.4.2 RegExp实例方法

- 主要方法是exec()，该方法是专门为捕获组而设计的。
  - exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。
  - 返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。
  - 对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不
    设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项
  - IE 的JavaScript 实现在lastIndex 属性上存在偏差，即使在非全局模式下，lastIndex属性每次也会变化。


- 第二个方法是test()
  - 接受一个字符串参数
  - 在模式与该参数匹配的情况下返回true；否则，返回false。
  - test()方法经常被用在if语句中
- RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。即使是通过调用RegExp构造函数创建的。
- 正则表达式的valueOf()方法返回正则表达式本身。


### 5.4.3 RegExp构造函数属性

- RegExp构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。

- 这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。

- 这些属性分别有一个长属性名和一个短属性名（Opera是例外，它不支持短属性名）。

  - | 长属性名         | 短属性名 | 说 明                                 |
    | ------------ | ---- | ----------------------------------- |
    | input        | $_   | 最近一次要匹配的字符串。Opera未实现此属性             |
    | lastMatch    | $&   | 最近一次的匹配项。Opera未实现此属性                |
    | lastParen    | $+   | 最近一次匹配的捕获组。Opera未实现此属性              |
    | leftContext  | $`   | input字符串中lastMatch之前的文本             |
    | multiline    | $*   | 布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性 |
    | rightContext | $'   | Input字符串中lastMatch之后的文本             |

  - 由于这些短属性名大都不是有效的ECMAScript标识符，因此必须通过方括号语法来访问它们

- 还有多达9个用于存储捕获组的构造函数属性。访问这些属性的语法是RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。

### 5.4.4 模式的局限性

- ECMAScript正则表达式不支持的特性
  - 匹配字符串开始和结尾的\A和\Z锚（ 但支持以插入符号（^）和美元符号（$）来匹配字符串的开始和结尾。）
  - 向后查找（lookbehind）（但完全支持向前查找（lookahead）。）
  - 并集和交集类
  - 原子组（atomic grouping）
  - Unicode支持（单个字符除外，如\uFFFF）
  - 命名的捕获组(但支持编号的捕获组。)
  - s（single，单行）和x（free-spacing，无间隔）匹配模式
  - 条件匹配
  - 正则表达式注释

## 5.5 Function类型

- 每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。
- 由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。


- 函数定义的方式:
  - 函数声明语法定义

    ```
    function sum (num1, num2) { 
    return num1 + num2; 
    } 
    ```

  - 函数表达式定义

    ```
    var sum = function(num1, num2){ 
    return num1 + num2; 
    }; 
    ```

  - 使用Function构造函数

    ```
    var sum = new Function("num1", "num2", "return num1 + num2");
    ```

    - Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。
    - 不推荐, 因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串）
    - 利于理解“函数是对象，函数名是指针”的概念

### 5.5.1 没有重载（深入理解）

- 将函数名想象为指针，也有助于理解为什么ECMAScript中没有函数重载的概念。


### 5.5.2 函数声明与函数表达式

- 解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。


- 在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。


- 除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。
- 可以同时使用函数声明和函数表达式，例如var sum = function sum(){}。不过，这种语法在Safari中会导致错误。

### 5.5.3 作为值的函数

- 可将一个函数作为另一个函数的结果返回，这也是极为有用的一种技术。



- 要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。

### 5.5.4 函数内部属性

- 函数内部有两个特殊的对象：arguments和this。
- arguments
  - arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。
    - 可解决递归算法的函数的执行与函数名紧密耦合


- this
  - this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。


- ECMAScript 5也规范化了另一个函数对象的属性：caller。（Opera的早期版本不支持）
  - 这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。


- 当函数在严格模式下运行时，访问arguments.callee 会导致错误。ECMAScript 5还定义了arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清arguments.caller和函数的caller属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。

### 5.5.5 函数属性和方法

- ECMAScript中的函数是对象。每个函数都包含两个属性：length和prototype。


- length
  - 表示函数希望接收的命名参数的个数


- prototype
  - 对于ECMAScript中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。
  - 创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的
  - 在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。


- 每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。
- apply()
  - apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。
  - 在严格模式下，未指定环境对象而调用函数，则this值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this 值将是undefined。
- call()方法
  - call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。
  - 对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来
- 事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。



//---缺了很多东西，sigh



# 第8章 BOM

## 8.1 window

### 8.1.1 全局作用域

- 全局变量（函数）会成为window对象的属性

- 定义全局变量与在window对象上直接定义属性差别：

  - 全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性可以。

    [^原因]: 使用var语句添加的window属性有一个名为[[Configurable\]\]的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete操作符删除。IE8及更早版本在遇到使用delete删除window属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9及更高版本不会抛出错误。

  - 尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在。

- Windows Mobile平台的IE浏览器不允许通过window.property = value之类的形式，直接在window对象上创建新的属性或方法。可是，在全局作用域中声明的所有变量和函数，照样会变成window对象的成员。

### 8.1.2 窗口关系及框架

- 如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象。每个window对象都有一个name属性，其中包含框架的名称。


- top对象始终指向最高（最外）层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。因为对于在一个框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而非最高层的框架。所以最好使用top而非window

- parent（父）对象始终指向当前框架的直接上层框架。在某些情况下，parent有可能等于top；但在没有框架的情况下，parent一定等于top（此时它们都等于window）。

  > 注意，除非最高层窗口是通过window.open()打开的（本章后面将会讨论），否则其window对象的name属性不会包含任何值。

- self对象，它始终指向window；实际上，self和window对象可以互换使用。引入self对象的目的只是为了与top和parent对象对应起来，因此它不格外包含其他值。

  > 在使用框架的情况下，浏览器中会存在多个Global对象。在每个框架中定义的全局变量会自动成为框架中window对象的属性。由于每个window对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。例如，top.Object并不等于top.frames[0].Object。这个问题会影响到对跨框架传递的对象使用instanceof操作符。

### 8.1.3 窗口位置

- 使用screenLeft 和screenTop，无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。

  > IE、Safari、Opera和Chrome都提供了screenLeft 和screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。Firefox则在screenX和screenY属性中提供相同的窗口位置信息，Safari和Chrome也同时支持这两个属性。Opera虽然也支持screenX和screenY属性，但与screenLeft和screenTop属性并不对应，因此建议大家不要在Opera中使用它们。

  > 在IE、Opera中，screenLeft和screenTop中保存的是从屏幕左边和上边到由window对象表示的页面可见区域的距离。换句话说，如果window对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即y轴坐标为0，那 么screenTop的值就是位于页面可见区域上方的浏览器工具栏的像素高度。但是，在Chrome、Firefox和Safari中，screenY或screenTop中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y轴坐标为0时返回0

  > Firefox、Safari和Chrome始终返回页面中每个框架的top.screenX 和top.screenY 值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用screenX和screenY每次也都会返回相同的值。而IE和Opera则会给出框架相对于屏幕边界的精确坐标值。

- 使用moveTo()和moveBy()方法倒是有可能将窗口精确地移动到一个新位置。两个方法都接收两个参数，moveTo()接收的是新位置的x和y坐标值，而moveBy()接收的是在水平和垂直方向上移动的像素数。

  > 需要注意的是，这两个方法可能会被浏览器禁用；而且，在Opera和IE 7（及更高版本）中默认就是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window对象使用。

### 8.1.4 窗口大小

- 4个属性：innerWidth、innerHeight、outerWidth和outerHeight。

  - 在IE9+、Safari和Firefox中，outerWidth和outerHeight返回浏览器窗口本身的尺寸（无论是从最外层的window对象还是从某个框架访问）。
  - 在Opera中，这两个属性的值表示页面视图容器的大小。而innerWidth和innerHeight
    则表示该容器中页面视图区的大小（减去边框宽度）。
  - 在Chrome中，outerWidth、outerHeight 与innerWidth、innerHeight返回相同的值，即视口（viewport）大小而非浏览器窗口大小。
  - IE8及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过DOM提供了页面可见区域的相关信息。

- 在IE、Firefox、Safari、Opera和Chrome中，document.documentElement.clientWidth和
  document.documentElement.clientHeight中保存了页面视口的信息。在IE6中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过document.body.clientWidth和document.body. clientHeight取得相同信息。而对于混杂模式下的Chrome，则无论通过document.documentEle- ment还是document.body中的clientWidth和clientHeight属性，都可以取得视口的大小。虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小

- 对于移动设备，window.innerWidth和window.innerHeight保存着可见视口，也就是屏幕上可见页面区域的大小。

  - 移动IE 浏览器不支持这些属性，但通过document.documentElement.clientWidth和document.documentElement.clientHeihgt提供了相同的信息。
  - 在其他移动浏览器中，document.documentElement 度量的是布局视口，即渲染后页面的实际大小（与可见视口不同，可见视口只是整个页面中的一小部分）。移动IE 浏览器把布局视口的信息保存在document.body.clientWidth和document.body.clientHeight中。这些值不会随着页面缩放变化。

- 使用resizeTo()和resizeBy()方法可以调整浏览器窗口的大小。resizeTo()接收浏览器窗口的新宽度和新高度，而resizeBy()接收新窗口与原窗口的宽度和高度之差。

  > 这两个方法与移动窗口位置的方法类似，也有可能被浏览器禁用；而且，在Opera和IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的window对象使用。

### 8.1.5 导航和打开窗口

- window.open()方法
  - 接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。
  - 第二个参数， 可以是已有窗口或框架的名称，也可以是特殊的窗口名称：\_self、\_parent、\_top或\_blank。

1. #### 弹出窗口

   - 如果传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。

   - 第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下表列出了可以出现在这个字符串中的设置选项。

     | 设 置        | 值      | 说 明                                      |
     | ---------- | ------ | ---------------------------------------- |
     | fullscreen | yes或no | 表示浏览器窗口是否最大化。仅限IE                        |
     | height     | 数值     | 表示新窗口的高度。不能小于100height  数值  表示新窗口的高度。不能小于100 |
     | left       | 数值     | 表示新窗口的左坐标。不能是负值                          |
     | location   | yes或no | 表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏可能会隐藏，也可能会被禁用（取决于浏览器） |
     | menubar    | yes或no | 表示是否在浏览器窗口中显示菜单栏。默认值为no                  |
     | resizable  | yes或no | 表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为no           |
     | scrollbars | yes或no | 表示如果内容在视口中显示不下，是否允许滚动。默认值为no             |
     | status     | yes或no | 表示是否在浏览器窗口中显示状态栏。默认值为no                  |
     | toolbar    | yes或no | 表示是否在浏览器窗口中显示工具栏。默认值为no                  |
     | top        | 数值     | 表示新窗口的上坐标。不能是负值                          |
     | width      | 数值     | 表示新窗口的宽度。不能小于100                         |

   > 可以通过逗号分隔的名值对列表来指定,其中，名值对以等号表示（注意，整个特性字符串中不允许出现空格）其中，名值对以等号表示（注意，整个特性字符串中不允许出现空格）

- window.open()方法会返回一个指向新窗口的引用。引用的对象与其他window对象大致相似，但我们可以对其进行更多控制。
- close()方法还可以关闭新打开的窗口。
  - 仅适用于通过window.open()打开的弹出窗口。
  - 对于浏览器的主窗口，如果没有得到用户的允许是不能关闭它的。
  - 弹出窗口倒是可以调用top.close()在不经用户允许的情况下关闭自己。弹出窗口关闭之后，窗口的引用仍然还在，但除了像下面这样检测其closed属性之外，已经没有其他用处了。
  - 新创建的window对象有一个opener属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window对象（top）中有定义，而且指向调用window.open()的窗口或框架。
  - 有些浏览器（如IE8和Chrome）会在独立的进程中运行每个标签页。当一个标签页打开另一个标签页时，如果两个window对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。在Chrome中，将新创建的标签页的opener属性设置为null，即表示在单独的进程中运行新标签页

1. #### 安全限制

   - 对弹出窗口施加了多方面的安全限制
   - 在打开计算机硬盘中的网页时，IE会解除对弹出窗口的某些限制。但是在服务器上执行这些代码会受到对弹出窗口的限制。

2. #### 弹出窗口屏蔽程序

   - 如果是浏览器内置的屏蔽程序阻止的弹出窗口，那么window.open()很可能会返回null
   - 如果是浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误。
   - 因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对window.open()的调用封装在一个try-catch块中，如下所示。

### 8.1.6 间歇调用和超时调用

- 超时调用需要使用window对象的setTimeout()方法，它接受两个参数：要执行的代码和以毫秒
  表示的时间（即在执行代码前需要等待多少毫秒）。由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数。
- setTimeout()的第二个参数告诉JavaScript再过多长时间把当前任务添加到队列中。
- 要取消尚未执行的超时调用计划，可以调用clearTimeout()方法并将相应的超时调用ID作为参数传递给它

> 超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined。

- 设置间歇调用的方法是setInterval()，它接受的参数与setTimeout()相同
- 一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而使用超时调用，则完全可以避免这一点。

### 8.1.7 系统对话框

- alert()、confirm()和prompt()方法
- 这几个方法打开的对话框都是同步和模态的。
- prompt()方法生成的，这是一个“提示”框，用于提示用户输入一些文本。提示框中除了显示OK和Cancel按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。
  - prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。
- Google Chrome浏览器还引入了一种新特性。如果当前脚本在执行过程中会打开两个或多个对话框，那么从第二个对话框开始，每个对话框中都会显示一个复选框，以便用户阻止后续的对话框显示，除非用户刷新页面（见图8-6）。IE9和Firefox 4也实现了它。
- “查找”和“打印”。这两个对话框都是异步显示的，能够将控制权立即交还给脚本。这两个对话框与用户通过浏览器菜单的“查找”和“打印”命令打开的对话框相同。而在JavaScript中则可以像下面这样通过window对象的find()和print()方法打开它们。这两个方法同样不会就用户在对话框中的操作给出任何信息，因此它们的用处有限。Chrome的对话框计数器也不会将它们计算在内。

## 8.2 location对象

- location 对象是很特别的一个对象，因为它既是window 对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。

- location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。

  | 属 性 名    | 例 子                  | 说 明                                      |
  | -------- | -------------------- | ---------------------------------------- |
  | hash     | "#contents"          | 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 |
  | host     | "www.wrox.com:80"    | 返回服务器名称和端口号（如果有）                         |
  | hostname | "www.wrox.com"       | 返回不带端口号的服务器名称                            |
  | href     | "http:/www.wrox.com" | 返回当前加载页面的完整URL。而location对象的              |
  | pathname | "/WileyCDA/"         | 返回URL中的目录和（或）文件名                         |
  | port     | "8080"               | 返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串    |
  | protocol | "http:"              | 返回页面使用的协议。通常是http:或https:                |
  | search   | "?q=javascript"      | 返回URL的查询字符串。这个字符串以问号开头                   |

### 8.2.1 查询字符串参数

- 上面的属性访问URL包含的查询字符串的属性并不方便。尽管location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。因此需要创建函数

### 8.2.2 位置操作

- 使用location对象改变浏览器的位置

  - 使用assign()方法并为其传递一个URL

    ```
    location.assign("http://www.wrox.com");
    ```

  - 如果是将location.href 或 window.location设置为一个URL值，也会以该值调用assign()方法。

    ```
    window.location = "http://www.wrox.com"; 
    location.href = "http://www.wrox.com"; 
    ```

  - 修改location对象的其他属性也可以改变当前加载的页面。

    - 每次修改location的属性（hash除外），页面都会以新URL重新加载。

    > 在IE8、Firefox 1、Safari 2+、Opera 9+和Chrome中，修改hash的值会在浏览器的历史记录中生成一条新记录。在IE的早期版本中，hash属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含hash的URL时才会被更新。

  - 上述任何一种方式修改URL之后，浏览器的历史记录中就会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用replace()方法。

    - 只接受一个参数，即要导航到的URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录。

  - reload() 方法，作用是重新加载当前显示的页面。

    - 如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true。
    - 位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。

## 8.3 navigator对象

- navigator对象，现在已经成为识别客户端浏览器的事实标准。

| 属性或方法                     | 说 明                                      |
| ------------------------- | ---------------------------------------- |
| appCodeName               | 浏览器的名称。通常都是Mozilla，即使在非Mozilla浏览器中也是如此   |
| appMinorVersion           | 次版本信息                                    |
| appName                   | 完整的浏览器名称                                 |
| appVersion                | 浏览器的版本。一般不与实际的浏览器                        |
| buildID                   | 浏览器编译版本                                  |
| cookieEnabled             | 表示cookie是否启用                             |
| cpuClass                  | 客户端计算机中使用的CPU类型（x86、68K、Alpha、PPC或Other） |
| javaEnabled()             | 表示当前浏览器中是否启用了Java                        |
| language                  | 浏览器的主语言                                  |
| mimeTypes                 | 在浏览器中注册的MIME类型数组                         |
| onLine                    | 表示浏览器是否连接到了因特网                           |
| opsProfile                | 似乎早就不用了。查不到相关文档                          |
| oscpu                     | 客户端计算机的操作系统或使用的CPU                       |
| platform                  | 浏览器所在的系统平台                               |
| plugins                   | 浏览器中安装的插件信息的数组                           |
| preference()              | 设置用户的首选项                                 |
| product                   | 产品名称（如 Gecko）                            |
| productSub                | 关于产品的次要信息（如Gecko的版本）                     |
| registerContentHandler()  | 针对特定的MIME类型将一个站点注册为处理程序                  |
| registerProtocolHandler() | 针对特定的协议将一个站点注册为处理程序                      |
| securityPolicy            | 已经废弃。安全策略的名称。为了与Netscape Navigator 4向后兼容而保留下来 |
| systemLanguage            | 操作系统的语言                                  |
| taintEnabled()            | 已经废弃。表示是否允许变量被修改（taint）。为了与Netscape Navigator 3向后兼容而保留下来 |
| userAgent                 | 浏览器的用户代理字符串                              |
| userLanguage              | 操作系统的默认语言                                |
| userProfile               | 借以访问用户个人信息的对象                            |
| vendor                    | 浏览器的品牌                                   |
| vendorSub                 | 有关供应商的次要信息                               |

### 8.3.1 检测插件

- 对于非IE 浏览器，可以使用plugins数组。该数组中的每一项都包含下列属性

  - name：插件的名字。
  - description：插件的描述。
  - filename：插件的文件名。
  - length：插件所处理的MIME类型数量。

  > 每个插件对象本身也是一个MimeType对象的数组，这些对象可以通过方括号语法来访问。每个MimeType对象有4个属性：包含MIME类型描述的description、回指插件对象的enabledPlugin、表示与MIME类型对应的文件扩展名的字符串suffixes（以逗号分隔）和表示完整MIME类型字符串的type。

- 在IE 中检测插件的唯一方式就是使用专有的ActiveXObject类型，并尝试创建一个特定插件的实例。IE是以COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其COM标识符。

> plugins集合有一个名叫refresh()的方法，用于刷新plugins以反映最新安装的插件。这个方法接收一个参数：表示是否应该重新加载页面的一个布尔值。如果将这个值设置为true，则会重新加载包含插件的所有页面；否则，只更新plugins集合，不重新加载页面。

### 8.3.2 注册处理程序

- registerContentHandler()和registerProtocolHandler()方法。HTML5中定义。这两个方法可以让一个站点指明它可以处理特定类型的信息。
- registerContentHandler()方法接收三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名称。
- registerProtocolHandler()方法，它也接收三个参数：要处理的协议（例如，mailto或ftp）、处理该协议的页面的URL和应用程序的名称。

## 8.4 screen对象

- screen对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息

| 属 性                  | 说 明                    |
| -------------------- | ---------------------- |
| availHeight          | 屏幕的像素高度减系统部件高度之后的值（只读） |
| availLeft            | 未被系统部件占用的最左侧的像素值（只读）   |
| availTop             | 未被系统部件占用的最上方的像素值（只读）   |
| availWidth           | 屏幕的像素宽度减系统部件宽度之后的值（只读） |
| bufferDepth          | 读、写用于呈现屏外位图的位数         |
| colorDepth           | 用于表现颜色的位数；多数系统都是32（只读） |
| deviceXDPI           | 屏幕实际的水平DPI（只读）         |
| deviceYDPI           | 屏幕实际的垂直DPI（只读）         |
| fontSmoothingEnabled | 表示是否启用了字体平滑（只读）        |
| height               | 屏幕的像素高度                |
| left                 | 当前屏幕距左边的像素距离           |
| logicalXDPI          | 屏幕逻辑的水平DPI（只读）         |
| logicalYDPI          | 屏幕逻辑的垂直DPI（只读）         |
| pixelDepth           | 屏幕的位深（只读）              |
| top                  | 当前屏幕距上边的像素距离           |
| updateInterval       | 读、写以毫秒表示的屏幕刷新时间间隔      |
| width                | 屏幕的像素宽度                |

## 8.5 history对象

- 使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。
  - 这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。
  - 可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做


- 可以使用两个简写方法back()和forward()来代替go()。
- history对象还有一个length属性，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length等于0。
- 当页面的URL改变时，就会生成一条历史记录。在IE8 及更高版本、Opera、Firefox、Safari 3及更高版本以及Chrome中，这里所说的改变包括URL中hash的变化（因此，设置location.hash会在这些浏览器中生成一条新的历史记录）。

## 8.6 小结



# 第9章 客户端检测

## 9.1 能力检测

- 能力检测的基本模式如下：
  ​

  ```
  if (object.propertyInQuestion){ 
  	//使用object.propertyInQuestion 
  } 
  ```

- 两个重要的概念

  - 先检测达成目的的最常用的特性。
  - 必须测试实际要用到的特性。一个特性存在，不一定意味着另一个特性也存在。

### 9.1.1 更可靠的能力检测

- 能力检测对于想知道某个特性是否会按照适当方式行事（而不仅仅是某个特性存在）非常有用。
- 在可能的情况下，要尽量使用typeof进行能力检测。特别是，宿主对象没有义务让typeof返回合理的值。
  - DOM对象是宿主对象，IE及更早版本中的宿主对象是通过COM而非JScript实现的。因此，document.createElement()函数确实是一个COM对象，所以typeof才会返回"object"。IE9纠正了这个问题，对所有DOM方法都返回"function"。
  - 关于typeof的行为不标准，ActiveX对象（只有IE支持）与其他对象的行为差异很大。
- 目前使用isHostMethod()方法还是比较可靠的，因为它考虑到了浏览器的怪异行为。

```
function isHostMethod(object, property) { 
    var t = typeof object[property]; 
    return t=='function' || 
    (!!(t=='object' && object[property])) || 
    t=='unknown'; 
} 
```

### 9.1.2 能力检测，不是浏览器检测

- 检测某个或某几个特性并不能够确定浏览器。实际上，根据浏览器不同将能力组合起来是更可取的方式。

## 9.2 怪癖检测

- 怪癖检测（quirks detection）的目标是识别浏览器的特殊行为。但与能力检测确认浏览器支持什么能力不同，怪癖检测是想要知道浏览器存在什么缺陷（“怪癖”也就是bug）。

## 9.3 用户代理检测

- 争议最大的一种客户端检测技术叫做用户代理检测。用户代理检测通过检测用户代理字符串来确定实际使用的浏览器。在每一次HTTP请求过程中，用户代理字符串是作为响应首部发送的，而且该字符串可以通过JavaScript的navigator.userAgent属性访问。
- 在服务器端，通过检测用户代理字符串来确定用户使用的浏览器是一种常用而且广为接受的做法。而在客户端，用户代理检测一般被当作一种万不得已才用的做法，其优先级排在能力检测和（或）怪癖检测之后。
- 所谓电子欺骗，就是指浏览器通过在自己的用户代理字符串加入一些错误或误导性信息，来达到欺骗服务器的目的。

9.3.1 用户代理字符串的历史

- HTTP规范（包括1.0和1.1版）明确规定，浏览器应该发送简短的用户代理字符串，指明浏览器的名称和版本号。

#### 1.早期的浏览器

- Netscape在坚持将产品名和版本号作为用户代理字符串开头的基础上，又在后面依次添加了下列信息。
  - 语言：即语言代码，表示应用程序针对哪种语言设计。
  - 平台：即操作系统和（或）平台，表示应用程序的运行环境。
  - 加密类型：即安全加密的类型。可能的值有U（128位加密）、I（40位加密）和N（未加密）。

#### 2.Netscape Navigator 3和Internet Explorer 3

#### 3.Netscape Communicator 4和IE4～IE8

- 增加IE8这个记号有助于分辨浏览器到底是IE7（没有Trident记号），还是运行在兼容模式下的IE8。

#### 4.Gecko

- Gecko是Firefox的呈现引擎。
- 很多时候，检测特定的浏览器还不如搞清楚它是否基于Gecko更重要。

#### 5.WebKit

- 基于WebKit的所有浏览器都将自己标识为Mozilla 5.0，与基于Gecko的浏览器完全一样。
- 一般来说，确定浏览器是否基于WebKit要比确定它是不是Safari更有价值，就像针对Gecko一样。

#### 6.Konqueror

- Konqueror，是一款基于KHTML开源呈现引擎的浏览器。

#### 7.Chrome

- Chrome浏览器以WebKit作为呈现引擎，但使用了不同的JavaScript引擎。

#### 8.Opera

- Opera是主要浏览器中唯一一个使用产品名和版本号来完全彻底地标识自身的浏览器。
- Opera 9以后，出现了两种修改用户代理字符串的方式。
  - 一种方式是将自身标识为另外一个浏览器，如Firefox或者IE。在这种方式下，用户代理字符串就如同Firefox或IE的用户代理字符串一样，只不过末尾追加了字符串Opera及Opera的版本号。
  - 另一种方式，就是把自己装扮成Firefox或IE。在这种隐瞒真实身份的情况下，用户代理字符串实际上与其他浏览器返回的相同——既没有Opera字样，也不包含Opera版本信息。

#### 9.iOS和Android

### 9.3.2 用户代理字符串检测技术

#### 1.识别呈现引擎

- 如前所述，确切知道浏览器的名字和版本号不如确切知道它使用的是什么呈现引擎。

- 要正确地识别呈现引擎，关键是检测顺序要正确。由于用户代理字符串存在诸多不一致的地方，如果检测顺序不对，很可能会导致检测结果不正确。

  - 第一步是识别Opera，因为它的用户代理字符串有可能完全模仿其他浏览器

  > 要识别Opera，必须得检测window.opera对象。Opera 5及更高版本中都有这个对象，用以保存与浏览器相关的标识信息以及与浏览器直接交互。在Opera 7.6及更高版本中，调用version()方法可以返回一个表示浏览器版本的字符串，而这也是确定Opera版本号的最佳方式。
  >
  > 要检测更早版本的Opera，可以直接检查用户代理字符串，因为那些版本还不支持隐瞒身份。

  - 第二位检测的呈现引擎是WebKit

  > 因为WebKit的用户代理字符串中包含"Gecko"和"KHTML"这两个子字符串，所以如果首先检测它们，很可能会得出错误的结论。
  >
  > 不过，WebKit的用户代理字符串中的"AppleWebKit"是独一无二的，因此检测这个字符串最合适。

  - 第三位是KHTML

  > 同样，KHTML的用户代理字符串中也包含"Gecko"，因此在排除KHTML之前，我们无法准确检测基于Gecko的浏览器。KHTML的版本号与WebKit的版本号在用户代理字符串中的格式差不多，因此可以使用类似的正则表达式。此外，由于Konqueror 3.1及更早版本中不包含KHTML的版本，故而就要使用Konqueror的版本来代替。

  - 第四位是Gecko

  > Gecko的版本号位于字符串"rv:"与一个闭括号之间，因此为了提取出这个版本号，正则表达式要查找所有不是闭括号的字符，还要查找字符串"Gecko/"后跟8个数字。

  - 最后要检测的呈现引擎是IE

  > IE的版本号位于字符串"MSIE"的后面、一个分号的前面

#### 2.识别浏览器

- 只有呈现引擎还不能说明存在所需的JavaScript功能。
- 可在代码中又添加了私有变量browser，用于保存每个主要浏览器的属性。
  - 对Opera和IE而言，browser对象中的值等于engine对象中的值。
  - 对Konqueror而言，browser.konq和browser.ver属性分别等于engine.khtml和engine.ver属性。
  - 在检测Firefox的版本时，首先要找到字符串"Firefox/"，然后提取出该字符串后面的数值（即版本号）。

#### 3.识别平台

- 在某些条件下，平台可能是必须关注的问题。
- 与呈现引擎不同，在不能访问操作系统或版本的情况下，平台信息通常是很有限的。对这三个平台而言，浏览器一般只报告Windows版本。
- 在确定平台时，检测navigator.platform要比检测用户代理字符串更简单，后者在不同浏览器中会给出不同的平台信息。而navigator.platform 属性可能的值包括"Win32"、"Win64"、

#### 4.识别Windows操作系统

- 第一步：匹配Windows 95和Windows 98这两个字符串。
- 第二步：Gecko在表示Windows NT时会在末尾添加"4.0"

#### 5.识别移动设备

#### 6.识别游戏系统

### 9.3.3 完整的代码

- 书中包含完整的用户代理字符串检测脚本，包括检测呈现引擎、平台、Windows操作系统、移动设备和游戏系统。

### 9.3.4 使用方法

- 用户代理检测一般适用于下列情形 :
  - 不能直接准确地使用能力检测或怪癖检测。

## 9.4 小结

- ​


# 第10章 DOM

- 注意，IE中的所有DOM对象都是以COM对象的形式实的。这意味着IE中的DOM对象与原生JavaScript对象的行为或活动特点并不一致。

## 10.1 节点层次

- 文档节点是每个文档的根节点。
- 文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。
  - 在HTML页面中，文档元素始终都是<html>元素。
  - 在XML中，没有预定义的元素，因此任何元素都可能成为文档元素。
- 每一段标记都可以通过树中的一个节点来表示：HTML元素通过元素节点表示，特性通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12种节点类型，这些类型都继承自一个基类型。

### 10.1.1 Node类型

- DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript 中是作为Node 类型实现的；除了IE 之外，在其他所有浏览器中都可以访问到这个类型。

- JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。

- 每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一：

  - Node.ELEMENT_NODE(1)；
  - Node.ATTRIBUTE_NODE(2)；
  - Node.TEXT_NODE(3)；
  - Node.CDATA_SECTION_NODE(4)；
  - Node.ENTITY_REFERENCE_NODE(5)；
  - Node.ENTITY_NODE(6)；
  - Node.PROCESSING_INSTRUCTION_NODE(7)；
  - Node.COMMENT_NODE(8)；
  - Node.DOCUMENT_NODE(9)；
  - Node.DOCUMENT_TYPE_NODE(10)；
  - Node.DOCUMENT_FRAGMENT_NODE(11)；
  - Node.NOTATION_NODE(12)。

- 通过比较上面这些常量，可以很容易地确定节点的类型

  ```javascript
  if (someNode.nodeType == 1){ //适用于所有浏览器
  	alert("Node is an element."); 
  } 
  ```

#### 1.nodeName和nodeValue属性

- 这两个属性的值完全取决于节点的类型。在使用这两个值以前，最好是像下面这样先检测一下节点的类型。

#### 2.节点关系

- 每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。
- 请注意，虽然可以通过方括号语法来访问NodeList的值，而且这个对象也有length属性，但它并不是Array的实例。NodeList对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList对象中。
- 访问保存在NodeList中的节点——可以通过方括号，也可以使用item()方法。
- 对arguments对象使用Array.prototype.slice()方法可以将其转换为数组。由于IE8及更早版本将NodeList
  实现为一个COM对象，而我们不能像使用JScript对象那样使用这种对象。要想在IE中将NodeList转换为数组，必须手动枚举所有成员。
- 每个节点都有一个parentNode属性，该属性指向文档树中的父节点。
- 包含在childNodes列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的previousSibling
  和nextSibling属性，可以访问同一列表中的其他节点。列表中第一个节点的previousSibling属性值为null，而列表中最后一个节点的nextSibling属性的值同样也为null
- 父节点与其第一个和最后一个子节点之间也存在特殊关系。父节点的firstChild和lastChild属性分别指向其childNodes列表中的第一个和最后一个节点。如果没有子节点，那么firstChild和lastChild的值均为null。
- hasChildNodes()也是一个非常有用的方法，这个方法在节点包含一或多个子节点的情况下返回true；应该说，这是比查询childNodes列表的length属性更简单的方法。
- 所有节点都有的最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。通过这个属性，我们可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档节点。

#### 3. 操作节点

- 最常用的方法是appendChild()，用于向childNodes列表的末尾添加一个节点。添加节点后，childNodes的新增节点、父节点及以前的最后一个子节点的关系指针都会相应地得到更新。
- 如果需要把节点放在childNodes 列表中某个特定的位置上，而不是放在末尾，那么可以使用insertBefore()方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是null，则insertBefore()与appendChild()执行相同的操作
- replaceChild()方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。
- 如果只想移除而非替换节点，可以使用removeChild()方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值
- 四个方法操作的都是某个节点的子节点，另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生。

#### 4. 其他方法

- 有两个方法是所有类型的节点都有的。第一个就是cloneNode()，用于创建调用这个方法的节点的一个完全相同的副本。
  - cloneNode()方法接受一个布尔值参数，表示是否执行深复制。
    - 在参数为true的情况下，执行深复制，也就是复制节点及其整个子节点树；
    - 在参数为false的情况下，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此，这个节点副本就成为了一个“孤儿”，除非通过appendChild()、insertBefore()或replaceChild()将它添加到文档中。

> cloneNode()方法不会复制添加到DOM节点中的JavaScript属性，例如事件处
> 理程序等。这个方法只复制特性、（在明确指定的情况下也复制）子节点，其他一切
> 都不会复制。IE在此存在一个bug，即它会复制事件处理程序，所以我们建议在复制
> 之前最好先移除事件处理程序。

- normalize()方法，这个方法唯一的作用就是处理文档树中的文本节点。
  - 由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。

### 10.1.2 Document类型

- 在浏览器中，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML页面。而且，document对象是window对象的一个属性，因此可以将其作为全局对象来访问。
- Document节点具有下列特征：
  - nodeType的值为9；
  - nodeName的值为"#document"；
  - nodeValue的值为null；
  - parentNode的值为null；
  - ownerDocument的值为 null；
  - 其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment。

#### 1. 文档的子节点

- 虽然DOM标准规定Document节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment，但还有两个内置的访问其子节点的快捷方式。

  - 第一个就是documentElement属性，该属性始终指向HTML页面中的<html>元素。
  - 另一个就是通过childNodes列表访问文档元素，但通过documentElement属性则能更快捷、更直接地访问该元素。

- 作为HTMLDocument的实例，document对象还有一个body属性，直接指向<body>元素。因为开发人员经常要使用这个元素，所以document.body在JavaScript代码中出现的频率非常高，其用法如下。
  `var body = document.body; //取得对<body>的引用`

- 所有浏览器都支持document.documentElement和document.body属性。

- Document另一个可能的子节点是DocumentType。通常将<!DOCTYPE>标签看成一个与文档其他部分不同的实体，可以通过doctype属性（在浏览器中是document.doctype）来访问它的信息。

  `var doctype = document.doctype; //取得对<!DOCTYPE>的引用`

- 浏览器对document.doctype的支持差别很大:

  - IE8 及之前版本：如果存在文档类型声明，会将其错误地解释为一个注释并把它当作Comment节点；而document.doctype的值始终为null。
  - IE9+及Firefox：如果存在文档类型声明，则将其作为文档的第一个子节点；document.doctype是一个DocumentType节点，也可以通过document.firstChild或document.childNodes[0]访问同一个节点。
  - Safari、Chrome和Opera：如果存在文档类型声明，则将其解析，但不作为文档的子节点。document.doctype是一个DocumentType节点，但该节点不会出现在document.childNodes中。

- 从技术上说，出现在<html>元素外部的注释应该算是文档的子节点。然而，不同的浏览器在是否解析这些注释以及能否正确处理它们等方面，也存在很大差异。

  - IE8及之前版本、Safari 3.1及更高版本、Opera和Chrome只为第一条注释创建节点，不为第二条注释创建节点。结果，第一条注释就会成为document.childNodes中的第一个子节点。
  - IE9及更高版本会将第一条注释创建为document.childNodes中的一个注释节点，也会将第二条注释创建为document.childNodes中的注释子节点。
  - Firefox以及Safari 3.1之前的版本会完全忽略这两条注释。

#### 2. 文档信息

- title属性
  - 包含着<title>元素中的文本——显示在浏览器窗口的标题栏或标签页上。
  - 通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。
  - 修改title属性的值不会改变<title>元素。
- URL
  - URL属性中包含页面完整的URL（即地址栏中显示的URL）
- domain
  - domain属性中只包含页面的域名
- referrer
  - referrer属性中则保存着链接到当前页面的那个页面的URL。
  - 在没有来源页面的情况下，referrer属性中可能会包含空字符串。
- URL与domain属性是相互关联的。
- 在这3个属性中，只有domain是可以设置的。但由于安全方面的限制，也并非可以给domain设置任何值。不能将这个属性设置为URL中不包含的域
- 当页面中包含来自其他子域的框架或内嵌框架时，能够设置document.domain就非常方便了。由于跨域安全限制，来自不同子域的页面无法通过JavaScript 通信。而通过将每个页面的document.domain设置为相同的值，这些页面就可以互相访问对方包含的JavaScript对象了。
- 浏览器对domain属性还有一个限制，即如果域名一开始是“松散的”（loose），那么不能将它再设置为“紧绷的”（tight）。换句话说，在将document.domain设置为"wrox.com"之后，就不能再将其设置回"p2p.wrox.com"，否则将会导致错误

#### 3. 查找元素

- 取得元素的操作：getElementById()和getElementsByTagName()
- getElementById()
  - 接收一个参数：要取得的元素的ID。
  - 如果找到相应的元素则返回该元素，如果不存在带有相应ID的元素，则返回null。
  - 注意，这里的ID必须与页面中元素的id特性（attribute）严格匹配，包括大小写。(IE8及较低版本不区分ID的大小写)
  - 如果页面中多个元素的ID值相同，getElementById()只返回文档中第一次出现的元素。IE7及较低版本还为此方法添加了一个有意思的“怪癖”：name 特性与给定ID 匹配的表单元素（<input>、<textarea>、<button>及<select>）也会被该方法返回。
- getElementsByTagName()
  - 接受一个参数，即要取得元素的标签名，而返回的是包含零或多个元素的NodeList。
  - 在HTML文档中，这个方法会返回一个HTMLCollection对象，作为一个“动态”集合，该对象与NodeList非常类似
  - HTMLCollection对象还有一个方法，叫做namedItem()，使用这个方法可以通过元素的name特性取得集合中的项。
  - 要想取得文档中的所有元素，可以向getElementsByTagName()中传入"*"。按照它们出现的先后顺序。
- getElementsByName()
  - 只有HTMLDocument类型才有的方法
  - 最常使用getElementsByName()方法的情况是取得单选按钮；为了确保发送给浏览器的值正确无误，所有单选按钮必须具有相同的name特性
  - 与getElementsByTagName()类似，getElementsByName()方法也会返回一个HTMLCollectioin。
  - 但是，对于这里的单选按钮来说，namedItem()方法则只会取得第一项（因为每一项的name特性都相同）

#### 4. 特殊集合

- document对象还有一些特殊的集合，都是HTMLCollection对象，为访问文档常用的部分提供了快捷方式
  - document.anchors，包含文档中所有带name特性的<a>元素；
  - document.applets，包含文档中所有的<applet>元素，因为不再推荐使用<applet>元素，所以这个集合已经不建议使用了；
  - document.forms，包含文档中所有的<form>元素，与document.getElementsByTagName("form")得到的结果相同；
  - document.images，包含文档中所有的<img>元素，与document.getElementsByTagName ("img")得到的结果相同；
  - document.links，包含文档中所有带href特性的<a>元素。

#### 5. DOM一致性检测

- document.implementation属性就是为检测浏览器实现了DOM的哪些部分提供相应信息和功能的对象，与浏览器对DOM的实现直接对应。

- DOM1级只为document.implementation规定了一个方法，即hasFeature()。

  - 这个方法接受两个参数：要检测的DOM功能的名称及版本号。

  - 如果浏览器支持给定名称和版本的功能，则该方法返回true

    | 功 能            | 版 本 号       | 说 明                             |
    | -------------- | ----------- | ------------------------------- |
    | Core           | 1.0、2.0、3.0 | 基本的DOM，用于描述表现文档的节点树             |
    | XML            | 1.0、2.0、3.0 | Core的XML扩展，添加了对CDATA、处理指令及实体的支持 |
    | HTML           | 1.0、2.0     | XML的HTML扩展，添加了对HTML特有元素及实体的支持   |
    | Views          | 2.0         | 基于某些样式完成文档的格式化                  |
    | StyleSheets    | 2.0         | 将样式表关联到文档                       |
    | CSS            | 2.0         | 对层叠样式表1级的支持                     |
    | CSS2           | 2.0         | 对层叠样式表2级的支持                     |
    | Events         | 2.0，3.0     | 常规的DOM事件                        |
    | UIEvents       | 2.0，3.0     | 用户界面事件                          |
    | MouseEvents    | 2.0，3.0     | 由鼠标引发的事件（click、mouseover等）      |
    | MutationEvents | 2.0，3.0     | DOM树变化时引发的事件                    |
    | HTMLEvents     | 2.0         | HTML4.01事件                      |
    | Range          | 2.0         | 用于操作DOM树中某个范围的对象和方法             |
    | Traversal      | 2.0         | 遍历DOM树的方法                       |
    | LS             | 3.0         | 文件与DOM树之间的同步加载和保存               |
    | LS-Async       | 3.0         | 文件与DOM树之间的异步加载和保存               |
    | Validation     | 3.0         | 在确保有效的前提下修改DOM树的方法              |

  - hasFeature()也有缺点，因为实现者可以自行决定是否与DOM规范的不同部分保持一致。建议多数情况下，在使用DOM的某些特殊的功能之前，最好除了检测hasFeature()之外，还同时使用能力检测。

#### 6. 文档写入

- 将输出流写入到网页中：write()、writeln()、open()和close()。
- write()和writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。write()会原样写入，而writeln()则会在字符串的末尾添加一个换行符（\n）。在页面被加载的过程中，可以使用这两个方法向页面中动态地
  加入内容
- 还可以使用write()和writeln()方法动态地包含外部资源，例如JavaScript文件等。在包含JavaScript文件时，必须注意不能像下面的例子那样直接包含字符串"</script>"，因为这会导致该字符串被解释为脚本块的结束，它后面的代码将无法执行。（使用"<\/script>"）
- 如果在文档加载结束后再调用document.write()，那么输出的内容将会重写整个页面
- 方法open()和close()分别用于打开和关闭网页的输出流。如果是在页面加载期间使用write()或writeln()方法，则不需要用到这两个方法

> 严格型XHTML文档不支持文档写入。

### 10.1.3 Element类型

- Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。Element节点具有以下特征：
  - nodeType的值为1；
  - nodeName的值为元素的标签名；
  - nodeValue的值为null；
  - parentNode可能是Document或Element；
  - 其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。
- 要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性；这两个属性会返回相同的值。但可能会有大小写差别，因为在HTML中，标签名始终都以全部大写表示；而在XML（有时候也包括XHTML）中，标签名则始终会与源代码中的保持一致。

#### 1. HTML元素

- 所有HTML元素都由HTMLElement类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性。

- id，元素在文档中的唯一标识符。

- title，有关元素的附加说明信息，一般通过工具提示条显示出来。

- lang，元素内容的语言代码，很少使用。

- dir，语言的方向，值为"ltr"（left-to-right，从左至右）或"rtl"（right-to-left，从右至左），也很少使用。

- className，与元素的class特性对应，即为元素指定的CSS类。没有将这个属性命名为class，是因为class是ECMAScript的保留字

- 所有HTML元素以及与之关联的类型：

  | 元 素        | 类 型                     | 元 素      | 类 型                 |
  | ---------- | ----------------------- | -------- | ------------------- |
  | A          | HTMLAnchorElement       | EM       | HTMLElement         |
  | ABBR       | HTMLElement             | FIELDSET | HTMLFieldSetElement |
  | ACRONYM    | HTMLElement             | FONT     | HTMLFontElement     |
  | ADDRESS    | HTMLElement             | FORM     | HTMLFormElement     |
  | APPLET     | HTMLAppletElement       | FRAME    | HTMLFrameElement    |
  | AREA       | HTMLAreaElement         | FRAMESET | HTMLFrameSetElement |
  | B          | HTMLElement             | H1       | HTMLHeadingElement  |
  | BASE       | HTMLBaseElement         | H2       | HTMLHeadingElement  |
  | BASEFONT   | HTMLBaseFontElement     | H3       | HTMLHeadingElement  |
  | BDO        | HTMLElement             | H4       | HTMLHeadingElement  |
  | BIG        | HTMLElement             | H5       | HTMLHeadingElement  |
  | BLOCKQUOTE | HTMLQuoteElement        | H6       | HTMLHeadingElement  |
  | BODY       | HTMLBodyElement         | HEAD     | HTMLHeadElement     |
  | BR         | HTMLBRElement           | HR       | HTMLHRElement       |
  | BUTTON     | HTMLButtonElement       | HTML     | HTMLHtmlElement     |
  | CAPTION    | HTMLTableCaptionElement | I        | HTMLElement         |
  | CENTER     | HTMLElement             | IFRAME   | HTMLIFrameElement   |
  | CITE       | HTMLElement             | IMG      | HTMLImageElement    |
  | CODE       | HTMLElement             | INPUT    | HTMLInputElement    |

  | COL      | HTMLTableColElement  | INS      | HTMLModElement          |
  | -------- | -------------------- | -------- | ----------------------- |
  | COLGROUP | HTMLTableColElement  | ISINDEX  | HTMLIsIndexElement      |
  | DD       | HTMLElement          | KBD      | HTMLElement             |
  | DEL      | HTMLModElement       | LABEL    | HTMLLabelElement        |
  | DFN      | HTMLElement          | LEGEND   | HTMLLegendElement       |
  | DIR      | HTMLDirectoryElement | LI       | HTMLLIElement           |
  | DIV      | HTMLDivElement       | LINK     | HTMLLinkElement         |
  | DL       | HTMLDListElement     | MAP      | HTMLMapElement          |
  | DT       | HTMLElement          | MENU     | HTMLMenuElement         |
  | META     | HTMLMetaElement      | STRONG   | HTMLElement             |
  | NOFRAMES | HTMLElement          | STYLE    | HTMLStyleElement        |
  | NOSCRIPT | HTMLElement          | SUB      | HTMLElement             |
  | OBJECT   | HTMLObjectElement    | SUP      | HTMLElement             |
  | OL       | HTMLOListElement     | TABLE    | HTMLTableElement        |
  | OPTGROUP | HTMLOptGroupElement  | TBODY    | HTMLTableSectionElement |
  | OPTION   | HTMLOptionElement    | TD       | HTMLTableCellElement    |
  | P        | HTMLParagraphElement | TEXTAREA | HTMLTextAreaElement     |
  | PARAM    | HTMLParamElement     | TFOOT    | HTMLTableSectionElement |
  | PRE      | HTMLPreElement       | TH       | HTMLTableCellElement    |
  | Q        | HTMLQuoteElement     | THEAD    | HTMLTableSectionElement |

  | S      | HTMLElement       | TITLE | HTMLTitleElement    |
  | ------ | ----------------- | ----- | ------------------- |
  | SAMP   | HTMLElement       | TR    | HTMLTableRowElement |
  | SCRIPT | HTMLScriptElement | TT    | HTMLElement         |
  | SELECT | HTMLSelectElement | U     | HTMLElement         |
  | SMALL  | HTMLElement       | UL    | HTMLUListElement    |
  | SPAN   | HTMLElement       | VAR   | HTMLElement         |
  | STRIKE | HTMLElement       |       |                     |

#### 2. 取得特性

- 操作特性的DOM方法主要有三个，分别是getAttribute()、setAttribute()和removeAttribute()。这三个方法可以针对任何特性使用，包括那些以HTMLElement类型属性的形式定义的特性。

  - 注意，传递给getAttribute()的特性名与实际的特性名相同。因此要想得到class特性值，应该传入"class"而不是"className"，后者只有在通过对象属性访问特性时才用。如果给定名称的特性不存在，getAttribute()返回null。
  - 通过getAttribute()方法也可以取得自定义特性（即标准HTML语言中没有的特性）的值。

  > 特性的名称是不区分大小写的，即"ID"和"id"代表的都是同一个特性。另外也要注意，根据HTML5规范，自定义特性应该加上data-前缀以便验证。

  - 只有公认的（非自定义的）特性才会以属性的形式添加到DOM对象中。（IE除外, 认为自定义特性也创建属性）

  - 有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过getAttribute()返回的值并不相同。

    - 第一类特性就是style，用于通过CSS为元素指定样式。在通过getAttribute()访问时，返回的style特性值中包含的是CSS文本，而通过属性来访问它则会返回一个对象。

    > 由于style属性是用于以编程方式访问元素样式的，因此并没有直接映射到style特性。

    - 第二类与众不同的特性是onclick这样的事件处理程序。当在元素上使用时，onclick特性中包含的是JavaScript 代码，如果通过getAttribute()访问，则会返回相应代码的字符串。而在访问onclick属性时，则会返回一个JavaScript函数（如果未在元素中指定相应特性，则返回null）。

    > 这是因为onclick及其他事件处理程序属性本身就应该被赋予函数值。

#### 3. 设置特性

- setAttribute()
  - 接受两个参数：要设置的特性名和值。
    - 如果特性已经存在，setAttribute()会以指定的值替换现有的值；
    - 如果特性不存在，setAttribute()则创建该属性并设置相应的值。
  - 通过setAttribute()方法既可以操作HTML特性也可以操作自定义特性。
  - 通过这个方法设置的特性名会被统一转换为小写形式。
  - 因为所有特性都是属性，所以直接给属性赋值可以设置特性的值
  - 为DOM元素添加一个自定义的属性，该属性不会自动成为元素的特性。可是，自定义属性在IE中会被当作元素的特性，反之亦然。
  - 在IE7及以前版本中，setAttribute()存在一些异常行为。通过这个方法设置class和style特性，没有任何效果，而使用这个方法设置事件处理程序特性时也一样
- removeAttribute()，这个方法用于彻底删除元素的特性。
  - 调用这个方法不仅会清除特性的值，而且也会从元素中完全删除特性
  - 这个方法并不常用，但在序列化DOM元素时，可以通过它来确切地指定要包含哪些特性。
  - IE6及以前版本不支持removeAttribute()。

#### 4. attributes属性

- Element类型是使用attributes属性的唯一一个DOM节点类型。
- attributes属性中包含一个NamedNodeMap，与NodeList类似，也是一个“动态”的集合。元素的每一个特性都由一个Attr节点表示，每个节点都保存在NamedNodeMap对象中。
- NamedNodeMap对象拥有下列方法。
  - getNamedItem(name)：返回nodeName属性等于name的节点；
  - removeNamedItem(name)：从列表中移除nodeName属性等于name的节点；
  - setNamedItem(node)：向列表中添加节点，以节点的nodeName属性为索引；
  - item(pos)：返回位于数字pos位置处的节点。
- attributes属性中包含一系列节点，每个节点的nodeName就是特性的名称，而节点的nodeValue就是特性的值。
- 调用 removeNamedItem() 方法与在元素上调用 removeAttribute()方法的效果相同——直接删除具有给定名称的特性。两个方法间唯一的区别，即removeNamedItem()返回表示被删除特性的Attr节点。
- setNamedItem()是一个很不常用的方法，通过这个方法可以为元素添加一个新特性，为此需要为它传入一个特性节点
- 如果想要遍历元素的特性，attributes属性倒是可以派上用场。

#### 5. 创建元素

- document.createElement()方法可以创建新元素。
  - 这个方法只接受一个参数，即要创建元素的标签名。这个标签名在HTML文档中不区分大小写，而在XML（包括XHTML）文档中，则是区分大小写的。
- 在使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocuemnt属性。
- 在IE中可以以另一种方式使用createElement()，即为这个方法传入完整的元素标签，也可以包含属性。这种方式有助于避开在IE7及更早版本中动态创建元素的某些问题。下面是已知的一些这类问题。
  - 不能设置动态创建的<iframe>元素的name特性。
  - 不能通过表单的reset()方法重设动态创建的<input>元素。
  - 动态创建的type特性值为"reset"的<buttou>元素重设不了表单。
  - 动态创建的一批name相同的单选按钮彼此毫无关系。name值相同的一组单选按钮本来应该用于表示同一选项的不同值，但动态创建的一批这种单选按钮之间却没有这种关系。

#### 6. 元素的子节点

- 不同浏览器在看待这些节点方面存在显著的不同如果需要通过childNodes属性遍历子节点，那么一定不要忘记浏览器间的这一差别。这意味着在执行某项操作以前，通常都要先检查一下nodeTpye属性

- 如果想通过某个特定的标签名取得子节点或后代节点该怎么办呢？实际上，元素也支持getElementsByTagName()方法。在通过元素调用这个方法时，除了搜索起点是当前元素之外，其他方面都跟通过document调用这个方法相同，因此结果只会返回当前元素的后代。

  ```
  var ul = document.getElementById("myList");
  var items = ul.getElementsByTagName("li");
  ```

### 10.1.4 Text类型

- 文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。
- Text节点具有以下特征：
  - nodeType的值为3；
  - nodeName的值为"#text"；
  - nodeValue的值为节点所包含的文本；
  - parentNode是一个Element；
  - 不支持（没有）子节点。
- 可通过nodeValue属性或data属性访问Text节点中包含的文本，这两个属性中包含的值相同。对nodeValue的修改也会通过data反映出来，反之亦然。
- 使用下列方法可以操作节点中的文本。
  - appendData(text)：将text添加到节点的末尾。
  - deleteData(offset, count)：从offset指定的位置开始删除count个字符。
  - insertData(offset, text)：在offset指定的位置插入text。
  - replaceData(offset, count, text)：用text替换从offset指定的位置开始到offset+count为止处的文本。
  - splitText(offset)：从offset指定的位置将当前文本节点分成两个文本节点。
  - substringData(offset, count)：提取从offset指定的位置开始到offset+count为止处的字符串。
- 文本节点还有一个length 属性，保存着节点中字符的数目。
- 在默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在。

#### 1. 创建文本节点

- document.createTextNode()创建新文本节点
  - 这个方法接受一个参数——要插入节点中的文本。
  - 与设置已有文本节点的值一样，作为参数的文本也将按照HTML或XML的格式进行编码。
  - 在创建新文本节点的同时，也会为其设置ownerDocument属性。
  - 如果两个文本节点是相邻的同胞节点，那么这两个节点中的文本就会连起来显示，中间不会有空格。

#### 2. 规范化文本节点

- normalize()
  - 在一个包含两个或多个文本节点的父元素上调用normalize()方法，则会将所有文本节点合并成一个节点，结果节点的nodeValue等于将合并前每个文本节点的nodeValue值拼接起来的值。
  - 浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行DOM操作的结果出现。
  - 在某些情况下，执行normalize()方法会导致IE6崩溃。

#### 3. 分割文本节点

- splitText()
  - 这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割nodeValue值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。
  - 这个方法会返回一个新文本节点，该节点与原节点的parentNode相同。
- 分割文本节点是从文本节点中提取数据的一种常用DOM解析技术。

### 10.1.5 Comment类型

- 注释在DOM中是通过Comment类型来表示的。
- Comment节点具有下列特征：
  - nodeType的值为8；
  - nodeName的值为"#comment"；
  - nodeValue的值是注释的内容；
  - parentNode可能是Document或Element；
  - 不支持（没有）子节点。
- Comment类型与Text类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法。
- 使用document.createComment()并为其传递注释文本也可以创建注释节点
- 尽管IE9 没有把注释当成元素，但它仍然通过一个名为HTMLCommentElement的构造函数来表示注释。

### 10.1.6 CDATASection类型

- CDATASection 类型只针对基于XML的文档，表示的是CDATA区域。与Comment 类似，
- CDATASection 类型继承自Text 类型，因此拥有除splitText()之外的所有字符串操作方法。
- CDATASection节点具有下列特征：
  - nodeType的值为4；
  - nodeName的值为"#cdata-section"；
  - nodeValue的值是CDATA区域中的内容；
  - parentNode可能是Document或Element；
  - 不支持（没有）子节点。
- CDATA区域只会出现在XML文档中，因此多数浏览器都会把CDATA区域错误地解析为Comment或Element。
- 在真正的XML文档中，可以使用document.createCDataSection()来创建CDATA区域，只需为其传入节点的内容即可。
- 在Firefox、Safari、Chrome和Opera中，可以访问CDATASection类型的构造函数和原型。IE9及之前版本不支持这个类型。

### 10.1.7 DocumentType类型

- DocumentType类型在Web浏览器中并不常用，仅有Firefox、Safari和Opera支持它。
- DocumentType包含着与文档的doctype有关的所有信息，它具有下列特征：
  - nodeType的值为10；
  - nodeName的值为doctype的名称；
  - nodeValue的值为null；
  - parentNode是Document；
  - 不支持（没有）子节点。
- 在DOM1级中，DocumentType对象不能动态创建，而只能通过解析文档代码的方式来创建。
- 支持它的浏览器会把DocumentType 对象保存在document.doctype 中。
- DOM1级描述了DocumentType对象的3个属性：name、entities和notations。
  - name表示文档类型的名称；
  - entities是由文档类型描述的实体的NamedNodeMap对象；
  - notations是由文档类型描述的符号的NamedNodeMap对象。
  - 通常，浏览器中的文档使用的都是HTML或XHTML文档类型，因而entities和notations都是空列表（列表中的项来自行内文档类型声明）。
- IE9 会给document.doctype赋正确的对象，但仍然不支持访问DocumentType类型。

### 10.1.8 DocumentFragment类型

- 在所有节点类型中，只有DocumentFragment 在文档中没有对应的标记。
- DOM规定文档片段（document fragment）是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。
- DocumentFragment节点具有下列特征：
  - nodeType的值为11；
  - nodeName的值为"#document-fragment"；
  - nodeValue的值为null；
  - parentNode的值为null；
  - 子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection 或 EntityReference。
- 虽然不能把文档片段直接添加到文档中，但可以将它作为一个“仓库”来使用，即可以在里面保存将来可能会添加到文档中的节点。如果逐个地添加列表项，将会导致浏览器反复渲染要创建文档片段，可以使用document.createDocumentFragment()方法
- 文档片段继承了Node的所有方法，通常用于执行那些针对文档的DOM操作。
- 如果将文档中的节点添加到文档片段中，就会从文档树中移除该节点，也不会从浏览器中再看到该节点。添加到文档片段中的新节点同样也不属于文档树。

### 10.1.9 Attr类型

- 元素的特性在DOM中以Attr类型来表示。在所有浏览器中（包括IE8），都可以访问Attr类型的构造函数和原型。从技术角度讲，特性就是存在于元素的attributes属性中的节点。
- 特性节点具有下列特征：
  - nodeType的值为2；
  - nodeName的值是特性的名称；
  - nodeValue的值是特性的值；
  - parentNode的值为null；
  - 在HTML中不支持（没有）子节点；
  - 在XML中子节点可以是Text或EntityReference。
- 尽管它们也是节点，但特性却不被认为是DOM文档树的一部分。开发人员最常使用的是getAttribute()、setAttribute()和remveAttribute()方法，很少直接引用特性节点。
- Attr对象有3个属性：name、value和specified。
  - name是特性名称（与nodeName的值相同）
  - value是特性的值（与nodeValue的值相同）
  - specified是一个布尔值，用以区别特性是在代码中指定的，还是默认的。
- 使用document.createAttribute()并传入特性的名称可以创建新的特性节点。
- 为了将新创建的特性添加到元素中，必须使用元素的setAttributeNode()方法。
- 添加特性之后，可以通过下列任何方式访问该特性：attributes属性、getAttributeNode()方法以及getAttribute()方法。其中，attributes和getAttributeNode()都会返回对应特性的Attr节点，而getAttribute()则只返回特性的值。不建议直接访问特性节点。

## 10.2 DOM操作技术

### 10.2.1 动态脚本

- 创建动态脚本也有两种方式：插入外部文件和直接插入JavaScript代码。
- 动态加载的外部JavaScript文件能够立即运行；另一种指定JavaScript代码的方式是行内方式
- IE 将<script>视为一个特殊的元素，不允许DOM访问其子节点。不过，可以使用<script>元素的text属性来指定JavaScript代码
- 以这种方式加载的代码会在全局作用域中执行，而且当脚本执行后将立即可用。
- 实际上，这样执行代码与在全局作用域中把相同的字符串传递给eval()是一样的。

### 10.2.2 动态样式

- 能够把CSS样式包含到HTML页面中的元素有两个。
- <link>元素用于包含来自外部的文件，而<style>元素用于指定嵌入的样式。
- 需要注意的是，必须将<link>元素添加到<head>而不是<body>元素，才能保证在所有浏览器中的行为一致。
- 加载外部样式文件的过程是异步的，也就是加载样式与执行JavaScript代码的过程没有固定的次序。
- 另一种定义样式的方式是使用<style>元素来包含嵌入式CSS，可以在Firefox、Safari、Chrome和Opera中运行，在IE中则会报错。

> IE将<style>视为一个特殊的、与<script>类似的节点，不允许访问其子节点。事实上，IE此时抛出的错误与向<script>元素添加子节点时抛出的错误相同。

- 解决IE中这个问题的办法，就是访问元素的styleSheet属性，该属性又有一个cssText属性，可以接受CSS代码

> 如果专门针对IE编写代码，务必小心使用styleSheet.cssText属性。在重用同一个<style>元素并再次设置这个属性时，有可能会导致浏览器崩溃。同样，将cssText属性设置为空字符串也可能导致浏览器崩溃。

### 10.2.3 操作表格

- 为<table>元素添加的属性和方法如下。
  - caption：保存着对<caption>元素（如果有）的指针。
  - tBodies：是一个<tbody>元素的HTMLCollection。
  - tFoot：保存着对<tfoot>元素（如果有）的指针。
  - tHead：保存着对<thead>元素（如果有）的指针。
  - rows：是一个表格中所有行的HTMLCollection。
  - createTHead()：创建<thead>元素，将其放到表格中，返回引用。
  - createTFoot()：创建<tfoot>元素，将其放到表格中，返回引用。
  - createCaption()：创建<caption>元素，将其放到表格中，返回引用。
  - deleteTHead()：删除<thead>元素。
  - deleteTFoot()：删除<tfoot>元素。
  - deleteCaption()：删除<caption>元素。
  - deleteRow(pos)：删除指定位置的行。
  - insertRow(pos)：向rows集合中的指定位置插入一行。
- 为<tbody>元素添加的属性和方法如下。
  - rows：保存着<tbody>元素中行的HTMLCollection。
  - deleteRow(pos)：删除指定位置的行。
  - insertRow(pos)：向rows集合中的指定位置插入一行，返回对新插入行的引用。
- 为<tr>元素添加的属性和方法如下。
  - cells：保存着<tr>元素中单元格的HTMLCollection。
  - deleteCell(pos)：删除指定位置的单元格。
  - insertCell(pos)：向cells集合中的指定位置插入一个单元格，返回对新插入单元格的引用。

### 10.2.4使用NodeList

- NodeList、NamedNodeMap和HTMLCollection，这三个集合都是“动态的”
- 从本质上说，所有NodeList对象都是在访问DOM文档时实时运行的查询。
- 如果想要迭代一个NodeList，最好是使用length属性初始化第二个变量，然后将迭代器与该变量进行比较
- 一般来说，应该尽量减少访问NodeList的次数。因为每次访问NodeList，都会运行一次基于文档的查询。所以，可以考虑将从NodeList中取得的值缓存起来。

## 10.3小结

- DOM由各种节点构成，简要总结如下。
  - 最基本的节点类型是Node，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自Node
  - Document类型表示整个文档，是一组分层节点的根节点。在JavaScript中，document对象是Document的一个实例。使用document对象，有很多种方式可以查询和取得节点。
  - Element节点表示文档中的所有HTML或XML元素，可以用来操作这些元素的内容和特性。
  - 另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA区域和文档片段。
- 访问DOM的操作在多数情况下都很直观，不过在处理<script>和<style>元素时还是存在一些复杂性。由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这些区别导致了在针对这些元素使用innerHTML时，以及在创建新元素时的一些问题。
- 理解DOM的关键，就是理解DOM对性能的影响。DOM操作往往是JavaScript程序中开销最大的部分，而因访问NodeList导致的问题为最多。NodeList对象都是“动态的”，这就意味着每次访问NodeList对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少DOM操作。

# 第11章 DOM 扩展

- 对DOM的两个主要的扩展是Selectors API（选择符API）和HTML5
- 还有一个不那么引人瞩目的Element Traversal（元素遍历）规范，为DOM添加了一些属性。

## 11.1 选择符API

- Selectors API 是由W3C发起制定的一个标准，致力于让浏览器原生支持CSS查询。
- Selectors API Level 1的核心是两个方法：querySelector()和querySelectorAll()。
- 目前已完全支持Selectors API Level 1的浏览器有IE 8+、Firefox 3.5+、Safari 3.1+、Chrome和Opera 10+。

### 11.1.1 querySelector()方法

- querySelector()方法接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。

### 11.1.2 querySelectorAll()方法

- 这个方法返回的是一个NodeList的实例。
- 具体来说，返回的值实际上是带有所有属性和方法的NodeList，而其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询。
- 只要传给querySelectorAll()方法的CSS选择符有效，该方法都会返回一个NodeList对象，而不管找到多少匹配的元素。

### 11.1.3 matchesSelector()方法

- matchesSelector()方法
  - 接收一个参数，即CSS选择符
  - 如果调用元素与该选择符匹配，返回true；否则，返回false。
- 浏览器支持性不确定，因此，如果你想使用这个方法，最好是编写一个包装函数。

## 11.2 元素遍历

- 对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。
- Element Traversal API为DOM元素添加了以下5个属性。
  - childElementCount：返回子元素（不包括文本节点和注释）的个数。
  - firstElementChild：指向第一个子元素；firstChild的元素版。
  - lastElementChild：指向最后一个子元素；lastChild的元素版。
  - previousElementSibling：指向前一个同辈元素；previousSibling的元素版。
  - nextElementSibling：指向后一个同辈元素；nextSibling的元素版。
- 支持的浏览器为DOM元素添加了这些属性，利用这些元素不必担心空白文本节点，从而可以更方便地查找DOM元素了。
- 支持Element Traversal规范的浏览器有IE 9+、Firefox 3.5+、Safari 4+、Chrome和Opera 10+。

## 11.3  HTML5

### 11.3.1 与类相关的扩充

#### 1. getElementsByClassName()方法

- 可通过document对象及所有HTML元素调用该方法。这个方法是通过既有的DOM功能实现的，而原生的实现具有极大的性能优势。


- 指定类的所有元素的NodeList。传入多个类名时，类名的先后顺序不重要。
- 调用这个方法时，只有位于调用元素子树中的元素才会返回。在document 对象上调用getElementsByClassName()始终会返回与类名匹配的所有元素，在元素上调用该方法就只会返回后代元素中匹配的元素。
- 支持getElementsByClassName()方法的浏览器有IE 9+、Firefox 3+、Safari 3.1+、Chrome和Opera 9.5+。

#### 2. classList属性

- 在操作类名时，需要通过className属性添加、删除和替换类名。因为className中是一个字符串，所以即使只修改字符串一部分，也必须每次都设置整个字符串的值。
- HTML5新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加classList属性。这个classList属性是新集合类型DOMTokenList的实例。与其他DOM集合类似，DOMTokenList有一个表示自己包含多少元素的length属性，而要取得每个元素可以使用item()方法，也可以使用方括号语法。
- 这个新类型还定义如下方法。
  - add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。
  - contains(value)：表示列表中是否存在给定的值，如果存在则返回true，否则返回false。
  - remove(value)：从列表中删除给定的字符串。
  - toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。
- 有了classList属性，除非你需要全部删除所有类名，或者完全重写元素的class属性，否则也就用不到className属性了。
- 支持classList属性的浏览器有Firefox 3.6+和Chrome。

### 11.3.2 焦点管理

- HTML5也添加了辅助管理DOM焦点的功能。
- 首先就是document.activeElement属性，这个属性始终会引用DOM中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入（通常是通过按Tab键）和在代码中调用focus()方法。
  - 默认情况下，文档刚刚加载完成时，document.activeElement中保存的是document.body元素的引用。文档加载期间，document.activeElement的值为null。
- 另外就是新增了document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。
- 查询文档获知哪个元素获得了焦点，以及确定文档是否获得了焦点，这两个功能最重要的用途是提高Web应用的无障碍性。无障碍Web应用的一个主要标志就是恰当的焦点管理
- 实现了这两个属性的浏览器的包括IE 4+、Firefox 3+、Safari 4+、Chrome和Opera 8+。

### 11.3.3 HTMLDocument的变化

#### 1. readyState属性

- IE4最早为document对象引入了readyState属性。然后，其他浏览器也都陆续添加这个属性，最终HTML5把这个属性纳入了标准当中。

- Document的readyState属性有两个可能的值：

  - loading，正在加载文档；
  - complete，已经加载完文档。

- 使用document.readyState的最恰当方式，就是通过它来实现一个指示文档已经加载完成的指示器。

- document.readyState属性的基本用法如下。

  ```
  if (document.readyState == "complete"){
  	//执行操作
  }
  ```

- 支持readyState属性的浏览器有IE4+、Firefox 3.6+、Safari、Chrome和Opera 9+。

#### 2. 兼容模式

- IE为此给document添加了一个名为compatMode的属性，这个属性就是为了告诉开发人员浏览器采用了哪种渲染模式。
- 在标准模式下，document.compatMode的值等于"CSS1Compat"，而在混杂模式下，document.compatMode的值等于"BackCompat"。

#### 3. head属性

- HTML5新增了document.head属性，引用文档的<head>元素。要引用文档的<head>元素，可以结合使用这个属性和另一种后备方法。

  ```
  var head = document.head || document.getElementsByTagName("head")[0];
  ```

- 实现document.head属性的浏览器包括Chrome和Safari 5。

### 11.3.4 字符集属性

- charset属性表示文档中实际使用的字符集，也可以用来指定新字符集。
- 默认情况下，这个属性的值为"UTF-16"，但可以通过<meta>元素、响应头部或直接设置charset属性修改这个值。
- 另一个属性是defaultCharset，表示根据默认浏览器及操作系统的设置，当前文档默认的字符集应该是什么。
- 支持document.charset 属性的浏览器有IE、Firefox、Safari、Opera和Chrome。
- 支持document.defaultCharset属性的浏览器有IE、Safari和Chrome。

### 11.3.5 自定义数据属性

- HTML5规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以data-开头即可。
- 添加了自定义属性之后，可以通过元素的dataset属性来访问自定义属性的值。
- dataset属性的值是DOMStringMap的一个实例，也就是一个名值对儿的映射。在这个映射中，每个data-name形式的属性都会有一个对应的属性，只不过属性名没有data-前缀
- 如果需要给元素添加一些不可见的数据以便进行其他处理，那就要用到自定义数据属性。在跟踪链接或混搭应用中，通过自定义数据属性能方便地知道点击来自页面中的哪个部分。

### 11.3.6 插入标记

- 使用插入标记的技术，直接插入HTML字符串不仅更简单，速度也更快。
- 以下与插入标记相关的DOM扩展已经纳入了HTML5规范。

#### 1. innerHTML属性

- 在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的HTML标记。
  - 不同浏览器返回的文本格式会有所不同。IE和Opera会将所有标签转换为大写形式，而Safari、Chrome和Firefox则会原原本本地按照原先文档中（或指定这些标签时）的格式返回HTML，包括空格和缩进。
- 在写模式下，innerHTML会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。
- 使用innerHTML属性也有一些限制。

> 比如，在大多数浏览器中，通过innerHTML插入<script>元素并不会执行其中的脚本。IE8及更早版本是唯一能在这种情况下执行脚本的浏览器，但必须满足一些条件。一是必须为<script>元素指定defer属性，二是<script>元素必须位于（微软所谓的）“有作用域的元素”（scoped element）之后 。<script>元素被认为是“无作用域的元素”（NoScope element），也就是在页面中看不到的元素，与<style>元素或注释类似。如果通过innerHTML插入的字符串开头就是一个“无作用域的元素”，那么IE会在解析这个字符串前先删除该元素。（可以插入隐藏的<input>域，不影响页面布局）

- 大多数浏览器都支持以直观的方式通过innerHTML插入<style>元素，但在IE8 及更早版本中，<style>也是一个“没有作用域的元素”
- 不支持innerHTML的元素有：<col>、<colgroup>、<frameset>、<head>、<html>、<style>、<table>、<tbody>、<thead>、<tfoot>和<tr>。
- 此外，在IE8及更早版本中，<title>元素也没有innerHTML属性。
- Firefox对在内容类型为application/xhtml+xml的XHTML文档中设置innerHTML有严格的限制。在XHTML文档中使用innerHTML时，XHTML代码必须完全符合要求。如果代码格式不正确，设置innerHTML将会静默地失败。
- 无论什么时候，只要使用innerHTML从外部插入HTML，都应该首先以可靠的方式处理HTML。IE8为此提供了window.toStaticHTML()方法，这个方法接收一个参数，即一个HTML字符串；返回一个经过无害处理后的版本——从源HTML中删除所有脚本节点和事件处理程序属性。

#### 2. outerHTML属性

- 在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。
- 在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。
- 支持outerHTML属性的浏览器有IE4+、Safari 4+、Chrome和Opera 8+。Firefox 7及之前版本都不支持outerHTML属性。

#### 3. insertAdjacentHTML()方法

- 插入标记的最后一个新增方式是insertAdjacentHTML()方法。这个方法最早也是在IE中出现的，
- 它接收两个参数：插入位置和要插入的HTML文本。
  - 第一个参数必须是下列值之一：
    - "beforebegin"，在当前元素之前插入一个紧邻的同辈元素；
    - "afterbegin"，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；
    - "beforeend"，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；
    - "afterend"，在当前元素之后插入一个紧邻的同辈元素。
    - 注意，这些值都必须是小写形式。
  - 第二个参数是一个HTML字符串（与innerHTML和outerHTML的值相同），如果浏览器无法解析该字符串，就会抛出错误。
- 支持insertAdjacentHTML()方法的浏览器有IE、Firefox 8+、Safari、Opera和Chrome。

#### 4. 内存与性能问题

- 使用本节介绍的方法替换子节点可能会导致浏览器的内存占用问题，尤其是在IE 中，问题更加明显。
- 在删除带有事件处理程序或引用了其他JavaScript对象子树时，就有可能导致内存占用问题。

> 在插入大量新HTML标记时，使用innerHTML属性与通过多次DOM操作先创建节点再指定它们之间的关系相比，效率要高得多。这是因为在设置innerHTML或outerHTML时，就会创建一个HTML解析器。这个解析器是在浏览器级别的代码（通常是C++编写的）基础上运行的，因此比执行JavaScript快得多。不可避免地，创建和销毁HTML解析器也会带来性能损失，所以最好能够将设置innerHTML或outerHTML的次数控制在合理的范围内。

### 11.3.7 scrollIntoView()方法

- HTML5最终选择了scrollIntoView()作为标准方法。
- scrollIntoView()可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。
- 如果给这个方法传入true作为参数，或者不传入任何参数，那么窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐。如果传入false作为参数，调用元素会尽可能全部出现在视口中（可能的话，调用元素的底部会与视口顶部平齐。）
- 实际上，为某个元素设置焦点也会导致浏览器滚动并显示出获得焦点的元素。
- 支持scrollIntoView()方法的浏览器有IE、Firefox、Safari和Opera。

## 11.4 专有扩展

### 11.4.1 文档模式

- IE8引入了一个新的概念叫“文档模式”。页面的文档模式决定了可以使用什么功能。到了IE9，总共有以下4种文档模式。

  - IE5：以混杂模式渲染页面（IE5的默认模式就是混杂模式）。IE8及更高版本中的新功能都无法使用。
  - IE7：以IE7标准模式渲染页面。IE8及更高版本中的新功能都无法使用。
  - IE8：以IE8标准模式渲染页面。IE8中的新功能都可以使用，因此可以使用Selectors API、更多CSS2级选择符和某些CSS3功能，还有一些HTML5的功能。不过IE9中的新功能无法使用。
  - IE9：以IE9标准模式渲染页面。IE9中的新功能都可以使用，比如ECMAScript 5、完整的CSS3以及更多HTML5功能。这个文档模式是最高级的模式。

- 要强制浏览器以某种模式渲染页面，可以使用HTTP头部信息X-UA-Compatible，或通过等价的<meta>标签来设置：

  ```
  <meta http-equiv="X-UA-Compatible" content="IE=IEVersion"> 
  ```

  注意，这里IE的版本（IEVersion）有以下一些不同的值，而且这些值并不一定与上述4种文档
  模式对应。

  - Edge：始终以最新的文档模式来渲染页面。忽略文档类型声明。对于IE8，始终保持以IE8标准模式渲染页面。对于IE9，则以IE9标准模式渲染页面。
  - EmulateIE9：如果有文档类型声明，则以IE9标准模式渲染页面，否则将文档模式设置为IE5。
  - EmulateIE8：如果有文档类型声明，则以IE8标准模式渲染页面，否则将文档模式设置为IE5。
  - EmulateIE7：如果有文档类型声明，则以IE7标准模式渲染页面，否则将文档模式设置为IE5。
  - 9：强制以IE9标准模式渲染页面，忽略文档类型声明。
  - 8：强制以IE8标准模式渲染页面，忽略文档类型声明。
  - 7：强制以IE7标准模式渲染页面，忽略文档类型声明。
  - 5：强制将文档模式设置为IE5，忽略文档类型声明。

- 通过document.documentMode属性可以知道给定页面使用的是什么文档模式。这个属性是IE8中新增的，它会返回使用的文档模式的版本号（在IE9中，可能返回的版本号为5、7、8、9）

### 11.4.2 children属性

- children属性是HTMLCollection 的实例，只包含元素中同样还是元素的子节点。除此之外，children属性与childNodes没有什么区别，即在元素只包含元素子节点时，这两个属性的值相同。
- 支持children属性的浏览器有IE5、Firefox 3.5、Safari 2（但有bug）、Safari 3（完全支持）、Opera8和Chrome（所有版本）。IE8及更早版本的children属性中也会包含注释节点，但IE9之后的版本则只返回元素节点。

### 11.4.3 contains()方法

- 调用contains()方法的应该是祖先节点，也就是搜索开始的节点，这个方法接收一个参数，即要检测的后代节点。如果被检测的节点是后代节点，该方法返回true；否则，返回false。

- 支持contains()方法的浏览器有IE、Firefox 9+、Safari、Opera和Chrome。

- 使用DOM Level 3compareDocumentPosition()也能够确定节点间的关系。支持这个方法的浏览器有IE9+、Firefox、Safari、Opera 9.5+和Chrome。这个方法用于确定两个节点间的关系，返回一个表示该关系的位掩码（bitmask）。

  | 掩码   | 节点关系                    |
  | ---- | ----------------------- |
  | 1    | 无关（给定的节点不在当前文档中）        |
  | 2    | 居前（给定的节点在DOM树中位于参考节点之前） |
  | 4    | 居后（给定的节点在DOM树中位于参考节点之后） |
  | 8    | 包含（给定的节点是参考节点的祖先）       |
  | 16   | 被包含（给定的节点是参考节点的后代）      |

- 为模仿contains()方法，应该关注的是掩码16。可以对compareDocumentPosition()的结果执行按位与，以确定参考节点（调用compareDocumentPosition()方法的当前节点）是否包含给定的节点（传入的节点）。

### 11.4.4 插入文本

- innerText和outerText没有被HTML5纳入规范。

#### 1. innerText属性

- 通过innertText 属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。

- 在通过innerText 读取值时，它会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。

- 在通过innerText写入值时，结果会删除元素的所有子节点，插入包含相应文本值的文本节点。

- 由于不同浏览器处理空白符的方式不同，因此输出的文本可能会也可能不会包含原始HTML代码中的缩进。

- 设置innerText属性移除了先前存在的所有子节点，完全改变了DOM子树。此外，设置innerText属性的同时，也对文本中存在的HTML语法字符（小于号、大于号、引号及和号）进行了编码。

- 设置innerText永远只会生成当前节点的一个子文本节点，而为了确保只生成一个子文本节点，就必须要对文本进行HTML编码。利用这一点，可以通过innerText属性过滤掉HTML标签。方法是将innerText设置为等于innerText，这样就可以去掉所有HTML标签，比如：

  ```
  div.innerText = div.innerText;
  ```

- 支持innerText 属性的浏览器包括IE4+、Safari 3+、Opera 8+和Chrome。Firefox虽然不支持innerText，但支持作用类似的textContent属性。

- textContent是DOM Level 3规定的一个属性，其他支持textContent属性的浏览器还有IE9+、Safari 3+、Opera 10+和Chrome。

- innerText 与textContent 返回的内容并不完全一样。

  - innerText会忽略行内的样式和脚本，而textContent则会像返回其他文本一样返回行内的样式和脚本代码。避免跨浏览器兼容问题的最佳途径，就是从不包含行内样式或行内脚本的DOM子树副本或DOM片段中读取文本。

#### 2. outerText属性

- 在读取文本值时，outerText与innerText的结果完全一样。
- 但在写模式下，outerText就完全不同了：outerText不只是替换调用它的元素的子节点，而是会替换整个元素（包括子节点）。
- 支持outerText属性的浏览器有IE4+、Safari 3+、Opera 8+和Chrome。由于这个属性会导致调用它的元素不存在，因此并不常用。

### 11.4.5 滚动

- scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。如果将可选的alignCenter参数设置为true，则表示尽量将元素显示在视口中部（垂直方向）。Safari和Chrome实现了这个方法。
- scrollByLines(lineCount)：将元素的内容滚动指定的行高，lineCount值可以是正值，也可以是负值。Safari和Chrome实现了这个方法。
- scrollByPages(pageCount)：将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。Safari和Chrome实现了这个方法。
- 注意，scrollIntoView()和scrollIntoViewIfNeeded()的作用对象是元素的容器，而scrollByLines()和scrollByPages()影响的则是元素自身。

## 11.5小结

- Selectors API，定义了两个方法，让开发人员能够基于CSS选择符从DOM中取得元素，这两个方法是querySelector()和querySelectorAll()。
- Element Traversal，为DOM元素定义了额外的属性，让开发人员能够更方便地从一个元素跳到另一个元素。之所以会出现这个扩展，是因为浏览器处理DOM元素间空白符的方式不一样。
- HTML5，为标准的DOM定义了很多扩展功能。其中包括在innerHTML属性这样的事实标准基础上提供的标准定义，以及为管理焦点、设置字符集、滚动页面而规定的扩展API。



# 第12章 DOM2和DOM3

## 12.1 DOM变化

### 12.1.1 针对XML命名空间的变化

- 从技术上说，HTML不支持XML命名空间，但XHTML支持XML命名空间。
- 命名空间要使用xmlns特性来指定。XHTML的命名空间是`http://www.w3.org/1999/xhtml`，在任何格式良好XHTML页面中，都应该将其包含在<html>元素中
- 要想明确地为XML命名空间创建前缀，可以使用xmlns后跟冒号，再后跟前缀

#### 1. Node类型的变化

在DOM2级中，Node类型包含下列特定于命名空间的属性。

- localName：不带命名空间前缀的节点名称。
- namespaceURI：命名空间URI或者（在未指定的情况下是）null。
- prefix：命名空间前缀或者（在未指定的情况下是）null。

DOM3级在此基础上更进一步，又引入了下列与命名空间有关的方法

- isDefaultNamespace(namespaceURI)：在指定的namespaceURI是当前节点的默认命名空间的情况下返回true。
- lookupNamespaceURI(prefix)：返回给定prefix的命名空间。
- lookupPrefix(namespaceURI)：返回给定namespaceURI的前缀。

#### 2. Document类型的变化

DOM2级中的Document类型也发生了变化，包含了下列与命名空间有关的方法。

- createElementNS(namespaceURI, tagName)：使用给定的tagName创建一个属于命名空间namespaceURI的新元素。
- createAttributeNS(namespaceURI, attributeName)：使用给定的attributeName创建一个属于命名空间namespaceURI的新特性。
- getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName元素的NodeList。

#### 3. Element类型的变化

“DOM2级核心”新增的方法如下。

- getAttributeNS(namespaceURI,localName)：取得属于命名空间namespaceURI且名为localName的特性。
- getAttributeNodeNS(namespaceURI,localName)：取得属于命名空间namespaceURI且名为localName的特性节点。
- getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName元素的NodeList。
- hasAttributeNS(namespaceURI,localName)：确定当前元素是否有一个名为localName的特性，而且该特性的命名空间是namespaceURI。注意，“DOM2级核心”也增加了一个hasAttribute()方法，用于不考虑命名空间的情况。
- removeAttriubteNS(namespaceURI,localName)：删除属于命名空间namespaceURI且名为localName的特性。
- setAttributeNS(namespaceURI,qualifiedName,value)：设置属于命名空间namespaceURI且名为qualifiedName的特性的值为value。
- setAttributeNodeNS(attNode)：设置属于命名空间namespaceURI的特性节点。

#### 4. NamedNodeMap类型的变化

由于特性是通过NamedNodeMap表示的，因此这些方法多数情况下只针对特性使用。

- getNamedItemNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName的项。
- removeNamedItemNS(namespaceURI,localName)：移除属于命名空间namespaceURI且名为localName的项。
- setNamedItemNS(node)：添加node，这个节点已经事先指定了命名空间信息。

由于一般都是通过元素访问特性，所以这些方法很少使用。



### 12.1.2 其他方面的变化

#### 1. DocumentType类型的变化

DocumentType类型新增了3个属性：publicId、systemId和internalSubset。其中，前两个属性表示的是文档类型声明中的两个信息段，这两个信息段在DOM1级中是没有办法访问到的。最后一个属性internalSubset，用于访问包含在文档类型声明中的额外定义

#### 2. Document类型的变化

Document类型的变化中唯一与命名空间无关的方法是importNode()。

- 这个方法的用途是从一个文档中取得一个节点，然后将其导入到另一个文档，使其成为这个文档结构的一部分。
- 需要注意的是，每个节点都有一个ownerDocument属性，表示所属的文档。如果调用appendChild()时传入的节点属于不同的文档（ownerDocument属性的值不一样），则会导致错误。但在调用importNode()时传入不同文档的节点则会返回一个新节点，这个新节点的所有权归当前文档所有。
- 接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使用。
- 这个方法在HTML文档中并不常用，在XML文档中用得比较多。

“DOM2级视图”模块添加了一个名为defaultView的属性，其中保存着一个指针，指向拥有给定文档的窗口（或框架）。

除IE之外的所有浏览器都支持defaultView属性。在IE中有一个等价的属性名叫parentWindow（Opera也支持这个属性）。

“DOM2级核心”还为document.implementation对象规定了两个新方法：createDocumentType()和createDocument()。前者用于创建一个新的DocumentType节点，接受3个参数：文档类型名称、publicId、systemId。

创建新文档时需要用到createDocument()方法。这个方法接受3个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型。

```javascript
e.g.	创建XHTML文档
var doctype = document.implementation.createDocumentType("html",
" -//W3C//DTD XHTML 1.0 Strict//EN","http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd");
var doc = document.implementation.createDocument("http://www.w3.org/1999/xhtml",
"html", doctype);
```

“DOM2级HTML”模块也为document.implementation新增了一个方法，名叫createHTMLDocument()。这个方法的用途是创建一个完整的HTML文档，包括<html>、<head>、<title>和<body>元素。这个方法只接受一个参数，即新创建文档的标题（放在<title>元素中的字符串），返回新的HTML文档

只有Opera和Safari支持这个方法。

#### 3. Node类型的变化

isSupported()方法。

- isSupported()方法用于确定当前节点具有什么能力。
- 接受相同的两个参数：特性名和特性版本号。
- 如果浏览器实现了相应特性，而且能够基于给定节点执行该特性，isSupported()就返回true。
- 这个方法同样也存在与DOM1的hasFeature()方法相同的问题。为此，我们建议在确定某个特性是否可用时，最好还是使用能力检测。

DOM3级引入了两个辅助比较节点的方法：isSameNode()和isEqualNode()。

- 这两个方法都接受一个节点参数，并在传入节点与引用的节点相同或相等时返回true。所谓相同，指的是两个节点引用的是同一个对象。所谓相等，指的是两个节点是相同的类型，具有相等的属性（nodeName、nodeValue，等等），而且它们的attributes和childNodes属性也相等（相同位置包含相同的值）。

DOM3级针对为DOM节点添加额外数据引入了新方法

- setUserData()方法
  - 将数据指定给节点
  - 接受3个参数：要设置的键、实际的数据（可以是任何数据类型）和处理函数。
    - 传入setUserData()中的处理函数会在带有数据的节点被复制、删除、重命名或引入一个文档时调用，因而你可以事先决定在上述操作发生时如何处理用户数据。
    - 处理函数接受5个参数：表示操作类型的数值（1表示复制，2表示导入，3表示删除，4表示重命名）、数据键、数据值、源节点和目标节点。在删除节点时，源节点是null；除在复制节点时，目标节点均为null。

#### 4. 框架的变化

框架和内嵌框架分别用HTMLFrameElement和HTMLIFrameElement表示，它们在DOM2级中都有了一个新属性，名叫contentDocument。

这个属性包含一个指针，指向表示框架内容的文档对象。在此之前，无法直接通过元素取得这个文档对象（只能使用frames集合）。

contentDocument属性是Document类型的实例，Opera、Firefox、Safari和Chrome支持这个属性。IE8之前不支持框架中的contentDocument属性，但支持一个名叫contentWindow的属性，该属性返回框架的window对象，而这个window对象又有一个document属性。

```javascript
要想在上述所有浏览器中访问内嵌框架的文档对象，可以使用下列代码。
var iframe = document.getElementById("myIframe");
var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
```

所有浏览器都支持contentWindow属性。

> 访问框架或内嵌框架的文档对象要受到跨域安全策略的限制。如果某个框架中的页面来自其他域或不同子域，或者使用了不同的协议，那么要访问这个框架的文档对象就会导致错误。



## 12.2 样式

要确定浏览器是否支持DOM2级定义的CSS能力，可以使用下列代码。

```javascript
var supportsDOM2CSS = document.implementation.hasFeature("CSS", "2.0"); 
var supportsDOM2CSS2 = document.implementation.hasFeature("CSS2", "2.0"); 
```

### 12.2.1 访问元素的样式

对于使用短划线（分隔不同的词汇，例如background-image）的CSS属性名，必须将其转换成驼峰大小写形式，才能通过JavaScript来访问。

多数情况下，都可以通过简单地转换属性名的格式来实现转换。其中一个不能直接转换的CSS属性就是float。由于float是JavaScript中的保留字，因此不能用作属性名。“DOM2级样式”规范规定样式对象上相应的属性名应该是cssFloat；Firefox、Safari、Opera和Chrome都支持这个属性，而IE支持的则是styleFloat。

> 在标准模式下，所有度量值都必须指定一个度量单位。在混杂模式下，可以将style.width 设置为"20"，浏览器会假设它是"20px"；但在标准模式下，将style.width设置为"20"会导致被忽略——因为没有度量单位。

#### 1. DOM样式属性和方法

“DOM2级样式”规范还为style对象定义了一些属性和方法。

- cssText：如前所述，通过它能够访问到style特性中的CSS代码。
- length：应用给元素的CSS属性的数量。
- parentRule：表示CSS信息的CSSRule对象。
- getPropertyCSSValue(propertyName)：返回包含给定属性值的CSSValue对象。
- getPropertyPriority(propertyName)：如果给定的属性使用了!important设置，则返回"important"；否则，返回空字符串。
- getPropertyValue(propertyName)：返回给定属性的字符串值。
- item(index)：返回给定位置的CSS属性的名称。
- removeProperty(propertyName)：从样式中删除给定属性。
- setProperty(propertyName,value,priority)：将给定属性设置为相应的值，并加上优先权标志（"important"或者一个空字符串）。

设计length属性的目的，就是将其与item()方法配套使用，以便迭代在元素中定义的CSS属性。在使用length和item()时，style对象实际上就相当于一个集合，都可以使用方括号语法来代替item()来取得给定位置的CSS属性

使用removeProperty()方法移除一个属性，意味着将会为该属性应用默认的样式（从其他样式,,表经层叠而来）。

#### 2. 计算的样式

##### getComputedStyle()

“DOM2级样式”增强了document.defaultView，提供了getComputedStyle()方法。

这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如":after"）。如果不需要伪元素信息，第二个参数可以是null。

getComputedStyle()方法返回一个CSSStyleDeclaration对象（与style属性的类型相同），其中包含当前元素的所有计算的样式。

> ```javascript
> <div id="myDiv" style="background-color: red; border: 1px solid black"></div>
> ```
>
> style里面同名的属性会覆盖myDiv中的同名属性

边框属性可能会也可能不会返回样式表中实际的border规则

##### currentStyle

IE不支持getComputedStyle()方法，但它有一种类似的概念。在IE中，每个具有style属性的元素还有一个currentStyle属性。这个属性是CSSStyleDeclaration的实例，包含当前元素全部计算后的样式。

IE也没有返回border样式，因为这是一个综合属性。

##### 总结

无论在哪个浏览器中，最重要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对象中的CSS属性。

### 12.2.2 操作样式表



CSSStyleSheet类型表示的是样式表，包括通过<link>元素包含的样式表和在<style>元素中定义的样式表。

> 这两个元素本身分别是由HTMLLinkElement和HTMLStyleElement类型表示的。但是，CSSStyleSheet类型相对更加通用一些，它只表示样式表，而不管这些样式表在HTML中是如何定义的。此外，上述两个针对元素的类型允许修改HTML特性，但CSSStyleSheet对象则是一套只读的接口（有一个属性例外）。

确定浏览器是否支持DOM2级样式表。

```javascript
var supportsDOM2StyleSheets = document.implementation.hasFeature("StyleSheets", "2.0"); 
```

CSSStyleSheet 继承自StyleSheet，后者可以作为一个基础接口来定义非CSS样式表。

继承而来的属性:

- disabled：表示样式表是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为true可以禁用样式表。
- href：如果样式表是通过<link>包含的，则是样式表的URL；否则，是null。
- media：当前样式表支持的所有媒体类型的集合。与所有DOM集合一样，这个集合也有一个length属性和一个item()方法。也可以使用方括号语法取得集合中特定的项。如果集合是空列表，表示样式表适用于所有媒体。在IE中，media是一个反映<link>和<style>元素media特性值的字符串。
- ownerNode：指向拥有当前样式表的节点的指针，样式表可能是在HTML中通过<link>或<style/>引入的（在XML中可能是通过处理指令引入的）。如果当前样式表是其他样式表通过@import导入的，则这个属性值为null。IE不支持这个属性。
- parentStyleSheet：在当前样式表是通过@import导入的情况下，这个属性是一个指向导入它的样式表的指针。
- title：ownerNode中title属性的值。
- type：表示样式表类型的字符串。对CSS样式表而言，这个字符串是"type/css"。除了disabled 属性之外，其他属性都是只读的。

除了disabled 属性之外，其他属性都是只读的。

在支持以上所有这些属性的基础上，CSSStyleSheet类型还支持下列属性和方法：

- cssRules：样式表中包含的样式规则的集合。IE不支持这个属性，但有一个类似的rules属性。
- ownerRule：如果样式表是通过@import导入的，这个属性就是一个指针，指向表示导入的规则；否则，值为null。IE不支持这个属性。
- deleteRule(index)：删除cssRules集合中指定位置的规则。IE不支持这个方法，但支持一个类似的removeRule()方法。
- insertRule(rule,index)：向cssRules集合中指定的位置插入rule字符串。IE不支持这个方法，但支持一个类似的addRule()方法。

应用于文档的所有样式表是通过document.styleSheets集合来表示的。

不同浏览器的document.styleSheets返回的样式表也不同。所有浏览器都会包含<style>元素和rel特性被设置为"stylesheet"的<link>元素引入的样式表。IE和Opera也包含rel特性被设置为"alternate stylesheet"的<link>元素引入的样式表。

也可以直接通过<link>或<style>元素取得CSSStyleSheet 对象。DOM规定了一个包含CSSStyleSheet 对象的属性，名叫sheet；除了IE，其他浏览器都支持这个属性。IE 支持的是styleSheet属性。

#### 1. CSS规则

CSSStyleRule对象包含下列属性。

- cssText：返回整条规则对应的文本。由于浏览器对样式表的内部处理方式不同，返回的文本可能会与样式表中实际的文本不一样；Safari始终都会将文本转换成全部小写。IE不支持这个属性。
- parentRule：如果当前规则是导入的规则，这个属性引用的就是导入规则；否则，这个值为null。IE不支持这个属性。
- parentStyleSheet：当前规则所属的样式表。IE不支持这个属性。
- selectorText：返回当前规则的选择符文本。由于浏览器对样式表的内部处理方式不同，返回的文本可能会与样式表中实际的文本不一样（例如，Safari 3之前的版本始终会将文本转换成全部小写）。在Firefox、Safari、Chrome和IE中这个属性是只读的。Opera允许修改selectorText。
- style：一个CSSStyleDeclaration对象，可以通过它设置和取得规则中特定的样式值。
- type：表示规则类型的常量值。对于样式规则，这个值是1。IE不支持这个属性。

#### 2.创建规则

##### insertRule()

DOM规定，要向现有样式表中添加新规则，需要使用insertRule()方法。

这个方法接受两个参数：规则文本和表示在哪里插入规则的索引。

插入的规则将成为样式表中的第一条规则（插入到了位置0）——规则的次序在确档的定层叠之后应用到文规则时至关重要。Firefox、Safari、Opera和Chrome都支持insertRule()方法。

##### addRule()

IE8 及更早版本支持一个类似的方法，名叫addRule()，也接收两必选参数：选择符文本和CSS样式信息；一个可选参数：插入规则的位置。

有关这个方法的规定中说，最多可以使用addRule()添加4 095条样式规则。超出这个上限的调用将会导致错误。

#### 3.删除规则

##### deleteRule()

这个方法接受一个参数：要删除的规则的位置。

IE支持的类似方法叫removeRule()，使用方法相同考虑到删除规则可能会影响CSS层叠的效果，要慎重使用。

### 12.2.3 元素大小

#### 1.偏移量

元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。

通过下列4个属性可以取得元素的偏移量。

- offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。
- offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。
- offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。
- offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。

其中，offsetLeft和offsetTop属性与包含元素有关，包含元素的引用保存在offsetParent属性中。offsetParent属性不一定与parentNode的值相等。

> 例如，<td>元素的offsetParent是作为其祖先元素的<table>元素，因为<table>是在DOM层次中距<td>最近的一个**具有大小**的元素。

要想知道某个元素在页面上的偏移量，将这个元素的offsetLeft和offsetTop与其offsetParent的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。

所有这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性；如果需要重复使用其中某些属性的值，可以将它们保存在局部变量中，以提高性能。

#### 2. 客户区大小

元素的客户区大小（client dimension），指的是元素内容及其内边距所占据的空间大小。

有关客户区大小的属性有两个：clientWidth和clientHeight。其中，clientWidth属性是元素内容区宽度加上左右内边距宽度；clientHeight属性是元素内容区高度加上上下内边距高度。

要确定浏览器视口大小，可以使用document.documentElement或document.body（在IE7 之前的版本中）的
clientWidth和clientHeight。

与偏移量相似，客户区大小也是只读的，也是每次访问都要重新计算的。

#### 3. 滚动大小

与滚动大小相关的属性。

- scrollHeight：在没有滚动条的情况下，元素内容的总高度。
- scrollWidth：在没有滚动条的情况下，元素内容的总宽度。
- scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。
- scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。

对于不包含滚动条的页面而言，这些属性会在不同浏览器间发现一些不一致性问题

- Firefox中这两组属性始终都是相等的，但大小代表的是文档内容区域的实际尺寸，而非视口的尺寸。
- Opera、Safari 3.1及更高版本、Chrome中的这两组属性是有差别的，其中scrollWidth 和scrollHeight等于视口大小，而clientWidth和clientHeight等于文档内容区域的大小。
- IE（在标准模式）中的这两组属性不相等，其中scrollWidth和scrollHeight等于文档内容区域的大小，而clientWidth和clientHeight等于视口大小。

在确定文档的总高度时（包括基于视口的最小高度时），必须取得scrollWidth/clientWidth和scrollHeight/clientHeight中的最大值，才能保证在跨浏览器的环境下得到精确的结果

> 注意，对于运行在混杂模式下的IE，则需要用document.body 代替document.documentElement。

通过scrollLeft和scrollTop属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置。

将元素的scrollLeft和scrollTop设置为0，就可以重置元素的滚动位置。

#### 4.确定元素大小

##### getBoundingClientRect()方法。

这个方法返回会一个矩形对象，包含4个属性：left、top、right和bottom。这些属性给出了元素在页面中相对于视口的位置。

但是，浏览器的实现稍有不同。IE8及更早版本认为文档的左上角坐标是(2, 2)，而其他浏览器包括IE9则将传统的(0,0)作为起点坐标。

对于不支持getBoundingClientRect()的浏览器，可以通过其他手段取得相同的信息。一般来说，right和left的差值与offsetWidth的值相等，而bottom和top的差值与offsetHeight相等。而且，left和top属性大致等于使用getElementLeft()和getElementTop()函数取得的值。

## 12.3遍历

“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker。这两个类型能够基于给定的起点对DOM结构执行深度优先（depth-first）的遍历操作。

在与DOM兼容的浏览器中支持。IE不支持DOM遍历。使用下列代码可以检测浏览器对DOM2级遍历能力的支持情况。

```javascript
var supportsTraversals = document.implementation.hasFeature("Traversal", "2.0");
var supportsNodeIterator = (typeof document.createNodeIterator == "function");
var supportsTreeWalker = (typeof document.createTreeWalker == "function");
```

### 12.3.1 NodeIterator

可使用document.createNodeIterator()方法创建它的新实例。这个方法接受下列4个参数。

- root：想要作为搜索起点的树中的节点。
- whatToShow：表示要访问哪些节点的数字代码。
- filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝某种特定节点的函数。
- entityReferenceExpansion：布尔值，表示是否要扩展实体引用。这个参数在HTML页面中没有用，因为其中的实体引用不能扩展。

##### 参数说明

whatToShow参数是一个位掩码，通过应用一或多个过滤器（filter）来确定要访问哪些节点。这个参数的值以常量形式在NodeFilter类型中定义，如下所示。

- NodeFilter.SHOW_ALL：显示所有类型的节点。
- NodeFilter.SHOW_ELEMENT：显示元素节点。
- NodeFilter.SHOW_ATTRIBUTE：显示特性节点。由于DOM结构原因，实际上不能使用这个值。
- NodeFilter.SHOW_TEXT：显示文本节点。
- NodeFilter.SHOW_CDATA_SECTION：显示CDATA节点。对HTML页面没有用。
- NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML页面没有用。
- NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML页面没有用。
- NodeFilter.SHOW_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML页面没有用。
- NodeFilter.SHOW_COMMENT：显示注释节点。
- NodeFilter.SHOW_DOCUMENT：显示文档节点。
- NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型节点。
- NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段节点。对HTML页面没有用。
- NodeFilter.SHOW_NOTATION：显示符号节点。对HTML页面没有用。

可以使用按位或操作符来组合多个选项

可以通过createNodeIterator()方法的filter参数来指定自定义的NodeFilter对象，或者指定一个功能类似节点过滤器（node filter）的 函 数 。每 个NodeFilter对象只有一个方法，即accept- Node()；如果应该访问给定的节点，该方法返回NodeFilter.FILTER_ACCEPT，如果不应该访问给定的节点，该方法返回NodeFilter.FILTER_SKIP。由于NodeFilter是一个抽象的类型，因此不能直接创建它的实例。在必要时，只要创建一个包含acceptNode()方法的对象，然后将这个对象传入createNodeIterator()中即可。

NodeIterator类型的两个主要方法是nextNode()和previousNode()。

当遍历到DOM子树的最后一个节点时，nextNode()返回null。previousNode()方法的工作机制类似。当遍历到DOM子树的最后一个节点，且previousNode()返回根节点之后，再次调用它就会返回null。

Firefox 3.5之前的版本没有实现createNodeIterator()方法，但支持createTreeWalker()方法。

### 12.3.2 TreeWalker

TreeWalker是NodeIterator的一个更高级的版本，还提供了下列用于在不同方向上遍历DOM结构的方法。

- parentNode()：遍历到当前节点的父节点；
- firstChild()：遍历到当前节点的第一个子节点；
- lastChild()：遍历到当前节点的最后一个子节点；
- nextSibling()：遍历到当前节点的下一个同辈节点；
- previousSibling()：遍历到当前节点的上一个同辈节点。

创建TreeWalker对象要使用document.createTreeWalker()方法，这个方法接受的4个参数与document.createNodeIterator()方法相同：作为遍历起点的根节点、要显示的节点类型、过滤器和一个表示是否扩展实体引用的布尔值。

filter可以返回的值有所不同。除了NodeFilter.FILTER_ACCEPT和NodeFilter.FILTER_SKIP 之外，还可以使用NodeFilter.FILTER_REJECT。

在使用NodeIterator 对象时，NodeFilter.FILTER_SKIP与NodeFilter.FILTER_REJECT的作用相同：跳过指定的节点。但在使用TreeWalker对象时，NodeFilter.FILTER_SKIP会跳过相应节点继续前进到子树中的下一个节点，
而NodeFilter.FILTER_REJECT 则会跳过相应节点及该节点的整个子树。

TreeWalker真正强大的地方在于能够在DOM结构中沿任何方向移动。
TreeWalker类型还有一个属性，名叫currentNode，表示任何遍历方法在上一次遍历中返回的节点。通过设置这个属性也可以修改遍历继续进行的起点

## 12.4 范围

通过范围可以选择文档中的一个区域，而不必考虑节点的界限（选择在后台完成，对用户是不可见的）。在常规的DOM操作不能更有效地修改文档时，使用范围往往可以达到目的。
Firefox、Opera、Safari和Chrome都支持DOM范围。IE以专有方式实现了自己的范围特性。

### 12.4.1 DOM中的范围

##### createRange()方法。

在兼容DOM的浏览器中，这个方法属于document对象。
使用hasFeature()或者直接检测该方法，都可以确定浏览器是否支持范围。

```javascript
var supportsRange = document.implementation.hasFeature("Range", "2.0");
var alsoSupportsRange = (typeof document.createRange == "function");
```

每个范围由一个Range类型的实例表示，这个实例拥有很多属性和方法。下列属性提供了当前范围在文档中的位置信息。

- startContainer：包含范围起点的节点（即选区中第一个节点的父节点）。
- startOffset：范围在startContainer中起点的偏移量。如果startContainer是文本节点、注释节点或CDATA节点，那么startOffset就是范围起点之前跳过的字符数量。否则，startOffset就是范围中第一个子节点的索引。
- endContainer：包含范围终点的节点（即选区中最后一个节点的父节点）。
- endOffset：范围在endContainer中终点的偏移量（与startOffset遵循相同的取值规则）。
- commonAncestorContainer：startContainer和endContainer共同的祖先节点在文档树中位置最深的那个。

#### 1. 用DOM范围实现简单选择

要使用范围来选择文档中的一部分，使用selectNode()或selectNodeContents()。
这两个方法都接受一个参数，即一个DOM节点，然后使用该节点中的信息来填充范围。
其中，selectNode()方法选择整个节点，包括其子节点；而selectNodeContents()方法则只选择节点的子节点。

为了更精细地控制将哪些节点包含在范围中，还可以使用下列方法。

- setStartBefore(refNode)

  将范围的起点设置在refNode之前，因此refNode也就是范围选区中的第一个子节点。同时会将startContainer属性设置为refNode.parentNode，将startOffset属性设置为refNode在其父节点的childNodes集合中的索引。

- setStartAfter(refNode)

  将范围的起点设置在refNode之后，因此refNode也就不在范围之内了，其下一个同辈节点才是范围选区中的第一个子节点。同时会将startContainer属性设置为refNode.parentNode，将startOffset 属性设置为refNode 在其父节点的childNodes集合中的索引加1。

- setEndBefore(refNode)

  将范围的终点设置在refNode之前，因此refNode也就不在范围之内了，其上一个同辈节点才是范围选区中的最后一个子节点。同时会将endContainer属性设置为refNode.parentNode，将endOffset属性设置为refNode在其父节点的childNodes集合中的索引。

- setEndAfter(refNode)

  将范围的终点设置在refNode之后，因此refNode也就是范围选区中的最后一个子节点。同时会将endContainer 属性设置为refNode.parentNode，将endOffset属性设置为refNode在其父节点的childNodes集合中的索引加1。

#### 2. 用DOM范围实现复杂选择

##### setStart()和setEnd()方法

这两个方法都接受两个参数：一个参照节点和一个偏移量值。
对setStart()来说，参照节点会变成startContainer，而偏移量值会变成startOffset。
对于setEnd()来说，参照节点会变成endContainer，而偏移量值会变成endOffset。

setStart()和setEnd()的主要用途，能够选择节点的一部分。

#### 3.操作DOM范围中的内容

##### deleteContents()

这个方法能够从文档中删除范围所包含的内容。由于范围选区在修改底层DOM结构时能够保证格式良好，因此即使内容被删除了，最终的DOM结构依旧是格式良好的。

##### extractContents()

也会从文档中移除范围选区。与deleteContents()方法的区别在于，extractContents()会返回范围的文档片段。利用这个返回的值，可以将范围的内容插入到文档中的其他地方。

##### cloneContents()

创建范围对象的一个副本，然后在文档的其他地方插入该副本。

#### 4.插入DOM范围中的内容

##### insertNode()

向范围选区的开始处插入一个节点
使用这种技术可以插入一些帮助提示信息，例如在打开新窗口的链接旁边插入一幅图像。

##### surroundContents()

环绕范围插入内容。这个方法接受一个参数，即环绕范围内容的节点。
在环绕范围插入内容时，后台会执行下列步骤。

- 提取出范围中的内容（类似执行extractContent()）；
- 将给定节点插入到文档中原来范围所在的位置上；
- 将文档片段的内容添加到给定节点中。

可以使用这种技术来突出显示网页中的某些词句

#### 5.折叠DOM范围

所谓折叠范围，就是指范围中未选择文档的任何部分。可以用文本框来描述折叠范围的过程。

##### collapse()

接受一个参数，一个布尔值，表示要折叠到范围的哪一端。参数true表示折叠到范围的起点，参数false表示折叠到范围的终点。
要确定范围已经折叠完毕，可以检查collapsed属性
检测某个范围是否处于折叠状态，可以帮我们确定范围中的两个节点是否紧密相邻。

#### 6.比较DOM范围

##### compareBoundaryPoints()

确定这些范围是否有公共的边界（起点或终点）。
这个方法接受两个参数：表示比较方式的常量值和要比较的范围。
表示比较方式的常量值如下所示。

- Range.START_TO_START(0)：比较第一个范围和第二个范围的起点；
- Range.START_TO_END(1)：比较第一个范围的起点和第二个范围的终点；
- Range.END_TO_END(2)：比较第一个范围和第二个范围的终点；
- Range.END_TO_START(3)：比较第一个范围的终点和第一个范围的起点。

返回值如下：

- 如果第一个范围中的点位于第二个范围中的点之前，返回-1；
- 如果两个点相等，返回0；如果第一个范围中的点位于第二个范围中的点之后，返回1。

#### 7. 复制DOM范围

##### cloneRange()

这个方法会创建调用它的范围的一个副本。

#### 8. 清理DOM范围

在使用完范围之后，最好是调用detach()方法，以便从创建范围的文档中分离出该范围。

### 12.4.2 IE8及更早版本中的范围

IE8及之前版本不支持DOM范围,支持文本范围。文本范围是IE专有的特性，其他浏览器都不支持。

通过<body>、<button>、<input>和<textarea>等这几个元素，可以调用createTextRange()方法来创建文本范围。

```javascript
var range = document.body.createTextRange();
```

#### 1. 用IE范围实现简单的选择

##### findText()

这个方法会找到第一次出现的给定文本，并将范围移过来以环绕该文本。如果没有找到文本，这个方法返回false；否则返回true。

还可以为findText()传入另一个参数，即一个表示向哪个方向继续搜索的数值。负值表示应该从当前位置向后搜索，而正值表示应该从当前位置向前搜索。

##### moveToElementText()

IE中与DOM中的selectNode()方法最接近，这个方法接受一个DOM元素，并选择该元素的所有文本，包括HTML标签。

在文本范围中包含HTML的情况下，可以使用htmlText属性取得范围的全部内容，包括HTML和文本

##### parentElement()

IE的范围没有任何属性可以随着范围选区的变化而动态更新。不过，其parentElement()方法倒是与DOM的commonAncestorContainer属性类似。

#### 2.使用IE范围实现复杂的选择

##### move()、moveStart()、moveEnd()和expand()

这些方法都接受两个参数：移动单位和移动单位的数量。
其中，移动单位是下列一种字符串值。

- "character"：逐个字符地移动。
- "word"：逐个单词（一系列非空格字符）地移动。
- "sentence"：逐个句子（一系列以句号、问号或叹号结尾的字符）地移动。
- "textedit"：移动到当前范围选区的开始或结束位置。

通过moveStart()方法可以移动范围的起点，通过moveEnd()方法可以移动范围的终点，移动的幅度由单位数量指定

使用expand()方法可以将范围规范化。换句话说，expand()方法的作用是将任何部分选择的文本全部选中。

move()方法则首先会折叠当前范围（让起点和终点相等），然后再将范围移动指定的单位数量

#### 3. 操作IE范围中的内容

可以使用text属性或pasteHTML()方法
注意，在设置text属性的情况下，HTML标签保持不变。
要向范围中插入HTML代码，就得使用pasteHTML()方法
不过，在范围中包含HTML代码时，不应该使用pasteHTML()，因为这样很容易导致不可预料的结果——很可能是格式不正确的HTML。

#### 4. 折叠IE范围

##### collapse()

传入true把范围折叠到起点，传入false把范围折叠到终点。

boundingWidth属性，该属性返回范围的宽度（以像素为单位）。如果boundingWidth属性等于0，就说明范围已经折叠了
此外，还有boundingHeight、boundingLeft 和boundingTop 等属性

#### 5. 比较IE范围

##### compareEndPoints()

compareEndPoints()方法与DOM范围的compareBoundaryPoints()方法类似。
这个方法接受两个参数：比较的类型和要比较的范围。
比较类型的取值范围是下列几个字符串值："StartToStart"、"StartToEnd"、"EndToEnd"和"EndToStart"。这几种比较类型与比较DOM范围时使用的几个值是相同的。
同样与DOM类似的是，compareEndPoints()方法也会按照相同的规则返回值，即如果第一个范围的边界位于第二个范围的边界前面，返回-1；如果二者边界相同，返回0；如果第一个范围的边界位于第二个范围的边界后面，返回1。

##### isEqual()和inRange()

isEqual()用于确定两个范围是否相等，inRange()用于确定一个范围是否包含另一个范围。

#### 6. 复制IE范围

##### duplicate()

在IE中使用duplicate()方法可以复制文本范围，结果会创建原范围的一个副本，新创建的范围会带有与原范围完全相同的属性。

## 12.5 小结

“DOM2级样式”模块主要针对操作元素的样式信息而开发，其特性简要总结如下。

- 每个元素都有一个关联的style对象，可以用来确定和修改行内的样式。
- 要确定某个元素的计算样式（包括应用给它的所有CSS规则），可以使用getComputedStyle()方法。
- IE不支持getComputedStyle()方法，但为所有元素都提供了能够返回相同信息currentStyle属性。
- 可以通过document.styleSheets集合访问样式表。
- 除IE之外的所有浏览器都支持针对样式表的这个接口，IE也为几乎所有相应的DOM功能提供了自己的一套属性和方法。

“DOM2级遍历和范围”模块提供了与DOM结构交互的不同方式，简要总结如下。

- 遍历即使用NodeIterator或TreeWalker对DOM执行深度优先的遍历。
- NodeIterator是一个简单的接口，只允许以一个节点的步幅前后移动。而TreeWalker在提供相同功能的同时，还支持在DOM结构的各个方向上移动，包括父节点、同辈节点和子节点等方向。
- 范围是选择DOM结构中特定部分，然后再执行相应操作的一种手段。
- 使用范围选区可以在删除文档中某些部分的同时，保持文档结构的格式良好，或者复制文档中的相应部分。
- IE8及更早版本不支持“DOM2级遍历和范围”模块，但它提供了一个专有的文本范围对象，可以用来完成简单的基于文本的范围操作。IE9完全支持DOM遍历。



# 第15章 使用 Canvas 绘图

## 15.1 基本用法

- 要使用<canvas>元素，必须先设置其width和height属性，指定可以绘图的区域大小。出现在开始和结束标签中的内容是后备信息，如果浏览器不支持<canvas>元素，就会显示这些信息。

- 在使用<canvas>元素之前，首先要检测getContext()方法是否存在，这一步非常重要。有些浏览器会为HTML规范之外的元素创建默认的HTML元素对象。在这种情况下，即使变量中保存着一个有效的元素引用，也检测不到getContext()方法。

- 使用toDataURL()方法，可以导出在<canvas>元素上绘制的图像。这个方法接受一个参数，即图像的MIME类型格式，而且适合用于创建图像的任何上下文。

  > 默认情况下，浏览器会将图像编码为PNG格式（除非另行指定）。Firefox和Opera也支持基于"image/jpeg"参数的JPEG编码格式。由于这个方法是后来才追加的，所以支持<canvas>的浏览器也是在较新的版本中才加入了对它的支持，比如IE9、Firefox 3.5和Opera 10。

  > 如果绘制到画布上的图像源自不同的域，toDataURL()方法会抛出错误。

## 15.2 2D上下文

- 默认情况下，width和height表示水平和垂直两个方向上可用的像素数目。

### 15.2.1 填充和描边

- 2D上下文的两种基本绘图操作是填充和描边。
- 操作的结果取决于两个属性：fillStyle和strokeStyle。
  - 这两个属性的值可以是字符串、渐变对象或模式对象，而且它们的默认值都是"#000000"。如果为它们指定表示颜色的字符串值，可以使用CSS中指定颜色值的任何格式，包括颜色名、十六进制码、rgb、rgba、hsl或hsla。

### 15.2.2 绘制矩形

- 方法包括fillRect()、strokeRect()和clearRect()。

  - 这三个方法都能接收4个参数：矩形的x坐标、矩形的y坐标、矩形宽度和矩形高度。这些参数的单位都是像素。

  > 描边线条的宽度由lineWidth属性控制，该属性的值可以是任意整数。另外，通过lineCap 属性可以控制线条末端的形状是平头、圆头还是方头（"butt"、"round"或"square"），通过lineJoin属性可以控制线条相交的方式是圆交、斜交还是斜接（"round"、"bevel"或"miter"）。

### 15.2.3 绘制路径

- 要绘制路径，首先必须调用beginPath()方法，表示要开始绘制新路径。
- 再通过调用下列方法来实际地绘制路径：
  - arc(x,y,radius,startAngle,endAngle, counterclockwise)
    - 最后一个参数表示startAngle和endAngle是否按逆时针方向计算，值为false表示按顺时针方向计算。
  - arcTo(x1, y1, x2, y2, radius)
  - bezierCurveTo(c1x, c1y, c2x, c2y, x, y)
  - lineTo(x, y)
  - moveTo(x, y)
  - quadraticCurveTo(cx, cy, x, y)
  - rect(x, y, width, height)
- 如果想绘制一条连接到路径起点的线条，可以调用closePath()。如果路径已经完成，你想用fillStyle填充它，可以调用fill()方法。另外，还可以调用stroke()方法对路径描边，描边使用的是strokeStyle。最后还可以调用clip()，这个方法可以在路径上创建一个剪切区域。
- isPointInPath()的方法，接收x和y坐标作为参数，用于在路径被关闭之前确定画布上的某一点是否位于路径上

### 15.2.4  绘制文本

- 绘制文本主要有两个方法：fillText()和strokeText()。
  - 两个方法都可以接收4个参数：要绘制的文本字符串、x坐标、y坐标和可选的最大像素宽度。
  - 都以下列3个属性为基础：
    - font：表示文本样式、大小及字体，用CSS中指定字体的格式来指定
    - textAlign：表示文本对齐方式。可能的值有"start"、"end"、"left"、"right"和"center"。建议使用"start"和"end"，不要使用"left"和"right"，因为前两者的意思更稳妥，能同时适合从左到右和从右到左显示（阅读）的语言。
    - textBaseline：表示文本的基线。可能的值有"top"、"hanging"、"middle"、"alphabetic"、"ideographic"和"bottom"。
- 2D上下文提供了辅助确定文本大小的方法measureText()。
  - 这个方法接收一个参数，即要绘制的文本；返回一个TextMetrics对象。
  - 返回的对象目前只有一个width属性，但将来还会增加更多度量属性。
  - measureText()方法利用font、textAlign和textBaseline的当前值计算指定文本的大小。
- fillText和strokeText()方法都可以接收第四个参数，也就是文本的最大像素宽度。不过，这个可选的参数尚未得到所有浏览器支持（最早支持它的是Firefox 4）。提供这个参数后，调用fillText()或strokeText()时如果传入的字符串大于最大宽度，则绘制的文本字符的高度正确，但宽度会收缩以适应最大宽度。

### 15.2.5 变换

- 修改变换矩阵方法：

  - rotate(angle)：围绕原点旋转图像angle弧度。

  - scale(scaleX, scaleY)：缩放图像，在x方向乘以scaleX，在y方向乘以scaleY。scaleX和scaleY的默认值都是1.0。

  - translate(x, y)：将坐标原点移动到(x,y)。执行这个变换之后，坐标(0,0)会变成之前由(x,y)表示的点。

  - transform(m1*1, m1*2, m2*1, m2*2, dx, dy)：直接修改变换矩阵，方式是乘以如下矩阵:

    ​

  - setTransform(m1*1, m1*2, m2*1, m2*2, dx, dy)：将变换矩阵重置为默认状态，然后再调用transform()。

- 有两个方法可以跟踪上下文的状态变化。如果你知道将来还要返回某组属性与变换的组合，可以调用save()方法。调用这个方法后，当时的所有设置都会进入一个栈结构，得以妥善保管。然后可以对上下文进行其他修改。等想要回到之前保存的设置时，可以调用restore()方法，在保存设置的栈结构中向前返回一级，恢复之前的状态。连续调用save()可以把更多设置保存到栈结构中，之后再连续调用restore()则可以一级一级返回。

  > 需要注意的是，save()方法保存的只是对绘图上下文的设置和变换，不会保存绘图上下文的内容。

### 15.2.6 绘制图像

- drawImage()方法 : 把一幅图像绘制到画布上

  - 最简单的调用方式是传入一个HTML <img>元素，以及绘制该图像的起点的x和y坐标。
  - 如果你想改变绘制后图像的大小，可以再多传入两个参数，分别表示目标宽度和目标高度。通过这种方式来缩放图像并不影响上下文的变换矩阵。
  - 还可以选择把图像中的某个区域绘制到上下文中。drawImage()方法的这种调用方式总共需要传入9个参数：要绘制的图像、源图像的x坐标、源图像的y坐标、源图像的宽度、源图像的高度、目标图像的x坐标、目标图像的y坐标、目标图像的宽度、目标图像的高度。
  - 除了给drawImage()方法传入HTML <img>元素外，还可以传入另一个<canvas>元素作为其第一个参数。这样，就可以把另一个画布内容绘制到当前画布上。

- 操作的结果可以通过toDataURL()方法获得.不过，有一个例外，即图像不能来自其他域。如果图像来自其他域，调用 toDataURL()会抛出一个错误。

  > toDataURL()是Canvas对象的方法，不是上下文对象的方法。

### 15.2.7阴影

- 2D上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影
  - shadowColor：用CSS颜色格式表示的阴影颜色，默认为黑色。
  - shadowOffsetX：形状或路径x轴方向的阴影偏移量，默认为0。
  - shadowOffsetY：形状或路径y轴方向的阴影偏移量，默认为0。
  - shadowBlur：模糊的像素数，默认0，即不模糊。
- 不同浏览器对阴影的支持有一些差异。IE9、Firefox 4和Opera 11的行为最为规范，其他浏览器多多少少会有一些奇怪的现象，甚至根本不支持阴影。

### 15.2.8渐变

- 要创建一个新的线性渐变，可以调用createLinearGradient()方法。
  - 这个方法接收4个参数：起点的x坐标、起点的y坐标、终点的x 坐标、终点的y 坐标。
  - 调用这个方法后，它就会创建一个指定大小的渐变，并返回CanvasGradient对象的实例。
- 创建了渐变对象后，下一步就是使用addColorStop()方法来指定色标。
  - 这个方法接收两个参数：色标位置和CSS颜色值。色标位置是一个0（开始的颜色）到1（结束的颜色）之间的数字。
- 由于渐变不重复，所以矩形的大部分区域都是黑色。确保渐变与形状对齐非常重要，有时候可以考虑使用函数来确保坐标合适。
- 要创建径向渐变（或放射渐变），可以使用createRadialGradient()方法。
  - 这个方法接收6个参数，对应着两个圆的圆心和半径。前三个参数指定的是起点圆的原心（x和y）及半径，后三个参数指定的是终点圆的原心（x和y）及半径。
  - 圆柱、圆锥、同心圆

### 15.2.9模式

- 模式其实就是重复的图像，可以用来填充或描边图形。创建一个新模式，可以调用createPattern()方法并传入两个参数：
  - 一个HTML <img>元素和一个表示如何重复图像的字符串。
  - 第二个参数的值与CSS的background-repeat属性值相同，包括"repeat"、"repeat-x"、"repeat-y"和"no-repeat"。
- 模式与渐变一样，都是从画布的原点(0,0)开始的。将填充样式（fillStyle）设置为模式对象，只表示在某个特定的区域内显示重复的图像，而不是要从某个位置开始绘制重复的图像。
- createPattern()方法的第一个参数也可以是一个<video>元素，或者另一个<canvas>元素。

### 15.2.10 使用图像数据

- 2D上下文的一个明显的长处就是，可以通过getImageData()取得原始图像数据。
  - 这个方法接收4个参数：要取得其数据的画面区域的x和y坐标以及该区域的像素宽度和高度。
  - 返回的每个ImageData对象都有三个属性：width、height和data。
    - 其中data属性是一个数组，保存着图像中每一个像素的数据。在data数组中，每一个像素用4个元素来保存，分别表示红、绿、蓝和透明度值。
    - 因此，第一个像素的数据就保存在数组的第0到第3个元素中
    - 通过修改图像数据，可以创建一个简单的灰阶过滤器等。
- 只有在画布“干净”的情况下（即图像并非来自其他域），才可以取得图像数据。如果画布“不干净”，那么访问图像数据时会导致JavaScript错误。

### 15.2.11合成

- globalAlpha是一个介于0和1之间的值（包括0和1），用于指定所有绘制的透明度。默认值为0。如果所有后续操作都要基于相同的透明度，就可以先把globalAlpha设置为适当值，然后绘制，最后再把它设置回默认值0。
- globalCompositionOperation表示后绘制的图形怎样与先绘制的图形结合。这个属性的值是字符串，可能的值如下：
  - source-over（默认值）：后绘制的图形位于先绘制的图形上方。
  - source-in：后绘制的图形与先绘制的图形重叠的部分可见，两者其他部分完全透明。
  - source-out：后绘制的图形与先绘制的图形不重叠的部分可见，先绘制的图形完全透明。
  - source-atop：后绘制的图形与先绘制的图形重叠的部分可见，先绘制图形不受影响。
  - destination-over：后绘制的图形位于先绘制的图形下方，只有之前透明像素下的部分才可见。
  - destination-in：后绘制的图形位于先绘制的图形下方，两者不重叠的部分完全透明。
  - destination-out：后绘制的图形擦除与先绘制的图形重叠的部分。
  - destination-atop：后绘制的图形位于先绘制的图形下方，在两者不重叠的地方，先绘制的图形会变透明。
  - lighter：后绘制的图形与先绘制的图形重叠部分的值相加，使该部分变亮。
  - copy：后绘制的图形完全替代与之重叠的先绘制图形。
  - xor：后绘制的图形与先绘制的图形重叠的部分执行“异或”操作。
- 在使用globalCompositionOperation的情况下，一定要多测试一些浏览器。因为不同浏览器对这个属性的实现仍然存在较大的差别。Safari和Chrome在这方面还有问题

## 15.3  WebGL

- WebGL是针对Canvas的3D上下文。与其他Web技术不同，WebGL并不是W3C制定的标准，而是由Khronos Group制定的。

### 15.3.1 类型化数组

- WebGL涉及的复杂计算需要提前知道数值的精度，而标准的JavaScript数值无法满足需要。为此，WebGL引入了一个概念，叫类型化数组（typed arrays）。
- 类型化数组的核心就是一个名为ArrayBuffer的类型。每个ArrayBuffer对象表示的只是内存中指定的字节数，但不会指定这些字节用于保存什么类型的数据。通过ArrayBuffer所能做的，就是为了将来使用而分配一定数量的字节。
- 创建了ArrayBuffer 对象后，能够通过该对象获得的信息只有它包含的字节数，方法是访问其 byteLength属性

#### 1. 视图

- 使用ArrayBuffer（数组缓冲器类型）的一种特别的方式就是用它来创建数组缓冲器视图。其中，最常见的视图是DataView，通过它可以选择ArrayBuffer中一小段字节。为此，可以在创建DataView实例的时候传入一个ArrayBuffer、一个可选的字节偏移量（从该字节开始选择）和一个可选的要选择的字节数。

- 实例化之后，DataView 对象会把字节偏移量以及字节长度信息分别保存在byteOffset 和byteLength属性中。

- 读取和写入DataView的时候，要根据实际操作的数据类型，选择相应的getter和setter方法。

  | 数据类型     | getter                              | setter                                   |
  | -------- | ----------------------------------- | ---------------------------------------- |
  | 有符号8位整数  | getInt8(byteOffset)                 | setInt8(byteOffset, value)               |
  | 无符号8位整数  | getUint8(byteOffset)                | setUint8(byteOffset, value)              |
  | 有符号16位整数 | getInt16(byteOffset,littleEndian)   | setInt16(byteOffset,value,littleEndian)  |
  | 无符号16位整数 | getUint16(byteOffset,littleEndian)  | setUint16(byteOffset,value,littleEndian) |
  | 有符号32位整数 | getInt32(byteOffset,littleEndian)   | setInt32(byteOffset,value,littleEndian)  |
  | 无符号32位整数 | getUint32(byteOffset,littleEndian)  | setUint32(byteOffset,value,littleEndian) |
  | 32位浮点数   | getFloat32(byteOffset,littleEndian) | setFloat32(byteOffset,value,littleEndian) |
  | 64位浮点数   | getFloat64(byteOffset,littleEndian) | setFloat64(byteOffset,value,littleEndian) |

  - 所有这些方法的第一个参数都是一个字节偏移量，表示要从哪个字节开始读取或写入。不要忘了，要保存有些数据类型的数据，可能需要不止1B。

    view.setUint16(2, 50);//不能从字节1开始，因为16位整数要用2B

  - 用于读写16位或更大数值的方法都有一个可选的参数littleEndian。这个参数是一个布尔值，表示读写数值时是否采用小端字节序（即将数据的最低有效位保存在低内存地址中），而不是大端字节序（即将数据的最低有效位保存在高内存地址中）。如果你也不确定应该使用哪种字节序，那不用管它，就采用默认的大端字节序方式保存即可。

1. #### 类型化视图

- 类型化视图一般也被称为类型化数组。类型化视图也分几种，而且它们都继承了DataView。
  - Int8Array：表示8位二补整数。
  - Uint8Array：表示8位无符号整数。
  - Int16Array：表示16位二补整数。
  - Uint16Array：表示16位无符号整数。
  - Int32Array：表示32位二补整数。
  - Uint32Array：表示32位无符号整数。
  - Float32Array：表示32位IEEE浮点值。
  - Float64Array：表示64位IEEE浮点值。
- 由于这些视图都继承自DataView，因而可以使用相同的构造函数参数来实例化。第一个参数是要使ArrayBuffer对象，第二个参数是作为起点的字节偏移量（默认为0），第三个参数是要包含的字节数。三个参数中只有第一个是必需的。
- 每个视图构造函数都有一个名为BYTES_PER_ELEMENT的属性，表示类型化数组的每个元素需要多少字节。因此，Uint8Array.BYTES_PER_ELEMENT就是1，而Float32Array.BYTES_PER_ELEMENT则为4。可以利用这个属性来辅助初始化。
- 类型化视图的目的在于简化对二进制数据的操作。除了前面看到的优点之外，创建类型化视图还可以不用首先创建ArrayBuffer对象。只要传入希望数组保存的元素数，相应的构造函数就可以自动创建一个包含足够字节数的ArrayBuffer对象
- 另外，也可以把常规数组转换为类型化视图，只要把常规数组传入类型化视图的构造函数即可这是用默认值来初始化类型化视图的最佳方式，也是WebGL项目中最常用的方式。
- 数据类型不匹配时不会抛出错误，所以你必须自己保证所赋的值不会超过相应元素的字节限制。
- 类型化视图还有一个方法，即subarray()，使用这个方法可以基于底层数组缓冲器的子集创建一个新视图。这个方法接收两个参数：开始元素的索引和可选的结束元素的索引。返回的类型与调用该方法的视图类型相同。
- 通过大视图创建小视图的主要好处就是，在操作大数组中的一部分元素时，无需担心意外修改了其他元素。

### 15.3.2 WebGL上下文

- 目前，在支持的浏览器中，WebGL的名字叫"experimental-webgl"，这是因为WebGL规范仍然未制定完成。制定完成后，这个上下文的名字就会变成简单的"webgl"。如果浏览器不支持WebGL，那么取得该上下文时会返回null。
- 一般都把WebGL上下文对象命名为gl。
- 通过给getContext()传递第二个参数，可以为WebGL上下文设置一些选项。这个参数本身是一个对象，可以包含下列属性。
  - alpha：值为true，表示为上下文创建一个Alpha通道缓冲区；默认值为true。
  - depth：值为true，表示可以使用16位深缓冲区；默认值为true。
  - stencil：值为true，表示可以使用8位模板缓冲区；默认值为false。
  - antialias：值为true，表示将使用默认机制执行抗锯齿操作；默认值为true。
  - premultipliedAlpha：值为true，表示绘图缓冲区有预乘Alpha值；默认值为true。
  - preserveDrawingBuffer：值 为true，表示在绘图完成后保留绘图缓冲区；默认值为false。建议确实有必要的情况下再开启这个值，因为可能影响性能。

#### 1. 常量

- 常量在OpenGL中都带前缀GL*。在WebGL中，保存在上下文对象中的这些常量都没有GL*前缀。WebGL以这种方式支持大多数OpenGL常量（有一部分常量是不支持的）。

#### 2. 方法命名

- 如果某方法可以接收不同类型及不同数量的参数，看方法名的后缀就可以知道。方法名的后缀会包含参数个数（1到4）和接收的数据类型（f表示浮点数，i表示整数）。
- 有很多方法接收数组参数而非一个个单独的参数。这样的方法其名字中会包含字母v（即vector，矢量）。

#### 3. 准备绘图

- 在实际操作WebGL上下文之前，一般都要使用某种实色清除<canvas>,首先必须使用clearColor()方法来指定要使用的颜色值，该方法接收4个参数：红、绿、蓝和透明度。每个参数必须是一个0到1之间的数值，表示每种分量在最终颜色中的强度。

- ​

  ``

  ​

  ​

  ​

  ​

  ```
  gl.clearColor(0,0,0,1); //black 
  ```

  ```
  gl.clear(gl.COLOR_BUFFER_BIT);
  ```

  ​

  > 把清理颜色缓冲区的值设置为黑色，然后调用了clear()方法，这个方法与OpenGL中的glClear()等价。传入的参数gl.COLOR_BUFFER_BIT告诉WebGL使用之前定义的颜色来填充相应区域。一般来说，都要先清理缓冲区，然后再执行其他绘图操作。

#### 4. 视口与坐标

- 默认情况下，视口可以使用整个<canvas>区域。要改变视口大小，可以调用viewport()方法并传入4个参数：（视口相对于<canvas>元素的）x坐标、y坐标、宽度和高度。
- 视口坐标与我们通常熟悉的网页坐标不一样。视口坐标的原点(0,0)在<canvas>元素的左下角，x轴和y轴的正方向分别是向右和向上，可以定义为(width1, height1)
- 视口内部的坐标系与定义视口的坐标系也不一样。在视口内部，坐标原点(0,0)是视口的中心
- 如果在视口内部绘图时使用视口外部的坐标，结果可能会被视口剪切。

#### 5. 缓冲区

- 顶点信息保存在JavaScript的类型化数组中，使用之前必须转换到WebGL的缓冲区。
- 要创建缓冲区，可以调用gl.createBuffer()，然后使用gl.bindBuffer()绑定到WebGL上下文。
- gl.bufferData()的最后一个参数用于指定使用缓冲区的方式，取值范围是如下几个常量。
  - gl.STATIC_DRAW：数据只加载一次，在多次绘图中使用。
  - gl.STREAM_DRAW：数据只加载一次，在几次绘图中使用。
  - gl.DYNAMIC_DRAW：数据动态改变，在多次绘图中使用。
- 如果不是非常有经验的OpenGL程序员，多数情况下将缓冲区使用方式设置为gl.STATIC_DRAW即可。
- 在包含缓冲区的页面重载之前，缓冲区始终保留在内存中。如果你不想要某个缓冲区了，可以直接调用gl.deleteBuffer()释放内存：

#### 6. 错误

- JavaScript与WebGL之间的一个最大的区别在于，WebGL操作一般不会抛出错误。为了知道是否有错误发生，必须在调用某个可能出错的方法后，手工调用gl.getError()方法。这个方法返回一个表示错误类型的常量。可能的错误常量如下。
  - gl.NO_ERROR：上一次操作没有发生错误（值为0）。
  - gl.INVALID_ENUM：应该给方法传入WebGL常量，但却传错了参数。
  - gl.INVALID_VALUE：在需要无符号数的地方传入了负值。
  - gl.INVALID_OPERATION：在当前状态下不能完成操作。
  - gl.OUT_OF_MEMORY：没有足够的内存完成操作。
  - gl.CONTEXT_LOST_WEBGL：由于外部事件（如设备断电）干扰丢失了当前WebGL上下文。

####  7. 着色器

- 着色器（shader）是OpenGL中的另一个概念。WebGL中有两种着色器：顶点着色器和片段（或像素）着色器。
  - 顶点着色器用于将3D顶点转换为需要渲染的2D点。
  - 片段着色器用于准确计算要绘制的每个像素的颜色。
- 这些着色器是使用GLSL（OpenGL Shading Language，OpenGL着色语言）写的，GLSL是一种与C和JavaScript完全不同的语言。

#### 8. 编写着色器

- GLSL是一种类C语言，专门用于编写OpenGL着色器。
- 每个着色器都有一个main()方法，该方法在绘图期间会重复执行。为着色器传递数据的方式有两种：Attribute和Uniform。通过Attribute可以向顶点着色器中传入顶点信息，通过Uniform可以向任何着色器传入常量值。Attribute和Uniform在main()方法外部定义，分别使用关键字attribute 和uniform。在这两个值类型关键字之后，是数据类型和变量名。

#### 9. 编写着色器程序

- 浏览器不能理解GLSL程序，因此必须准备好字符串形式的GLSL程序，以便编译并链接到着色器程序。为便于使用，通常是把着色器包含在页面的<script>标签内，并为该标签指定一个自定义的type属性。
- 然后，可以通过text属性提取出<script>元素的内容
- 复杂一些的WebGL应用可能会通过Ajax（详见第21章）动态加载着色器。而使用着色器的关键是要有字符串形式的GLSL程序。
- 取得了GLSL字符串之后，接下来就是创建着色器对象。要创建着色器对象，可以调用gl.createShader()方法并传入要创建的着色器类型（gl.VERTEX_SHADER或gl.FRAGMENT_SHADER）。编译着色器使用的是gl.compileShader()。
- 然后把对象链接到着色器程序中（gl.attachShader）。最后调用gl.linkProgram()则把两个着色器封装到了变量program中。链接完程序之后，就可以通过gl.useProgram()方法通知WebGL使用这个程序了。
- 调用gl.useProgram()方法后，所有后续的绘图操作都将使用这个程序。

#### 10. 为着色器传入值

- 对于Uniform变量，可以使用gl.getUniformLocation()，这个方法返回一个对象，表示Uniform变量在内存中的位置。然后可以基于变量的位置来赋值。
- 对于顶点着色器中的Attribute变量，也是差不多的赋值过程。要找到Attribute变量在内存中的位置，可以调用gl.getAttribLocation()。取得了位置之后，然后又通过gl.enableVertexAttribArray()启用它。最后一行创建了指针，指向由gl.bindBuffer()指定的缓冲区，并将其保存在aVertexPosition中，以便顶点着色器使用。

#### 11. 调试着色器和程序

- 与WebGL中的其他操作一样，着色器操作也可能会失败，而且也是静默失败。如果你想知道着色器或程序执行中是否发生了错误，必须亲自询问WebGL上下文。

- 对于着色器，可以在操作之后调用gl.getShaderParameter()，取得着色器的编译状态：

  ​

  ```

  ```

  ​

  ​

  ​

  ​

  ```
  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
  ```

  ```
      alert(gl.getShaderInfoLog(vertexShader));
  ```

  ```
  }
  ```

  ​

- 程序也可能会执行失败，因此也有类似的方法——gl.getProgramParameter()，可以用来检测执行状态。最常见的程序失败发生在链接过程中，要检测链接错误，可以使用下列代码。

  ​

  ```

  ```

  ​

  ​

  ​

  ​

  ```
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)){
  ```

  ```
      alert(gl.getProgramInfoLog(program));
  ```

  ```
  }
  ```

  ​

- 与gl.getShaderParameter()类似，gl.getProgramParameter()返回true表示链接成功，返回false表示链接失败。同样，也有一个gl.getProgramInfoLog()方法，用于捕获程序失败的消息。

#### 12. 绘图

- WebGL只能绘制三种形状：点、线和三角。
- 执行绘图操作要调用gl.drawArrays()或gl.drawElements()方法，前者用于数组缓冲区，后者用于元素数组缓冲区。它们的第一个参数都是一个常量，表示要绘制的形状。可取值的常量范围包括以下这些：
  - gl.POINTS：将每个顶点当成一个点来绘制。
  - gl.LINES：将数组当成一系列顶点，在这些顶点间画线。每个顶点既是起点也是终点，因此数组中必须包含偶数个顶点才能完成绘制。
  - gl.LINE_LOOP：将数组当成一系列顶点，在这些顶点间画线。线条从第一个顶点到第二个顶点，再从第二个顶点到第三个顶点，依此类推，直至最后一个顶点。然后再从最后一个顶点到第一个顶点画一条线。结果就是一个形状的轮廓。
  - gl.LINE_STRIP：除了不画最后一个顶点与第一个顶点之间的线之外，其他与gl.LINE_LOOP相同。
  - gl.TRIANGLES：将数组当成一系列顶点，在这些顶点间绘制三角形。除非明确指定，每个三角形都单独绘制，不与其他三角形共享顶点。
  - gl.TRIANGLES_STRIP：除了将前三个顶点之后的顶点当作第三个顶点与前两个顶点共同构成一个新三角形外，其他都与gl.TRIANGLES相同。
  - gl. TRIANGLES_FAN：除了将前三个顶点之后的顶点当作第三个顶点与前一个顶点及第一个顶点共同构成一个新三角形外，其他都与gl.TRIANGLES相同。
- gl.drawArrays()方法接收上面列出的常量中的一个作为第一个参数，接收数组缓冲区中的起始索引作为第二个参数，接收数组缓冲区中包含的顶点数（点的集合数）作为第三个参数。

#### 13. 纹理

- WebGL的纹理可以使用DOM中的图像。要创建一个新纹理，可以调用gl.createTexture()，然后再将一幅图像绑定到该纹理。

- 如果图像尚未加载到内存中，可能需要创建一个Image对象的实例，以便动态加载图像。图像加载完成之前，纹理不会初始化，因此，必须在load事件触发后才能设置纹理。

- 与在OpenGL中创建纹理的步骤最大的差异是使用gl.pixelStore1()设置像素存储格式。gl.UNPACK_FLIP_Y_WEBGL是WebGL独有的常量，在加载Web中的图像时，多数情况下都必须使用这个常量。这主要是因为GIF、JPEG和PNG图像与WebGL使用的坐标系不一样，如果没有这个标志，解析图像时就会发生混乱。

- 用作纹理的图像必须与包含页面来自同一个域，或者是保存在启用了CORS（Cross-Origin Resource Sharing，跨域资源共享）的服务器上。

  > 图像、加载到<video>元素中的视频，甚至其他<canvas>元素都可以用作纹理。跨域资源限制同样适用于视频

#### 14. 读取像素

- 通过WebGL上下文也能读取像素值。读取像素值的方法readPixels()与OpenGL中的同名方法只有一点不同，即最后一个参数必须是类型化数组。像素信息是从帧缓冲区读取的，然后保存在类型化数组中。
- readPixels()方法的参数有：x、y、宽度、高度、图像格式、数据类型和类型化数组。
  - 前4个参数指定读取哪个区域中的像素。
  - 图像格式参数几乎总是gl.RGBA。
  - 数据类型参数用于指定保存在类型化数组中的数据的类型，但有以下限制。
    - 如果类型是gl.UNSIGNED_BYTE，则类型化数组必须是Uint8Array。
    - 如果类型是gl.UNSIGNED_SHORT*5*6*5、gl.UNSIGNED_SHORT*4*4*4*4 或 gl.UNSIGNED* SHORT*5*5*5*1，则类型化数组必须是Uint16Array。
- 如果想在绘制发生后读取像素数据，那在初始化WebGL上下文时必须传入适当的preserveDrawingBuffer选项。设置这个标志的意思是让帧缓冲区在下一次绘制之前，保留其最后的状态。这个选项会导致性能损失，因此能不用最好不要用。

### 15.3.3支持

- Firefox 4+和Chrome都实现了WebGL API。Safari 5.1也实现了WebGL，但默认是禁用的。
- WebGL比较特别的地方在于，某个浏览器的某个版本实现了它，并不一定意味着就真能使用它。某个浏览器支持WebGL，至少意味着两件事：首先，浏览器本身必须实现了WebGL API；其次，计算机必须升级显示驱动程序。从稳妥的角度考虑，在使用WebGL之前，最好检测其是否得到了支持，而不是只检测特定的浏览器版本。
- 可以说，WebGL目前只适合实验性地学习，不适合真正开发和应用。

### 15.4 小结



# 第16章 HTML5脚本编程

## 16.1 跨文档消息传递

跨文档消息传送（cross-document messaging），有时候简称为XDM，指的是在来自不同域的页面间
传递消息。

XDM的核心是postMessage()方法。对于XDM而言，传递的对象是包含在当前页面中的`<iframe>`元素，或者由当前页面弹出的窗口。

postMessage()方法接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方。

```javascript
//注意：所有支持XDM的浏览器也支持iframe的contentWindow属性
var iframeWindow = document.getElementById("myframe").contentWindow; 
iframeWindow.postMessage("A secret", "http://www.wrox.com"); 
```

接收到XDM消息时，会触发window对象的message事件。这个事件是以异步形式触发的，因此从发送消息到接收消息（触发接收窗口的message事件）可能要经过一段时间的延迟。

触发message事件后，传递给onmessage处理程序的事件对象包含以下三方面的重要信息。

- data：作为postMessage()第一个参数传入的字符串数据。
- origin：发送消息的文档所在的域，例如"http://www.wrox.com"。
- source：发送消息的文档的window对象的代理。这个代理对象主要用于在发送上一条消息的窗口中调用postMessage()方法。如果发送消息的窗口来自同一个域，那这个对象就是window。

接收到消息后验证发送窗口的来源的基本的检测模式如下：

```javascript
EventUtil.addHandler(window, "message", function(event){ 
	//确保发送消息的域是已知的域
	if (event.origin == "http://www.wrox.com"){ 
        //处理接收到的数据
        processMessage(event.data); 
    	//可选：向来源窗口发送回执
    	event.source.postMessage("Received!", "http://p2p.wrox.com"); 
    } 
}); 
```

注意：event.source大多数情况下只是window对象的代理，并非实际的window对象。换句话说，不能通过这个代理对象访问window对象的其他任何信息。

XDM还有一些怪异之处：postMessage()的第一个参数最早是作为“永远都是字符串”来实现的。如果你想传入结构化的数据，最佳选择是先在要传入的数据上调用JSON.stringify()，通过postMessage()传入得到的字符串，然后再在onmessage事件处理程序中调用JSON.parse()。

支持XDM的浏览器有IE8+、Firefox 3.5+、Safari 4+、Opera、Chrome、iOS版Safari及Android版
WebKit。

## 16.2 原生拖放

### 16.2.1 拖放事件

拖动某元素时，将依次触发下列事件：

1. dragstart 
2. drag 
3. dragend 

按下鼠标键并开始移动鼠标时，会在被拖放的元素上触发dragstart事件。拖动开始时，可以通过ondragstart事件处理程序来运行JavaScript代码。

触发dragstart事件后，随即会触发drag事件，而且在元素被拖动期间会持续触发该事件。这
个事件与mousemove事件相似，在鼠标移动过程中，mousemove事件也会持续发生。

当拖动停止时（无论是把元素放到了有效的放置目标，还是放到了无效的放置目标上），会触发dragend事件。

当某个元素被拖动到一个有效的放置目标上时，下列事件会依次发生：

1. dragenter 
2. dragover 
3. dragleave或drop

只要有元素被拖动到放置目标上，就会触发dragenter事件（类似于mouseover事件）。

紧随其后的是dragover事件，而且在被拖动的元素还在放置目标的范围内移动时，就会持续触发该事件。

如果元素被拖出了放置目标，dragover事件不再发生，但会触发dragleave事件（类似于mouseout
事件）。如果元素被放到了放置目标中，则会触发drop事件而不是dragleave事件。

### 16.2.2 自定义放置目标

有些元素默认是不允许放置的。可以把任何元素变成有效的放置目标，方法是重写dragenter和dragover事件的默认行为。

```javascript
var droptarget = document.getElementById("droptarget"); 
EventUtil.addHandler(droptarget, "dragover", function(event){ 
	EventUtil.preventDefault(event); 
}); 
EventUtil.addHandler(droptarget, "dragenter", function(event){ 
	EventUtil.preventDefault(event); 
}); 
```

在Firefox 3.5+中，放置事件的默认行为是打开被放到放置目标上的URL。因此，为了让Firefox支持正常的拖放，还要取消drop事件的默认行为，阻止它打开URL：

```javascript
EventUtil.addHandler(droptarget, "drop", function(event){ 
	EventUtil.preventDefault(event); 
}); 
```

### 16.2.3 dataTransfer对象

dataTransfer对象，它是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据。

目前，HTML5规范草案也收入了dataTransfer对象。

dataTransfer对象有两个主要方法：getData()和setData()。

setData()方法的第一个参数，也是getData()方法唯一的一个参数，是一个字符串，表示保存的数据类型，取值为"text"或"URL"

IE只定义了"text"和"URL"两种有效的数据类型，而HTML5则对此加以扩展，允许指定各种MIME类型。考虑到向后兼容，HTML5也支持"text"和"URL"，但这两种类型会被映射为"text/plain"和"text/uri-list"。

实际上，dataTransfer对象可以为每种MIME类型都保存一个值。不过，保存在dataTransfer对象中的数据只能在drop事件处理程序中读取。如果在ondrop处理程序中没有读到数据，那就是dataTransfer对象已经被销毁，数据也丢失了。

在拖动文本框中的文本时，浏览器会调用setData()方法，将拖动的文本以"text"格式保存在dataTransfer对象中。类似地，在拖放链接或图像时，会调用setData()方法并保存URL。可以在dragstart事件处理程序中调用setData()

将数据保存为文本和保存为URL是有区别的。如果将数据保存为文本格式，那么数据不会得到任
何特殊处理。而如果将数据保存为URL，浏览器会将其当成网页中的链接。

Firefox 在其第5 个版本之前不能正确地将"url"和"text"映射为"text/uri-list"和"text/plain"。但是却能把"Text"（T大写）映射为"text/plain"。

### 16.2.4 dropEffect与effectAllowed

dropEffect属性可以知道被拖动的元素能够执行哪种放置行为。有下列4个可能的值。

- "none"：不能把拖动的元素放在这里。这是除文本框之外所有元素的默认值。
- "move"：应该把拖动的元素移动到放置目标。
- "copy"：应该把拖动的元素复制到放置目标。
- "link"：表示放置目标会打开拖动的元素（但拖动的元素必须是一个链接，有URL）。

浏览器只能帮你改变光标的样式，而其他的都要靠你自己来实现。要使用dropEffect属性，必须在ondragenter事件处理程序中针对放置目标来设置它。

dropEffect属性只有搭配effectAllowed属性才有用。effectAllowed属性表示允许拖动元素的哪种dropEffect，effectAllowed属性可能的值如下。

- "uninitialized"：没有给被拖动的元素设置任何放置行为。
- "none"：被拖动的元素不能有任何行为。
- "copy"：只允许值为"copy"的dropEffect。
- "link"：只允许值为"link"的dropEffect。
- "move"：只允许值为"move"的dropEffect。
- "copyLink"：允许值为"copy"和"link"的dropEffect。
- "copyMove"：允许值为"copy"和"move"的dropEffect。
- "linkMove"：允许值为"link"和"move"的dropEffect。
- "all"：允许任意dropEffect。

必须在ondragstart事件处理程序中设置effectAllowed属性。

> Firefox 5及之前的版本在处理effectAllowed属性时有一个问题，即如果你在代码中设置了这个属性的值，那不一定会触发drop事件

### 16.2.5 可拖动

HTML5为所有HTML元素规定了一个draggable属性，表示元素是否可以拖动。图像和链接的draggable属性自动被设置成了true，而其他元素这个属性的默认值都是false。要想让其他元素可拖动，或者让图像或链接不能拖动，都可以设置这个属性。

支持draggable属性的浏览器有IE 10+、Firefox 4+、Safari 5+和Chrome。为了让Firefox支持可拖动属性，还必须添加一个ondragstart事件处理程序，并在dataTransfer对象中保存一些信息。

> 在IE9及更早版本中，通过mousedown事件处理程序调用dragDrop()能够让任何元素可拖动。而在Safari 4及之前版本中，必须额外给相应元素设置CSS样式–khtml-user-drag: element。

### 16.2.6 其他成员

HTML5规范规定dataTransfer对象还包含下列方法和属性。

- addElement(element)：为拖动操作添加一个元素。添加这个元素只影响数据（即增加作为拖动源而响应回调的对象），不会影响拖动操作时页面元素的外观。在写作本书时，只有Firefox 3.5+实现了这个方法。


- clearData(format)：清除以特定格式保存的数据。实现这个方法的浏览器有IE、Fireforx 3.5+、Chrome和Safari 4+。


- setDragImage(element, x, y)：指定一幅图像，当拖动发生时，显示在光标下方。这个方法接收的三个参数分别是要显示的HTML元素和光标在图像中的x、y坐标。其中，HTML元素可以是一幅图像，也可以是其他元素。是图像则显示图像，是其他元素则显示渲染后的元素。实现这个方法的浏览器有Firefox 3.5+、Safari 4+和Chrome。
- types：当前保存的数据类型。这是一个类似数组的集合，以"text"这样的字符串形式保存着数据类型。实现这个属性的浏览器有IE10+、Firefox 3.5+和Chrome。

## 16.3 媒体元素

HTML5新增了两个与媒体相关的标签:`<audio>`和`<video>`。

使用这两个元素时，至少要在标签中包含src属性，指向要加载的媒体文件。还可以设置width和height属性以指定视频播放器的大小，而为poster属性指定图像的URI可以在加载视频内容期间显示一幅图像。另外，如果标签中有controls属性，则意味着浏览器应该显示UI控件，以便用户直接操作媒体。位于开始和结束标签之间的任何内容都将作为后备内容，在浏览器不支持这两个媒体元素的情况下显示。

并非所有浏览器都支持所有媒体格式,为此，不用在标签中指定src属性，而是要使用一或多个`<source>`元素

### 16.3.1 属性

`<video>`和`<audio>`元素都提供了完善的JavaScript接口

| 属 性                 | 数据类型 | 说 明                                      |
| ------------------- | ---- | ---------------------------------------- |
| autoplay            | 布尔值  | 取得或设置autoplay标志                          |
| buffered            | 时间范围 | 表示已下载的缓冲的时间范围的对象                         |
| bufferedBytes       | 字节范围 | 表示已下载的缓冲的字节范围的对象                         |
| bufferingRate       | 整数   | 下载过程中每秒钟平均接收到的位数                         |
| bufferingThrottled  | 布尔值  | 表示浏览器是否对缓冲进行了节流                          |
| controls            | 布尔值  | 取得或设置controls属性，用于显示或隐藏浏览器内置的控件          |
| currentLoop         | 整数   | 媒体文件已经循环的次数                              |
| currentSrc          | 字符串  | 当前播放的媒体文件的URL                            |
| currentTime         | 浮点数  | 已经播放的秒数                                  |
| defaultPlaybackRate | 浮点数  | 取得或设置默认的播放速度。默认值为1.0秒                    |
| duration            | 浮点数  | 媒体的总播放时间（秒数）                             |
| ended               | 布尔值  | 表示媒体文件是否播放完成                             |
| loop                | 布尔值  | 取得或设置媒体文件在播放完成后是否再从头开始播放                 |
| muted               | 布尔值  | 取得或设置媒体文件是否静音                            |
| networkState        | 整数   | 表示当前媒体的网络连接状态：0表示空，1表示正在加载，2表示正在加载元数据，3表示已经加载了第一帧，4表示加载完成 |
| paused              | 布尔值  | 表示播放器是否暂停                                |
| playbackRate        | 浮点数  | 取得或设置当前的播放速度。用户可以改变这个值，让媒体播放速度变快或变慢，这与defaultPlaybackRate只能由开发人员修改的defaultPlaybackRate不同 |
| played              | 时间范围 | 到目前为止已经播放的时间范围                           |
| readyState          | 整数   | 表示媒体是否已经就绪（可以播放了）。0表示数据不可用，1表示可以显示当前帧，2表示可以开始播放，3表示媒体可以从头到尾播放 |
| seekable            | 时间范围 | 可以搜索的时间范围                                |
| seeking             | 布尔值  | 表示播放器是否正移动到媒体文件中的新位置                     |
| src                 | 字符串  | 媒体文件的来源。任何时候都可以重写这个属性                    |
| start               | 浮点数  | 取得或设置媒体文件中开始播放的位置，以秒表示                   |
| totalBytes          | 整数   | 当前资源所需的总字节数                              |
| videoHeight         | 整数   | 返回视频（不一定是元素）的高度。只适用于`<video>`            |
| videoWidth          | 整数   | 返回视频（不一定是元素）的宽度。只适用于`<video>`            |
| volume              | 浮点数  | 取得或设置当前音量，值为0.0到1.0                      |

### 16.3.2 事件

| 事 件                 | 触发时机                                    |
| ------------------- | --------------------------------------- |
| abort               | 下载中断                                    |
| canplay             | 可以播放时；readyState值为2                     |
| canplaythrough      | 播放可继续，而且应该不会中断；readyState值为3            |
| canshowcurrentframe | 当前帧已经下载完成；readyState值为1                 |
| dataunavailable     | 因为没有数据而不能播放；readyState值为0               |
| durationchange      | duration属性的值改变                          |
| emptied             | 网络连接关闭                                  |
| empty               | 发生错误阻止了媒体下载                             |
| ended               | 媒体已播放到末尾，播放停止                           |
| error               | 下载期间发生网络错误                              |
| load                | 所有媒体已加载完成。这个事件可能会被废弃，建议使用canplaythrough |
| loadeddata          | 媒体的第一帧已加载完成                             |
| loadedmetadata      | 媒体的元数据已加载完成                             |
| loadstart           | 下载已开始                                   |
| pause               | 播放已暂停                                   |
| play                | 媒体已接收到指令开始播放                            |
| playing             | 媒体已实际开始播放                               |
| progress            | 正在下载                                    |
| ratechange          | 播放媒体的速度改变                               |
| seeked              | 搜索结束                                    |
| seeking             | 正移动到新位置                                 |
| stalled             | 浏览器尝试下载，但未接收到数据                         |
| timeupdate          | currentTime被以不合理或意外的方式更新                |
| volumechange        | volume属性值或muted属性值已改变                   |
| waiting             | 播放暂停，等待下载更多数据                           |

### 16.3.3 自定义媒体播放器

### 16.3.4 检测编解码器的支持情况

#### canPlayType()

检测浏览器是否支持某种格式和编解码器
该方法接收一种格式/编解码器字符串，返回"probably"、"maybe"或""（ 空字符串）。
空字符串是假值,而"probably"和"maybe"都是真值
注意，编解码器必须用引号引起来才行。

已得到支持的音频格式和编解码器:

| 音 频    | 字  符  串                       | 支持的浏览器                          |
| ------ | ----------------------------- | ------------------------------- |
| AAC    | audio/mp4; codecs="mp4a.40.2" | IE9+、Safari 4+、iOS版Safari       |
| MP3    | audio/mpeg                    | IE9+、Chrome                     |
| Vorbis | audio/ogg; codecs="vorbis"    | Firefox 3.5+、Chrome、Opera 10.5+ |
| WAV    | audio/wav; codecs="1"         | Firefox 3.5+、Opera 10.5+、Chrome |

已得到支持的视频格式和编解码器。

| 视 频    | 字  符  串                                  | 支持的浏览器                                   |
| ------ | ---------------------------------------- | ---------------------------------------- |
| H.264  | video/mp4; codecs="avc1.42E01E, mp4a.40.2" | IE9+、Safari 4+、iOS版Safari、Android版WebKit |
| Theora | video/ogg; codecs="theora"               | Firefox 3.5+、Opera 10.5、Chrome           |
| WebM   | video/webm; codecs="vp8, vorbis"         | Firefox 4+、Opera 10.6、Chrome             |

### 16.3.5  Audio类型

Audio与Image很相似，但Audio不用像Image那样必须插入到文档中。只要创建一个新实例，并传入音频源文件即可。

创建新的Audio实例即可开始下载指定的文件。下载完成后，调用play()就可以播放音频。

## 16.4 历史状态管理

通过hashchange事件，可以知道URL的参数什么时候发生了变化，即什么时候该有所反应。而
通过状态管理API，能够在不加载新页面的情况下改变浏览器的URL。为此，需要使用
history.pushState()方法，该方法可以接收三个参数：状态对象、新状态的标题和可选的相对URL。

执行pushState()方法后，新的状态信息就会被加入历史状态栈，而浏览器地址栏也会变成新的相对URL。但是，浏览器并不会真的向服务器发送请求。第二个参数目前还没有浏览器实现，因此完全可以只传入一个空字符串，或者一个短标题也可以。而第一个参数则应该尽可能提供初始化页面状态所需的各种信息。

因为pushState()会创建新的历史状态，所以你会发现“后退”按钮也能使用了。按下“后退”按钮，会触发window对象的popstate事件。popstate事件的事件对象有一个state属性，这个属性就包含着当初以第一个参数传递给pushState()的状态对象。

得到这个状态对象后，必须把页面重置为状态对象中的数据表示的状态。记住，浏览器加载的第一个页面没有状态，因此单击“后退”按钮返回浏览器加载的第一个页面时，event.state值为null。

要更新当前状态，可以调用replaceState()，传入的参数与pushState()的前两个参数相同。调用这个方法不会在历史状态栈中创建新状态，只会重写当前状态。

支持HTML5历史状态管理的浏览器有Firefox 4+、Safari 5+、Opera 11.5+和Chrome。

> 在使用HTML5的状态管理机制时，请确保使用pushState()创造的每一个“假”URL，在Web服务器上都有一个真的、实际存在的URL与之对应。否则，单击“刷新”按钮会导致404错误。

## 16.5 小结

- 跨文档消息传递API能够让我们在不降低同源策略安全性的前提下，在来自不同域的文档间传递消息。
- 原生拖放功能让我们可以方便地指定某个元素可拖动，并在操作系统要放置时做出响应。还可以创建自定义的可拖动元素及放置目标。


- 新的媒体元素`<audio>`和`<video>`拥有自己的与音频和视频交互的API。并非所有浏览器支持所有的媒体格式，因此应该使用canPlayType()检查浏览器是否支持特定的格式。


- 历史状态管理让我们不必卸载当前页面即可修改浏览器的历史状态栈。有了这种机制，用户就可以通过“后退”和“前进”按钮在页面状态间切换，而这些状态完全由JavaScript进行控制。



# 第17章 错误处理与调试

## 17.1 浏览器报告的错误

### 17.1.1 IE 

### 17.1.2 Firefox 

### 17.1.3 Safari

### 17.1.4 Opera

### 17.1.5 Chrome 

## 17.2 错误处理

### 17.2.1 try-catch语句

出错对象中包含的实际信息会因浏览器而异，但共同的是有一个保存着错误消息的message属性。ECMA-262还规定了一个保存错误类型的name属性；

IE添加了与message属性完全相同的description属性，还添加了保存着内部错误数量的number属性。Firefox添加了fileName、lineNumber和stack（包含栈跟踪信息）属性。Safari添加了line（表示行号）、sourceId（表示内部错误代码）和sourceURL属性

#### 1. finally子句

finally子句一经使用，其代码无论如何都会执行。只要代码中包含finally子句，那么无论try还是catch语句块中的return语句都将被忽略。

IE7及更早版本中有一个bug：除非有catch子句，否则finally中的代码永远不会执行。

#### 2. 错误类型

ECMA-262定义了下列7种错误类型：

- Error 
- EvalError 
- RangeError 
- ReferenceError 
- SyntaxError 
- TypeError 
- URIError 

Error是基类型，主要目的是供开发人员抛出自定义错误。

EvalError在使用eval()函数而发生异常时被抛出。简单地说，如果没有把eval()当成函数调用，就会抛出错误

RangeError类型的错误会在数值超出相应范围时触发。

ReferenceError，在访问不存在的变量时会发生这种错误

SyntaxError，把语法错误的JavaScript字符串传入eval()函数时，就会导致此类错误。

TypeError，在变量中保存着意外的类型时，或者在访问不存在的方法时，都会导致这种错误。最常发生类型错误的情况，就是传递给函数的参数事先未经检查，结果传入类型与预期类型不相符。

URIError，在使用encodeURI()或decodeURI()，而URI格式不正确时

要想知道错误的类型，可以在try-catch语句的catch语句中使用instanceof操作符。

#### 3. 合理使用try-catch

### 17.2.2 抛出错误

throw操作符，用于随时抛出自定义错误。
抛出错误时，必须要给throw操作符指定一个值，这个值是什么类型，没有要求。
在遇到throw操作符时，代码会立即停止执行。仅当有try-catch语句捕获到被抛出的值时，代码才会继续执行。

在创建自定义错误消息时最常用的错误类型是Error、RangeError、ReferenceError和TypeError。

利用原型链还可以通过继承Error来创建自定义错误类型。此时 ，需要为新创建的错误类型指定name和message属性。

> IE只有在抛出Error对象的时候才会显示自定义错误消息。对于其他类型，它都无一例外地显示"exception thrown and not caught"（抛出了异常，且未被捕获）。

#### 1. 抛出错误的时机

#### 2. 抛出错误与使用try-catch

捕获错误的目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。

### 17.2.3 错误（error）事件

任何没有通过try-catch处理的错误都会触发window对象的error事件。

在任何Web浏览器中，onerror事件处理程序都不会创建event对象，但它可以接收三个参数：错误消息、错误所在的URL和行号。

> 浏览器在使用这个事件处理错误时的方式有明显不同。在IE中，即使发生error事件，代码仍然会正常执行；所有变量和数据都将得到保留，因此能在onerror事件处理程序中访问它们。但在Firefox中，常规代码会停止执行，事件发生之前的所有变量和数据都将被销毁，因此几乎就无法判断错误了。

图像也支持error事件。只要图像的src特性中的URL不能返回可以被识别的图像格式，就会触发error事件。

### 17.2.4 处理错误的策略

### 17.2.5 常见的错误类型

一般来说，需要关注三种错误：

- 类型转换错误
- 数据类型错误
- 通信错误

#### 1. 类型转换错误

建议使用全等（===）和不全等（!==）操作符，以避免类型转换。

在流控制语句中使用非布尔值，是极为常见的一个错误来源。

#### 2. 数据类型错误

在将预料之外的值传递给函数的情况下，最容易发生数据类型错误。

一个常见的错误就是将参数与null值进行比较。与null进行比较只能确保相应的值不是null和undefined。

另一种错误的做法，就是只针对要使用的某一个特性执行特性检测。在确切知道应该传入什么类型的情况下，最好是使用instanceof来检测其数据类型

大体上来说，基本类型的值应该使用typeof来检测，而对象的值则应该使用instanceof来检测。

#### 3. 通信错误

第一种通信错误与格式不正确的URL或发送的数据有关。最常见的问题是在将数据发送给服务器之前，没有使用encodeURIComponent()对数据进行编码。

在服务器响应的数据不正确时，也会发生通信错误。

### 17.2.6 区分致命错误和非致命错误

对于非致命错误，可以根据下列一或多个条件来确定：

- 不影响用户的主要任务；
- 只影响页面的一部分；
- 可以恢复；
- 重复相同操作可以消除错误。

致命错误，可以通过以下一或多个条件来确定：

- 应用程序根本无法继续运行；
- 错误明显影响到了用户的主要操作；
- 会导致其他连带错误。

### 17.2.7 把错误记录到服务器

可使用Image对象来从查询字符串中取得数据，然后再将数据写入错误日志中。

## 17.3 调试技术

### 17.3.1 将消息记录到控制台

对IE8、Firefox、Chrome和Safari来说，则可以通过console对象向JavaScript控制台中写入消息，这个对象具有下列方法。

- error(message)：将错误消息记录到控制台
- info(message)：将信息性消息记录到控制台
- log(message)：将一般消息记录到控制台
- warn(message)：将警告消息记录到控制台

Opera 10.5之前的版本中，JavaScript控制台可以通过opera.postError()方法来访问。这个方法接受一个参数，即要写入到控制台中的参数

还有一种方案是使用LiveConnect，也就是在JavaScript中运行Java代码。Firefox、Safari和Opera都支持LiveConnect，因此可以操作Java控制台。

### 17.3.2 将消息记录到当前页面

另一种输出调试消息的方式，就是在页面中开辟一小块区域，用以显示消息。

这种技术在不支持JavaScript控制台的IE7及更早版本或其他浏览器中十分有用。

### 17.3.3 抛出错误

对于大型应用程序来说，自定义的错误通常都使用assert()函数抛出。这个函数接受两个参数，一个是求值结果应该为true的条件，另一个是条件为false时要抛出的错误。

可以用这个assert()函数代替某些函数中需要调试的if语句，以便输出错误消息。

## 17.4 常见的IE错误

### 17.4.1 操作终止

在IE8之前的版本中，存在操作终止。发生错误时，会出现一个模态对话框，告诉你“操作终止。”

要避免这个问题，可以等到目标元素加载完毕后再对它进行操作，或者使用其他操作方法。

### 17.4.2 无效字符

在JavaScript文件中存在无效字符时，IE会抛出无效字符（invalid character）错误。

其他浏览器对无效字符做出的反应与IE类似，Firefox会抛出非法字符（illegal character）错误，Safari会报告发生了语法错误，而Opera则会报告发生了ReferenceError（引用错误），因为它会将无效字符解释为未定义的标识符。

### 17.4.3 未找到成员

IE中的未找到成员错误，就是由于垃圾收集例程配合错误所直接导致的。

具体来说，如果在对象被销毁之后，又给该对象赋值，就会导致未找到成员错误。而导致这个错误的，一定是COM对象。发生这个错误的最常见情形是使用event对象的时候。IE中的event对象是window的属性，该对象在事件发生时创建，在最后一个事件处理程序执行完毕后销毁。

### 17.4.4 未知运行时错误

当使用innerHTML或outerHTML以下列方式指定HTML时，就会发生未知运行时错误（Unknown 
runtime error）：一是把块元素插入到行内元素时，二是访问表格任意部分（<table>、<tbody>等）的
任意属性时。

### 17.4.5 语法错误

### 17.4.6 系统无法找到指定资源

在使用JavaScript请求某个资源URL，而该URL的长度超过了IE对URL最长不能超过2083个字符的限制时，就会发生这个错误。

## 17.5 小结

下面是几种避免浏览器响应JavaScript错误的方法。

- 在可能发生错误的地方使用try-catch语句，这样你还有机会以适当的方式对错误给出响应，而不必沿用浏览器处理错误的机制。
- 使用window.onerror事件处理程序，这种方式可以接受try-catch不能处理的所有错误（仅限于IE、Firefox和Chrome）。

另外，对任何Web应用程序都应该分析可能的错误来源，并制定处理错误的方案。

- 首先，必须要明确什么是致命错误，什么是非致命错误。
- 其次，再分析代码，以判断最可能发生的错误。JavaScript中发生错误的主要原因如下。
  - 类型转换
  - 未充分检测数据类型
  - 发送给服务器或从服务器接收到的数据有错误



# 第18章 JavaScript 与 XML

## 18.1 浏览器对XML DOM的支持

### 18.1.1 DOM2级核心

DOM2级在document.implementation中引入了createDocument()方法。IE9+、Firefox、Opera、Chrome和Safari都支持这个方法。

```javascript
var xmldom = document.implementation.createDocument(namespaceUri, root, doctype);
var xmldom = document.implementation.createDocument("", "root", null);
```

在通过JavaScript处理XML时，通常只使用参数root，因为这个参数指定的是XML DOM文档元素的标签名。而namespaceUri参数则很少用到，原因是在JavaScrip中管理命名空间比较困难。最后，doctype参数用得就更少了。

要检测浏览器是否支持DOM2级XML，可以使用下面这行代码：

```javascript
var hasXmlDom = document.implementation.hasFeature("XML", "2.0"); 
```

### 18.1.2 DOMParser类型

在解析XML之前，首先必须创建一个DOMParser 的实例，然后再调用parseFromString()方法。这个方法接受两个参数：要解析的XML字符串和内容类型（内容类型始终都应该是"text/xml"）。返回的值是一个Document的实例。

DOMParser只能解析格式良好的XML，因而不能把HTML解析为HTML文档。在发生解析错误时，仍然会从parseFromString()中返回一个Document 对象，但这个对象的文档元素是`<parsererror>`，而文档元素的内容是对解析错误的描述。

Firefox和Opera都会返回这种格式的文档。Safari和Chrome返回的文档也包含<parsererror>元素，
但该元素会出现在发生解析错误的地方。IE9 会在调用parseFromString()的地方抛出一个解析错误。

### 18.1.3 XMLSerializer类型

XMLSerializer：将DOM文档序列化为XML字符串。

Firefox、IE9+、Opera、Chrome和Safari都支持了XMLSerializer。

要序列化DOM文档，首先必须创建XMLSerializer的实例，然后将文档传入其serializeToString ()方法

> 如果将非DOM对象传入serializeToString()，会导致错误发生。

### 18.1.4 IE8及之前版本中的XML

要创建一个XML文档的实例，也要使用ActiveXObject构造函数并为其传入一个表示XML文档版本的字符串。有6种不同的XML文档版本可以供选择。

- Microsoft.XmlDom：最初随同IE发布；不建议使用。
- MSXML2.DOMDocument：为方便脚本处理而更新的版本，建议仅在特殊情况下作为后备版本使用。
- MSXML2.DOMDocument.3.0：为了在JavaScript中使用，这是最低的建议版本。
- MSXML2.DOMDocument.4.0：在通过脚本处理时并不可靠，使用这个版本可能导致安全警告。
- MSXML2.DOMDocument.5.0：在通过脚本处理时并不可靠，使用这个版本同样可能导致安全警告。
- MSXML2.DOMDocument.6.0：通过脚本能够可靠处理的最新版本。

在这6个版本中，微软只推荐使用MSXML2.DOMDocument.6.0或MSXML2.DOMDocument.3.0；前者是最新最可靠的版本，而后者则是大多数Windows操作系统都支持的版本。

要解析XML字符串，首先必须创建一个DOM文档，然后调用loadXML()方法。新创建的XML文档完全是一个空文档，因而不能对其执行任何操作。为loadXML()方法传入的XML字符串经解析之后会被填充到DOM文档中。

如果解析过程中出错，可以在parseError属性中找到错误消息。这个属性本身是一个包含多个属性的对象，每个属性都保存着有关解析错误的某一方面信息。

- errorCode：错误类型的数值编码；在没有发生错误时值为0。
- filePos：文件中导致错误发生的位置。
- line：发生错误的行。
- linepos：发生错误的行中的字符。
- reason：对错误的文本解释。
- srcText：导致错误的代码。
- url：导致错误的文件的URL（如果有这个文件的话）。

parseError的valueOf()方法返回errorCode的值。错误类型的数值编码可能是正值，也可能是负值，因此我们只需检测它是不是等于0。

#### 1. 序列化XML 

IE将序列化XML的能力内置在了DOM文档中。每个DOM节点都有一个xml属性，其中保存着表示该节点的XML字符串。

#### 2. 加载XML文件

与DOM3级中的功能类似，要加载的XML文档必须与页面中运行的JavaScript代码来自同一台服务器。同样与DOM3级规范类似，加载文档的方式也可以分为同步和异步两种。要指定加载文档的方式，可以设置async属性，true表示异步，false表示同步（默认值为true）。

在确定了加载XML文档的方式后，调用load()可以启动下载过程。这个方法接受一个参数，即要加载的XML文件的URL。在同步方式下，调用load()后可以立即检测解析错误并执行相关的XML处理

在异步加载XML文件的情况下，需要为XML DOM文档的onreadystatechange事件指定处理程序。有4个就绪状态。
​	1：DOM正在加载数据。
​	2：DOM已经加载完数据。
​	3：DOM已经可以使用，但某些部分可能还无法访问。
​	4：DOM已经完全可以使用。

在事件处理程序内部，还必须注意要使用XML文档变量的名称（xmldom），不能使用this对象。原因是ActiveX控件为预防安全问题不允许使用this对象。

> 虽然可以通过XML DOM文档对象加载XML文件，但公认的还是使用XMLHttpRequest对象比较好。

### 18.1.5 跨浏览器处理XML

## 18.2 浏览器对XPath的支持

### 18.2.1 DOM3级XPath

要确定某浏览器是否支持DOM3级XPath：

```javascript
var supportsXPath = document.implementation.hasFeature("XPath", "3.0")
```

#### XPathEvaluator

用于在特定的上下文中对XPath表达式求值。这个类型有下列3个方法。

- createExpression(expression, nsresolver)：将XPath表达式及相应的命名空间信息转换成一个XPathExpression，这是查询的编译版。在多次使用同一个查询时很有用。
- createNSResolver(node)：根据node的命名空间信息创建一个新的XPathNSResolver对象。在基于使用命名空间的XML文档求值时，需要使用XPathNSResolver对象。
- evaluate(expression, context, nsresolver, type, result)：在给定的上下文中，基于特定的命名空间信息来对XPath表达式求值。剩下的参数指定如何返回结果。

evaluate()是最常用的。这个方法接收5个参数：XPath表达式、上下文节点、命名空间求解器、返回结果的类型和保存结果的XPathResult对象（通常是null，因为结果也会以函数值的形式返回）。其中，第三个参数（命名空间求解器）只在XML代码中使用了XML命名空间时有必要指定；如果XML代码中没有使用命名空间，则这个参数应该指定为null。第四个参数（返回结果的类型）的取值范围是下列常量之一。

- XPathResult.ANY_TYPE：返回与XPath表达式匹配的数据类型。
- XPathResult.NUMBER_TYPE：返回数值。
- XPathResult.STRING_TYPE：返回字符串值。
- XPathResult.BOOLEAN_TYPE：返回布尔值。
- XPathResult.UNORDERED_NODE_ITERATOR_TYPE：返回匹配的节点集合，但集合中节点的次序不一定与它们在文档中的次序一致。
- XPathResult.ORDERED_NODE_ITERATOR_TYPE：返回匹配的节点集合，集合中节点的次序与它们在文档中的次序一致。这是最常用的结果类型。
- XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE：返回节点集合的快照，由于是在文档外部捕获节点，因此对文档的后续操作不会影响到这个节点集合。集合中节点的次序不一定与它们在文档中的次序一致。
- XPathResult.ORDERED_NODE_SNAPSHOT_TYPE：返回节点集合的快照，由于是在文档外部捕获节点，因此对文档的后续操作不会影响到这个节点集合。集合中节点的次序与它们在文档中的次序一致。
- XPathResult.ANY_UNORDERED_NODE_TYPE：返回匹配的节点集合，但集合中节点的次序不一定与它们在文档中的次序一致。
- XPathResult.FIRST_ORDERED_NODE_TYPE：返回只包含一个节点的节点集合，包含的这个节点就是文档中第一个匹配的节点。

如果指定的是快照结果类型（不管是次序一致还是次序不一致的），就必须使用snapshotItem()方法和snapshotLength属性

#### 1. 单节点结果

指定常量XPathResult.FIRST_ORDERED_NODE_TYPE会返回第一个匹配的节点，可以通过结果的singleNodeValue属性来访问该节点。

#### 2. 简单类型结果

XPathResult的布尔值、数值和字符串类型分别会通过booleanValue、numberValue和stringValue属性返回一个值。

对于布尔值类型，如果至少有一个节点与XPath表达式匹配，则求值结果返回true，否则返回false。

对于数值类型，必须在XPath表达式参数的位置上指定一个能够返回数值的XPath函数

对于字符串类型，evaluate()方法会查找与XPath表达式匹配的第一个节点，然后返回其第一个子节点的值（实际上是假设第一个子节点为文本节点）。如果没有匹配的节点，结果就是一个空字符串。

#### 3. 默认类型结果

要确定返回的是什么结果类型，可以检测结果的resultType属性

#### 4. 命名空间支持

对于利用了命名空间的XML文档，XPathEvaluator必须知道命名空间信息，然后才能正确地进行求值。

处理命名空间的第一种方法是通过createNSResolver()来创建XPathNSResolver对象。这个方法接受一个参数，即文档中包含命名空间定义的节点。

处理命名空间的第二种方法就是定义一个函数，让它接收一个命名空间前缀，返回关联的URI

### 18.2.2 IE中的XPath 

IE对XPath的支持是内置在基于ActiveX的XML DOM文档对象中的，没有使用DOMParser返回的DOM对象。因此，为了在IE9及之前的版本中使用XPath，必须使用基于ActiveX的实现。

这个接口在每个节点上额外定义了两个的方法：selectSingleNode()和selectNodes()。

selectSingleNode()方法接受一个XPath模式，在找到匹配节点时返回第一个匹配的节点，如果没有找到匹配的节点就返回null。

selectNodes()也接收一个XPath模式作为参数，但它返回与模式匹配的所有节点的NodeList（如果没有匹配的节点，则返回一个包含零项的NodeList）。

#### IE对命名空间的支持

要在IE中处理包含命名空间的XPath表达式，你必须知道自己使用的命名空间，并按照下列格式创建一个字符串：

```xml
"xmlns:prefix1='uri1' xmlns:prefix2='uri2' xmlns:prefix3='uri3'"
```

传入到XML DOM文档对象的特殊方法setProperty()中，这个方法接收两个参数：要设置的属性名和属性值。

### 18.2.3 跨浏览器使用XPath 

要在其他使用DOM3级XPath对象的浏览器中，重新创建selectSingleNode()和selectNodes()方法。

selectSingleNode()，它接收三个参数：上下文节点、XPath表达式和可选的命名空间对象。

命名空间对象应该是下面这种字面量的形式。

```xml
{ 
prefix1: "uri1", 
prefix2: "uri2", 
prefix3: "uri3" 
} 
```

selectNodes()函数,接收与selectSingleNode()相同的三个参数

为了求得最佳的浏览器兼容性，我们建议在JavaScript中使用XPath时，只考虑使用这两个方法。

## 18.3 浏览器对XSLT的支持

XSLT是与XML相关的一种技术，它利用XPath将文档从一种表现形式转换成另一种表现形式。

XSLT没有正式的API，在正式的DOM规范中也没有它的位置。

### 18.3.1 IE中的XSLT

IE对XSLT的支持也是通过ActiveX对象实现的。

从MSXML 3.0（即IE6.0）时代起，IE就支持通过JavaScript实现完整的XSLT 1.0操作。IE9中通过DOMParser创建的DOM文档不能使用XSLT。

#### 1. 简单的XSLT转换

使用XSLT样式表转换XML文档的最简单方式，就是将它们分别加到一个DOM文档中，然后再使用transformNode()方法。

transformNode()方法：存在于文档的所有节点中，它接受一个参数，即包含XSLT样式表的文档。调用transformNode()方法会返回一个包含转换信息的字符串。

如果不是在文档元素上调用transformNode()，那么转换就会从调用节点上面开始。不过，XSLT样式表则始终都可以针对调用节点所在的整个XML文档，而无需更换。

#### 2. 复杂的XSLT转换

第一步是要把XSLT样式表加载到一个线程安全的XML文档中。而这可以通过使用ActiveX对象MSXML2.FreeThreadedDOMDocument来做到。

除了签名不同之外，线程安全的XML DOM文档与常规XML DOM文档的使用仍然是一样的

在创建并加载了自由线程的DOM文档之后，必须将它指定给一个XSL模板，这也是一个ActiveX对象。

在创建了XSL处理器之后，必须将要转换的节点指定给input属性。这个值可以是一个文档，也可以是文档中的任何节点。然后，调用transform()方法即可执行转换并将结果作为字符串保存在output属性中。

> XSL模板对象的3.0和6.0版本存在显著的差别。在3.0版本中，必须给input属性指定一个完整的文档；如果指定的是节点，就会导致错误。而在6.0版本中，则可以为input属性指定文档中的任何节点。

XSLT样式表可以接受传入的参数，并将其用作局部变量。

addParameter()方法接收两个参数：要设置的参数名称（与在`<xsl:param>`的name特性中指定的一样）和要指定的值（多数情况下是字符串，但也可以是数值或布尔值）。

XSL处理器能够设置一种操作模式。在XSLT中，可以使用mode特性为模板定义一种模式。在定义了模式后，如果没有将`<xsl:apply-templates>`与匹配的mode特性一起使用，就不会运行该模板。

setStartMode()方法只接受一个参数，即要为处理器设置的模式。与addParameter()一样，设置模式也必须在调用transform()之前进行。

如果你打算使用同一个样式表进行多次转换，可以在每次转换之后重置处理器。调用reset()方法后，就会清除原先的输入和输出属性、启动模式及其他指定的参数。

### 18.3.2 XSLTProcessor类型

非IE实现：

与IE的实现类似，第一步也是加载两个DOM文档，一个基于XML，另一个基于XSLT。

然后，创建一个新XSLTProcessor对象，并使用importStylesheet()方法为其指定一个XSLT。

最后一步就是执行转换。这一步有两种不同的方式，如果想返回一个完整的DOM文档，可以调用transformToDocument()。而通过调用transformToFragment()则可以得到一个文档片段对象。一般来说，使用transformToFragment()的唯一理由，就是你还想把返回的结果添加到另一个DOM文档中。

在使用transformToDocument()时，只要传入XML DOM，就可以将结果作为一个完全不同的DOM文档来使用。

transformToFragment()方法接收两个参数：要转换的XML DOM和应该拥有结果片段的文档。换句话说，如果你想将返回的片段插入到页面中，只要将document作为第二个参数即可。

当输出格式为"text"时调用transformToDocument()，仍然会返回一个完整的XML文档，但这个文档的内容在不同浏览器中却不一样。使用transformToFragment()方法可以解决这个问题，这个方法返回的是只包含一个子节点的文档片段，而子节点中包含着结果文本。

#### 1. 使用参数

XSLTProcessor也支持使用setParameter()来设置XSLT的参数，这个方法接收三个参数：命名空间URI、参数的内部名称和要设置的值。通常，命名空间URI都是null，而内部名称就是参数的名称。另外，必须在调用transformToDocument()或transformToFragment()之前调用这个方法。

还有两个不常用的与参数有关的方法，getParameter()和removeParameter()，分别用于取得和移除当前参数的值。这两个方法都要接受命名空间参数（同样，通常是null）和参数的内部名称。

#### 2. 重置处理器

重置处理器时要调用reset()方法，这个方法会从处理器中移除所有参数和样式表。然后，你就可以再次调用importStylesheet()，以加载不同的XSLT样式表

### 18.3.3  跨浏览器使用XSLT

跨浏览器兼容性最好的XSLT转换技术，只能是返回结果字符串。为此在IE中只需在上下文节点上调用transformNode()即可，而在其他浏览器中则需要序列化transformToDocument()操作的结果。

## 18.4 小结

IE采取了下列方式。

- 通过ActiveX对象来支持处理XML，而相同的对象也可以用来构建桌面应用程序。
- Windows携带了MSXML库，JavaScript能够访问这个库。
- 这个库中包含对基本XML解析和序列化的支持，同时也支持XPath和XSLT等技术。

Firefox为处理XML的解析和序列化，实现了两个新类型。

- DOMParser类型比较简单，其对象可以将XML字符串解析为DOM文档。
- XMLSerializer类型执行相反的操作，即将DOM文档序列化为XML字符串。

DOM3级引入了一个针对XPath API的规范，该规范已经由Firefox、Safari、Chrome和Opera实现。这些API可以让JavaScript基于DOM文档运行任何XPath查询，并且能够返回任何数据的结果。IE以自己的方式实现了对XPath的支持；具体来说，就是两个方法：selectSingleNode()和selectNodes()。

与XML相关的最后一种技术是XSLT，Firefox为通过JavaScript处理转换创建了XSLTProcessor类型；IE则针对XSLT提供了自己的方案，一个是简单的transformNode()方法，另一个是较为复杂的模板/处理器手段。



# 第19章 E4X 

E4X本身不是一门语言，它只是ECMAScript语言的可选扩展。

尽管浏览器实现这个扩展标准的步伐非常缓慢，但Firefox 1.5及更高版本则支持几乎全部E4X标准。

## 19.1 E4X的类型

E4X定义了如下几个新的全局类型。

- XML：XML结构中的任何一个独立的部分。
- XMLList：XML对象的集合。
- Namespace：命名空间前缀与命名空间URI之间的映射。
- QName：由内部名称和命名空间URI组成的一个限定名。

### 19.1.1 XML类型

XML类型继承自Object类型，因此它也继承了所有对象默认的所有属性和方法。

创建XML对象的方式

```javascript
//方式1
var x = new XML(); 
var x = new XML("<employee position=\"Software Engineer\"><name>Nicholas " + 
"Zakas</name></employee>"); 
//方式2
var x = new XML(xmldom);
//方式3
var employee = <employee position="Software Engineer"> 
<name>Nicholas C. Zakas</name> 
</employee>; 
```

> Firefox对E4X的实现不支持解析XML的开头代码（prolog）。无论<?xml version="1.0" ?>出现在传递给XML构造函数的文本中，还是出现在XML字面量中，都会导致语法错误。

XML类型的toXMLString()方法会返回XML对象及其子节点的XML字符串表示。

XML类型的toString()方法则会基于不同XML对象的内容返回不同的字符串。如果内容简单（纯文本），则返回文本；否则，toString()方法与toXMLString()方法返回的字符串一样。

### 19.1.2 XMLList类型

显式地创建一个XMLList对象

```javascript
//方式1
var list = new XMLList(); 
//方式2
var list = new XMLList("<item/><item/>"); 
//方式3
var list = <item/> + <item/> ;
var list = <><item/><item/></>; 
```

可以使用方括号语法及位置来访问每个元素

每个XMLList对象都有length()方法，用于返回对象中包含的元素数量。注意，length()是方法，不是属性。这一点是故意与数组和NodeList相区别的。

E4X有意模糊XML和XMLList类型之间的区别，这一点很值得关注。为了减少两者之间的区别，每个XML对象也同样有一个length()方法和一个由[0]引用的属性（返回XML对象自身）。

XMLList 对象的toString()和toXMLString()方法返回相同的字符串值，也就是将其包含的
XML对象序列化之后再拼接起来的结果。

### 19.1.3 Namespace类型

通常，Namespace对象是用来映射命名空间前缀和命名空间URI的，不过有时候并不需要前缀。

创建Namespace对象

```javascript
var ns = new Namespace();
```

传入URI或前缀加URI, 可以初始化Namespace对象

```javascript
var ns = new Namespace("http://www.wrox.com/"); 
var wrox = new Namespace("wrox", "http://www.wrox.com/");
```

可使用prefix和uri属性来取得Namespace对象中的信息

在没有给Namespace对象指定前缀的情况下，prefix属性会返回undefined。要想创建默认的命名空间，应该将前缀设置为空字符串。

如果XML字面量中包含命名空间，或者通过XML构造函数解析的XML字符串中包含命名空间信息，那么就会自动创建Namespace对象。然后，就可以通过前缀和namespace()方法来取得对Namespace对象的引用。

Namespace对象的toString()方法始终会返回命名空间URI。

### 19.1.4 QName类型

QName类型表现的是XML对象的限定名，即命名空间与内部名称的组合。向QName构造函数中传入名称或Namespace对象和名称，可以手工创建新的QName对象

可以访问它的两个属性：uri和localName。其中，uri属性返回在创建对象时指定的命名空间的URI（如果未指定命名空间，则返回空字符串），而localName属性返回限定名中的内部名称

这两个属性是只读的，如果你想修改它们的值，会导致错误发生。QName对象重写了toString()方法，会以uri::localName形式返回一个字符串

在解析XML结构时，会为表示相应元素或特性的XML对象自动创建QName对象。

使用setName()方法并传入一个新QName对象，可以修改XML对象的限定名

## 19.2 一般用法

在将XML对象、元素、特性和文本集合到一个层次化对象之后，就可以使用点号加特性或标签名的方式来访问其中不同的层次和结构。

如果你不确定子元素的内部名称，或者你想访问所有子元素，不管其名称是什么，也可以像下面这样使用星号（*）。

```javascript
var allChildren = employees.*; //返回所有子元素，不管其名称是什么
```

child()方法。将属性名或索引值传递给child()方法，会得到相同的值。

children()方法始终返回所有子元素。

elements()的行为与child()类似，区别仅在于它只返回表示元素的XML对象。

要删除子元素，可以使用delete操作符

### 19.2.1 访问特性

访问特性也可以使用点语法,为了区分特性名与子元素的标签名，必须在名称前面加上一个@字符。这是从XPath中借鉴的语法；XPath也是使用@来区分特性和标签的名称。

要取得特性的名称，可以使用对象的name()方法。

可使用child()方法来访问特性，只要传入带有@前缀的特性的名称即可。由于访问XML对象的属性时也可以使用child()，因此必须使用@字符来区分标签名和特性名。

使用attribute()方法并传入特性名，可以只访问XML对象的特性。不需要传入带@字符的特性名。

要取得XML或XMLList对象中的所有特性，可以使用attributes()方法。这个方法会返回一个表示所有特性的XMLList对象。使用这个方法与使用@*的结果相同

在E4X中修改特性的值与修改属性的值一样非常简单，只要像下面这样为特性指定一个新值。也可以用来添加新特性

修改的特性会在内部反映出来，换句话说，此后再序列化XML对象，就会使用新的特性值。

由于特性与其他ECMAScript属性类似，因此也可以使用delete操作符来删除特性

### 19.2.2 其他节点类型

在默认情况上，E4X不会解析注释或处理指令，因此这些部分不会出现在最终的对象层次中。如果想让解析器解析这些部分，可以像下面这样设置XML构造函数的下列两个属性。

```javascript
XML.ignoreComments = false; 
XML.ignoreProcessingInstructions = false; 
```

使用nodeKind()方法可以得到XML对象表示的类型，该访问可能会返回"text"、"element"、"comment"、"processing-instruction"或"attribute"。

不能在包含多个XML对象的XMLList上调用nodeKind()方法；否则，会抛出一个错误。

可以只取得特定类型的节点，而这就要用到下列方法。

-  attributes()：返回XML对象的所有特性。
- comments()：返回XML对象的所有子注释节点。
- elements(tagName)：返回XML对象的所有子元素。可以通过提供元素的tagName（标签名）来过滤想要返回的结果。


- processingInstructions(name)：返回XML对象的所有处理指令。可以通过提供处理指令的name（名称）来过滤想要返回的结果。


- text()：返回XML对象的所有文本子节点。

上述方法都返回一个包含适当XML对象的XMLList。

使用hasSimpleContent()和hasComplexContent()方法，可以确定XML对象中是只包含文本，还是包含更复杂的内容。如果XML对象中只包含子文本节点，则前一个方法会返回true；如果XML对象的子节点中有任何非文本节点，则后一个方法返回true。

### 19.2.3 查询

引用不表现XML 结构中某一部分的属性仍然会返回XMLList；只不过这个XMLList中什么也不会包含。

使用两个点，则可以进一步扩展查询的深度，查询到所有后代节点。要想取得特定标签的元素，需要将星号替换成实际的标签名

```javascript
var allDescendants = employees..*; //取得<employees/>的所有后代节点
```

同样的查询可以使用descendants()方法来完成。在不给这个方法传递参数的情况下，它会返回所有后代节点（与使用..*相同），而传递一个名称作为参数则可以限制结果。

同样的查询可以取得所有后代元素中的所有特性

除了访问后代元素之外，还可以指定查询的条件。

```javascript
var salespeople = employees.employee.(@position == "Salesperson"); 
```

同样的语法也可以用于修改XML结构中的某一部分。

```javascript
employees.employee.(@position == "Salesperson")[0].@position= "Senior Salesperson"; 
```

注意，圆括号中的表达式会返回一个包含结果的XMLList，而方括号返回其中的一项

使用parent()方法能够在XML结构中上溯，这个方法会返回一个XML对象，表示当前XML对象的父元素。如果在XMLList上调用parent()方法，则会返回列表中所有对象的公共父元素。

### 19.2.4 构建和操作XML 

可以在字面量中嵌入JavaScript变量，语法是使用花括号（{}）。

E4X也支持使用标准的JavaScript语法来构建完整的XML结构。

- E4XappendChild(child)：将给定的child作为子节点添加到XMLList的末尾。
- copy()：返回XML对象副本。
- insertChildAfter(refNode, child)：将child作为子节点插入到XMLList中refNode的后面。
- insertChildBefore(refNode, child)：将child作为子节点插入到XMLList中refNode的前面。
- prependChild(child)：将给定的child作为子节点添加到XMLList的开始位置。
- replace(propertyName, value)：用value值替换名为propertyName的属性，这个属性可能是一个元素，也可能是一个特性。
- setChildren(children)：用children替换当前所有的子元素，children可以是XML对象，也可是XMLList对象。类似DOM的方法：

### 19.2.5 解析和序列化

与XML解析相关的设置有如下三个。

- ignoreComments：表示解析器应该忽略标记中的注释。默认设置为true。
- ignoreProcessingInstructions：表示解析器应该忽略标记中的处理指令。默认设置为true。
- ignoreWhitespace：表示解析器应该忽略元素间的空格，而不是创建表现这些空格的文本节点。默认设置为true。

与XML数据序列化相关的设置有如下两个。这两个设置将影响到toString()和toXMLString()的输出。

- prettyIndent：表示在序列化XML时，每次缩进的空格数量。默认值为2。
- prettyPrinting：表示应该以方便人类认读的方式输出XML，即每个元素重起一行，而且子元素都要缩进。默认设置为true。

以上五个设置都保存在settings对象中，通过XML构造函数的settings()方法可以取得这个对象

使用defaultSettings()方法则可以取得一个包含默认设置的对象

### 19.2.6 命名空间

使用namspace()方法可以取得与特定前缀对应的Namespace对象。而通过使用setNamespace()并传入Namespace对象，也可以为给定元素设置命名空间。

如果只想添加一个命名空间声明，而不想改变元素，可以使用addNamespace()方法并传入Namespace对象

调用removeNamespace()方法并传入Namespace对象，可以移除表示特定命名空间前缀和URI的命名空间声明；注意，必须传入丝毫不差的表示命名空间的Namespace对象。

有两个方法可以返回与节点相关的Namespace 对象的数组：namespaceDeclarations()和
inScopeNamespaces()。前者返回在给定节点上声明的所有命名空间的数组，后者返回位于给定节点作用域中（即包括在节点自身和祖先元素中声明的）所有命名空间的数组。

使用双冒号（::）也可以基于Namespace对象来查询XML结构中具有特定命名空间的元素。注意，这里使用的是JavaScript变量，而不是命名空间前缀。

可以为某个作用域中的所有XML对象设置默认命名空间。为此，要使用default xml namespace语句，并将一个Namespace对象或一个命名空间URI作为值赋给它。

```javascript
default xml namespace = "http://www.wrox.com/";
```

注：在局部作用域中设置默认命名空间并不会改变全局作用域中的默认XML命名空间

## 19.3 其他变化

E4X引入了for-each-in循环，以便迭代遍历每一个属性并返回属性的值

虽然for-each-in循环是在E4X中定义的，但这个语句也可以用于常规的数组和对象

对于数组，for-each-in循环会返回数组中的每一项。对于非XML对象，这个循环返回对象每个属性的值。

E4X还添加了一个全局函数，名叫isXMLName()。这个函数接受一个字符串，并在这个字符串是元素或特性的有效内部名称的情况下返回true。在使用未知字符串构建XML数据结构时，这个函数可以为开发人员提供方便。

E4X对标准ECMAScript的最后一个修改是typeof操作符。在对XML对象或XMLList对象使用这个操作符时，typeof返回字符串"xml"。但在对其他对象使用这个操作符时，返回的都是"object"

## 19.4 全面启用E4X 

Firefox在默认情况下只启用E4X中与其他代码能够相安无事的那些特性。要想完整地启用E4X，需要将`<script>`标签的type 特性设置为"text/javascript;e4x=1"

## 19.5 小结

E4X具有下列特征。

- 与DOM不同，E4X只用一个类型来表示XML中的各种节点。
- XML对象中封装了对所有节点都有用的数据和行为。为表现多个节点的集合，这个规范定义了XMLList类型。


- 另外两个类型，Namespace和QName，分别表现命名空间和限定名。

E4X还修改了标准了的ECMAScript语法

- 使用两个点（..）表示要匹配所有后代元素，使用@字符表示应该返回一或多个特性。
- 星号字符（*）是一个通配符，可以匹配任意类型的节点。
- 所有这些查询都可以通过一组执行相同操作的方法来实现。






