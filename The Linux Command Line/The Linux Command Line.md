# The Linux Command Line #
## 1 引言 ##

## 2 什么是 shell ##

## 3 文件系统中跳转 ##

## 4 探究操作系统 ##
### 4.2 选项和参数 ###
- 加上长选项“–reverse”，则结果会以相反的顺序输出. e.g. ls -lt --reverse
- ls
    选项 长选项 描述
    -d --directory 通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。
    -F --classify 这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是目录名，则会加上一个’/’ 字符。
    -h --human-readable 当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。
    -l 以长格式显示结果。
    -r --reverse 以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。
    -S 命令输出结果按照文件大小来排序。
    -t 按照修改时间来排序。

### 4.3 深入研究长格式输出 ###
-rw-r--r--  1

-rw-r--r--      开头的“－”说明是一个普通文件,“d”表明是一个目录,"l"符号链接。
1               文件的硬链接数目。参考随后讨论的关于链接的内容。

### 4.6 less 就是 more ###
- less 属于 “页面调度器” 程序类，这些程序允许通过页方式，在一页中轻松地浏览长长的文本文档。然而 more 程序只能向前分页浏览，而 less 程序允许前后分页浏览

### 4.7 旅行指南 ###
- 按下鼠标中键，粘贴文件名到命令行中

    /boot       • /boot/grub/grub.conf or menu.lst，被用来配置启动加载程序。
                • /boot/vmlinuz，Linux 内核。
    /etc        这个目录包含所有系统层面的配置文件。
                • /etc/crontab，定义自动运行的任务。
                • /etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。
                • /etc/passwd，包含用户帐号列表。
    /lost+found     每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统，都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。除非文件系统真正的损坏了，那么这个目录会是个空目录。
    /opt        这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能安装在系统中的商业软件产品
    /proc       由 Linux 内核维护的虚拟文件系统。
    /sbin       这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。
    /usr/local  这个/usr/local 目录，是非系统发行版自带，却打算让系统使用的程序的安装目录。通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中，会存在这个目录，但却是空目录，直到系统管理员放些东西到它里面。
    /usr/sbin   包含许多系统管理程序。
    /var        除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说，它们的内容不会改变。/var 目录是可能需要改动的文件存储的地方。各种数据库，假脱机文件，用户邮件等等，都驻扎在这里。
    /var/log    这个/var/log 目录包含日志文件，各种系统活动的记录。这些文件非常重要，并且应该时时监测它们。其中最重要的一个文件是/var/log/messages。

## 5 操作文件和目录 ##
### 5.1 通配符 ###
    [!characters]   匹配任意一个不是字符集中的字符
    [[:class:]]     匹配任意一个属于指定字符类中的字符

    [:alnum:]   匹配任意一个字母或数字
    [:alpha:]   匹配任意一个字母
    [:digit:]   匹配任意一个数字
    [:lower:]   匹配任意一个小写字母
    [:upper]    匹配任意一个大写字母

### 5.4 有用的选项和实例 ###
- cp  命令 
    -a, --archive           属性，包括所有权和权限
    -i, --interactive       在重写已存在文件之前，提示用户确认
    -u, --update            当把文件从一个目录复制到另一个目录时，仅复制目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。
    -v, --verbose           显示翔实的命令操作信息

### 5.9 ln —创建链接 ###
- ln file link
- ln -s item link       “item” 可以是一个文件或是一个目录。

### 5.10 硬链接 ###
- 一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联与链接本身不在同一个磁盘分区上的文件。
- 一个硬链接不能关联一个目录。
- 当一个硬链接被删除时，这个链接被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被重新分配），
- 当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。

### 5.15 创建硬链接 ###
- ls 命令有一种方法，来展示（文件索引节点）的信息。在命令中加上 “-i” 选项

### 5.17 移动文件和目录 ###
- 在 GNOME 里面，当拖动文件时，同时按下 Ctrl+Shift 按键会创建一个链接，而不是复制（或移动）文件。

## 6 使用命令 ##
### 6.3 type －显示命令的类型 ###
- 显示命令的类别

### 6.4 which －显示一个可执行程序的位置 ###
- 这个命令只对可执行程序有效，不包括内部命令和命令别名

### 6.6 help －得到 shell 内部命令的帮助文档 ###
- 注意表示法：出现在命令语法说明中的方括号，表示可选的项目。一个竖杠字符表示互斥选项。

### 6.7 --help - 显示用法信息 ###

### 6.8 man －显示程序手册页 ###
- 没有指定章节号，我们总是得到第一个匹配项
    e.g.man 5 passwd    显示文件/etc/passwd 的文件格式说明手册。

### 6.9 apropos －显示适当的命令 ###
- 输出结果每行的第一个字段是手册页的名字，第二个字段展示章节。
- 注意，man 命令加上“-k” 选项，和 apropos 完成一样的功能。

### 6.10 whatis －显示非常简洁的命令说明 ###

### 6.11 info －显示程序 Info 条目 ###
- info 页是超级链接形式的，和网页很相似。

### 6.12 README 和其它程序文档 ###
- gzip 软件包包括一个特殊的 less 版本，叫做 zless，zless 可以显示由 gzip压缩的文本文件的内容。

### 6.13 用别名（alias）创建你自己的命令 ###
- alias name='string'
- 删除别名，使用 unalias 命令
- 要查看所有定义在系统环境中的别名，使用不带参数的 alias 命令。

## 7 重定向 ##
### 7.2 重定向标准输出 ###
- “>>” 重定向符 把重定向结果追加到文件内容后面.如果文件不存在，文件会被创建

### 7.4 重定向标准输出和错误到同一个文件 ###
- 方法1 :[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt 2>&1
- 方法2 :[me@linuxbox ~]$ ls -l /bin/usr &> ls-output.txt

### 7.7 cat －连接文件 ###
- 如果 cat 没有给出任何参数，它会从标准输入读入数据

### 7.9 过滤器 ###
- 管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。通常，以这种方式使用的命令被称为过滤器。

### 7.10 uniq - 报道或忽略重复行 ###
- uniq 命令经常和 sort 命令结合在一起使用。
- uniq 从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。
- 想看到重复的数据列表，让 uniq 命令带上 “-d” 选项

### 7.11 wc －打印行，字和字节数 ###
- “-l” 选项限制命令输出只能报道行数。

### 7.12 grep －打印匹配行 ###
- “-i” 导致 grep 忽略大小写当执行搜索时（通常，搜索是大小写敏感的）
- “-v” 选项会告诉 grep 只打印不匹配的行。

### 7.13 head / tail －打印文件开头部分/结尾部分 ###
- head命令打印文件的前十行，而 tail 命令打印文件的后十行。
- “-n” 选项来调整命令打印的行数。
- “-f” 选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即出现在屏幕上。

## 8 从 shell 眼中看世界 ##
### 8.1 (字符)展开 ###
### 8.2 路径名展开 ###
- 隐藏文件路径名展开
    ls -d .[!.]?*

### 8.3 波浪线展开 ###
### 8.4 算术表达式展开 ###
- $((expression))

### 8.5 花括号展开 ###
- 花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可能包含一个由逗号分开的字符串列表，或者一系列整数，或者单个的字符串。这种模式不能嵌入空白字符。

### 8.6 参数展开 ###
- USER  ：   echo $USER
- 查看有效的变量列表 ：   printenv | less

### 8.7 命令替换 ###
- 命令替换允许我们把一个命令的输出作为一个展开模式来使用
- 可用$()或``

### 8.8 引用 ###
### 8.9 双引号 ###
- 在双引号中，参数展开，算术表达式展开，和命令替换仍然有效：
- 在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作单词之间的界定符。
- 如果我们加上双引号：单词分割被禁止，内嵌的空格也不会被当作界定符，它们成为参数的一部分。
- 事实上，单词分割机制把换行符看作界定符，对命令替换产生了一个

### 8.10 单引号 ###
- 如果需要禁止所有的展开，我们使用单引号。

### 8.11 转义字符 ###
- 注意在单引号中，反斜杠失去它的特殊含义，它被看作普通字符。
- echo 命令带上 ‘-e’ 选项，能够解释转义序列。可以把转义序列放在 $’ ’ 里面。

### 8.12 总结归纳 ###
### 8.13 拓展阅读 ###

## 9 键盘高级操作技巧 ##
### 9.1 命令行编辑 ###

### 9.2 移动光标 ###
- 按键
    Ctrl-f  光标前移一个字符；和右箭头作用一样。
    Ctrl-b  光标后移一个字符；和左箭头作用一样。
    Alt-f   光标前移一个字。
    Alt-b   光标后移一个字。

### 9.3 修改文本 ###
- 按键
    Ctrl-d  删除光标位置的字符。
    Ctrl-t  光标位置的字符和光标前面的字符互换位置。
    Alt-t   光标位置的字和其前面的字互换位置。
    Alt-l   把从光标位置到字尾的字符转换成小写字母。
    Alt-u   把从光标位置到字尾的字符转换成大写字母。

### 9.4 剪切和粘贴文本 ###
- 术语 killing 和 yanking 来指我们平常所说的剪切和粘贴。剪切下来的本文被存储在一个叫做剪切环 (kill-ring) 的缓冲区中。
- 按键
    Ctrl-k          剪切从光标位置到行尾的文本。
    Ctrl-u          剪切从光标位置到行首的文本。
    Alt-d           剪切从光标位置到词尾的文本。
    Alt-Backspace   剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。
    Ctrl-y          把剪切环中的文本粘贴到光标位置。

#### 元键 ####
- 在当今的键盘上，这个元键是指 Alt 键，但并不总是这样。如果你仍然在使用终端（在 Linux 中，你仍然可以得到一个终端），你也可以按下和释放 Esc 键来得到如控制 Alt 键一样的效果。

### 9.5 自动补全 ###
- 按键
    Alt-?   显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按两次 tab 键，这会更容易些。
    Alt-*   插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。

### 9.6 利用历史命令 ###
- 这个命令列表被保存在你家目录下，一个叫做.bash history 的文件里。

### 9.7 搜索历史命令 ###
- 在默认情况下，bash 会存储你所输入的最后 500 个命令。
- 对于历史列表，可以**启动递增搜索**：
    输入 Ctrl-r，其后输入你要寻找的文本。当你找到它以后，你可以敲入 Enter 来执行命令，或者输入 Ctrl-j，从历史列表中复制这一行到当前命令行。再次输入 Ctrl-r，来找到下一个匹配项（向上移动历史列表）。输入 Ctrl-g 或者 Ctrl-c，退出搜索。
- 操作历史列表按键
    Ctrl-p  移动到上一个历史条目。类似于上箭头按键。
    Ctrl-n  移动到下一个历史条目。类似于下箭头按键。
    Alt-<   移动到历史列表开头。
    Alt->   移动到历史列表结尾，即当前命令行。
    Ctrl-r  反向递增搜索。从当前命令行开始，向上递增搜索。
    Alt-p   反向搜索，不是递增顺序。输入要查找的字符串，然后按下Enter，执行搜索。
    Alt-n   向前搜索，非递增顺序。
    Ctrl-o  执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便。 

### 9.8 历史命令展开 ###
- 展开特性：
    !!          重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。
    !number     重复历史列表中第 number 行的命令。
    !string     重复最近历史列表中，以这个字符串开头的命令。
    !?string    重复最近历史列表中，包含这个字符串的命令。

- 许多Linux 发行版包括一个叫做 script 的程序，这个程序可以记录整个 shell 会话，并把 shell 会话存在一个文件里面。这个命令的基本语法是：
    script [file]

### 9.9 总结归纳 ###
### 9.10 拓展阅读 ###
    http://en.wikipedia.org/wiki/Computer_terminal

## 10 权限 ##
### 10.1 拥有者，组成员，和其他人 ###
    id

### 10.2 读取，写入，和执行 ###
- 文件类型属性
    -  一个普通文件
    d  一个目录
    l  一个符号链接。注意对于符号链接文件，剩余的文件属性总是”rwxrwxrwx”，而且都是虚拟值。真正的文件属性是指符号链接所指向的文件的属性。
    c   一个字符设备文件。这种文件类型是指按照字节流，来处理数据的设备。比如说终端机，或者调制解调器
    b   一个块设备文件。这种文件类型是指按照数据块，来处理数据的设备，例如一个硬盘，或者 CD-ROM 盘。

### 10.3 chmod －更改文件模式 ###
- 常见的映射关系
    7 (rwx)，6 (rw-)，5 (r-x)，4 (r--)，和 0 (-–)
- chmod 命令符号表示法
    u       ”user” 的简写，意思是文件或目录的所有者。
    g       用户组。
    o       ”others” 的简写，意思是其他所有的人。
    a       ”all” 的简写，是”u”, ”g” 和“o”三者的联合。

    u+x     为文件所有者添加可执行权限。
    u-x     删除文件所有者的可执行权限。
    +x      为文件所有者，用户组，和其他所有人添加可执行权限。等价于 a+x。
    o-rw    除了文件所有者和用户组，删除其他人的读权限和写权限。
    go=rw   给群组的主人和任意文件拥有者的人读写权限。如果群组的主人或全局之前已经有了执行的权限，他们将被移除。
    u+x,go=rw 给文件拥有者执行权限并给组和其他人读和执行的权限。多种设定可以用逗号分开。

### 10.4 借助 GUI 来设置文件模式 ###

### 10.5 umask －设置默认权限 ###
- 当创建一个文件时，umask 命令控制着文件的默认权限。umask 命令使用八进制表示法来表达从文件模式属性中删除一个位掩码。
- 注意掩码中若出现一个数字 1，则删除文件模式中和这个 1 在相同位置的属性
- 一些特殊权限:
    setuid 位（八进制 4000)      把有效用户 ID 从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。
    setgid 位（八进制 2000）
    sticky 位（八进制 1000）     在 Unix 中，它可能把一个可执行文件标志为“不可交换的”。在 Linux 中，会忽略文件的 sticky 位，但是如果一个目录设置了 sticky 位，那么它能阻止用户删除或重命名文件，除非用户是这个目录的所有者，或者是文件所有者，或是超级用户。个经常用来控制访问共享目录，比方说/tmp。

    chmod u+s program   授予一个程序 setuid 权限
    chmod g+s dir       授予一个目录 setgid 权限
    chmod +t dir        授予一个目录 sticky 权限

### 10.6 更改身份 ###
- su 命令允许你，假定为另一个用户的身份
- sudo 命令允许一个管理员设置一个叫做/etc/sudoers 的配置文件，并且定义了一些具体命令

### 10.7 su －以其他用户身份和组 ID 运行一个 shell ###
    su [-[l]] [user]        如果包含 “-l” 选项，那么会为指定用户启动一个需要登录的 shell。如果不指定用户，那么就假定是超级用户。注意（不可思议地），选项 “-l” 可以缩写为”-”
    su -c 'command'         使用这种模式，命令传递到一个新 shell 中执行。把命令用单引号引起来很重要，因为我们不想命令在我们的 shell 中展开，但需要在新 shell 中展开。

### 10.8 sudo －以另一个用户身份执行命令 ###
- 只有一个用户可以执行一个或多个特殊命令时，（更体现了 sudo命令的方便性）。另一个重要差异是 sudo 命令不要求超级用户的密码。使用 sudo 命令时，用户使用他/她自己的密码来认证。
- su 和 sudo 之间的一个重要区别是 sudo 不会重新启动一个 shell，也不会加载另一个用户的 shell 运行环境。这意味者命令不必用单引号引起来。

### 10.9 chown －更改文件所有者和用户组 ###
- chown 命令的语法
    chown [owner][:[group]] file...

- 注意，第一次使用 sudo 命令之后，为什么（shell）没有提示 janet 输入她的密码？这是因为，在大多数的配置中，sudo 命令会相信你几分钟，直到计时结束。

### 10.10 chgrp －更改用户组所有权 ###

### 10.11 练习使用权限 ###
- umask 命令设置的掩码值只能在当前 shell 会话中生效，若当前 shell 会话结束后，则必须重新设置。

### 10.12 更改用户密码 ###
    passwd [user]

### 10.13 拓展阅读 ###
http://en.wikipedia.org/wiki/Malware

## 11 进程 ##
### 11.1 进程是怎样工作的 ###

### 11.2 查看进程 ###
    ps
- TTY 是 “Teletype” 的简写，是指进程的控制终端。在 TTY 一栏中出现的 “?” ，表示没有控制终端。
- TIME 字段表示进程所消耗的 CPU 时间数量。
- 加上 “x” 选项（注意没有开头的”-“ 字符），告诉 ps 命令，展示所有进程，不管它们由什么终端（如果有的话）控制。
- 输出结果中，新添加了一栏，标题为 STAT 。STAT 是 “state” 的简写，它揭示了进程当前状态：
    状态 意义
    R   运行。这意味着，进程正在运行或准备运行。
    S   正在睡眠。进程没有运行，而是，正在等待一个事件，比如说，一个按键或者网络数据包。
    D   不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。
    T   已停止. 已经指示进程停止运行。稍后介绍更多。
    Z   一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。（父进程没有把子进程从进程表中删除）
    <   一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice），因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。
    N   低优先级进程。一个低优先级进程（一个“好”进程）只有当其它高优先级进程执行之后，才会得到处理器时间。

- 另一个流行的选项组合是 “aux”（不带开头的 “-” 字符）。
    标题      意思
    USER    用户 ID. 进程的所有者。
    %CPU    以百分比表示的 CPU 使用率
    %MEM    以百分比表示的内存使用率
    VSZ     虚拟内存大小
    RSS     进程占用的物理内存的大小，以千字节为单位。
    START   进程运行的起始时间。若超过 24 小时，则用天表示

### 11.3 用 top 命令动态查看进程 ###
- top 程序连续显示系统进程更新的信息（默认情况下，每三分钟更新一次）
    行号      字段              意义
    1       top             程序名。
            14:59:20        当前时间。
            up 6:30         这是正常运行时间。它是计算机从上次启动到现在所运行的时间。在这个例子里，系统已经运行了六个半小时。
            2 users         有两个用户登录系统。
            load average:   加载平均值是指，等待运行的进程数目，也就是说，处于运行状态的进程个数，这些进程共享 CPU。展示了三个数值，每个数值对应不同的时间周期。第一个是最后 60 秒的平均值，下一个是前 5 分钟的平均值，最后一个是前 15 分钟的平均值。若平均值低于 1.0，则指示计算机工作不忙碌。
    2       Tasks:          总结了进程数目和各种进程状态。
    3       Cpu(s):         这一行描述了 CPU 正在执行的进程的特性。
            0.7%us          0.7% of the CPU is being used for user processes. 这意味着进程在内核之外。
            1.0%sy          1.0% 的 CPU 时间被用于系统（内核）进程。
            0.0%ni          0.0% 的 CPU 时间被用于”nice”（低优先级）进程。
            98.3%id         98.3% 的 CPU 时间是空闲的。
            0.0%wa          0.0% 的 CPU 时间来等待 I/O。
    4       Mem:            展示物理内存的使用情况。
    5       Swap:           展示交换分区（虚拟内存）的使用情况。

### 11.4 控制进程 ###

### 11.5 中断一个进程 ###

### 11.6 把一个进程放置到后台 (执行) ###

### 11.7 进程返回到前台 ###
- 一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 Ctrl-c 来中断它。使用 fg命令，让一个进程返回前台执行
- fg 命令之后，跟随着一个百分号和工作序号（叫做 jobspec）。如果我们只有一个后台任务，那么 jobspec 是可有可无的。

### 11.8 停止一个进程 ###
- 输入 Ctrl-z，可以停止一个前台进程。
- 使用 fg 命令，可以恢复程序到前台运行，或者用 bg 命令把程序移到后台。

### 11.9 Signals ###
- kill 命令，并且指定我们想要终止的进程 PID。可以用 jobspec（例如，“％1”）来代替 PID。

### 11.10 通过 kill 命令给进程发送信号 ###
    kill [-signal] PID...
- 常用信号
    编号  名字          含义
    1   HUP     挂起。这个信号被用来告诉程序，控制的终端机已经“挂起”。发送这个信号到终端机上的前台程序，程序会终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后，这个进程会重新启动，并且重新读取它的配置文件。
    2   INT     中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。
    9   KILL    杀死。这个信号很特别。鉴于进程可能会选择不同的方式，来处理发送给它的信号，其中也包含忽略信号，这样呢，从不发送 Kill 信号到目标进程。而是内核立即终止这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是存劳动成果。因为这个原因，把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。
    15  TERM    终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么这个信号终止。
    18  CONT    继续。在停止一段时间后，进程恢复运行。
    19  STOP    停止。这个信号导致进程停止运行，而没有终止。像KILL 信号，它不被发送到目标进程，因此它不能被忽略。

- 其它常用信号：
    编号  名字      含义
    3   QUIT    退出
    11  SEGV    段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说，程序试图写入内存，而这个内存空间是不允许此程序写入的。
    20  TSTP    终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号，TSTP 信号由目标进程接收，且可能被忽略。
    28  WINCH   改变窗口大小。当改变窗口大小时，系统会发送这个信号。一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。

- 得到一个完整的信号列表
    kill -l

### 11.11 通过 killall 命令给多个进程发送信号 ###
    killall [-u user] [-signal] name..

### 11.12 更多和进程相关的命令 ###
- 其它与进程相关的命令
    命令名     命令描述
    pstree  输出一个树型结构的进程列表，这个列表展示了进程间父/子关系。
    vmstat  输出一个系统资源使用快照，包括内存，交换分区和磁盘I/O。为了看到连续的显示结果，则在命令名后加上延时的时间（以秒为单位）。
    xload   一个图形界面程序，可以画出系统负载的图形。
    tload   与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。

## 12 shell 环境 ##
### 12.1 什么存储在环境变量中？ ###

### 12.2 检查环境变量 ###
- set命令可以显示 shell 和环境变量两者
- printenv 只是显示环境变量。
- 如果 shell 环境中的一个成员既不可用 set 命令也不可用 printenv 命令显示，则这个变量是别名。输入不带参数的 alias 命令来查看它们

### 12.3 一些有趣的变量 ###
- 环境变量
    变量          内容
    DISPLAY     如果你正在运行图形界面环境，那么这个变量就是你显示器的名字。通常，它是”:0”，意思是由 X 产生的第一个显示器。
    EDITOR      文本编辑器的名字。
    SHELL       shell 程序的名字。
    HOME        用户家目录。
    LANG        定义了字符集以及语言编码方式。
    OLD_PWD     先前的工作目录。
    PAGER       页输出程序的名字。这经常设置为/usr/bin/less。
    PATH        由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。
    PS1         Prompt String 1. 这个定义了你的 shell 提示符的内容。随后我们可以看到，这个变量内容可以全面地定制。
    PWD         当前工作目录。
    TERM        终端类型名。类 Unix 的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。
    TZ          指定你所在的时区。大多数类 Unix 的系统按照协调时间时(UTC) 来维护计算机内部的时钟，然后应用一个由这个变量指定的偏差来显示本地时间。
    USER 你的用户名
    
### 12.4 如何建立 shell 环境？ ###
- 登录 shell 会话的启动文件
    文件              内容
    /etc/profile    应用于所有用户的全局配置脚本。
    ˜/.bash profile 用户私人的启动文件。可以用来扩展或重写全局配置脚本中的设置。
    ˜/.bash login   如果文件 ˜/.bash profile 没有找到，bash 会尝试读取这个脚本。
    ˜/.profile      如果文件 ˜/.bash profile 或文件 ˜/.bash login 都没有找到，bash 会试图读取这个文件。这是基于 Debian 发行版的默认设置，比方说 Ubuntu。

- 非登录 shell 会话会读取以下启动文件：
    文件                  内容
    /etc/bash.bashrc    应用于所有用户的全局配置文件。
    ˜/.bashrc           用户私有的启动文件。可以用来扩展或重写全局配置脚本中的设置。
- 除了读取以上启动文件之外，非登录 shell 会话也会继承它们父进程的环境设置，通常是一个登录 shell。

### 12.5 一个启动文件的内容 ###
- 这个 export 命令告诉 shell 让这个 shell 的子进程可以使用 PATH 变量的内容。
    export $PATH

### 12.6 修改 shell 环境 ###
### 12.7 我们应该修改哪个文件？ ###
- 按照通常的规则，添加目录到你的 PATH 变量或者是定义额外的环境变量，要把这些更改放置到.bash profile 文件中
- 对于其它的更改，要放到.bashrc 文件中。

### 12.8 文本编辑器 ###
### 12.9 使用文本编辑器 ###
- alias ll=’ls -l --color=auto’ 创建一个叫做’ll’ 的命令，这个命令会显示长格式目录列表。

### 12.10 激活我们的修改 ###
### 12.11 总结 ###
### 12.12 拓展阅读 ###

## 13 vi 简介 ##
### 13.1 为什么我们应该学习 vi ###
### 13.2 一点儿背景介绍 ###
### 13.3 启动和停止 vi ###
### 13.4 编辑模式 ###
#### 13.4.1 插入模式 ####
#### 13.4.2 保存我们的工作 ####
### 13.5 移动光标 ###
    Ctrl-f or Page Down 向下翻一页
    Ctrl-b or Page Up 向上翻一页

### 13.6 基本编辑 ###
#### 13.6.1 追加文本 ####
    A   在行尾附加文本
#### 13.6.2 打开一行 ####
    o 当前行的下方打开一行。
    O 当前行的上方打开一行。
#### 13.6.3 删除文本 ####
#### 13.6.4 剪切，复制和粘贴文本 ####
#### 13.6.5 连接行 ####
    大写的 J       把行与行之间连接起
### 13.7 查找和替换 ###
#### 13.7.1 查找一行 ####
#### 13.7.2 查找整个文件 ####
#### 13.7.3 全局查找和替代 ####
- vi 使用 ex 命令来执行查找和替代操作
    :%s/Line/line/g
    条目      含义
    :       冒号字符运行一个 ex 命令。
    %       指定要操作的行数。% 是一个快捷方式，表示从第一行到最后一行。另外，操作范围也可以用 1,5 来代替（因为我们的文件只有 5 行文本），或者用 1,$ 来代替，意思是“从第一行到文件的最后一行。”如果省略了文本行的范围，那么操作只对当前行生效。
    s       指定操作。在这种情况下是，替换（查找与替代）。/Line/line 查找类型与替代文本。
    g       这是“全局”的意思，意味着对文本行中所有匹配的字符串执行查找和替换操作。如果省略 g，则只替换每个文本行中第一个匹配的字符串。
- 通过添加一个 “c” 字符到这个命令的末尾，指定一个需要用户确认的替换命令。会出现：replace with Line (y/n/a/q/l/^E/^Y)?
    按键          行为
    y           执行替换操作
    n           跳过这个匹配的实例
    a           对这个及随后所有匹配的字符串执行替换操作。
    q or esc    退出替换操作。
    l           执行这次替换并退出。l 是“last”的简写。
    Ctrl-e, Ctrl-y 分别是向下滚动和向上滚动。用于查看建议替换的上下文。

### 13.8 编辑多个文件 ###
#### 13.8.1 文件之间转换 ####
- 从这个文件转到下一个文件，使用这个 ex 命令：
    :n
- 回到先前的文件使用：
    :N
- 我们可以查看正在编辑的文件列表，使用命令：
    :buffers

#### 13.8.2 从一个文件复制内容到另一个文件 ####

#### 13.8.3 插入整个文件到另一个文件 ####
- 把指定的文件插入到光标位置之前
    :r foo.txt

### 13.9 保存工作 ###
- 在命令模式下，输入 ZZ 就会保存并退出当前文件

### 13.10 拓展阅读 ###

## 14 自定制 shell 提示符 ##
### 14.1 解剖一个提示符 ###
- 提示符是由一个环境变量定义的，叫做 PS1（是“prompt string one”的简写）。
- Shell 提示符中用到的转义字符
    序列  显示值
    \a  以 ASCII 格式编码的铃声. 当遇到这个转义序列时，计算机会发出嗡嗡的响声。
    \d  以日，月，天格式来表示当前日期。例如，“Mon May 26.”
    \h  本地机的主机名，但不带末尾的域名。
    \H  完整的主机名。
    \j  运行在当前 shell 会话中的工作数。
    \l  当前终端设备名。
    \n  一个换行符。
    \r  一个回车符。
    \s  shell 程序名。
    \t  以 24 小时制，hours:minutes:seconds 的格式表示当前时间.
    \T  以 12 小时制表示当前时间。
    \@  以 12 小时制，AM/PM 格式来表示当前时间。
    \A  以 24 小时制，hours:minutes 格式表示当前时间。
    \u  当前用户名。
    \v  shell 程序的版本号。
    \V  Version and release numbers of the shell.
    \w  当前工作目录名。
    \W  当前工作目录名的最后部分。
    \!  当前命令的历史号。
    \#  当前 shell 会话中的命令数。
    \$  这会显示一个”$” 字符，除非你拥有超级用户权限。在那种情况下，它会显示一个”#” 字符。
    \[  标志着一系列一个或多个非打印字符的开始。这被用来嵌入非打印的控制字符，这些字符以某种方式来操作终端仿真器，比方说移动光标或者是更改文本颜色。
    \]  标志着非打印字符序列结束。

### 14.2 试试一些可替代的提示符设计 ###
### 14.3 添加颜色 ###
- 用转义序列来设置文本颜色
    序列          文本颜色    序列          文本颜色
    \033[0;30m  黑色      \033[1;30m      深灰色
    \033[0;31m  红色      \033[1;31m      浅红色
    \033[0;32m  绿色      \033[1;32m      浅绿色
    \033[0;33m  棕色      \033[1;33m      黄色
    \033[0;34m  蓝色      \033[1;34m      浅蓝色
    \033[0;35m  粉红      \033[1;35m      浅粉色
    \033[0;36m  青色      \033[1;36m      浅青色
    \033[0;37m  浅灰色    \033[1;37m       白色

- 用转义序列来设置背景颜色
    \033[0;40m  蓝色      \033[1;44m      黑色
    \033[0;41m  红色      \033[1;45m      粉红
    \033[0;42m  绿色      \033[1;46m      青色
    \033[0;43m  棕色      \033[1;47m      浅灰色

### 14.4 移动光标 ###
- 光标移动转义序列
    转义编码            行动
    \033[l;cH       把光标移到第 l 行，第 c 列。
    \033[nA         把光标向上移动 n 行。
    \033[nB         把光标向下移动 n 行。
    \033[nC         把光标向前移动 n 个字符。
    \033[nD         把光标向后移动 n 个字符。
    \033[2J         清空屏幕，把光标移到左上角（第零行，第零列）。
    \033[K          清空从光标位置到当前行末的内容。
    \033[s          存储当前光标位置。
    \033[u          唤醒之前存储的光标位置。

### 14.5 保存提示符 ###
### 14.6 总结归纳 ###
### 14.7 拓展阅读 ###

## 15 软件包管理 ##
### 15.1 打包系统 ###
### 15.2 软件包管理系统是怎样工作的 ###
### 15.3 包文件 ###
### 15.4 资源库 ###
### 15.5 依赖性 ###
### 15.6 上层和底层软件包工具 ###
    发行版                                       底层工具     上层工具
    Debian-Style                                dpkg        apt-get, aptitude
    Fedora, Red Hat Enterprise Linux, CentOS    rpm         yum

### 15.7 常见软件包管理任务 ###
### 15.8 查找资源库中的软件包 ###
    风格          命令
    Debian      apt-get update; apt-cache search search string
    Red Hat     yum search search string

### 15.9 从资源库中安装一个软件包 ###
### 15.10 通过软件包文件来安装软件 ###
    风格              命令
    Debian      dpkg --install package file
    Red Hat     rpm -i package file

### 15.11 卸载软件 ###
    风格          命令
    Debian      apt-get remove package name
    Red Hat     yum erase package name

### 15.12 经过资源库来更新软件包 ###
### 15.13 经过软件包文件来升级软件 ###
    风格          命令
    Debian      dpkg --install package file
    Red Hat     rpm -U package file

- 注意：rpm 程序安装一个软件包和升级一个软件包所用的选项是不同的，而dpkg 程序所用的选项是相同的。

### 15.14 列出所安装的软件包 ###
    风格          命令
    Debian      dpkg --list
    Red Hat     rpm -qa

### 15.15 确定是否安装了一个软件包 ###
    风格          命令
    Debian      dpkg --status package name
    Red Hat     rpm -q package name

### 15.16 显示所安装软件包的信息 ###
    风格          命令
    Debian      apt-cache show package name
    Red Hat     yum info package name

### 15.17 查找安装了某个文件的软件包 ###
    风格          命令
    Debian      dpkg --search file name
    Red Hat     rpm -qf file name

### 15.18 总结归纳 ###
- 缺少驱动程序支持通常是由以下三种情况之一导致：
    1. 设备太新。 因为许多硬件供应商没有积极地支持 Linux 的发展，那么编写内核驱动代码的任务就由一些 Linux 社区来承担，而这需要花费时间。
    2. 设备太奇异。 不是所有的发行版都包含每个可能的设备驱动。每个发行版会建立它们自己的内核，因为内核是可以配置的（这使得从手表到主机的每台设备上运行 Linux 成为可能），这样它们可能会忽略某个特殊设备。通过定位和下载驱动程序的源码，可能需要你自己（是的，由你）来编译和安装驱动。这个过程不是很难，而是参与。
    3. 硬件供应商隐藏信息。 他们既不发布应用于 Linux 系统的驱动程序代码，也不发布技术文档来让某人创建它。这意味着硬件供应商试图保密此设备的程序接口。

### 15.19 拓展阅读 ###

## 16 存储媒介 ##
### 16.1 挂载和卸载存储设备 ###
- /etc/fstab 的文件可以列出系统启动时要挂载的设备（典型地，硬盘分区）。
- /etc/fstab 字段：
    字段  内容      说明
    1   设备名     传统上，这个字段包含与物理设备相关联的设备文件的实际名字，比如说/dev/hda1（第一个 IDE 通道上第一个主设备分区）。许多现代的 Linux 发行版用一个文本标签和设备相关联。
    2   挂载点     设备所连接到的文件系统树的目录。
    3   文件系统类型  Linux 允许挂载许多文件系统类型。
    4   选项      文件系统可以通过各种各样的选项来挂载。
    5   频率      一位数字，指定是否和在什么时间用 dump 命令来备份一个文件系统。
    6   次序      一位数字，指定 fsck 命令按照什么次序来检查文件系统。

### 16.2 查看挂载的文件系统列表 ###
- mount 命令被用来挂载文件系统。列表的格式是：设备 on 挂载点 type 文件系统类型（可选的）。
    e.g.    mount -t iso9660 /dev/hdc /mnt/cdrom
            umount /dev/hdc
- 缓存区允许非常快速地写入存储设备，因为写入物理设备的操作被延迟到后面进行。同时，这些注定要传送到设备中的数据正在内存中堆积起来。时不时地，操作系统会把这些数据写入物理设备。
- 卸载一个设备需要把所有剩余的数据写入这个设备，所以设备可以被安全地移除。如果没有卸载设备，就移除了它，就有可能没有把注定要发送到设备中的数据输送完毕。

### 16.3 确定设备名称 ###
- Linux 存储设备名称
    模式          设备
    /dev/fd*    软盘驱动器
    /dev/hd*    老系统中的 IDE(PATA) 磁盘。典型的主板包含两个 IDE连接器或者是通道，每个连接器带有一根缆线，每根缆线上有两个硬盘驱动器连接点。缆线上的第一个驱动器叫做主设备，第二个叫做从设备。设备名称这样安排，/dev/hdb 是指第一通道上的主设备名；/dev/hdb 是第一通道上的从设备名；/dev/hdc 是第二通道上的主设备名，等等。末尾的数字表示硬盘驱动器上的分区。例如，/dev/hda1 是指系统中第一硬盘驱动器上的第一个分区，而/dev/hda 则是指整个硬盘驱动器。
    /dev/lp*    打印机
    /dev/sd*    SCSI 磁盘。在最近的 Linux 系统中，内核把所有类似于磁盘的设备（包括 PATA/SATA 硬盘，闪存，和 USB 存储设备，比如说可移动的音乐播放器和数码相机）看作 SCSI 磁盘。剩下的命名系统类似于上述所描述的旧的/dev/hd* 命名方案。
    /dev/sr*    光盘（CD/DVD 读取器和烧写器）

- 实时观察系统:
    tail -f /var/log/messages 

### 16.4 创建新的文件系统 ###
- 用 Linux 本地文件系统来重新格式化这个闪存驱动器，而不是它现用的FAT32 系统。
    1.（可选的）创建一个新的分区布局若已存在的分区不是我们喜欢的。
    2. 在这个闪存上创建一个新的空的文件系统。

### 16.5 用 fdisk 命令操作分区 ###
    e.g.    sudo fdisk /dev/sdb

### 16.6 用 mkfs 命令创建一个新的文件系统 ###
    e.g.    sudo mkfs -t ext3 /dev/sdb1

### 16.7 测试和修复文件系统 ###
- 每次系统启动时，在挂载系统之前，都会按照惯例检查文件系统的完整性。这个任务由 fsck 程序（是”filesystem check” 的简写）完成。每个 fstab 项中的最后一个数字指定了设备的检查顺序。在上面的实例中，我们看到首先检查根文件系统，然后是 home 和 boot 文件系统。若最后一个数字是零则相应设备不会被检查。
- fsck 还能修复受损的文件系统，其成功度依赖于损坏的数量。在类 Unix 的文件系统中，文件恢复的部分被放置于 lost+found 目录里面，位于每个文件系统的根目录下面。

### 16.8 格式化软盘 ###
- 分两个步骤:首先，对这张软盘执行低级格式化，然后创建一个文件系统。
- 使用 fdformat 程序完成格式化:
    e.g.    sudo fdformat /dev/fd0
            sudo mkfs -t msdos /dev/fd0

### 16.9 直接把数据移入/出设备 ###
- dd 程序语法:
    dd if=input_file of=output_file [bs=block_size [count=blocks]]
- e.g.
    dd if=/dev/sdb of=/dev/sdc
    dd if=/dev/sdb of=flash_drive.img


### 16.10 创建 CD-ROM 映像 ###
- 两步组成;首先，构建一个 iso 映像文件，这就是一个 CD-ROM 的文件系统映像，第二步，把这个映像文件写入到CD-ROM 媒介中。

#### 16.10.1 创建一个 CD-ROM 的映像拷贝 ####
- 制作一张现有 CD-ROM 的 iso 映像
    e.g.    dd if=/dev/cdrom of=ubuntu.iso
- 这项技术也适用于 DVD 光盘，但是不能用于音频 CD，因为它们不使用文件系统来存储数据。对于音频 CD，看一下 cdrdao 命令。

#### 16.10.2 从文件集合中创建一个映像 ####
- 创建一个包含目录内容的 iso 映像文件
    genisoimage -o cd-rom.iso -R -J ~/cd-rom-files
- “-R” 选项添加元数据为 Rock Ridge 扩展，这允许使用长文件名和 POSIX 风格的文件权限。同样地，这个 “-J” 选项使 Joliet 扩展生效，这样 Windows 中就支持长文件名了。

### 16.11 写入 CD-ROM 镜像 ###
#### 16.11.1 直接挂载一个 ISO 镜像 ####
- 添加 “-o loop” 选项来挂载（同时带有必需的 “-t iso9660” 文件系统类型），挂载这个映像文件就好像它是一台设备，把它连接到文件系统树上：    
    mkdir /mnt/iso_image
    mount -t iso9660 -o loop image.iso /mnt/iso_image

#### 16.11.2 清除一张可重写入的 CD-ROM ####
    wodim dev=/dev/cdrw blank=fast

#### 16.11.3 写入镜像 ####
    wodim dev=/dev/cdrw image.iso
- wodim 命令常见的两个选项是:
    “-v” 可详细输出
    “－ dao” 以 disk-at-once 模式写入光盘。
- wodim 命令的默认模式是 track-at-once，这对于录制音乐很有用。

### 16.12 拓展阅读 ###

### 16.13 友情提示 ###
- 检查完整性：
    md5sum image.iso
- 除了检查下载文件的完整性之外，我们也可以使用 md5sum 程序验证新写入的光学存储介质。

## 17 网络系统 ##
### 17.1 检查和监测网络 ###
#### 17.1.1 ping ####
- ping 命令发送一个特殊的网络数据包，叫做 IMCP ECHO REQUEST

#### 17.1.2 traceroute ####
-  traceroute 程序（一些系统使用相似的 tracepath 程序来代替）会显示从本地到指定主机要经过的所有“跳数”的网络流量列表。

#### 17.1.3 netstat ####
- netstat 程序被用来检查各种各样的网络设置和统计数据。
- 使用“-ie”选项，我们能够查看系统中的网络接口
- “-r”选项会显示内核的网络路由表。
- IP 地址以零结尾是指网络，而不是个人主机

### 17.2 网络中传输文件 ###
#### 17.2.1 ftp ####
- FTP（它的原始形式）并不是安全的，因为它会以明码形式发送帐号的姓名和密码
    ftp fileserver

#### 17.2.2 lftp - 更好的 ftp ####
- 它带有额外的便捷特性，包括多协议支持（包括 HTTP），若下载失败会自动地重新下载，后台处理，用 tab 按键来补全路径名，还有很多。

#### 17.2.3 wget ####
- 不只能下载单个文件，多个文件，甚至整个网站都能下载。这个程序的许多选项允许 wget 递归地下载，在后台下载文件（你退出后仍在下载），能完成未下载全的文件。

### 17.3 与远程主机安全通信 ###
#### 17.3.1 ssh ####
- SSH 由两部分组成。SSH 服务器运行在远端主机上运行，在端口号 22 上监听将要到来的连接，而 SSH 客户端用在本地系统中，用来和远端服务器通信。
- SSH 通道
> 当你通过 SSH 协议与远端主机建立连接的时候，其中发生的事就是在本地与远端系统之间创建了一条加密通道。通常，这条通道被用来把在本地系统中输入的命令安全地传输到远端系统，同样地，再把执行结果安全地发送回来。除了这个基本功能之外，SSH 协议允许大多数网络流量类型通过这条加密通道来被传送，在本地与远端系统之间创建某种 VPN（虚拟专用网络）。

#### 17.3.2 scp 和 sftp ####
- SSH 文件复制命令：scp。源或者目标路径名要以远端主机的名字，后跟一个冒号字符开头。
    scp remote-sys:document.txt .
- SSH 文件复制命令：sftp。使用加密的SSH 通道。sftp 不需要远端系统中运行 FTP服务器。它仅仅要求 SSH 服务器。

### 17.4 拓展阅读 ###

## 18 查找文件 ##
### 18.1 locate - 查找文件的简单方法 ###
- locate 程序快速搜索路径名数据库，并且输出每个与给定字符串相匹配的文件名
- locate 数据库来自何方？
> locate 数据库由另一个叫做 updatedb 的程序创建。通常，这个程序作为一个 cron 工作例程周期性运转；也就是说，一个任务在特定的时间间隔内被 cron 守护进程执行。大多数装有 locate的系统会每隔一天运行一回 updatedb 程序。因为数据库不能被持续地更新，所以当使用 locate 时，你会发现目前最新的文件不会出现。为了克服这个问题，可以手动运行 updatedb 程序，更改为超级用户身份，在提示符下运行 updatedb 命令。

### 18.2 find - 查找文件的复杂方式 ###
#### 18.2.1 Tests ####
- find 文件类型
    文件类型        描述
    b           块设备文件
    c           字符设备文件
    d           目录
    f           普通文件
    l           符号链接

- 额外的测试条件
    e.g.    find ~ -type f -name "\*.JPG" -size +1M | wc -l     查找所有文件名匹配通配符模式“*.JPG”和文件大小大于 1M 的文件

- 需要数值参数的情况下。开头的加号表明我们正在寻找文件大小大于指定数的文件。若字符串以减号开头，则意味着查找小于指定数的文件。
- find 大小单位
    字符      单位
    b       512 个字节块。如果没有指定单位，则这是默认值。
    c       字节
    w       两个字节的字
    k       千字节 (1024 个字节单位)
    M       兆字节 (1048576 个字节单位)
    G       千兆字节 (1073741824 个字节单位)

- find 测试条件
    测试条件                描述
    -cmin n         匹配的文件和目录的内容或属性最后修改时间正好在 n 分钟之前。指定少于 n 分钟之前，使用 -n，指定多于 n 分钟之前，使用 +n。
    -cnewer file    匹配的文件和目录的内容或属性最后修改时间早于那些文件。
    -ctime n        匹配的文件和目录的内容和属性最后修改时间在 n\*24 小时之前。
    -empty          匹配空文件和目录。
    -group name     匹配的文件和目录属于一个组。组可以用组名或组 ID 来表示。
    -iname pattern  就像 -name 测试条件，但是不区分大小写。
    -inum n         匹配的文件的 inode 号是 n。这对于找到某个特殊 inode 的所有硬链接很有帮助。
    -mmin n         匹配的文件或目录的内容被修改于 n 分钟之前。
    -mtime n        匹配的文件或目录的内容被修改于 n\*24 小时之前。
    -name pattern   用指定的通配符模式匹配的文件和目录。
    -newer file     匹配的文件和目录的内容早于指定的文件。当编写 shell 脚本，做文件备份时，非常有帮助。每次你制作一个备份，更新文件（比如说日志），然后使用 find 命令来决定自从上次更新，哪一个文件已经更改了。
    -nouser         匹配的文件和目录不属于一个有效用户。这可以用来查找属于删除帐户的文件或监测攻击行为。
    -nogroup        匹配的文件和目录不属于一个有效的组。
    -perm mode      匹配的文件和目录的权限已经设置为指定的 mode。mode可以用八进制或符号表示法。
    -samefile name  相似于 -inum 测试条件。匹配和文件 name 享有同样 inode号的文件。
    -size n         匹配的文件大小为 n。
    -type c         匹配的文件类型是 c。
    -user name      匹配的文件或目录属于某个用户。这个用户可以通过用户名或用户 ID 来表示。

#### 18.2.2 操作符 ####
- find 命令的逻辑操作符
    操作符     描述
    -and    如果操作符两边的测试条件都是真，则匹配。可以简写为-a。注意若没有使用操作符，则默认使用 -and。
    -or     若操作符两边的任一个测试条件为真，则匹配。可以简写为-o。
    -not    若操作符后面的测试条件是真，则匹配。可以简写为一个感叹号（!）。
    ()      把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。

### 18.3 预定义的操作 ###
- 几个预定义的 find 命令操作
    操作          描述
    -delete     删除当前匹配的文件。
    -ls         对匹配的文件执行等同的 ls -dils 命令。并将结果发送到标准输出。
    -print      把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是默认操作。
    -quit       一旦找到一个匹配，退出。

- 在每个测试和操作之间会默认应用 -and 逻辑运算符

### 18.4 用户定义的行为 ###
- 唤醒随意的命令
    -exec command {} ;
- 通过使用 -ok 行为来代替 -exec，在执行每个指定的命令之前，会提示用户

### 18.5 提高效率 ###
- 通过把 -exec 末尾的分号改为加号，就激活了 find 命令的一个功能，把搜索结果结合为一个参数列表，然后执行一次所期望的命令。

#### 18.5.1 xargs ####
- 执行带有 –show–limits 选项的xargs 命令，来查看命令行的最大值。
- 处理古怪的文件名
> find 命令和 xarg 程序允许可选择的使用一个 null 字符作为参数分隔符。一个 null 字符被定义在 ASCII 码中，由数字零来表示（相反的，例如，空格字符在 ASCII 码中由数字 32 表示）。find 命令提供的 -print0 行为，则会产生由 null 字符分离的输出，并且 xargs 命令有一个 –null 选项，这个选项会接受由 null 字符分离的输入。
    e.g.    find ~ -iname ‘*.jpg’ -print0 | xargs –null ls -l

### 18.6 返回操练场 ###
- touch 命令通常被用来设置或更新文件的访问，更改，和修改时间。
- 注意不同于 ls 命令，find 命令的输出结果是无序的。其顺序由存储设备的布局决定。
- stat 命令会展示系统对某个文件及其属性所知道的所有信息

#### 18.6.1 选项 ####
-  find 命令选项
    选项                      描述
    -depth              指导 find 程序先处理目录中的文件，再处理目录自身。当指定 -delete 行为时，会自动应用这个选项。
    -maxdepth levels    当执行测试条件和行为的时候，设置 find 程序陷入目录树的最大级别数
    -mindepth levels    在应用测试条件和行为之前，设置 find 程序陷入目录数的最小级别数。
    -mount              指导 find 程序不要搜索挂载到其它文件系统上的目录。
    -noleaf             指导 find 程序不要基于搜索类 Unix 的文件系统做出的假设，来优化它的搜索。

### 18.7 拓展阅读 ###

## 19 归档和备份 ##
### 19.1 压缩文件 ###
- 游程编码
- 压缩算法分为两大类，无损压缩和有损压缩。
- 有损压缩的例子有 JPEG（图像）文件和 MP3（音频）文件。

#### 19.1.1 gzip ####
- gzip:原始文件的压缩版会替代原始文件。相对应的 gunzip 程序
- gzip 命令有许多选项
选项 说明
    -c 把输出写入到标准输出，并且保留原始文件。也有可能用--stdout 和 --to-stdout 选项来指定。
    -d 解压缩。正如 gunzip 命令一样。也可以用 --decompress 或者 --uncompress 选项来指定.
    -f 强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用 --force 选项来指定。
    -h 显示用法信息。也可用 --help 选项来指定。
    -l 列出每个被压缩文件的压缩数据。也可用 --list 选项。
    -r 若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用 --recursive 选项来指定。
    -t 测试压缩文件的完整性。也可用 --test 选项来指定。
    -v 显示压缩过程中的信息。也可用 --verbose 选项来指定。
    -number 设置压缩指数。number 是一个在 1（最快，最小压缩）到 9（最慢，最大压缩）之间的整数。数值 1 和 9 也可以各自用 --fast 和 --best 选项来表示。默认值是整数 6。

- 对应于 gzip 还有一个程序，叫做 zcat，它等同于带有 -c 选项的 gunzip 命令。它可以被用来如 cat 命令作用于 gzip 压缩文件
- 还有一个 zless 程序。类似于 zcat foo.txt.gz | less

#### 19.1.2 bzip2 ####
- 与 gzip 程序相似，但是使用了不同的压缩算法，舍弃了压缩速度，而实现了更高的压缩级别。用扩展名.bz2 来表示
- bunzip2 和 bzcat 程序来解压缩文件。
- bzip2 文件也带有 bzip2recover 程序，其会试图恢复受损的.bz2 文件。
- 不要强迫性压缩
> 如果你再次压缩已经压缩过的文件，实际上你会得到一个更大的文件。这是因为所有的压缩技术都会涉及一些开销，文件中会被添加描述此次压缩过程的信息。

### 19.2 归档文件 ###
- 归档就是收集许多文件，并把它们捆绑成一个大文件的过程。归档经常作为系统备份的一部分来使用。当把旧数据从一个系统移到某种类型的长期存储设备中时，也会用到归档程序。

#### 19.2.1 tar ####
- tape archive 的简称，揭示了它的根源，它是一款制作磁带备份的工具。
- tar 模式
    模式      说明
    c       为文件和／或目录列表创建归档文件。
    x       抽取归档文件。
    r       追加具体的路径到归档文件的末尾。
    t       列出归档文件的内容。
- e.g.  tar cf playground.tar playground
- 模式和选项可以写在一起，而且不需要开头的短横线
- 除非你是超级用户，要不然从归档文件中抽取的文件和目录的所有权由执行此复原操作的用户所拥有，而不属于原始所有者。
- GNU 版本的 tar 命令通过 --wildcards 选项来支持通配符。
- tar 命令经常结合 find 命令一起来制作归档文件。
    find playground -name 'file-A' -exec tar rf playground.tar '{}' '+'
- 用“-”来表示标准输入／输出的惯例，也被大量的其它程序使用
- --file-from 选项（也可以用 -T 来指定）导致 tar 命令从一个文件而不是命令行来读入它的路径名列表。
- 把 z 改为 j,并且把输出文件的扩展名改为.tbz，来指示一个bzip2 压缩文件），就使 bzip2 命令压缩生效了。
- tar 命令涉及到在系统之间经过网络传输文件

### 19.2.2 zip ###
- zip 命令：
    zip options zipfile file...
- zip 命令会使用两种存储方法之一，来添加文件到文件包中：
    要不它会“store”没有压缩的文件，正如这里所示
    或者它会“deflate”文件，执行压缩操作。
- 对于 zip 命令（与 tar 命令相反）要注意一点，就是如果指定了一个已经存在的文件包，其被更新而不是被替代。这意味着会保留此文件包，但是会添加新文件，同时替换匹配的文件。
- 可以列出文件或者有选择地从一个 zip 文件包中抽取文件，只要给 unzip 命令指定文件名
- 使用 -l 选项，导致 unzip 命令只是列出文件包中的内容而没有抽取文件。如果没有指定文件，unzip 程序将会列出文件包中的所有文件。添加这个 -v 选项会增加列表的冗余信息。
- 通过 -@ 选项，有可能把一系列的文件名管道到 zip 命令。
    e.g.    find playground -name "file-A" | zip -@ file-A.zip
- zip 命令也支持把它的输出写入到标准输出,unzip 程序，不接受标准输入。
    e.g.    ls -l /etc/ | zip ls-etc.zip -      zip命令把末尾的横杠解释为“使用标准输入作为输入文件。”
- unzip 程序允许它的输出发送到标准输出，当指定了 -p 选项之后

### 19.3 同步文件和目录 ###
- rsync 唤醒
    rsync options source destination
- source 和 destination 是下列选项之一：
    • 一个本地文件或目录
    • 一个远端文件或目录，以 [user@]host:path 的形式存在
    • 一个远端 rsync 服务器，由 rsync://[user@]host[:port]/path 指定
    注意 source 和 destination 两者之一必须是本地文件。
- 选项：
     -a 选项（递归和保护文件属性）
     -v 选项（冗余输出）
     –delete 选项（来删除可能在备份设备中已经存在但却不再存在于源设备中的文件）

#### 19.3.1 在网络间使用 rsync 命令 ####
- rsync 远程复制可以通过两种方法完成
- 第一个方法要求另一个系统已经安装了rsync 程序，还安装了远程 shell 程序，比如 ssh。
    e.g.    sudo rsync -av --delete --rsh=ssh /etc /home /usr/local remote-sys:/backup
            --rsh=ssh 选项，其指示 rsync 使用 ssh 程序作为它的远程 shell。
- 第二种方式是通过使用 rsync 服务器。rsync 可以被配置为一个守护进程，监听即将到来的同步请求。
    e.g.    rsync -av -delete rsync://rsync.gtlib.gatech.edu/fedora-linuxcore/development/i386/os fedora-devel

### 19.4 拓展阅读 ###

## 20 正则表达式 ##
### 20.1 grep ###
- grep 程序
    grep [options] regex [file...]
- grep 选项
    选项  描述
    -i  忽略大小写。不会区分大小写字符。也可用 --ignore-case 来指定。
    -v  不匹配。通常，grep 程序会打印包含匹配项的文本行。这个选项导致 grep 程序只会不包含匹配项的文本行。也可用--invert-match 来指定。
    -c  打印匹配的数量（或者是不匹配的数目，若指定了 -v 选项），而不是文本行本身。也可用 --count 选项来指定。
    -l  打印包含匹配项的文件名，而不是文本行本身，也可用--files-with-matches 选项来指定。
    -L  相似于 -l 选项，但是只是打印不包含匹配项的文件名。也可用 --files-without-match 来指定。
    -n  在每个匹配行之前打印出其位于文件中的相应行号。也可用--line-number 选项来指定。
    -h  应用于多文件搜索，不输出文件名。也可用 --no-filename选项来指定。

### 20.2 元字符和文本 ###

### 20.3 任何字符 ###

### 20.4 锚点 ###
- 在正则表达式中，插入符号和美元符号被看作是锚点。
- 正则表达式‘ˆ$’（行首和行尾之间没有字符）会匹配空行。

### 20.5 中括号表达式和字符类 ###
- 在两种情况下，会在中括号表达式中使用元字符，并且有着不同的含义。
    第一个元字符是插入字符，其被用来表示否定；
    第二个是连字符字符，其被用来表示一个字符区域。

### 20.6 否定 ###
- 这个插入字符如果是中括号表达式中的第一个字符的时候，才会唤醒否定功能；否则，它会失去它的特殊含义，变成字符集中的一个普通字符。

### 20.7 传统的字符区域 ###

### 20.8 POSIX 字符集 ###
- POSIX 字符集:
    字符集         说明
    [:alnum:]   字母数字字符。在 ASCII 中，等价于：[A-Za-z0-9]
    [:word:]    与 [:alnum:] 相同, 但增加了下划线字符。
    [:alpha:]   字母字符。在 ASCII 中，等价于：[A-Za-z]
    [:blank:]   包含空格和 tab 字符。
    [:cntrl:]   ASCII 的控制码。包含了 0 到 31，和 127 的 ASCII 字符。
    [:digit:]   数字 0 到 9
    [:graph:]   可视字符。在 ASCII 中，它包含 33 到 126 的字符。
    [:lower:]   小写字母。
    [:punct:]   标点符号字符。在 ASCII 中，等价于：
    [:print:]   可打印的字符。在 [:graph:] 中的所有字符，再加上空格字符。
    [:space:]   空白字符，包括空格，tab，回车，换行，vertical tab, 和 form feed. 在 ASCII 中，等价于：[ \t\r\n\v\f]
    [:upper:]   大写字母。
    [:xdigit:]  用来表示十六进制数字的字符。在 ASCII 中，等价于：[0-9A-Fa-f]

- 恢复到传统的排列顺序
    使用 locale 命令，来查看 locale 的设置。
    把这个 LANG 变量设置为 POSIX，来更改 locale，使其使用传统的 Unix 行为。

### 20.9 POSIX 基本的 Vs. 扩展的正则表达式 ###
- POSIX 把正则表达式的实现分成了两类：基本正则表达式（BRE）和扩展的正则表达式（ERE）。
- BRE 和 ERE 之间区别关于元字符：
    BRE 可以辨别以下元字符：      ^ $ . [ ] *
    ERE 添加了以下元字符:       ( ) { } ? + |

- 对于ERE ，egrep 程序来执行这项操作，但是 GUN 版本的 grep 程序也支持扩展的正则表达式，当使用了 -E 选项之后。
- “POSIX”这个名字，象征着可移植的操作系统接口

### 20.10 Alternation ###
- 扩展表达式的第一个特性：alternation（交替）是一款允许从一系列表达式之间选择匹配项的实用程序。
- 为了把 alternation 和其它正则表达式元素结合起来，我们可以使用 () 来分离 alternation。
    e.g.    grep -Eh '^(bz|gz|zip)' dirlist*.txt

### 20.11 限定符 ###
#### 20.11.1 ? - 匹配零个或一个元素 ####

### 20.12 * - 匹配零个或多个元素 ###
#### 20.12.1 + - 匹配一个或多个元素 ####
- 这个正则表达式只匹配那些由一个或多个字母字符组构成的文本行，字母字符之间由**单**个空格分开
    e.g.    echo "abc d" | grep -E '^([[:alpha:]]+ ?)+$'    空

#### 20.12.2 { } - 匹配特定个数的元素 ####
- 指定匹配的数目
    限定符         意思
    n           匹配前面的元素，如果它确切地出现了 n 次。
    n,m         匹配前面的元素，如果它至少出现了 n 次，但是不多于 m次。
    n,          匹配前面的元素，如果它出现了 n 次或多于 n 次。
    ,m          匹配前面的元素，如果它出现的次数不多于 m 次。

### 20.13 让正则表达式工作起来 ###
#### 20.13.1 通过 grep 命令来验证一个电话簿 ####
- 使用 -v 选项来产生相反的匹配

#### 20.13.2 用 find 查找丑陋的文件名 ####
- 发现包含空格和其它潜在不规范字符的路径名：
    e.g.    find . -regex '.*[^-\_./0-9a-zA-Z].*'

#### 20.13.3 用 locate 查找文件 ####
- 这个 locate 程序支持基本的（--regexp 选项）和扩展的（--regex 选项）正则表达式。

#### 20.13.4 在 less 和 vim 中查找文本 ####

### 20.14 总结归纳 ###

### 20.15 拓展阅读 ###

## 21 文本处理 ##
### 21.1 文本应用程序 ###
#### 21.1.1 文档 ####
#### 21.1.1 文档 ####
#### 21.1.3 电子邮件 ####
#### 21.1.4 打印输出 ####
#### 21.1.5 程序源码 ####

### 21.2 回顾一些老朋友 ###
#### 21.2.1 cat ####
- -A 选项，其用来在文本中显示非打印字符。
- MS-DOS 文本 Vs. Unix 文本
> Unix 和 DOS 在文本文件中定义每行结束的方式不相同。Unix 通过一个换行符（ASCII 10）来结束一行，然而 MS-DOS 和它的衍生品使用回车（ASCII 13）和换行字符序列来终止每个文本行。
> dos2unix 和 unix2dos
- cat 程序也包含用来修改文本的选项。最著名的两个选项是 -n，其给文本行添加行号和 -s，禁止输出多个空白行。

#### 21.2.2 sort ####
- sort 程序能接受命令行中的多个文件作为参数，所以有可能把多个文件合并成一个有序的文件。
    e.g.    sort file1.txt file2.txt file3.txt > final_sorted_list.txt
- 常见的 sort 程序选项
    选项  长选项                         描述
    -b  --ignore-leading-blanks     默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致 sort 程序忽略每行开头的空格，从第一个非空白字符开始排序。
    -f  --ignore-case               让排序不区分大小写。
    -n  --numeric-sort              基于字符串的长度来排序。使用此选项允许根据数字值执行排序，而不是字母值。
    -r  --reverse                   按相反顺序排序。结果按照降序排列，而不是升序。
    -k  --key=field1[,field2]       对从 field1 到 field2 之间的字符排序，而不是整个文本行。看下面的讨论。
    -m  --merge                     把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排好序的文件，而没有执行额外的排序。
    -o  --output=file               把排好序的输出结果发送到文件，而不是标准输出。
    -t  --field-separator=char      定义域分隔字符。默认情况下，域由空格或制表符分隔。
- tab 字符经常由ˆI 字符来表示。
- e.g.  -k 3.7      其始于第三个字段中的第七个字符

#### 21.2.3 uniq ####
- 当给定一个**排好序**的文件（包括标准输出），uniq 会删除任意重复行，并且把结果发送到标准输出。它常常和 sort 程序一块使用，来清理重复的输出。
- 因为 uniq 只会删除相邻的重复行。
- uniq 程序有几个选项。这里是一些常用选项：
    选项      说明
    -c      输出所有的重复行，并且每行开头显示重复的次数。
    -d      只输出重复行，而不是特有的文本行。
    -f n    忽略每行开头的 n 个字段，字段之间由空格分隔，正如 sort程序中的空格分隔符；然而，不同于 sort 程序，uniq 没有选项来设置备用的字段分隔符。
    -i      在比较文本行的时候忽略大小写。
    -s n    跳过（忽略）每行开头的 n 个字符。
    -u      只是输出独有的文本行。这是默认的。

### 21.3 切片和切块 ###
#### 21.3.1 cut ####
- cut 程序被用来从文本行中抽取文本，并把其输出到标准输出。
- cut 程序选择项
    选项              说明
    -c char list    从文本行中抽取由 char list 定义的文本。这个列表可能由一个或多个逗号分隔开的数值区间组成。
    -f field list   从文本行中抽取一个或多个由 field list 定义的字段。这个列表可能包括一个或多个字段，或由逗号分隔开的字段区间。
    -d delim char   当指定 -f 选项之后，使用 delim char 做为字段分隔符。默认情况下，字段之间必须由单个 tab 字符分隔开。
    --complement    抽取整个文本行，除了那些由 -c 和／或 -f 选项指定的文本。
- e.g.  cut -f 3 distros.txt | cut -c 7-10  可以抽取年份
    SUSE^I10.2^I12/07/2006$
    Fedora^I10^I11/25/2008$
    SUSE^I11.0^I06/19/2008$
    Ubuntu^I8.04^I04/24/2008$
    Fedora^I8^I11/08/2007$

- 展开 Tabs
> 如果我们想要cut程序按照字符，而不是字段来操作一个文件，这要求我们用相应数目的空格来代替 tab 字符。GNU 的 Coreutils 软件包有一个工具来解决这个问题。这个程序名为 expand，它既可以接受一个或多个文件参数，也可以接受标准输入，并且把修改过的文本送到标准输出。Coreutils 软件包也提供了 unexpand 程序，用 tab 来代替空格。
    e.g.    expand distros.txt | cut -c 23-

#### 21.3.2 paste ####
- paste 命令通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。

#### 21.3.3 join ####
- join 命令类似于 paste，它会往文件中添加列
- 一个 join 操作通常与关系型数据库有关联，在关系型数据库中来自多个享有共同关键域的表格的数据结合起来，得到一个期望的结果。这个 join 程序执行相同的操作。它把来自于多个基于共享关键域的文件的数据结合起来。
- 有必要指出，为了使 join命令能正常工作，所有文件必须按照关键数据域排序。
- 默认情况下，join 命令使用空白字符做为输入字段的界定符，一个空格作为输出字段的界定符。这种行为可以通过指定的选项来修改。

### 21.4 比较文本 ###
#### 21.4.1 comm ####
- comm 程序会比较两个文本文件，并且会显示每个文件特有的文本行和共有的文把行。
- comm 命令产生了三列输出。第一列包含第一个文件独有的文本行；第二列，文本行是第二列独有的；第三列包含两个文件共有的文本行。
- comm 支持 -n 形式的选项，这里 n 代表 1，2 或 3。这些选项使用的时候，指定了要隐藏的列。

#### 21.4.2 diff ####
- diff 能够递归地检查源码目录，经常称之为源码树。
- diff 程序的一个常见用例是创建 diff 文件或者补丁，它会被其它程序使用
- 在默认格式中，每组的更改之前都是一个更改命令，其形式为 range operation range ，用来描述要求更改的位置和类型，从而把第一个文件转变为第二个文件：
    改变          说明
    r1ar2   把第二个文件中位置 r2 处的文件行添加到第一个文件中的r1 处。
    r1cr2   用第二个文件中位置 r2 处的文本行更改（替代）位置 r1 处的文本行。
    r1dr2   删除第一个文件中位置 r1 处的文本行，这些文本行将会出现在第二个文件中位置 r2 处。
- 在这种格式中，一个范围就是由逗号分隔开的开头行和结束行的列表。虽然这种格式是默认情况，但是它并不像其它可选格式一样被广泛地使用。

- 最流行的两种格式是上下文模式和统一模式。
- 使用上下文模式（带上 -c 选项）：
- diff 上下文模式更改指示符
    指示符         意思
    blank       上下文显示行。它并不表示两个文件之间的差异。
    -           删除行。这一行将会出现在第一个文件中，而不是第二个文件内。
    +           添加行。这一行将会出现在第二个文件内，而不是第一个文件中。
    !           更改行。将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分。

- 统一模式相似于上下文模式，但是更加简洁。通过 -u 选项来指定它
- diff 统一模式更改指示符：
    字符          意思
    空格      两个文件都包含这一行。
    -        在第一个文件中删除这一行。
    +         添加这一行到第一个文件中。

#### 21.4.3 patch ####
- 使用 diff/patch 组合提供了两个重大优点：
    1. 一个 diff 文件非常小，与整个源码树的大小相比较而言。
    2. 一个 diff 文件简洁地显示了所做的修改，从而允许程序补丁的审阅者能快速地评估它。
- 建议这样使用diff：
    diff -Naur old_file new_file > diff_file
- 把旧文件修补成新文件:
    patch < diff_file

### 21.5 运行时编辑 ###
#### 21.5.1 tr ####
- tr 程序被用来更改字符。
    e.g.    echo "lowercase letters" | tr a-z A-Z
- tr 命令接受两个参数：要被转换的字符集以及相对应的转换后的字符集。字符集可以用三种方式来表示：
    1. 一个枚举列表。例如，ABCDEFGHIJKLMNOPQRSTUVWXYZ
    2. 一个字符域。例如，A-Z 。注意这种方法有时候面临与其它命令相同的问题，归因于语系的排序规则，因此应该谨慎使用。
    3. POSIX 字符类。例如，[:upper:]
- tr 命令能允许字符从输入流中简单地被删除。
    e.g.    tr -d '\r' < dos_file > unix_file

- ROT13
> ROT13 是一款微不足道的基于一种简易的替换暗码的加密类型。有时候它被用来隐藏文本中潜在的攻击内容。这个方法就是简单地把每个字符在字母表中向前移动 13 位。因为移动的位数是可能的 26 个字符的一半，所以对文本再次执行这个算法，就恢复到了它最初的形式。
    e.g.    echo “secret text” tr a-zA-Z n-za-mN-ZA-M
- tr 也可以完成另一个技巧。使用 -s 选项，tr 命令能“挤压”（删除）重复的字符
    e.g.    echo "aaabbbccc" | tr -s ab     abccc
- 注意重复的字符必须是相邻的。

#### 21.5.2 sed ####
- sed 是 stream editor（流编辑器）的简称。它对文本流进行编辑，要不是一系列指定的文件，要不就是标准输入。
- sed 的工作方式是要不给出单个编辑命令（在命令行中）要不就是包含多个命令的脚本文件名，然后它就按行来执行这些命令。
- sed 将会接受紧随命令之后的任意字符做为分隔符。
    e.g.    $ echo "front" | sed 's\_front\_back\_'     下划线字符变成界定符

- sed 中的大多数命令之前都会带有一个地址，其指定了输入流中要被编辑的文本行。如果省略了地址，然后会对输入流的每一行执行编辑命令。
- sed 地址表示法:
    地址          说明
    n           行号，n 是一个正整数。
    $           最后一行。
    /regexp/    所有匹配一个 POSIX 基本正则表达式的文本行。注意正则表达式通过斜杠字符界定。选择性地，这个正则表达式可能由一个备用字符界定，通过\cregexpc 来指定表达式，这里c 就是一个备用的字符。
    addr1,addr2 从 addr1 到 addr2 范围内的文本行，包含地址 addr2 在内。地址可能是上述任意单独的地址形式。
    first˜step  匹配由数字 first 代表的文本行，然后随后的每个在 step 间隔处的文本行。
    addr1,+n    匹配地址 addr1 和随后的 n 个文本行。
    addr!       匹配所有的文本行，除了 addr 之外，addr 可能是上述任意的地址形式。

- sed 基本编辑命令:
    命令                          说明
    =                       输出当前的行号。
    a                       在当前行之后追加文本。
    d                       删除当前行。
    i                       在当前行之前插入文本。
    p                       打印当前行。默认情况下，sed 程序打印每一行，并且只是编辑文件中匹配指定地址的文本行。通过指定 -n 选项，这个默认的行为能够被忽略。
    q                       退出 sed，不再处理更多的文本行。如果不指定 -n 选项，输出当前行。
    Q                       退出 sed，不再处理更多的文本行。
    s/regexp/replacement/   只要找到一个 regexp 匹配项，就替换为 replacement 的内容。replacement 可能包括特殊字符 &，其等价于由 regexp匹配的文本。另外，replacement 可能包含序列 \1 到 \9，其是 regexp 中相对应的子表达式的内容。在 replacement             末尾的斜杠之后，可以指定一个可选的标志，来修改 s 命令的行为。
    y/set1/set2             执行字符转写操作，通过把 set1 中的字符转变为相对应的set2 中的字符。注意不同于 tr 程序，sed 要求两个字符集合具有相同的长度。

- 一个正则表达式的新功能，它出现在一些使用 BRE 的应用程序中。这个功能叫做 逆参照，像这样工作：如果序列\n 出现在 replacement 中，这里 n 是指从 1 到 9 的数字，则这个序列指的是在前面正则表达式中相对应的子表达式。为了创建这个子表达式，我们简单地把它们用圆括号括起来

- e.g. 修改日期格式
    sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/' distros.txt
    原始:
    Ubuntu 8.04 04/24/2008
    Fedora 8 11/08/2007
    目标:
    Ubuntu 8.04 2008-04-24
    Fedora 8 2007-11-08

- s 命令的另一个功能是使用可选标志，其跟随替代字符串。一个最重要的可选标志是 g 标志，其指示 sed 对某个文本行全范围地执行查找和替代操作，不仅仅是对第一个实例，这是默认行为。
    e.g.    echo "aaabbbccc" | sed 's/b/B/g'        aaaBBBccc

- 使用 -f 选项，也有可能在一个脚本文件中构建更加复杂的命令。把 sed 脚本保存为 .sed 文件，然后像这样运行它：
    e.g.    sed -f distros.sed distros.txt

- 反斜杠回车符，来产生一个转义的回车符，或者就是所谓的连行符。这个序列能够被用在许多环境下，包括 shell 脚本，从而允许把回车符嵌入到文本流中，而没有通知解释器（在这是指 sed 解释器）已经到达了文本行的末尾。

> perl，经常被用来代替 shell 脚本，来完成许多系统管理任务，同时它也是一款非常流行网络开发语言。awk 更专用一些。其具体优点是其操作表格数据的能力。awk 程序通常逐行处理文本文件

#### 21.5.3 aspell ####
-  aspell,一款交互式的拼写检查器,够智能地检查各种类型的文本文件，包括 HTML 文件，C/C++ 程序，电子邮件和其它种类的专业文本。
    e.g.    aspell check textfile
- aspell会创建一个包含原始文本的备份文件。除非使用命令行选项 --dont-backup 
- 通过包含 -H（HTML）检查模式选项,解决HTML 标志的内容问题。在这种模式下，HTML 标志的内容被忽略了，不会进行拼写检查。然而，ALT 标志的内容，会被检查。
- 注意：默认情况下，aspell 会忽略文本中 URL 和电子邮件地址。通过命令行选项，可以重写此行为。也有可能指定哪些标志进行检查及跳过。

### 21.6 总结归纳 ###

### 21.7 拓展阅读 ###

### 21.8 友情提示 ###
- split（把文件分割成碎片）
- csplit（基于上下文把文件分割成碎片）
- sdiff（并排合并文件差异）。

## 22 格式化输出 ##
### 22.1 简单的格式化工具 ###
#### 22.1.1 nl - 添加行号 ####
- 它添加文件的行数。在它最简单的用途中，它相当于 cat -n
- nl 有一个相当数量的选项并支持一个简单的标记方式去允许更多复杂的方式的计算。
- nl 在计算文件行数的时候支持一个叫“逻辑页面”的概念。用到那些选项的时候，可以设置一个特殊的开始值，并且在某个可限定的程度上还能设置它的格式。一个逻辑页面被进一步分为 header,body 和 footer 这样的元素。在每一个部分中，数行数可以被重设，并且/或被设置成另外一个格式。如果 nl 同时处理多个文件，它会把他们当成一个单一的文本流。文本流中的部分被一些相当古怪的标记的存在加进了文本。每一个上述的标记元素肯定在自己的行中独自出现。在处理完一个标记元素之后，nl 把它从文本流中删除。
- 常用 nl 选项：
    选项          含义
    -b style    把 body 按被要求方式数行，可以是以下方式：
                a = 数所有行
                t = 数非空行。这是默认设置。
                n = 无
                pregexp = 只数那些匹配了正则表达式的行
    -f style    将 footer 按被要求设置数。默认是无
    -h style    将 header 按被要求设置数。默认是
    -i number   将页面增加量设置为数字。默认是一。
    -n format   设置数数的格式，格式可以是：
                ln = 左偏，没有前导零。
                rn = 右偏，没有前导零。
                rz = 右偏，有前导零。
    -p          不要在没一个逻辑页面的开始重设页面数。
    -s string   在没一个行的末尾加字符作分割符号。默认是单个的 tab。
    -v number   将每一个逻辑页面的第一行设置成数字。默认是一。
    -w width    将行数的宽度设置，默认是六。

#### 22.1.2 fold - 限制文件行宽 ####
- fold 接受一个或多个文件及标准输入
- 可用用 -w 选项分解成块。
    e.g.    echo "The quick brown fox jumped over the lazy dog." | fold -w 12 -s
- 如果没有字符设置，默认是 80。
- 注意到文本行不会因为单词边界而不会被分解。增加的 -s 选项将让 fold 分解到最后可用的空白字符，即会考虑单词边界。

#### 22.1.3 fmt - 一个简单的文本格式器 ####
- 它接受文本或标准输入并且在文本流上呈现照片转换。基础来说，他填补并且将文本粘帖在一起并且保留了空白符和缩进。
- 默认来说，空白行，单词间距，还有缩进都会在输出中保留；
- 持续输入不同的缩进的流不会被结合；
- tabs 被用来扩展输入并且引入输出。
- -c 选项，去除缩进等；
- -p 选项，可以格式文件选中的部分，通过在开头使用一样的符号。

## 23 打印 ##
### 23.1 打印简史 ###
#### 23.1.1 早期的打印 ####
#### 23.1.2 基于字符的打印机 ####
- 菊轮式打印和点阵式打印。
- 80 年代的打印机技术有两方面的不同:
    那时的打印机基本上都是打击式打印机。
    早期打印机的特点是它使用设备内部固定的一组字符集。

#### 23.1.3 图形化打印机 ####
- 从基于字符的方式到转移到图形化的方式提出了一个严峻的技术挑战：许多慢速的个人电脑网络无法接受激光打印机打印一页需要传输将近 1 兆的数据
- 页面描述语言（PDL）：PDL 是一种描述页面内容的编程语言。简单的说就是，“到这个地方，印一个 10 点大小的黑体字符 a ，到这个地方。。。”这样直到页面上的所有内容都描述完了。
- 第一种主要的 PDL 是 Adobe 系统开发的 PostScript
- 打印机有自己的处理器和内存（通常这让打印机比连接它的计算机更为强大），能执行一种叫做 PostScript 解析器的特殊程序用于读取输入的 PostScript 程序并生成结果导入打印机的内存，这样就形成了要转移到纸上的位（点）图。这种将页面渲染成大型位图（bitmap）的过程有个通用名称作光栅图像处理器（raster image processor），又叫 RIP。

### 3.2 在 Linux 下打印 ###
- 当前 Linux 系统采用两套软件配合显示和管理打印
    第一，CUPS（Common Unix Printing System，一般 Unix 打印系统），用于提供打印驱动和打印任务管理；
    第二，Ghostscript，一种 PostScript 解析器，作为 RIP 使用。

### 23.3 为打印准备文件 ###
#### 23.3.1 pr - 转换需要打印的文本文件 ####
- pr 命令则能够根据不同的页眉和页边距排列文本使其适应指定的纸张。
- 常用 pr 选项
    选项                  描述
    +first[:last]       输出从 first 到 last（默认为最后）范围内的页面。
    -columns            根据 columns 指定的列数排版页面内容。
    -a                  默认多列输出为垂直，用 -a (across) 可使其水平输出。
    -d                  双空格输出。
    -D format           用 format 指定的格式修改页眉中显示的日期，日期命令中format 字符串的描述详见参考手册。
    -f                  改用换页替换默认的回车来分割页面。
    -h header           在页眉中部用 header 参数替换打印文件的名字。
    -l length           设置页长为 length，默认为 66 行（每英寸 6 行的美国信纸）。
    -n                  输出行号。
    -o offset           创建一个宽 offset 字符的左页边。
    -w width            设置页宽为 width，默认为 72 字符。

### 23.4 将打印任务送至打印机 ###
- CUPS 打印体系支持两种曾用于类 Unix 系统的打印方式。一种，叫 Berkeley 或 LPD（用于 Unix 的 Berkeley 软件发行版），使用 lpr 程序；另一种，叫 SysV（源自 System V 版本的Unix），使用 lp 程序。

#### 23.4.1 lpr - 打印文件（Berkeley 风格） ####
- 由于它能接收标准输入，所以能用管道来协同工作。
- 常用 lpr 选项：
    选项              描述
    -# number   设定打印份数为 number。
    -p          使每页页眉标题中带有日期、时间、工作名称和页码。这种所谓的“美化打印”选项可用于打印文本文件。
    -P printer  指定输出打印机的名称。未指定则使用系统默认打印机。
    -r          打印后删除文件。对程序产生的临时打印文件较为有用。

#### 23.4.2 lp - 打印文件（System V 风格） ####
- lp 可以接收文件或标准输入为打印内容。与 lpr 不同的是 lp 支持不同的选项（略为复杂）
- 常用 lp 选项
        选项                              描述
    -d printer              设定目标（打印机）为 printer。若 d 选项未指定，则使用系统默认打印机。
    -n number               设定的打印份数为 number。
    -o landscape            设置输出为横向。
    -o fitplot              缩放文件以适应页面。打印图像时较为有用，如 JPEG 文件。
    -o scaling=number       缩放文件至 number。100 表示填满页面，小于100 表示缩小，大于 100 则会打印在多页上。
    -o cpi=number           设定输出为 number 字符每英寸。默认为 10。
    -o lpi=number           设定输出为 number 行每英寸，默认为 6。
    -o page-bottom=points   设置页边距，单位为点，一种印刷上的单位。一英寸 =72 点。
    -o page-left=points
    -o page-right=points
    -o page-top=points
    -P pages                指定打印的页面。pages 可以是逗号分隔的列表或范围——例如 1,3,5,7-10。

#### 23.4.3 另一种选择：a2ps ####
- a2ps，ASCII to PostScript，它是用来为 PostScript 打印机准备要打印的文本文件的；后来变成Anything to PostScript。它实际的功能却是打印。它的默认输出不是标准输出，而是系统的默认打印机。它可以改善输出的外观。
- a2ps 选项：
        选项                  描述
    --center-title text     设置中心页标题为 text。
    --columns number        将所有页面排列成 number 列。默认为 2。
    --footer text           设置页脚为 text。
    --guess                 报告参数中文件的类型。由于 a2ps 会转换并格式化所有类型的数据，所以当给定文件类型后，这个选项可以很好的用来判断 a2ps 应该做什么。
    --left-footer text      设置左页脚为 text。
    --left-title text       设置页面左标题为 text。
    --line-numbers=interval 每隔 interval 行输出行号。
    --list=defauls          显示默认设置。
    --list=topic            显示 topic 设置，topic 表示下列之一：代理程序（用来转换数据的外部程序），编码，特征，变量，媒介（页面大小等），ppd（PostScript 打印机描述信息），打印机，起始程序（为常规输出添加前缀的代码部分），样式表，或用户选项。
    --pages range           打印 range 范围内的页面。
    --right-footer text     设置右页脚为 text。
    --right-title text      设置页面右标题为 text。
    --rows number           将所有页面排列成 number 排。默认为 1。
    -B                      没有页眉。
    -b text                 设置页眉为 text。
    -f size                 使用字体大小为 size 号。
    -l number               设置每行字符数为 number。此项和 -L 选项可以给文件用其他程序来更准确的分页，如 pr。
    -L number               设置每页行数为 number。
    -M name                 使用打印媒介的名称——例如，A4。
    -n number               每页输出 number 份。
    -o file                 输出到文件 file。如果指定为 - ，则输出到标准输出。
    -P printer              使用打印机 printer。如果未指定，则使用系统默认打印机。
    -R                      纵向打印。
    -r                      横向打印。
    -T number               设置制表位为每 number 字符。
    -u text                 用 text 作为页面底图（水印）。

- 另一个转换文本为 PostScript 的输出格式化工具，名叫 enscript。它具有许多相同的格式化和打印功能，但和 a2ps 唯一的不同在于，它只能处理纯文本的输入。

### 23.5 监视和控制打印任务 ###
#### 23.5.1 lpstat - 显示打印系统状态 ####
- 常用 lpstat 选项
        选项              描述
    -a [printer...]     显示 printer 打印机的队列。这里显示的状态是打印机队列承受任务的能力，而不是实体打印机的状态。若未指定打印机，则显示所有打印队列。
    -d                  显示系统默认打印机的名称。
    -p [printer...]     显示 printer 指定的打印机的状态。若未指定打印机，则显示所有打印机状态。
    -r                  显示打印系统的状态。
    -s                  显示汇总状态。
    -t                  显示完整状态报告。

#### 23.5.2 lpq - 显示打印机队列状态 ####
- 使用 lpq 程序从中我们可以看到队列的状态和所包含的打印任务。

#### 23.5.3 lprm 和 cancel - 取消打印任务 ####
- CUPS 提供两个程序来从打印队列中终止并移除打印任务。一个是 Berkeley 风格的（lprm），另一个是 System V 的（cancel）。

## 24 编译程序 ##
### 24.1 什么是编译？ ###
#### 24.1.1 所有的程序都是可编译的吗？ ####
- 为什么解释型程序这样流行呢？对于许多编程任务来说，原因是“足够快”，但是真正的优势是一般来说开发解释型程序要比编译程序快速且容易。

### 24.2 编译一个 C 语言 ###
#### 24.2.1 得到源码 ####
- 由你的系统发行版源码会把源码安装在/usr/src 目录下，而供多个用户使用的源码，通常安装在/usr/local/src 目录下。

### 24.3 检查源码树 ###
#### 24.3.1 构建程序 ####
#### 24.3.2 安装程序 ####
- 打包良好的源码经常包括一个特别的 make 目标文件，叫做 install。这个目标文件将在系统目录中安装最终的产品，以供使用。通常，这个目录是/usr/local/bin，为在本地所构建软件的传统安装位置。通常普通用户不能写入该目录，所以我们必须变成超级用户

### 24.4 总结 ###
### 24.5 拓展阅读 ###

## 25 编写第一个 Shell 脚本 ##
### 25.1 什么是 Shell 脚本？ ###
### 25.2 怎样编写一个 Shell 脚本 ###
### 25.3 脚本文件格式 ###
-  #! 字符序列是一种特殊的结构叫做 shebang。这个 shebang 被用来告诉操作系统将执行此脚本所用的解释器的名字。

### 25.4 可执行权限 ###
- 有两个常见的权限设置：
    权限为 755 的脚本，则每个人都能执行，和权限为 700 的脚本，只有文件所有者能够执行。

### 25.5 脚本文件位置 ###
- Q：为什么没有指定脚本文件明确的路径，直接执行会提示command not found？
- A：会自动在目录列表 $PATH 下搜索

#### 25.5.1 脚本文件的好去处 ####
- 系统中的每个用户都可以使用它，那么这个脚本的传统位置是/usr/local/bin。
- 系统管理员使用的脚本经常放到/usr/local/sbin 目录下。
- 大多数情况下，本地支持的软件，不管是脚本还是编译过的程序，都应该放到/usr/local 目录下

### 25.6 更多的格式技巧 ###
#### 25.6.1 长选项名称 ####
- 当在命令行中输入选项的时候，短选项更受欢迎，但是当书写脚本的时候，长选项能提供可读性。

#### 25.6.1 长选项名称 ####
- 通过使用行继续符（反斜杠 -回车符序列）和缩进，这个复杂命令的逻辑性更清楚地描述给读者。
- 脚本和命令行的一个区别是，脚本可能雇佣 tab 字符拉实现缩进，然而命令行却不能，因为tab 字符被用来激活自动补全功能。

### 25.7 总结归纳 ###
### 25.8 拓展阅读 ###

## 26 启动一个项目 ##
### 26.1 第一阶段：最小的文档 ###
### 26.2 第二阶段：添加一点儿数据 ###
### 26.3 变量和常量 ###
- shell 确实提供了一种方法，通过使用带有 -r （只读）选项的内部命令declare，来强制常量的不变性。

#### 26.3.1 给变量和常量赋值 ####

### 26.4 Here Documents ###
- here document 是另外一种 I/O 重定向形式，它这样工作：
    command << token
    text
    token
- 使用一个 here document 的优点：
    除了默认情况下，here documents 中的单引号和双引号会失去它们在 shell 中的特殊含义。
- Here documents 可以和任意能接受标准输入的命令一块使用
- 如果我们把重定向操作符从“<<”改为“<<-”，shell 会忽略在此 here document 中开头的 tab 字符。这就能缩进一个 here document，从而提高脚本的可读性

### 26.5 总结归纳 ###
### 26.6 拓展阅读 ###

## 27 自顶向下设计 ##
### 27.1 Shell 函数 ###
- Shell 函数的命名规则和变量一样。一个函数必须至少包含一条命令。这条 return 命令（是可选的）满足要求。

### 27.2 局部变量 ###
### 27.3 保持脚本运行 ###
### 27.4 总结归纳 ###
### 27.5 拓展阅读 ###

## 28 流程控制：if 分支结构 ##
### 28.1 if ###
### 28.2 退出状态 ###
- 这个值是一个 0 到 255 之间的整数，说明命令执行成功或是失败。

### 28.3 测试 ###
#### 28.3.1 文件表达式 ####
### 28.3 测试 ###
- test 命令执行各种各样的检查与比较。它有两种等价模式：
    test expression
    [ expression ]
- 当表达式为假时，test 命令退出状态为 1。

#### 28.3.1 文件表达式 ####
- 测试文件表达式
    表达式                 如果为真
    file1 -ef file2     file1 和 file2 拥有相同的索引号（通过硬链接两个文件名指向相同的文件）。
    file1 -nt file2     file1 新于 file2。
    file1 -ot file2     file1 早于 file2。
    -b file             file 存在并且是一个块（设备）文件。
    -c file             file 存在并且是一个字符（设备）文件。
    -d file             file 存在并且是一个目录。
    -e file             file 存在。
    -f file             file 存在并且是一个普通文件。
    -g file             file 存在并且设置了组 ID。
    -G file             file 存在并且由有效组 ID 拥有。
    -k file             file 存在并且设置了它的“sticky bit”。
    -L file             file 存在并且是一个符号链接。
    -O file             file 存在并且由有效用户 ID 拥有。
    -p file             file 存在并且是一个命名管道。
    -r file             file 存在并且可读（有效用户有可读权限）。
    -s file             file 存在且其长度大于零。
    -S file             file 存在且是一个网络 socket。
    -t fd               fd 是一个定向到终端／从终端定向的文件描述符。这可以被用来决定是否重定向了标准输入／输出错误。
    -u file             file 存在并且设置了 setuid 位。
    -w file             file 存在并且可写（有效用户拥有可写权限）。
    -x file             file 存在并且可执行（有效用户有执行／搜索权限）。

- 注意：在表达式中参数 $FILE 是怎样被引用的。引号并不是必需的，但这是为了防范空参数。如果 $FILE 的参数展开是一个空值，就会导致一个错误（操作符将会被解释为非空的字符串而不是操作符）。用引号把参数引起来就确保了操作符之后总是跟随着一个字符串，即使字符串为空。
- 注意：脚本末尾的 exit 命令。这个 exit 命令接受一个单独的，可选的参数，其成为脚本的退出状态。当不传递参数时，退出状态默认为零。以这种方式使用 exit 命令，则允许此脚本提示失败如果 $FILE 展开成一个不存在的文件名。

#### 28.3.2 字符串表达式 ####
- 测试字符串表达式：
    表达式                 如果为真...
    string              string 不为 null。
    -n string           字符串 string 的长度大于零。
    -z string           字符串 string 的长度为零。
    string1 = string2   string1 和 string2 相同. 单或双等号都可以，不过双等号更受欢迎。
    string1 == string2
    string1 != string2  string1 和 string2 不相同。
    string1 > string2   sting1 排列在 string2 之后。
    string1 < string2   string1 排列在 string2 之前。

- 警告：这个 > 和 < 表达式操作符必须用引号引起来（或者是用反斜杠转义），当与 test 一块使用的时候。如果不这样，它们会被 shell 解释为重定向操作符，造成潜在地破坏结果。
- 把错误信息重定向到标准错误，这是处理错误信息的“合理”方法。

#### 28.3.3 整型表达式 ####
- 测试整数表达式：
        表达式                     如果为真...
    integer1 -eq integer2   integer1 等于 integer2.
    integer1 -ne integer2   integer1 不等于 integer2.
    integer1 -le integer2   integer1 小于或等于 integer2.
    integer1 -lt integer2   integer1 小于 integer2.
    integer1 -ge integer2   integer1 大于或等于 integer2.
    integer1 -gt integer2   integer1 大于 integer2.

### 28.4 更现代的测试版本 ###
- 语法：
    [[ expression ]]
- 增加了一个重要的新的字符串表达式：
    string1 =~ regex
    如果 string1 匹配扩展的正则表达式 regex ，其返回值为真
- 添加的另一个功能是 == 操作符支持类型匹配，正如路径名展开所做的那样。
    e.g.    if [[ $FILE == foo.* ]];

### 28.5 (( )) - 为整数设计 ###
### 28.6 结合表达式 ###
- 逻辑操作符
    操作符     测试      [[ ]] and (( ))
    AND         -a          &&
    OR          -o          ||
    NOT         !           !

-  test 和 [[ ]] 比较：
    test 更传统（是 POSIX 的一部分），然而 [[ ]] 特定于 bash。

### 28.7 控制操作符：分支的另一种方法 ###
- 使用 && 和 || 控制分支任务执行

### 28.8 总结 ###
### 28.9 拓展阅读 ###

## 29 读取键盘输入 ##
### 29.1 read - 从标准输入读取数值 ###
-  read 内部命令被用来从标准输入读取单行数据。
    read [-options] [variable...]
- 如果 read 命令接受到变量值数目少于期望的数字，那么额外的变量值为空，而多余的输入数据则会被包含到最后一个变量中。如果 read 命令之后没有列出变量名，则一个 shell 变量，REPLY，将会包含所有的输入：

#### 29.1.1 选项 ####
- read 选项：
        选项                  说明
    -a array        把输入赋值到数组 array 中，从索引号零开始。
    -d delimiter    用字符串 delimiter 中的第一个字符指示输入结束，而不是一个换行符。
    -e              使用 Readline 来处理输入。这使得与命令行相同的方式编辑输入。
    -n num          读取 num 个输入字符，而不是整行。
    -p prompt       为输入显示提示信息，使用字符串 prompt。
    -r              Raw mode. 不把反斜杠字符解释为转义字符。
    -s              Silent mode. 不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这会很有帮助。
    -t              seconds 超时. 几秒钟后终止输入。read 会返回一个非零退出状态，若输入超时。
    -u              fd 使用文件描述符 fd 中的输入，而不是标准输入。

### 29.2 IFS ###
- shell 变量 IFS （内部字符分隔符）。IFS 的默认值包含一个空格，一个 tab，和一个换行符，每一个都会把字段分割开。
- Shell 允许在一个命令之前立即发生一个或多个变量赋值。
- <<< 操作符指示一个 here 字符串。一个 here 字符串就像一个 here 文档，只是比较简短，由单个字符串组成。
- 注意：不能管道 read
> 虽然通常 read 命令接受标准输入.但是在 bash（和其它 shells，例如 sh）中，管道线会创建子 shell，read 命令将在子 shell 中执行。
> 使用 here 字符串是解决此问题的一种方法。

### 29.3 校正输入 ###
### 29.4 菜单 ###
### 29.5 总结归纳 ###
#### 29.5.1 友情提示 ####
### 29.6 拓展阅读 ###

## 30 流程控制：while/until 循环 ##
### 30.1 循环 ###
#### 30.1.1 while ####
- 语法：
    while commands; do commands; done

### 30.2 跳出循环 ###
- break 和 continue 

#### 30.2.1 until ####
- until 循环会继续执行直到它接受了一个退出状态零。
- 当循环终止的时候，循环中创建的任意变量或赋值的变量都会消失

### 30.3 使用循环读取文件 ###
### 30.4 总结 ###
### 30.5 拓展阅读 ###

## 31 疑难排解 ##
### 31.1 语法错误 ###
#### 31.1.1 丢失引号 ####
- 常见：echo 命令的参数中，删除其末尾的双引号

#### 31.1.2 丢失或意外的标记 ####
- 常见：忘记补全一个复合命令，比如说 if 或者是 while。

#### 31.1.3 预料不到的展开 ####
- 常见：除了代表空字符串之外，引号应该被用于这样的场合，一个要展开成多单词字符串的数值，及其包含嵌入式空格的文件名。

### 31.2 逻辑错误 ###
1. 不正确的条件表达式。
2. “超出一个值”错误。当编写带有计数器的循环语句的时候，计数出错。
3. 3. 意外情况。大多数逻辑错误来自于程序碰到了程序员没有预见到的数据或者情况。

#### 31.2.1 防错编程 ####

#### 31.2.2 验证输入 ####
- e.g.  [[ $REPLY =~ ^[0-3]$ ]]     测试输入条件

### 31.3 测试 ###
#### 31.3.1 测试案例 ####
### 31.4 调试 ###
#### 31.4.1 找到问题区域 ####
#### 31.4.2 追踪 ####
- bash 还提供了一种名为追踪的方法，这种方法可通过 -x 选项和 set 命令加上 -x 选项两种途径实现（#!/bin/bash -x）。
- 加号是追踪输出的默认字符。它包含在 PS4（提示符 4）shell 变量中。可以调整这个变量值让提示信息更有意义。
- 使用 set 命令加上 -x 选项来启动追踪，+x 选项关闭追踪。

#### 31.4.3 执行时检查数值 ####
### 31.5 总结 ###
### 31.6 拓展阅读 ###

## 32 流程控制：case 分支 ##
### 32.1 case ###
- 语法：
    case word in
        [pattern [| pattern]...) commands ;;]...
    esac
- 若找到一个模式之后，就不会再继续寻找。

### 32.2 模式 ###
- 模式以一个“)”为终止符。
- case 模式实例
    模式              描述
    a)              若单词为“a”，则匹配
    [[:alpha:]])    若单词是一个字母字符，则匹配
    ???)            若单词只有 3 个字符，则匹配
    *.txt)          若单词以“.txt”字符结尾，则匹配
    *)              匹配任意单词。把这个模式做为 case 命令的最后一个模式，是一个很好的做法

- 可以使用竖线字符作为分隔符，把多个模式结合起来。

### 32.3 执行多个动作 ###
- 早于 4.0的 bash，对于 case 语法绝不能匹配多个测试条件。
- 现在的 bash 版本，添加的“;;&”的语法允许 case 语句继续执行下一条测试，而不是简单地终止运行。

### 32.4 总结 ###
### 32.5 拓展阅读 ###

## 33 位置参数 ##
### 33.1 访问命令行 ###
- 即使不带命令行参数，位置参数 $0 总会包含命令行中出现的第一个单词，也就是已执行程序的路径名。

#### 33.1.1 确定参数个数 ####
- 得到命令行参数个数的变量: $#

#### 33.1.2 shift - 访问多个参数的利器 ####
#### 33.1.3 简单应用 ####
#### 33.1.4 Shell 函数中使用位置参数 ####
### 33.2 处理集体位置参数 ###
- 特殊参数:
    参数          描述
    $*      展开成一个从 1 开始的位置参数列表。当它被用双引号引起来的时候，展开成一个由双引号引起来的字符串，包含了所有的位置参数，每个位置参数由 shell 变量 IFS 的第一个字符（默认为一个空格）分隔开。
    $@      展开成一个从 1 开始的位置参数列表。当它被用双引号引起来的时候，它把每一个位置参数展开成一个由双引号引起来的分开的字符串。

- 到目前为止，“$@” 在大多数情况下是最有用的方法，因为它保留了每一个位置参数的完整性。

### 33.3 一个更复杂的应用 ###
### 33.4 总结 ###
### 33.5 拓展阅读 ###

## 34  流程控制：for 循环 ##
### 34.1 for: 传统 shell 格式 ###
- for 命令真正强大的功能是我们可以通过许多有趣的方式创建 words 列表。例如，通过花括号展开,或者路径名展开,或者命令替换

### 34.2 for: C 语言格式 ###
- 格式:
    for (( expression1; expression2; expression3 )); do
        commands
    done

### 34.3 总结 ###
### 34.4 拓展阅读 ###

## 35 字符串和数字 ##
### 35.1 参数展开 ###
#### 35.1.1 基本参数 ####
- 注意添加花括号

#### 35.1.2 管理空变量的展开 ####
- 几种用来处理不存在和空变量的参数展开形式：
    ${parameter:-word}      若 parameter 没有设置（例如，不存在）或者为空，展开结果是 word 的值。若 parameter不为空，则展开结果是 parameter 的值。
    ${parameter:=word}      若 parameter 没有设置或为空，展开结果是 word 的值。另外，word 的值会赋值给parameter。若 parameter 不为空，展开结果是 parameter 的值。
    ${parameter:?word}      若 parameter 没有设置或为空，这种展开导致脚本带有错误退出，并且 word 的内容会发送到标准错误。若 parameter 不为空，展开结果是 parameter 的值。
    ${parameter:+word}      若 parameter 没有设置或为空，展开结果为空。若 parameter 不为空，展开结果是 word 的值会替换掉 parameter 的值；然而，parameter 的值不会改变。

### 35.2 返回变量名的参数展开 ###
- 返回以 prefix 开头的已有变量名
    ${!prefix*}
    ${!prefix@}

#### 35.2.1 字符串展开 ####
- 展开成由 parameter 所包含的字符串的长度。然而，如果parameter 是 @ 或者是 * 的话，则展开结果是位置参数的个数。
    ${#parameter}

- 从 parameter 所包含的字符串中提取一部分字符。
    ${parameter:offset}
    ${parameter:offset:length}
- 若 offset 的值为负数，则认为 offset 值是从字符串的末尾开始算起，而不是从开头。注意负数前面必须有一个空格，为防止与 ${parameter:-word} 展开形式混淆。
- 如果 parameter 是 @，展开结果是 length 个位置参数，从第 offset 个位置参数开始。

- 从 paramter 所包含的字符串中清除开头一部分文本，这些字符要匹配定义的patten。pattern 是通配符模式，就如那些用在路径名展开中的模式。这两种形式的差异之处是该 # 形式清除最短的匹配结果，而该 ## 模式清除最长的匹配结果。
    ${parameter#pattern}
    ${parameter##pattern}

- 清除的文本从 parameter 所包含字符串的末尾开始，而不是开头。
    ${parameter%pattern}
    ${parameter%%pattern}

- 对 parameter 的内容执行查找和替换操作。如果找到了匹配通配符 pattern的文本，则用 string 的内容替换它。在正常形式下，只有第一个匹配项会被替换掉。在该// 形式下，所有的匹配项都会被替换掉。该/# 要求匹配项出现在字符串的开头，而/% 要求匹配项出现在字符串的末尾。/string 可能会省略掉，这样会导致删除匹配的文本。
    ${parameter/pattern/string}
    ${parameter//pattern/string}
    ${parameter/#pattern/string}
    ${parameter/%pattern/string}

- 字符串操作展开可以用来替换其它常见命令比方说 sed 和cut。通过减少使用外部程序，展开提高了脚本的效率。
    e.g.    用参数展开 ${#j} 取代命令 $(echo $j | wc -c) 及其 subshell 

- PS：使用 time 命令可以查看程序或命令执行的时间

#### 35.2.2 大小写转换 ####
- bash 有四个参数展开和 declare 命令的两个选项来支持大小写转换
    declare -u
    declare -l
    \${parameter„}      把 parameter 的值全部展开成小写字母。
    \${parameter,}      仅仅把 parameter 的第一个字符展开成小写字母。
    \${parameterˆˆ}     把 parameter 的值全部转换成大写字母。
    \${parameterˆ}      仅仅把 parameter 的第一个字符转换成大写字母（首字母大写）。

### 35.3 算术求值和展开 ###
#### 35.3.1 数基 ####
- 指定不同的数基
    表示法                 描述
    number          默认情况下，没有任何表示法的数字被看做是十进制数（以 10 为底）。
    0number         在算术表达式中，以零开头的数字被认为是八进制数。
    0xnumber        十六进制表示法
    base#number     number 以 base 为底

#### 35.3.2 一元运算符 ####

#### 35.3.3 简单算术 ####
- 算术运算符:
    **  乘方
- 在循环中计算余数是很有用处的。

#### 35.3.4 赋值运算符 ####
- 因为 test 命令接受单个 = 运算符来测试字符串等价性。这也是使用更现代的 [[ ]] 和 (( )) 复合命令来代替 test 命令的另一个原因。
- 类似C,也包含++和--

#### 35.3.5 位运算符 ####
#### 35.3.6 逻辑运算符 ####
- 当表达式用于逻辑运算时，表达式遵循算术逻辑规则；也就是，表达式的计算结果是零则认为假，而非零表达式认为真。该 (( )) 复合命令把结果映射成 shell 正常的退出码：

### 35.4 bc - 一种高精度计算器语言 ###
- bc 脚本 使用和 C 编程语言一样的注释语法。

#### 35.4.1 使用 bc ####
- 将bc 脚本保存为 xxx.bc
    e.g.    bc foo.bc
- bc 也能够交互使用，quit 命令结束交互会话
    e.g.    bc -q
- 标准输入把一个脚本传递给 bc 程序
    e.g.    bc < foo.bc
- 这种接受标准输入的能力，意味着我们可以使用 here 文档，here 字符串，和管道来传递脚本。
    e.g.    bc <<< "2+2"

#### 35.4.2 一个脚本实例 ####
- 使用here：
    bc <<- EOF
    scale = 10
    i = $interest / 12
    p = $principal
    n = $months
    a = p * ((i * ((1 + i) ^ n)) / (((1 + i) ^ n) - 1))
    print a, "\n"
    EOF

### 35.5 总结 ###
### 35.6 额外加分 ###
### 35.7 拓展阅读 ###

## 36 数组 ##
### 36.1 什么是数组？ ###
- Bash 中的数组仅限制为单一维度。

### 36.2 创建一个数组 ###
- declare 命令使用 -a 选项创建了数组。
    e.g.    declare -a array

### 36.3 数组赋值 ###
- 单个值赋值：
    name[subscript]=value

- 多个值赋值：
    name=(value1 value2 ...)

- 还可以通过指定下标，把值赋给数组中的特定元素：
    e.g.    days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat)

### 36.4 访问数组元素 ###
### 36.5 数组操作 ###
#### 36.5.1 输出整个数组的内容 ####
- 下标 * 和 @ 可以被用来访问数组中的每一个元素。与位置参数一样，@ 表示法在两者之中更有用处。
    e.g.    animals=("a dog" "a cat" "a fish")
            ${animals[*]} 和 ${animals[@]}一样：
                                                a
                                                dog
                                                a
                                                cat
                                                a
                                                fish
            "${animals[*]}" ：   a dog a cat a fish
            "${animals[@]}" ：
                                a dog
                                a cat
                                a fish

#### 36.5.2 确定数组元素个数 ####
- 使用参数展开：
    e.g.    a[100]=foo
            echo ${#a[@]} # number of array elements
            1
            echo ${#a[100]} # length of element 100
            3

#### 36.5.3 找到数组使用的下标 ####
- bash 允许赋值的数组下标包含“间隔”，确定哪个元素真正存在，用引号引起来的 @ 格式是最有用的，因为它能展开成分离词：
    ${!array[*]}
    ${!array[@]}


#### 36.5.4 在数组末尾添加元素 ####
- 通过使用 += 赋值运算符，我们能够自动地把值附加到数组末尾。


#### 36.5.5 数组排序 ####
    e.g.    a_sorted=($(for i in "${a[@]}"; do echo $i; done | sort))

#### 36.5.6 删除数组 ####
- 删除数组，使用 unset 命令

### 36.6 关联数组 ###
- 关联数组使用字符串而不是整数作为数组索引。
- 不同于整数索引的数组，仅仅引用它们就能创建数组，关联数组必须用带有 -A 选项的declare 命令创建。

### 36.7 总结 ###
### 36.8 拓展阅读 ###

## 37 奇珍异宝 ##
### 37.1 组命令和子 shell ###
- 组命令：
    { command1; command2; [command3; ...] }     花括号与命令之间必须有一个空格，并且最后一个命令必须用一个分号或者一个换行符终止。
- 子 shell：
    (command1; command2; [command3;...])

- bash可使用printf

#### 37.1.1 进程替换 ####
- 进程替换：
    一种适用于产生标准输出的进程：     <(list)          list 是一串命令列表
    另一种适用于接受标准输入的进程：    >(list)

### 37.2 陷阱 ###
- trap 使用如下语法：
    trap argument signal [signal...]        argument 是一个字符串，它被读取并被当作一个命令，signal 是一个信号的说明，它会触发执行所要解释的命令。

- 临时文件
> 除了为暴露给系统中所有用户的文件设置合适的权限，这一明显步骤之外，给临时文件一个不可预测的文件名是很重要的。这就避免了一种为大众所知的 temp race 攻击。比如:tempfile=/tmp/$(basename $0).$$.$RANDOM；一个比较好的方法是使用 mktemp 程序来命名和创建临时文件，比如:tempfile=$(mktemp /tmp/foobar.$$.XXXXXXXXXX)

### 37.3 异步执行 ###
#### 37.3.1 等待 ####
- wait 命令导致一个父脚本暂停运行，直到一个特定的进程（例如，子脚本）运行结束。
    wait $pid

### 37.4 命名管道 ###
- 命名管道用来在两个进程之间建立连接，也可以像其它类型的文件一样使用。
- 有一种常见的编程架构，叫做客户端-服务器，它可以利用像命名管道这样的通信方式，也可以使用其它类型的进程间通信方式，比如网络连接。
- 命令管道的行为类似于文件，但实际上形成了先入先出（FIFO）的缓冲。和普通（未命令的）管道一样，数据从一端进入，然后从另一端出现。

#### 37.4.1 设置一个命名管道 ####
- 使用 mkfifo 命令创建命令管道：
    e.g.    mkfifo pipe1

- 使用 ls 命令，我们查看这个文件，看到位于属性字段的第一个字母是“p”，表明它是一个命名管道。

#### 37.4.2 使用命名管道 ####
- 按下 Enter 按键，命令将会挂起。这是因为在管道的另一端没有任何接受数据。当这种现象发生的时候，据说是管道阻塞了。
    e.g.  ls -l > pipe1
          cat < pipe1

### 37.5 总结 ###
### 37.6 拓展阅读 ###
