# vim #
> 本文是一个vim的合集的最详细的一部分，即user-manual部分；vim总结文档一共包括：
> vimtutor
> :h quickref
> user_manual-1.9.0
> Reference Manual in PDF 
> 一些网页操作
> 插件相关

# Vim中文用户手册 #
## 初步知识 ##
### usr_01.txt 关于本手册 ###
#### 01.1  手册的两个部分 ####
- 跳转
大部分链接放在两根竖线之间，如：|bar|。另外，'number' 形式的选项名，用双引号括住的命令 ":write" 或者其它任何单词都可以用作一个超级链接。

#### 01.2 安装了 Vim 之后 ####
	:set compatible?   检测Vim 是否运行在 Vi 兼容选项关闭的模式下。 "nocompatible"，则一切正常

#### 01.3 教程使用说明 ####
#### 01.4 版权声明 ####

### usr_02.txt Vim 初步 ###
#### 02.1 第一次运行 Vim ####
#### 02.2 插入文本 ####
#### 02.3 移动光标 ####
#### 02.4 删除字符 ####
    J   删除一个换行符

#### 02.5 撤销与重做 ####

#### 02.6 其它编辑命令 ####
- 指定计数
    9k      向上移动 9 行
    3a!     增加三个感叹号
    3x"     删除三个字符

#### 02.7 退出 ####
    ZZ      保存文件并退出
    e!      重新装载原来的文件,放弃修改重新编辑

#### 02.8 寻求帮助 ####
    :help
    <F1>

	:help
        提供非常概括的帮助。往下滚动，可以看到所有帮助文件的列表，包括
		本地添加的文件 (即不是 Vim 发布带来的)。 >
	:help user-toc.txt
        用户手册的内容目录。 >
	:help :subject
 		Ex-命令 "subject"，例如下例: >
	:help :help
 		关于如何得到帮助的帮助。 >
	:help abc
 		普通模式命令 "abc"。 >
	:help CTRL-B
 		普通模式下控制键 <C-B>。 >
	:help i_abc
	:help i_CTRL-B
 		同上，但在插入模式下。 >
	:help v_abc
	:help v_CTRL-B
 		同上，但在可视模式下。 >
	:help c_abc
	:help c_CTRL-B
 		同上，但在命令行模式下。 >
	:help 'subject'
 		选项 'subject'。 >
	:help subject()
 		函数 "subject"。 >
	:help -subject
 		命令行选项 "-subject"。 >
	:help +subject
 		编译时特性 "+subject"。 >
	:help EventName
 		自动命令事件 "EventName"。 >
	:help digraphs.txt
 		帮助文件 "digraph.txt" 的顶部。
		其他帮助文件亦同。 >
	:help pattern<Tab>
 		寻找 "pattern" 开始的一个帮助标签。重复按 <Tab> 找下一个。 >
	:help pattern<Ctrl-D>
 		一次性列出所有匹配 "pattern" 的帮助标签。 >
	:helpgrep pattern
 		在所有帮助文件的全部文本中寻找模式 "pattern"，并跳到第一个匹配。要跳到其它的匹配，可用:
	    :cn
 			下一个匹配 >
	    :cprev
	    :cN
 			前一个匹配 >
	    :cfirst
	    :clast
 			第一个或最后一个匹配 >
	    :copen
	    :cclose
 			打开/关闭 quickfix 窗口；按 <Enter> 跳转到光标所在的项
			目上

- "*" 之间的名字被帮助系统用来定义一个标签 (也就是超级链接的目标)。

### usr_03.txt 移动 ###
#### 03.1 词移动 ####
    w       移动到下一个单词的词首
    b       向后移动到前一个词的词首：
    e       移到下一个单词的词末
    ge      移动到前一个单词的末尾
    大写的WORD    空白字符分隔的 "字串" () 移动。
    W
    B
    E
    gE

#### 03.2 移动到行首或行尾 ####
    $ 或 <End> 键        行尾   
    ^                   第一个非空字符
    0 或 <Home> 键       第一个字符
- 2$ 移动到下一行的行尾

#### 03.3 移动到一个指定的字符 ####
    fx      向前查找本行中的字符 x。
    3fx
    F       向左查找：
    tx      与 "fx" 相似，但它只把光标移动到目标字符的前一个字符上。提示："t" 表示 "To" (到达)。
    Tx

    这四个命令可以通过 ";" 命令重复，"," 命令则用于反向重复。

#### 03.4 括号匹配 ####
    %       匹配() [] {}

#### 03.5 移动到指定的行 ####
    33G
    %       "50％" 移动到文件的中间，
    H       "Home" (头)
    L       "Middle" (中) 
    M       "Last" (尾)。

#### 03.6 确定当前位置 ####
    CTRL-G
    :set number     :set nonumber
    :set ruler

#### 03.7 滚屏 ####
    CTRL-U      视窗向上滚动半屏。
    CTRL-D      视窗向下移动半屏，

    CTRL-E      文字上滚一行
    CTRL-Y      文字下滚一行

    CTRL-F      文字正向滚动一整屏
    CTRL-B      文字反向向滚动一整屏

    zt          光标所在行移动到屏幕的顶部
    zz          移动光标到中间。
    zb          移动到屏幕的底部
    
#### 03.8 简单查找 ####
    /
    ?       反方向查找
- "N" 命令在反方向重复前一次查找.? N 是正向查找。
- 忽略大小写
    :set ignorecase 	:set noignorecase
- 在文本中查找一个单词
    把光标移到那个单词下面使用 "*" 命令
    "#" 命令在反向完成相同的功能。
- 查找整个单词
    "\>" 只匹配单词末尾
    "\<" 只匹配单词开头
    e.g. /\<the\>只查找the
- 高亮匹配
    :set hlsearch
    :set nohlsearch     
	:nohlsearch        本次关掉高亮
- 调节查找方式
    :set incsearch      使 Vim 在你输入字符串的过程中就显示匹配点
    :set nowrapscan     使得找到文件结尾后停止查找。或者当你往回查找的时候遇到文件开头停止查找。默认情况下 'wrapscan' 的状态是 "on"。
- 加入.vimrc
    Go:set hlsearch<Esc>    "G" 移动到文件的结尾，"o" 开始一个新行，然后你在那里输入 ":set" 命令。最后你用 <Esc> 结束插入模式。然后用如下命令存盘：ZZ

#### 03.9 简单的查找模式 ####
    ^   行首
    $   行尾

#### 03.10 使用标记 ####
    `` 或 ''             回到G跳转位置,再次执行这个命令你会跳回去.可以在两个位置上跳来跳去.
    CTRL-O              跳到一个 "较老" 的地方 (提示： O 表示 older)。
    CTRL-I 或 <Tab>      跳到一个 "较新" 的地方 (提示：I 在键盘上紧靠着O)。
    :jumps              输出一个你可以跳往的位置的列表。最后一个你使用的标记会用 ">" 符号标记出来。
- 有名字的标记bookmark
    ma              用 a 标记当前的光标位置。
    `mark           跳转到mark
    'mark           移到标记所在行的行首
	:marks          取得标记的列表
                	'	跳转前的光标位置
                	"	最后编辑的光标位置
                	[	最后修改的开始位置
                	]	最后修改的结束位置

### usr_04.txt 做小改动 ###
#### 04.1 操作符与动作 ####
- 操作符－动作
  例如，"d" 就是一个删除操作符。然后你输入一个动作命令，例如 "4l" 或者 "w"。

#### 04.2 改变文本 ####
- c 操作符在很多地方都和 d 一样，但有一个例外，"cw"。它实际上象 "ce" 一样，删除到单词尾。这样单词后面的空格就不包括在内了。
- "cc" 修改一整行。但它会保留这一行的缩进 (前导空格)。
- 快捷键
    x  表示  dl  (删除当前光标下的字符)
	X  表示  dh  (删除光标左边的字符)
	D  表示  d$  (删除到行尾)
	C  表示  c$  (修改到行尾)
	s  表示  cl  (修改一个字符)
	S  表示  cc  (修改一整行)
- "r" 命令不是操作符。它只是等你输入一个字符然后用这个字符替换当前光标上的字符。

#### 04.3 重复一个修改 ####
    "."    重复任何除 "u" (撤销)，CTRL-R (重做) 和冒号命令外的修改。

#### 04.4 可视模式 ####
    "V"         按行选择
    CTRL-V      列块选择
    o           可视模式 文字移动到另一端 ;列块可视模式,移到对角上
    O           列块可视模式,移到同一行的另一个角上。

#### 04.5 移动文本 ####
    p       put
    P       象 "p" 一样也是插入字符，但插入点在光标前面。
    xp      交换两个字符  e.g. teh xp: the

#### 04.6 拷贝文本 ####
    y       拷贝 (yank)
    yw      包括单词后面的空白字符。
    ye      不包括单词后面的空白字符。
    Y       拷贝一整行. 区别于"D" 删除到行尾
    y$      拷贝到行尾。

#### 04.7 使用剪贴板 ####
    "*      e.g."*yy

#### 04.8 文本对象 ####
    daw     在一个单词的中间而又想删掉这个单词.
            aw      文本对象。表示 "A Word".该单词后的空s字符也被删除掉了。
    cis     改变一个句子.
            is      文本对象。表示 "Inner Sentence"(内含句子)。不包括句子后面的空白字符而
            as      文本对象。包括句子后面的空白字符

#### 04.9 替换模式 ####
    R	              启动替换模式。。如果超出行的范围，"R" 命令自动进行行扩展，而不是替换到下一行。
    <BS> (退格键)      进行修正时，原来被替换的字符又回来了

#### 04.10 结论 ####
    ~	修改光标下字符的大小写，并移动到下一个字符。这不是一个操作符，所以你不能连接一个动作命令。在可视模式下也有效，
    I	移到当前行的第一个非空字符并启动插入模式。
	A	移动到行尾并启动插入模式。

### usr_05.txt 选项设置 ###
#### 05.1 vimrc 文件 ####
    vimrc-intro
    设置选项命令      e.g.set incsearch   始终开启 'incsearch' 选项

#### 05.2 vimrc 示例解释 ####
    vimrc_example.vim
    set nocompatible                    要关闭 'compatible' 选项，'nocompatible' 。
    set backspace=indent,eol,start      指明在插入模式下在哪里允许 <BS> 删除光标前面的字符。三个值分别指：行首的空白字符，换行符和插入模式开始处之前的字符。
    set autoindent                      使用与前一行一样的缩进
    if has("vms")                       Vim 当覆盖一个文件的时候保留一个备份。但 VMS 系统除外，因为 VMS 系统会自动产生备份文件。
	  set nobackup
	else
	  set backup
	endif
    set history=50                      保存 50 个命令和 50 个查找模式的历史
    set ruler                           窗口的右下角显示当前光标位置。
    set showcmd                         在 Vim 窗口右下角，标尺的右边显示未完成的命令。
    set incsearch                       在输入部分查找模式时显示相应的匹配点。
    map Q gq                            定义一个键映射。
    vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ *.c *.h"<CR>        在可视模式下拷贝已选择的文本并在 C 文件中查找它
	if &t_Co > 2 || has("gui_running")     激活语法高亮功能，但仅在有色彩的时候才有效。
	  syntax on
	  set hlsearch
	endif

    vimrc-filetype
    filetype plugin indent on           1. 文件类型探测   2. 使用文件类型相关的插件  3. 使用缩进文件
    autocmd FileType text setlocal textwidth=78     Vim 在一行长于 78 个字符的时候自动换行，但仅对纯文本文件中有效。
    
    restore-cursor
    autocmd BufReadPost *               它设置为在读入任何文件之后自动执行。
	    \ if line("'\"") > 1 && line("'\"") <= line("$") |
	    \   exe "normal! g`\"" |
	    \ endif

#### 05.3 简单键盘映射 ####
    :map <F5> i{<Esc>ea}<Esc>       移到单词的第一个字符上并按 F5。会在单词两端加上 {}
- 一个可用于映射的键是反斜杠。
- ":map" 命令 (无参数) 列出当前已定义的映射，至少会包括普通模式下的那些。

#### 05.4 添加插件 ####
- Vim 中有两种插件：
    全局插件：用于所有类型的文件
    文件类型插件：仅用于特定类型的文件   :filetype plugin on

#### 05.5 添加帮助 ####
- 使 Vim 允许你跳转到新的主题上         :helptags ~/.vim/doc
-  Vim 可以添加那些本地的帮助文件

#### 05.6 选项窗口 ####
- 如果要找一个选项
    :options
- 可以通过这个窗口改变一个选项的值。

#### 05.7 常用选项 ####
- 可以通过 ":help" 命令获得更多的帮助。方法是在选项命令前后加上单引号    e.g.    :help 'wrap'
- 如果你搞乱了一个选项，你可以通过在选项后加上一个 & 号把它恢复到默认值。 e.g.    :set iskeyword&
- 禁止回绕行
    :set nowrap
    :set sidescroll=10
- 移动命令换行
    :set whichwrap=b,s
    :set whichwrap=b,s,<,>
    :set whichwrap=b,s,<,>,[,]
- 显示TAB键
    :set list
    :set listchars=tab:>-,trail:-
- 关键字
    :set iskeyword
	:set iskeyword+=-
	:set iskeyword-=_
- 显示消息的空间
    :set cmdheight=3

### usr_06.txt 使用语法高亮 ###
#### 06.1 功能激活 ####
    :syntax enable

#### 06.2 颜色显示不出来或者显示出错误的颜色怎么办？ ####
- 你的终端不支持彩色。
- 你的终端其实支持颜色，可是 Vim 不知道。
    setenv TERM xterm-color
- 文件类型无法识别。
    :set filetype
    # vim: syntax=make
- 颜色是错的
    :set background=dark
    :set background=light

#### 06.3 使用不同的颜色 ####
    :colorscheme evening
1. 选择一种接近你理想的色彩方案。
2. 编辑这个色彩方案，常用的有下面的这些条目：
	term		黑白终端的属性
	cterm		彩色终端的属性
	ctermfg		彩色终端的前景色
	ctermbg		彩色终端的背景色
	gui		GUI 版本属性
	guifg		GUI 版本的前景色
	guibg		GUI 版本的背景色
3. 告诉 Vim 总使用你这个色彩方案。
	colorscheme mine
如果你要测试一下常用的色彩组合，用如下命令：
	:runtime syntax/colortest.vim

#### 06.4 是否使用色彩 ####
- 临时关掉这个功能：
    :syntax clear
- 完全关闭这个功能：
    :syntax off
- 只对特定的文件采用语法高亮:
    :syntax manual
要在当前缓冲区中使用高亮
    :set syntax=ON

#### 06.5 带颜色打印 ####
- 打印当前文件：
    :hardcopy
- 下面几个选项可以改变 Vim 的打印行为：
	'printdevice'
	'printheader'
	'printfont'
	'printoptions'
- 要仅打印一定范围内的行:
    v100j:hardcopy
- 如下命令把当前文件转换成 HTML 格式：
	:TOhtml
如果不行:
	:source $VIMRUNTIME/syntax/2html.vim
#### 06.6 深入阅读 ####

### usr_07.txt 编辑多个文件 ###
#### 07.1 编辑另一个文件 ####
- 在 Vim 中打开另一个文件：
	:edit foo.txt
- 如果当前文件被修改过而没有存盘,Vim 会显示错误信息而不会打开这个新文件：
解决方法：
可以通过如下命令保存当前文件
    :write
可以强制 Vim 放弃当前修改并编辑新的文件：
    :edit! foo.txt
想编辑另一个文件，但又不想马上保存当前文件，可以隐藏它：
    :hide edit foo.txt

#### 07.2 文件列表 ####
- 可以在启动 Vim 的时候指定一堆文件。e.g.    vim one.c two.c three.c
    :next       可以编辑第二个
    :next!      放弃当前修改
    :wnext      保存当前文件再进入下一个(=  :write    :next)
    :args       显示当前文件在文件列表中的位置，这是 "arguments" (参数) 的缩写。
    :previous   回到前一个文件
    :wprevious
    :last       移动到列表中的最后一个文件
    :first      移动到列表中的第一个文件
    :2next      要向后跳2个文件
    :2previous  

- 自动保存
    :set autowrite
    :set noautowrite        关闭自动保存
- 编辑另一个文件列表
    :args five.c six.c seven.h
    :args *.txt         使用通配符
    :args!              放弃修改

#### 07.3 从一个文件中跳到另一个文件 ####
- 两个文件间快速跳转
    CTRL-^      在两个文件间快速跳转（注意 CTRL-^ 不会改变你在文件列表中的位置。）
- 预定义标记
    `"          这个标记使你跳转到你上次离开这个文件时的位置。
    `.          记住你最后一次修改文件的位置：
- 文件标记
    可以使用大写字母标记，这种标记是全局的，它们可以在任何文件中使用。
    mJ          标记
    `J          跳到标记
    :marks J    找到标记J在什么地方
    可以 CTRL-O 和 CTRL-I 在整个跳转序列中前后跳转。

#### 07.4 备份文件 ####
- 备份文件
    :set backup             备份文件的文件名是在原始文件的后面加上一个 ~ 。
    :set backupext=.bak     
    backupdir               指定备份文件的目录
- 备注:如果 'backup' 选项没有置位而 'writebackup' 选项置了位，Vim 还是会创建备份文件的。但在文件编辑完后，这个备份文件会被自动删除。这个功能用于避免发生异常情况导致没有存盘
- 保留原始文件
    :set patchmode=.orig
- 如果你让 'patchmode' 设为空 (这是默认的情况)，则原始文件不会被保留。

#### 07.5 文件间拷贝 ####
- 使用寄存器
    fyas     "yas" 命令拷贝一个句子，而 "f 告诉 Vim 把文本拷贝到寄存器 f 。
    "fp     粘贴f寄存器的内容
- 添加到文件
    :write >> logfile   将文本写入到文件的末尾
    :write              只拷贝一部分内容，可以先用可视模式选中这些内容后在执行

#### 07.6 显示文件 ####
    vim -R file     只读模式启动 Vim  （修改还是会被接纳的）
    view file       只读模式    （同上）
    vim -M file     禁止文件修改
	:set modifiable
	:set write

#### 07.7 修改文件名 ####
    :edit copy.c
    :saveas move.c      用 ":write"，写入的时候，被写入的就是 "move.c"。而 "copy.c" 不会被改变。
    :file move.c        Vim 会把这个文件标记为 "未编辑"。这表示 Vim 知道你现在编辑的文件不是原来那个文件了。

### usr_08.txt 分割窗口 ###
#### 08.1 分割窗口 ####
    :split      把屏幕分解成两个窗口并把光标置于上面的窗口中
    CTRL-W w    在窗口间跳转。
    :close      关闭窗口.可以避免你在剩下一个窗口的时候不小心退出 Vim 
    :only       关闭除当前窗口外的所有窗口。

#### 08.2 用另一个文件分割窗口 ####
    :split two.c    打开另一个窗口并用该窗口编辑另一个指定的文件
    :new            打开窗口编辑一个新文件

#### 08.3 窗口大小 ####
    :split              接受计数前缀。如果指定了这个前缀，这个数将作为窗口的高度。
    :3split alpha.c     打开一个三行的窗口并编辑文件 alpha.c

    CTRL-W +            扩大窗口
    CTRL-W -            缩小窗口
    这两个命令接受计数前缀用于指定扩大和缩小的行数。

    {height}CTRL-W _    把一个窗口设置为指定的高度
    CTRL-W _            把一个窗口扩展到尽可能大

    'winheight'         选项设置最小的期望窗口高度
    'winminheight'      选项设置最小的 "硬性"高度。
    'winwidth'          设置最小期望宽度
    'winminwidth'       设置最小硬性宽度。
    'equalalways'       选项使所有的窗口在关闭或者打开新窗口的时候总保持相同大小。

#### 08.4 垂直分割 ####
    :vsplit             在窗口左边打开新窗口
    :vsplit two.c
    "vnew"              命令，用于打开一个垂直分割的新窗口
    :vertical new       "vertical" 命令可以放在任何分割窗口的命令的前面。这会在分割窗口的时候用垂直分割取代水平分割。(如果命令不分割窗口，这个前缀不起作用)。

	CTRL-W h	              跳转到左边的窗口
	CTRL-W j	              跳转到下面的窗口
	CTRL-W k              跳转到上面的窗口
	CTRL-W l	              跳转到右边的窗口
	CTRL-W t	              跳转到最顶上的窗口
	CTRL-W b	              跳转到最底下的窗口

#### 08.5 移动窗口 ####
	CTRL-W K              把当前窗口移到最上边
	CTRL-W H	              把当前窗口移到最左边
	CTRL-W J	              把当前窗口移到最下边
	CTRL-W L	              把当前窗口移到最右边

#### 08.6 对所有窗口执行命令 ####
    :qall
	:wall
	:wqall
	:qall!

    vim -o one.txt two.txt three.txt    让 Vim 为每个文件打开一个窗口；"-o" 参数用于垂直分割窗口。

    :all                    为参数列表中的每个文件打开一个窗
    :vertical all           以垂直分割的方法打开窗口。

#### 08.7 用 vimdiff 显示文件差异 ####
- 启动比较模式一：
    vimdiff main.c~ main.c
    zo      打开一个折叠。
    zc      关闭使用 
- 启动比较模式二：
	:edit main.c
	:vertical diffsplit main.c~ 
- 启动比较模式三：
	:edit main.c
	:vertical diffpatch main.c diff
- 警告：补丁文件中必须仅包括为一个目标文件所做的补丁，否则你可能会得到一大堆错误信息。还可能有些你没打算打补丁的文件也被打了补丁。补丁功能只改变内存中的文件备份，不会修改你硬盘上的文件 (除非你决定写入改动)。

- 滚动绑定
    :set noscrollbind

- 跳转到修改的地方(可加上一个计数前缀)
    ]c     跳转到下一个修改点
	[c     反向跳转

- 消除差异
    :diffupdate     修正 Vim 有时可能无法及时更新高亮显示 问题
    :dp             "dp" 代表 "diff put"。
    :do             "do" 代表 "diffobtain"
    "dg"            diff get
    "dgg"           删除从光标为止到首行的所有文本

#### 08.8 杂项 ####
- 'laststatus' 选项用于指定什么时候对最后一个窗口显示状态条：
	0	永远不
	1	只有用分割窗口的时候 (默认)
	2	永远有

- 很多编辑另一个文件的命令都有一个使用分割窗口的变体。对于命令行命令，这通过前置一个 "s" 实现。
- 对于普通模式，前置一个 CTRL-W 可以完成这个功能。例如，CTRL-^ 跳到轮换文件，而 CTRL-W CTRL-^ 打开一个新窗口并编辑轮换文件。
- 'splitbelow' 选项可以让新的窗口出现在当前窗口的下面。'splitright' 选项让垂直分割的窗口出现在当前窗口的右边。

- 打开一个新窗口时可以在命令前加上一个修饰符说明新窗口应该出现在什么地方：
	:leftabove {cmd}	当前窗口的左上方
	:aboveleft {cmd}	同上
	:rightbelow {cmd}	当前窗口的右下方
	:belowright {cmd}	同上
	:topleft {cmd}		整个 Vim 窗口的最上面或者最左边
	:botright {cmd}		整个 Vim 窗口的最下面或者最右边

#### 08.9 标签页 ####
- 建立新的标签页
    :tabedit thatfile
- 切换标签页
    gt      助记符：Goto Tab。

- 在任何打开窗口的 Ex 命令前面，你都可以放上 ":tab"。这个窗口在新标签页中打开。

- 在末尾标签后面的空白处单击鼠标：选择下个标签页
- 在右上角的 "X" 处单击鼠标： 关闭当前标签页
- 在标签行上双击鼠标：建立新标签页
- "tabonly" 命令：关闭除了当前标签页以外的所有标签页，除非其它标签页中的改变没有保存

### usr_09.txt 使用 GUI 版本 ###
#### 09.1 GUI 版本的组件 ####
- 启动gVim：
	gvim file.txt
	vim -g file.txt
- 窗口标题
首先显示的是文件名，然后是一个特殊字符，最后是用括号括住的目录名。下面的是这些特殊字符的含义：
	-	文件不能被修改 (例如帮助文件)
	+	已经被修改过
	=	文件只读
	=+	文件只读，但仍被修改过
如果没有显示任何特殊字符，表示这是一个普通的，没有改过的文件。

- 菜单栏

- 工具栏
    :set guioptions-=T      关闭工具条

- 滚动条
  当你使用垂直分割的时候，可以考虑把滚动条放在左边。这可以通过菜单激活，或者使用 'guioptions' 选项，这是在 'guioptions' 中增加 'l' 标志位。：
	:set guioptions+=l

#### 09.2 使用鼠标 ####
- 使鼠标用起来象 X Windows：
	:behave xterm

- 使鼠标用起来象微软 Windows：
	:behave mswin

- XTERM 鼠 标 行 为
    左键单击		          定位光标
    左键拖动		          在可视模式下选中文本
    中键单击		          从剪贴板中粘贴文本
    右键单击		          把选中的文本扩展到当前的光标位置

- 微软 Windows 鼠标行为
    左键单击		          定位光标
    左键拖动		          在选择模式下选中文本 (参见 |09.4|)
    按住 Shift，左键单击    把选中的文本扩展到当前的光标位置
    中键单击		          从剪贴板中粘贴文本
    右键单击		          显示一个弹出式菜单


可以进一步定制鼠标。请参见下面的选项：

	'mouse'		鼠标的使用模式
	'mousemodel'	鼠标单击的效果
	'mousetime'	双击的间隔允许时间
	'mousehide'	输入的时候隐藏鼠标
	'selectmode'	鼠标启动可视模式还是选择模式


#### 09.3 剪贴板 ####
- 要拷贝当前选择区的内容：
	"*P
- 注意这里 "P" 是大写，表示把文字拷贝到光标的前面。

- "+ 寄存器用于真剪贴板。例如，要把当前光标位置到行末的文本拷到真剪贴板：
	"+y$

- 要把真剪贴板的内容拷到光标前面：
	"+P

#### 09.4 选择模式 ####
- 启用选择模式
    :set selectmode+=mouse
- 由于输入普通文本导致选中的文字被删除，这时你不能使用 "hjkl"，"w" 等移动命令。这时可以使用 "Shift" 加功能键。<S-Left> (shift 键加左箭头) 使光标左移。选中的文字象可视模式一样被扩展或者减少。其它箭头起的作用你也可以猜到了，<S-End> 和<S-Home> 也一样。

### usr_10.txt 做大修改 ###
#### 10.1 记录与回放命令 ####
- "." 命令重复前一个修改操作。
- 记录命令
    1. "q{register}" 命令启动一次击键记录，结果保存到 {register} 指定的寄存器中。寄存器名可以用 a 到 z 中任一个字母表示。
    2. 输入你的命令。
    3. 键入 q (后面不用跟任何字符) 命令结束记录。
    现在，你可以用 "@{register}" 命令执行这个宏。

- 移动并执行
    @a
    @@      如果已经执行过一次

- 回放命令和 "." 命令比较:
    首先，"." 只能重复一次改动。"@a" 可以重复多次改动，还能够执行移动操作。
    第二， "." 只能记住最后一次变更操作。而寄存器执行命令允许你记录任何操作并使用象 "@a" 这样的命令回放这些被记录的操作。
    最后，你可以使用 26 个寄存器，因此，你可以记录多达26 个命令序列。

- 使用寄存器

- 追加寄存器
    记录到一个大写寄存器表示附加命令到对应的小写寄存器。这种方法在宏记录，拷贝和删除命令中都有效。

#### 10.2 替换 ####
- 在连续的行中执行字符串替换。
	:[range]substitute/from/to/[flags]         这个命令把 [range] 指定范围中的字符串 "from" 修改为字符串 "to"。
- 备注:":substitute" 命令缩写形式 ":s" 

- 如果不指定行范围，":s" 命令只作用在当前行上。可用 "%" 表示命令作用于全部行。

- 默认情况下，":substitute" 命令只对某一行中的第一个匹配点起作用。
- 要对行中所有匹配点起作用，你需要加一个 g (global，全局) 标记
    e.g.    :%s/Professor/Teacher/g

- ":s" 命令还支持其它一些标志位，包括 "p" (print，打印)，用于在命令执行的时候打印出最后一个被修改的行。还有 "c" (confirm，确认) 标记会在每次替换前向你询问是否需要替换。

- 如果你要在 "from" 或者 "to" 中使用正斜杠，你需要在前面加上一个反斜杠。更简单的方法是用加号代替正斜杠。

#### 10.3 命令范围 ####
- ":substitute" 命令和很多其它的 ":" 命令一样，可以作用于选中的一些行。这称为一个"范围"。
- "{number},{number}"       最简单的范围表达形式
- 如果只用一个数值，表示某个指定的行
- 有些命令在不指定范围的时候作用于整个文件。要让它只作用于当前行可以用当前行范围标识 "."。e.g.    :.write otherfile
- "%" 就是 "1,$" 的缩写形式，表示从文件首到文件末。

- 在范围中使用模式
    e.g.    :?^Chapter?,/^Chapter/s=grey=gray=g     "?pattern?" 用于向前查找。同样，"/^Chapter/" 用于向后查找下一章。

- 加减号
    e.g.    /Chapter/-1     要查找一个模式，并且使用它的前一行
            /Chapter/+2
            :.+3,$-5        指定当前行下面第三行到文件末倒数第五行的范围。

- 使用标记
    e.g.    用 "mt" 标记开头，再用"mb" 标记结尾。    :'t,'b      表示一个范围 (包括标记的那一行)

- 可视模式和范围
    在可视模式中选中一些行。如果你现在输入 ":" 启动冒号命令模式，你会看到：  :'<,'>  ,可以输入剩下的命令，这个命令的作用范围就是可视模式中指定的范围。

- 备注:
	如果使用可视模式选中行的一部分，或者用 CTRL-V 选中一个文本列块，然后执行冒号命令，命令仍作用于整行，而不只是选中的范围。这可能会在以后的版本中修正
- '< 和 '> 实际上是标记，分别标识可视模式的开始和结尾。还可以把这个标记和其它标记混合: e.g.   :'>,$   表示从选中部分的结尾到文件末

- 指定行数
    如果你知道要修改多少行，你可以先输入一个数值再输入冒号。e.g     "5:",可以继续你的命令，这个命令将作用于当前行及其后 4 行。

#### 10.4 global 命令 ####
- 它允许你找到一个匹配点并且在那里执行一个命令。一般形式是：
	:[range]global/{pattern}/{command}
- 	备注:
	global 中执行的命令只能是冒号命令。普通模式命令不能在这里使用。如果需要，可以使用 |:normal| 命令。
-  全局命令的默认范围是整个文件，所以这个例子中没有指定范围。这一点与":substitute" 是不同的。后者只作用于一行。

#### 10.5 可视列块模式 ####
- 插入文本

- 修改文本
    C       从块的左边界开始删除所有行的后半段，然后状态切换到 "插入" 模式让你输入文本。新的文本被插入到每一行的末尾。
	~       交换大小写     (a -> A 而 A -> a)
	U       转换成大写     (a -> A 而 A -> A)
	u       转换成小写     (a -> a 而 A -> a)

- 以一个字符填充
    要以某一个字符完全填充整个块，可以使用 "r" 命令。

- 平移
    ">" 命令把选中的文档向右移动一个 "平移单位"，中间用空白填充。平移的起始点是可视列块的左边界。
    平移的距离由 'shiftwidth' 选项定义。 e.g.:set shiftwidth=4s

- 连接若干行
    "J" 命令连接被选中的行。其实就是删除所有的换行符。其实不只是换行符，行前后的多余空白字符会一起被删除而全部用一个空格取代。如果行尾刚好是句尾，就插入两个空格
    如果你不想改变那些空白字符，可以使用 "gJ" 命令。

#### 10.6 读、写部分文件内容 ####
- 包括另一个文件：
    :read {filename}"
    :$r patch       插入到当前文件的最后。
    :0read patch    插入到当前文件的最前。

- 保存部分行
    :.,$write tempo     写入当前位置到文件末的全部行到文件 "tempo" 中。如果这个文件已经存在，你会被提示错误。
	:.,$write! tempo   如果你知道你在干什么而且确实想这样做，就加一个叹号：

- 添加内容到文件中
    :.write collection      把当前行写入文件
    :.write >>collection    ">>" 通知 Vim 把内容添加到文件 "collection" 的后面。

#### 10.7 排版文本 ####
- 自动换行
    :set textwidth=72       

- 排版当前的段落
    gqap
- 这个命令用 "gq" 开始，作为操作符，然后跟着 "ap"，作为文本对象，该对象表示 "一段" (a paragraph)。"一段" 与下一段的分割符是一个空行。
- 备注:只包括空白字符的空白行不能分割 "一段"。这很不容易分辨。

- 排版整个文档：
    gggqG       "gg" "gq" "G" 

#### 10.8 改变大小写 ####
- 以下命令都是操作符，所以它们可以用于 "动作"命令，文本对象和可视模式。
    gU      改成大写
    gu      改成小写
    g~      交换大小写

- 要让一个操作符作用于当前行，可以执行这个操作符两次。e.g. dd gugu(可缩成 guu) gUU g~~

#### 10.9 使用外部程序 ####
- 用一个外部程序对一个文本块进行过滤
    !{motion}{program}
- e.g.
    !5Gsort<Enter>          sort 程序用前 5 行作为输入执行，程序的输出替换了原来的 5 行。

- "!!" 命令用于对当前行执行过滤命令。e.g."!!date<Enter>" 用 "date" 的输出代替当前行。这在为文件加入时间戳的时候非常有用。

- 如果命令不执行怎么办?检查下面选项:
	'shell'		      指定 Vim 用于执行外部命令的 shell。
	'shellcmdflag'	    传给 shell 的参数
	'shellquote'	  shell 程序使用的引号 (用于引用命令)
	'shellxquote'	 用于命令和重定向文件名的引号
	'shelltype'	       shell 程序的类型 (仅用于 Amiga)
	'shellslash'	  在命令中使用正斜杠 (仅用于 MS-Windows 和相容系统)
	'shellredir'	  用于把命令输出写入文件所使用的字符串

- 读入一个命令的输出
    e.g.    :read !ls

- 把文本输出到一个命令
    e.g.    :write !wc

- 重画屏幕
    CTRL-L

### usr_11.txt 从崩溃中恢复 ###
#### 11.1 基本恢复 ####
- 读取交换文件 (用于保存你的编辑数据的文件) 并且提取原文的编辑碎片
    vim -r help.txt
- 最后所做的一些修改不能恢复是正常的。Vim 在你停止大约 4 秒不输入的时候或者输入大约两百个字符以后才会更新交换文件。这间可以通过 'updatetime' 和 'updatecount'两个选项来调整。这样，如果系统崩溃前 Vim 没有更新交换文件，最后一次更新后编辑的内容就会丢失。
- 编辑的时候没有给定文件名，可以用一个空的字符串来表示文件名：
    vim -r ""

#### 11.2 交换文件在哪 ####
- 列出所有它能找到的交换文件:
    vim -r

- 使用指定的交换文件
    如果你知道要用哪个文件，你可以指定交换文件的名字。Vim 会找出交换文件所对应的原始文件的名字。
    	Vim -r .help.txt.swo
    这个方法在交换文件在一个非预期的目录中时很有用。Vim 知道 *.s`[uvw][a-z]` 模式的文件是交换文件。

#### 11.3 是不是崩溃了？ ####
- 交换文件已经存在。可能的原因有两个：
    1. 这个文件正在被另一个进程编辑。
    2. 交换文件可能是由于前一次 Vim 或者计算机崩溃导致的。检查提示信息中的日期。如果交换文件比你正在编辑的文件新，而且出现这个信息：
		modified: YES ~
   这就表明你很可能需要恢复了。

- 无法读取的交换文件

- 恢复一个文件
    :recover

#### 11.4 深入阅读 ####
    swap-file       解释交换文件在什么地方创建以及名字是什么。
    :preserve       手工刷新交换文件
    :swapname       查看当前文件的交换文件
    'updatecount'	多少个键被敲下后执行一次交换文件刷新
    'updatetime'	交换文件刷新后的超时时间
    'swapsync'      交换文件刷新后是否执行磁盘同步
    'directory'	    列出用于保存交换文件的目录
    'maxmem'        写入交换文件前的内存使用限制
    'maxmemtot'     同上，当用于所有文件

### usr_12.txt 小窍门 ###
#### 12.1 单词替换 ####
- 在全文中用一个单词替换另一个单词：
    e.g.    :%s/\<four\>/4/g
    "%" 范围前缀表示在所有行中执行替换。最后的 "g" 标记表示替换行中的所有匹配点。c在每次替换前提示

- 在多个文件中替换
    e.g.        :将C++ 文件的目录下所有以 ".cpp" 结尾，"GetResp" 的函数改名为 "GetAnswer"。
    vim *.cpp
    qq          用 q 作为寄存器启动一次记录。
    :%s/\<GetResp\>/GetAnswer/ge    "e" 标记通知 ":substitute" 命令找不到不是错误。
    :wnext		保存文件并移到下一个文件。
    q			中止记录。
	@q			回放 q 中的记录。这会执行又一次替换和":wnext"。你现在可以检查一下记录有没有错。
	999@q		对剩下的文件执行 q 中的命令

- 备注:在回放记录的时候，任何错误都会中止回放的过程。所以，要注意保证记录中的命令不会产生错误。

#### 12.2 把 "Last, First" 改成 "First Last" ####
- Doe, John ~  >  John Doe ~
    e.g.    :%s/\([^,]*\), \(.*\)/\2 \1/
    替换命令的参数格式是 "from/to"
    "\2" 和 "\1"。这些称为 "反向引用"。它们指向前面模式中的\( 和 \) 间的部分。     
- 可以在替换部分使用多达 9 个反向引用。"\0" 表示整个匹配部分。

#### 12.3 排序 ####
    e.g.	Makefile排序
        OBJS = \ ~
		version.o \ ~
		pch.o \ ~
		getopt.o \ ~
		util.o \ ~
		getopt1.o \ ~
		inp.o \ ~
		patch.o \ ~
		backup.o ~

	/^OBJS
	j
	:.,/^$/-1!sort

#### 12.4 反转行顺序 ####
- |:global| 命令可以和 |:move| 命令联用，将所有行移动到文件首部。结果是文件被按行反转了次序。
    :g/^/m 0
    :move 0 命令将匹配的行移动到那个神秘的第 0 行之后。

#### 12.5 单词统计 ####
- 统计整个文件的字数
    g CTRL-G

#### 12.6 查阅 man 信息 ####
- man 手册查询某个命令或者函数的用法
    K
    :Man csh
- CTRL-W w 跳转到原来的窗口
- 指定手册的章节，可以在手册名称前面指定:
    e.g.   :Man 3 echo  找第三章的 "echo"
- 显示当前光标下的单词的手册
	\K

#### 12.7 删除多余空格 ####
    :%s/\s\+$//

#### 12.8 查找单词的使用位置 ####
- 找到包括单词的那个文件
    vim `grep -l frame_counter *.c`
    ":next" 和 ":first"
- 找到每一行
    :grep error_string *.c
    :cnext      下一个匹配行
    :cprev      上一个匹配行
    :clist      所有的匹配点
- ":grep" 命令会使用一个外部的程序。可以通过 'grepprg' 选项修改这个设置。

## 高效的编辑 ##
### usr_20.txt 快速键入命令行命令 ###
#### 20.1 命令行编辑 ####
- 命令行上移动光标时最常用的键:
    <Left>          左移一个字符
    <Right>         右移一个字符
    <S-Left> 或 <C-Left> 左移一个单词
    <S-Right> 或 <C-Right>   右移一个单词
    CTRL-B 或 <Home> 命令行行首
    CTRL-E 或 <End>      命令行行尾
- 备注:
    <S-Left> (光标左移键和 Shift 键同时按下) 和 <C-Left> (光标左移键和Control 键同时按下) 并非在所有键盘上都有效。其它 Shift 和 Control 组合键也是这种情况。

- 删除
    <BS> 键删除光标前一个字符。
    删除光标前整个单词，则用 CTRL-W。
    CTRL-U 删除命令行上全部文字，从而让你从头开始。

- 替换
    插入键 <Insert>

- 取消
    CTRL-C 或 <Esc>

#### 20.2 命令行缩写 ####
- 最短的有效缩写形式可以在帮助文件里找到。
    e.g.    ":substitute" 可以被缩写成 ":s"

#### 20.3 命令行补全 ####
- 使用 CTRL-P 依相反方向循环匹配列表

- 看匹配列表
    CTRL-D

- 更多选项
    CTRL-L          把词补全为最长无歧义字符串。
    选项 'wildmode'   可用来改变补全时采用的方式。
    选项 'wildmenu'   可用来取得菜单式的匹配列表。
    选项 'suffixes'   来指定一些不太重要的文件，并让它们出现在文件列表末尾。
    选项 'wildignore' 指定一些根本用不着表列的文件。

#### 20.4 命令行历史 ####
- 搜索历史记录:
    :history /

- 不愿用光标方向键，CTRL-P 作用就跟 <Up> 一样。而 CTRL-N 跟 <Down> 一样。
- 可用    :se<Up>     匹配

#### 20.5 命令行窗口 ####
- 打开命令行窗口:
	q:

- 在命令行窗口内所作的修改不会被保存。它们不会导致历史记录被修改。唯一例外就是你执行的命令将被加到历史记录的末尾，跟所有执行过的命令一样。

- 搜索命令 "?config" 是可以用来寻找先前那个含有 "config" 的命令的。

### usr_21.txt 离开和回来 ###
#### 21.1 挂起和继续 ####
- 命令
	CTRL-Z
	{any sequence of shell commands}
	fg
- 按 CTRL-Z 行不通时，你还可以用命令 ":suspend"。

#### 21.2 执行 shell 命令 ####
- 字符 "!" 也用在其它有个程序被调用运行的场合。
	:!{program}		      执行 {program}
	:r !{program}		    执行 {program} 并读取其输出
	:w !{program}		    执行 {program} 传送文本至其输入
	:[range]!{program}	    经由 {program} 过滤文本

- 启动一个新 shell:
	:shell

#### 21.3 记忆有关信息；viminfo ####
- 信息文件 viminfo 设计用来储存状态信息:
	命令行和模式搜索的历史记录
	寄存器内文本
	各种文件的标记
	缓存器列表
	全局变量

- 选项 'viminfo' 的默认设定是还原有限的几种信息。

- 设定它记住更多的信息：
    :set viminfo=string
- 该字符串的语法为一个选项字符跟一个参数。选项和参数组成的对子之间由逗号分隔。
- 选项 ' 用于规定你为多少个文件保存标记 (a-z)。为此选项凑一个整数就行 (比如 1000)。
	e.g.   :set viminfo='1000

- 选项 f 控制是否要储存全局标记 (A-Z 和 0-9)。如果这个选项设为 0，那么什么也不存储。如果设为 1，或你对 f 选项不作规定，那么标记就被存储。
	e.g.   :set viminfo='1000,f1

- 选项 < 控制着每个寄存器内保存几行文本。默认情况下，所有的文本行都被保存。如果设为 0，则什么也不保存。
	e.g.	:set viminfo='1000,f1,<500

- 其它选项:
	:	保存命令行历史记录内的行数
	@	保存输入行历史记录内的行数
	/	保存搜索历史记录内的行数
	r	可移介质，其上的文件不保存标记 (可用多次)
	!	以大写字母开头并且不含有小写字母的全局变量
	h	启动时关闭选项 'hlsearch' 高亮显示
	%	缓冲区列表 (只有当不带参数启动 Vim 时才用来恢复)
	c	用编码 'encoding' 转换文本
	n	用于 viminfo 文件的名称 (必须为最后一项选项)

----------

- 重返 VIM 中断处
    '0
- 每次退出 Vim，它都创建一个标记。最后那个是 '0。原来那个 '0 所指的位置就成了 '1。而原来那个 '1 就成了 '2，依此类推。而原来的标记 '9 就没了。要发现标记 '0 至 '9 指向何处，|:marks| 命令很有用。

- 重返某文件
	:oldfiles      最近曾经编辑过的文件
    :e #<2          编辑第二个文件     "#<2" 这种形式可以用在 "%" (当前文件名) 和 "#" (轮换文件名) 可以出现的地方。
    :split #<3

----------

- Vim间信息移动
- 用命令 ":wviminfo" 和 ":rviminfo" 来保存和还原信息。
- ":wviminfo" 用字符 ! 来强制重写一个已存在文件。如果省略而文件却存在，那么这些信息就跟那个文件合并到一起。
- 用于 ":rviminfo" 的 ! 字符意味着所有的信息都被采用，这可能会重写一些已存在信息。若不用 ! 字符，则只有那些尚未设定的信息才会被采用。

#### 21.4 会话 ####
-  Vim 会话存放着所有跟你的编辑相关的信息。这包括诸如文件列表、窗口布局、全局变量、选项、以及其它信息。
- 创建一个会话文件:
	:mksession vimbook.vim

- 还原这个会话:
	:source vimbook.vim

- 启动 Vim 并还原某个特别的会话:
	vim -S vimbook.vim         参数 'S' 指会话 (实际上，你可以用 -S 运行任何 Vim 脚本，因而，你也不妨指其为运行脚本，"source")。

- 究竟还原了什么取决于 'sessionoptions' 选项。默认值为 "blank,buffers,curdir,folds,help,options,winsize"。
	blank		保留空窗口
	buffers		所有缓冲区，而非仅仅一个窗口内的
	curdir		当前目录
	folds		折叠，包括人工创建的
	help		帮助窗口
	options		所有选项和映射
	winsize		窗口大小

- 可以修改会话：
	e.g.       :set sessionoptions+=resize        还原 Vim 窗口大小

----------

- 提示: 要在一个空窗口中打开一个表列在浏览器窗口中的文件，请把光标移到文件名上并按 "O"。用鼠标双击也行。

----------

- UNIX 和微软视窗
> 若今天在微软视窗上，而明天则在 Unix 上工作。存盘的会话文件的格式在两种系统上都适用。
    :set sessionoptions+=unix,slash

- Vim 将因而使用 Unix 格式，因为微软视窗上的 Vim 能读写 Unix 文件，但 Unix 上的Vim 却不能读取微软视窗格式的会话文件。类似地，微软视窗上的 Vim 懂得文件路径名称里用以分隔名字的 / ，但 Unix 上的 Vim 却不懂微软视窗上的 \。

----------

- 会话记录和信息文件
- 保存:
	:mksession! ~/.vim/secret.vim
	:wviminfo! ~/.vim/secret.viminfo

- 还原:
	:source ~/.vim/secret.vim
	:rviminfo! ~/.vim/secret.viminfo

#### 21.5 视图 ####
- 会话记录储存着整个 Vim 窗口外观。当你只需要为某个窗口储存特性时，得用视图。事实上，当你储存会话时，每个窗口的视图都储存了。
- 视图有两种基本用法。
- 第一种是让 Vim 为视图文件挑一个文件名。在以后编辑同一文件时还原该视图。
	:mkview        储存视图
	:loadview      恢复视图

- 可以用这个方法为同一个文件储存视图达十个之多，一个没序号的，而九个则有序号 1 至 9。

----------

- 命名视图
- 第二种视图基本用法是把视图储存在一个你选定的文件内。你可以在编辑另外一个文件时载入这个视图。
    :mkview ~/.vim/main.vim        储存视图
	:source ~/.vim/main.vim        恢复视图


#### 21.6 模式行 ####
- 模式行是一行文本，它把一些只适用于该文件的选项设定告诉 Vim。
- 将模式行插入该文件起首五行或结尾五行。对于有些文件，模式行放在头部挺合适，所以它应该置于该文件的顶部。对于文本文件和其它那些模式行会影响正文阅读的文件，把模式行放在文件结尾处。
    e.g.    /* vim:set shiftwidth=4: */ ~       把缩进值设为 4 的倍数。

- 选项 'modelines' 规定了要在文件起首和结尾几行之内检查那儿是否包含了模式行。
    e.g.    :set modelines=10       检查十行

- 撤销设定：
    :set nomodeline

- 模式行可以用这种格式:
	any-text vim:set {option}={value} ... : any-text ~
- "any-text" 表示你可以在 Vim 实际用到的部分之前和之后加任意文本。冒号之间的部分是命令 ":set" 。它的用法就跟键入 ":set" 命令一模一样，只除了在命令包含的任何冒号之前需要插入一个反斜杠
    e.g.    // vim:set textwidth=72 dir=c\:\tmp:  use c:\tmp here ~     在第一个冒号之前多一个反斜杠，因此它被包括在 ":set" 命令内。第二个冒号后面的文本则被忽略不计，因此可以在那儿放个注释。

### usr_22.txt 寻找要编辑的文件 ###
#### 22.1 文件浏览器 ####
- 编辑一个目录
    :edit .

- 返回父目录。按 "-" 键可达到同样的目的，且无须先把光标移到 "../" 条目上。

- 你可以按 <F1> 键获取关于 netrw 文件浏览器功能的帮助。
    要选择显示和编辑的文件: (光标在某文件名上)
	<enter>		在当前窗口打开文件			          |netrw-cr|
	o		    横向分割窗口并显示文件			      |netrw-o|
	v		    竖向分割窗口并显示文件			      |netrw-v|
	p		    使用 |preview-window|	 		  |netrw-p|
	P		    在上次的窗口中编辑			          |netrw-P|
	t		    在新标签页中打开文件			      |netrw-t|

    接下来的普通模式命令用来控制浏览器显示:
	i		控制列表风格 (瘦、长、宽和树形)。长列表包含文件大小和日期信息。
	s		反复按 s 会改变文件排序的方式；可以按照名字、修改日期或文件大小排序。
	r		逆转排列顺序。

    略举数例其它的普通模式命令:
	c		把当前目录改成显示在窗口中的那个目录。(见|g:netrw_keepdir|，它也控制此行为)
	R		为光标下文件改名。Vim 将提示你提供新文件名。
	D		删除光标下文件。Vim 将提示你确认删除动作。
	mb gb	建立书签/转到书签

    还有命令模式，e.g.
	:Explore [directory]	   浏览指定/当前目录
	:NetrwSettings		       当前 netrw 设置的综合列表，带有帮助链接。

#### 22.2 当前目录 ####
- ":cd" 命令可以用来改变当前目录。你可以用 ":pwd" 命令来查看当前目录使什么
- 可以用 "cd -" 命令回去。

----------

- 窗口本地目录
- 不发出 ":lcd" 命令，所有窗口共享同一个当前目录。
- 执行过 ":lcd" 命令的窗口记得它特有的当前目录。在其它窗口执行 ":cd" 或":lcd" 命令对它毫无影响。
- 在一个采用特有当前目录的窗口执行 ":cd" 命令以后，该窗口就回过头来又采用共享的当前目录了。

#### 22.3 查找文件 ####
- 查看当前目录下include文件
    gf
- 头文件存放在目录不在当前目录:
    :set path+=c:/prog/include

- 'path' 选项还允许你用其它许多方法来指定在其中寻找文件的目录。
- 'isfname' 选项用来决定哪些字符可用于文件名，以及哪些不可以

- 要找的文件名没出现在你编辑的文件里时:
    :find inits.h

- 要在新窗口内打开那个已经找到的文件，用 CTRL-W f，而不是 "gf"，或用 ":sfind" 而不是 ":find"。
- 有个好办法可以直接启动 Vim 来编辑 'path' 中的某个文件:
	vim "+find stdio.h"
    这会在你的 'path' 中查找 "stdio.h"。双引号是必需的，用来把括起来的当做一个参数|-+c|。

#### 22.4 缓冲区列表 ####
- 隐藏的缓冲区
    e.g.    在编辑文件 one.txt，同时又要编辑文件 two.txt,又不想在此时就把 one.txt 存盘
    :hide edit two.txt

- 也可以不用 ":hide" 命令而设定 'hidden' 选项。其作用是当离开任何缓冲区时，该缓冲区变成隐藏。

----------

- 非激活缓冲区
    激活		显示在窗口内，并加载文本
    隐藏		不显示在窗口内，但加载文本
    非激活	不显示在窗口内，不加载文本

- 非激活缓冲区不会被遗忘，因为 Vim 保存着关于它们的信息，如标记等。而且记住文件名有个好处，你可以调阅你编辑过的文件名，再次编辑它们。

----------

- 缓冲区列表
    :buffers    或       :ls

- 第一栏存放缓冲区号。你可以利用它来编辑文件，而不用键入文件名。紧随缓冲区号的是些标志位。然后是文件名，以及光标最后一次停留的行号。可能出现的标志位有以下这些 (自左至右):
    u	列表外缓冲区 |unlisted-buffer|。
    %	当前缓冲区。
    \#	轮换缓冲区。
    a	激活缓冲区，缓冲区被加载且显示。
    h	隐藏缓冲区，缓冲区被加载但不显示。
    =	只读缓冲区。
    -	不可改缓冲区， 'modifiable' 选项不置位。
    +	已修改缓冲区。

----------

- 编辑缓冲区
    :buffer 2

- 要在新窗口中打开一个缓冲区: 
	:sbuffer 3

----------

- 使用缓冲区列表
	:bnext		编辑下一个缓冲区
	:bprevious	编辑前一个缓冲区
	:bfirst		编辑第一个缓冲区
	:blast		编辑最后一个缓冲区

- 要从缓冲区列表上删除一个缓冲区，用这个命令: 
	:bdelete 3

- 备注:即使用 ":bdelete" 命令删除了缓冲区以后，Vim 依然记得它。这个缓冲区实际上成了 "列表外" 缓冲区，它不再出现在 ":buffers" 命令所报告的列表中。不过 ":buffers!" 命令仍会列出 "列表外" 缓冲区 (没错，Vim 无所不能)。要让Vim 彻底忘记一个缓冲区，用 ":bwipe" 命令。另见 'buflisted' 选项。

### usr_23.txt 编辑特殊文件 ###
#### 23.1 DOS、Mac 和 Unix 文件 ####
- UNIX 开发者决定他们可以用 <Line Feed> 一个字符来表示行尾。Apple 开发者规定了用 <CR>。开发 MS-DOS (以及微软视窗) 的那些家伙则决定沿用老式的 <CR><LF>。
- 选项 'fileformats' 包含各种各样的格式：
    e.g.    :set fileformats=unix,dos       先尝试用 UNIX 格式，其次，尝试MS-DOS 格式
- 探测到的文件格式会被存入 'fileformat' 选项。执行下面这个命令可以显示你当前使用的文件格式:
	:set fileformat?
- Vim 能使用的三种格式如下:
	unix   <LF>
	dos    <CR><LF>
	mac    <CR>

----------

- 使用MAC格式
    一个同时包含 <CR> 和 <LF> 的文件，Vim 假设你一般不会在 Unix 上编辑一个 Mac 文件，所以干脆对这种文件格式不作检查。果真要检查此种格式，就把 "mac" 加入 'fileformats':    :set fileformats+=mac

----------

- 强制格式
- Vi 来尝试编辑一个采用 MS-DOS 格式，^M 就是 <CR>。 Vim 的自动探测功能就避免了这个问题。强制 Vim 忽略文件格式而使用你指定的格式:
	:edit ++ff=unix file.txt       "++" 告诉 Vim 后面跟的是选项名，以取代其默认值。
- 目前 Vim 仅仅实现了 "++ff" 和 "++enc"。用全称"++fileformat" 和 "++encoding" 也行。

----------
- 转换
    e.g.    将MS-DOS 文件转换成 UNIX 格式。
        :set fileformat=unix
    	:write

#### 23.2 互联网上的文件 ####
- 把光标移到那个超链接里任何一个字符上，然后使用这个命令:
	gf
运气好的话，Vim 将确定用哪个程序来下载这个文件，并把文件下载下来让你编辑该副本。在另一个新窗口打开这个文件，则用 CTRL-W f。

#### 23.3 加密 ####
- 编辑一个需要加密的新文件
    vim -x exam.txt

----------

- 开/关加密
- 撤除加密
    :set key=

- ":X" 命令会像 "-x" 参数向你索取一个密码:
	:X

----------

- 加密的局限性
- 不让人们读到你的交换文件的一个方法就是不使用交换文件。如果在命令行上用了 -n参数，交换文件就不会被创建了
- 如果已经在编辑这个文件了，那么交换文件 swapfile 可以用下面的命令禁止:
	:setlocal noswapfile

#### 23.4 二进制文件 ####
- 启动 Vim 时加上 "-b" 参数，这个参数设定了 'binary' 选项。其作用是排除所有的意外副作用。
- 文件里的很多字符都是不可显示的。用 Hex 格式来显示它们的值:
	:set display=uhex
- 可以用命令 "ga"  来显示光标下的字符值。
- 可以关闭 'wrap' 选项来获得总览的效果:
	:set nowrap

----------

- 字节位置
- 在文件中的当前字节位置：
    g CTRL-G
- 要移到文件中某个指定的字节：
    2345go

----------

- 使用XXD
- 把这个文件转换成十六进制:
    :%!xxd
- 把这个文件转换回来:
    :%!xxd -r

#### 23.5 压缩文件 ####
- 插件 "gzip"负责在你编辑这个文件时把它解压缩，以及在你存盘时再把它压缩起来。
- 支持的压缩方法：
	.Z	compress
	.gz	gzip
	.bz2	bzip2

### usr_24.txt 快速插入 ###
#### 24.1 更正 ####
- 整个词都打错了的时候，用 CTRL-W 来更正
- 一行字弄得不可收拾，而要从头来过的话，用 CTRL-U 来删除。这个命令保留了光标之后的文本，也保留了行首的缩进。它只删除了自第一个非空字符至光标位置之间的文本。
- 在插入模式下可以利用的特殊键：
    <C-Home>	        移到文件首
	<PageUp>	    上卷一屏
	<Home>		    移到行首
	<S-Left>        左移一个单词
	<C-Left>       	左移一个单词
	<S-Right>	    右移一个单词
	<C-Right>	    右移一个单词
	<End>		    移到行尾
	<PageDown>	    下卷一屏
	<C-End>		    移到文件尾

#### 24.2 显示匹配 ####
- 显示匹配:
	:set showmatch
- 可以用 'matchtime' 选项改变 Vim 在匹配括号上停留的时间:
    e.g.    :set matchtime=15       指定的时间以 1/10 秒为单位。

#### 24.3 补全 ####
- 往上搜索补全，用 CTRL-P
- 往下搜索补全，用 CTRL-N。
- 默认情况下，它搜索如下一些地方:
	1. 当前文件
	2. 其它窗口内的文件
	3. 其它载入文件 (隐藏缓冲区)
	4. 未载入文件 (非激活缓冲区)
	5. 标签文件
	6. 被当前文件以 #include 语句包含的所有头文件

----------
- 选项
- 利用 'complete' 选项定制搜索顺序。
- 使用 'ignorecase' 选项
- 补全选项是 'infercase'。它的用处是在寻找忽略大小写的匹配时('ignorecase' 必须先被设定)，但仍然采用已键入部分的大小写。

----------
- 补全特定文本
	CTRL-X CTRL-F		文件名
	CTRL-X CTRL-L		整行
	CTRL-X CTRL-D		宏定义 (包括包含文件里的)
	CTRL-X CTRL-I		当前文件以及所包含的文件
	CTRL-X CTRL-K		字典文件内的单词
	CTRL-X CTRL-T		同义词词典文件内的单词
	CTRL-X CTRL-]		标签
	CTRL-X CTRL-V		Vim 命令行

----------
- 补全文件名

----------
- 补全源代码
- 全能补全：
    CTRL-X CTRL-O

#### 24.4 重复一次插入 ####
- CTRL-A，编辑器就把你上次在插入模式下输入的文本再输入一次。
- CTRL-@ 命令会完成 CTRL-A 的操作后退出插入模式

#### 24.5 从另一行拷贝 ####
- CTRL-Y 命令插入光标上方的字符。
- CTRL-E 命令操作起来跟 CTRL-Y 一样，只不过它插入光标下方的字符。

#### 24.6 插入一个寄存器内容 ####
- 命令 CTRL-R {register} 插入寄存器里的内容。它的用处是让你不必键入长词。
- 把文件名摄入寄存器:
    e.g.    "vyiw   "v 指定寄存器，"yiw" 意思是拷贝一个词，不含空格
- 如果寄存器存放着诸如 <BS> 或其它特殊字符，这些字符就被解释成好像它们本来是从键盘键入的。如果你不要这样解释 (你确实要在文本中插入 <BS>)，那么要命令 CTRL-R CTRL-R {register}。

#### 4.7 缩写 ####
- Vim 让你键入缩写，然后为你自动扩展。
    e.g.    :iabbrev ad advertisement
- 键入一个不可能成为单词一部分的字符，例如一个空格，就会触发缩写功能

----------
- 多词缩写
    e.g.    :iabbrev JB Jack Benny

- 备注:   ":iabbrev" 有点嫌长。":iab" 作用也一样。

----------
- 更正打字错误
    e.g.    :abbreviate teh the

----------
- 缩写列表
    ":abbreviate" 命令列出所有缩写
    第一栏的字符:
        i   表明插入模式。             :iabbrev
        c	命令行模式                 :cabbrev
        !	插入模式和命令行模式        :abbreviate

----------
- 删除缩写
    :unabbreviate
    :abclear        删除全部缩写
- 变形：
    在插入模式下是 "iunabbreviate" 和":iabclear"
    在命令行模式下是 ":cunabbreviate" 和 "cabclear"。

----------
- 缩写再映射
- 定义缩写时，有一点要注意的: 扩展产生的字符串不应当被映射成别的什么。
- 用 ":noreabbrev" 命令。它的作用跟 ":abbreviate" 一样，但却避免了扩展产生的字符串被用于映射:
    e.g.    :noreabbrev @a adder

#### 24.8 插入特殊字符 ####
- CTRL-V 命令用来插入下一个字面意义上的字符。换言之，无论该字符多特殊，其特殊含义都被忽略不计。
- CTRL-V {digits} 来插入一个以若干个十进位数字 {digits} 表示的字符。例如，字符编码 127 是字符 <Del> (但并不一定是 <Del> 键！)。要插入 <Del>，键入: >
	CTRL-V 127
- 可以用这样的方法输入数值不超过 255 的字符。当你键入一个不足两位的数字时，就要添加一个非数字的字符来结束命令。为了回避这个非数字字符的要求，在它前面加一或两个零以满足三位数的要求。
- 输入一个 16 进制数字，在 CTRL-V 后面，用 "x" 开头
- 可以用 "o" 开头输入一个以 8 进制数表示的字符，以及另外两种方法，让你输入多至二进制 16 位和 32 位
的数字表示的字符 ：
    e.g.    CTRL-V o123     CTRL-V U12345678

#### 24.9 二合字母 ####
- 键入二合字母
    e.g.    CTRL-K Co
- 查找有哪些二合字母可供利用:
	:digraphs
- 可以交换两个字符的顺序，只要那样组合不代表另一个二合字母。
- 备注:二合字母表取决于 Vim 假定你所使用的字符集。
- 定义你自己的二合字母：
    e.g.    :digraph a" ä       :digraph a" 228

#### 24.10 普通模式命令 ####
- 用 CTRL-O {command} 你可以在插入模式下执行任何普通模式命令。

### usr_25.txt 编辑已经编排过的文本 ###
#### 25.1 断行 ####
- 设置了 'textwidth' 选项，Vim 就会自动插入换行符。
    e.g.    :set textwidth=30
- 备注: 'wrap' 选项会使 Vim 分行显示文本，但并不会在文件中插入换行符。

----------
- 重排文本
- Vim 编辑器并不是一个字处理器。字处理器在你删除了段落开头的一些东西时会重新调整换行符。(译者注: 这意味着后边的文本会向前补进，使换行位置保持不变)。可用 "gq" 操作符保持段落形状。
- 因为 "gq" 是一个操作符，所以你可以通过下面三种方法之一来选择要操作的文本范围:
    可视模式，一个移动操作，或是一个文本对象。
    e.g.    v4jgq    gq} 从当前光标处至当前段段尾所包括的文本进行排版操作
- 可以和 "gq" 一起使用的一个很有用的文本对象是段落:
    gqap    "ap" 意味着 "a-paragraph" (译者注: 一个段落)。这将对一个段落 (用空行隔开) 的文本进行排版操作。也包括在光标之前的部分。
- 如果你所有的段落都已经用空行分隔好了:
	gggqG
- 警告: 如果你的段落没有被正确的分隔开，它们将被连接在一起。一个常见的错误是文件内包含一些只有空格或制表符的行。这些是空白行，但不是空行。

#### 25.2 对齐文本 ####
- 行居中：
    :{range}center [width]
    {range} 即是那些通常命令所能指定的范围。 [width] 是一个可选项，用来确定要居中的行的宽度。如果没有指定 [width]，则默认使用 'textwidth' 的值。(如果'textwidth' 是 0，则默认为 80。)

----------
- 右对齐
- ":right" 命令将使文本右对齐
    e.g.    :1,5right 37

----------
- 左对齐
	:{range}left [margin]
    和 ":center" ":right" 不同的是，":left" 的参数并不是行的宽度，而是左边的页边距。如果这个参数被省略了，文本将被紧靠在屏幕的左边缘 

----------
- 两端对齐
- 没有提供内建的方法来使文本两端对齐。不过，我们可以通过使用一个灵巧的宏来做:
    :runtime macros/justify.vim
- 这个 Vim 脚本文件定义了一个新的可视命令 "_j"。要使一块文本两端对齐，只需在可视模式中选择该文本块，然后执行 "_j"。

#### 25.3 缩进和制表符 ####
- 置位 'autoindent' 选项可以自动插入缩进:
    :set autoindent

----------
- 增加缩进
- 要增加一行中的缩进量，可以使用 ">" 操作符。一个经常使用的操作是 ">>"，这将为当前行增加缩进。
- 增加的缩进量是使用 'shiftwidth' 来指定的。默认的值是 8。可设置:
	:set shiftwidth=4

----------
- 制表位
    :set softtabstop=4
- 把 'shiftwidth' 设置为 4。但是当你敲下 <Tab>键时，你仍然会得到八个空格宽度的缩进。可以：
    :set softtabstop=4
- 备注:你可以把 'tabstop' 选项设置为 4。尽管如此，如果你在另一个时间再次编辑这个文件时 'tabstop' 的默认值是 8，文件缩进看起来会不对。在其它程序中或者在打印的时候，缩进也将是错的。因此，建议把 'tabstop' 的值始终保持为 8。这是所有地方的标准值。

----------
- 更换制表位
- Vim 可以更换你文件使用的制表位。
    e.g.       :set tabstop=3
	           :retab 8
- 警告: 当你对一个程序文件使用 ":retab" 命令时，它可能会改变一个字符串常量中的空白。因此，要养成在程序中使用 "\t" 而不是输入一个制表符的好习惯。

#### 25.4 对长行的处理 ####
- 'wrap' 选项设置决定是否采用环绕显示
- Vim默认 并不在 GUI 中显示水平滚动条。可显示:
    :set guioptions+=b      出现在底部
- 用下面这些命令来滚动文本：
	zh		向右滚动
	4zh		向右滚动四个字符
	zH		向右滚动半个窗口宽度
	ze		向右滚动使光标处于行尾
	zl		向左滚动
	4zl		向左滚动四个字符
	zL		向左滚动半个窗口宽度
	zs		向左滚动使光标处于行首

----------
- 在关闭折行情况下移动
- 通过以下命令来使光标移动到你可以看到的一个字符处。这些命令不会使文本卷动:
	g0		移动到当前行的第一个可见字符
	g^		移动到当前行的第一个非空白的可见字符
	gm		移动到当前行的中点
	g$		移动到当前行的最后一个可见字符

----------
- 断词
- 使用 'nowrap' 选项的一个弊端是你看不见你正在处理的整个句子。当 'wrap' 选项开启时，会从单词中间断开，从而难以阅读。
- 编辑此类段落时，一个好的解决方法是设置 'linebreak' 选项。这样，Vim 将会在一个适当的地方回绕行显示，同时仍保持文件中的文本不变。
    :set linebreak

----------
- 在可见行间移动
- 使用 "gj" 和 "gk" 命令可以只移动一个屏幕行。当一行没有回绕时，它们和 "j"和 "k" 命令所起的作用一样。当一行回绕时，它们将在屏幕上显示的上一行和下一行的一个字符之间移动。
- 下面这些移动命令的键映射也许对你有用:
	:map <Up> gk
	:map <Down> gj

----------
- 变段为行
- 如果你的段落是由空行分隔开的，下面这个命令就可以要把一个段转化为一个单行:
	:g/./,/^$/join
        g/./		  一个 ":global" 命令，用来搜索至少含一个字符的所有行。
        ,/^$/	      一个范围，从当前行开始 (非空行) 到一个空行。
        join	       ":join" 命令把范围内的行连接成一行。
- 注意:当分隔段落的行是含有空格和/或制表符的空白行而不是空行时，这行命令将不起作用。下列的命令对于空白行仍起作用:
	:g/\S/,/^\s*$/join

#### 25.5编辑表格 ####
- 对于表格类型的编辑操作有一个特殊的选项:
    set virtualedit=all
- 现在你可以把光标移动到没有任何文本的位置。这叫做 "虚拟空间"。
- 备注:你可以把光标移动到窗口的任何地方，也可以超出行尾。但是，Vim 在你未在该位置插入字符之前并不会插入空格

----------
- 拷贝一列
- 返回到光标的非虚拟移动模式:
    :set virtualedit=

----------
- 虚拟替换模式
- 使用 'virtualedit' 的弊端是你会 "感觉" 不太一样。当你移动光标的时候，你不能分辨超出行尾的制表符或空格。另一种可行的方法是: 虚拟替换模式。
-  "gr" 命令确保了新字符占据了正确的屏幕空间。额外需要的空格或制表符被插入到间隙中。
- "gR" 使用虚拟替换模式。这保全了版面布局

### usr_26.txt 重复 ###
#### 26.1 可视模式下的重复 ####
- "gv" 命令再次选择上次选过的文本，让你对同一段文本再作别的修改。

#### 26.2 加与减 ####
- CTRL-A 加一
- 可以在 CTRL-A 之前附加数字来增加一个大于一的数。
- Vim 根据首位出现的 "0" 而误以为 "007" 是个八进位数字。不要首位为 "0" 的数字被处理成八进位数字：
	:set nrformats-=octal
- CTRL-X 命令用于减数字，用法与加数字类似。

#### 26.3 改动多个文件 ####
- 把所有相关文件放进参数列表:
	:args *.c
- 对所有这些文件执行替代命令:
	:argdo %s/\<x_cnt\>/x_counter/ge | update          "x_cnt" 而你要把他改为 "x_counter"
    用 "\<x_cnt\>" 来查找 "x_cnt"。"\<" 和 "\>" 用来指定仅匹配那些完整的词
    "update" 命令将那些有改动的文件存盘。

- ":windo" 命令，用于在所有窗口内执行其参数所规定的命令。以及 ":bufdo"命令，对所有缓冲区执行其参数所规定的命令。

#### 26.4 在 shell 脚本里使用 Vim ####
- 可以用Ex 模式(命令行 (:) 命令的另一个名称)或是写入".vim"脚本中

----------
- 从标准输入读取
- 需要在通常是文件名的地方传送一个参数 "-"
    e.g.    ls | vim -      编辑 "ls" 命令的输出结果

----------
- 普通模式脚本
- 要在脚本内利用普通模式命令:
    e.g.    vim -s script file.txt ..
- 注意:当 "-s" 不与 "-e" 一起用时，它的意思是不同的。此时，它的意思是把文件"script" 里的命令当作普通模式命令来执行。而与 "-e" 一起用时，它的意思是保持安静，并不会把下一个参数视为文件名。

- 另一种方法是在你手动执行那些命令时把它们记录下来。
    e.g.    vim -w script file.txt ..
- 参数 "-w" 会将新键入的命令附加在一个已存在的脚本文件末尾。这在你需要一点儿一点儿记录该脚本时是很不错的。但当你要从零开始重新记录你的脚本时，你则需要用"-W" 参数。该参数重写任何已存在的文件。

### usr_27.txt 查找命令及模式 ###
#### 27.1 忽略大小写 ####
- 查找忽略大小写敏感。设定 'ignorecase' 选项:
    :set ignorecase
- 撤销这个选项:
    :set noignorecase

- 设定 'smartcase' 选项:
    :set ignorecase smartcase
- 如果你采用的模式里至少有一个大写字母，查找就成了大小写敏感的。可以这样理解，你不必键入大写字母，也能查找到含有大写字母的词，所以，你若键入大写字母，必然是因为你要大小写敏感的匹配。

----------
- 单个模式里的大小写
- 忽略一个特定的模式里的大小写，那么，在模式前添加 "\c" 字符串就行了。添加 "\C" 将使该模式的匹配大小写敏感。
- 这个设置项排除了 'ignorecase' 和 'smartcase' 选项的影响

- 备注:在查找模式中使用以 "\" 开头的项，其效果取决于 'magic' 选项。

#### 27.2 在文件尾折返 ####
- 检查是否越过了该位置。一种办法是设定 'ruler' 选项:
    :set ruler
- 查找：
    n   正向
    ?   反向

----------
- 无折返查找
- 取消查找折返功能:
    :set nowrapscan

#### 27.3 偏移 ####
- 在正向查找命令 "/" 中指定偏移，就是在模式后面附加一个斜线符 (/) 以及偏移值: 
    /默认/2
- 如果该偏移为一简单数字，那么光标就会被放置在距离匹配那么多行的那一行的行首。该偏移值可为正数或负数。如

----------
- 字符偏移
- 偏移符 "e" 表示一个偏移从匹配末尾算起。它把光标移到匹配的最后一个字符上。
    e.g.    /const/e
- 加一个数字，光标就从该位置再移动该数字指定的那么多个字符。
    e.g.    /const/e+1
            /const/e-1

- 如果偏移以 "b" 开头，那么光标就移到匹配模式的首位。因为不用 "b" 光标也一样会被移到首位，所以单独使用时没什么意义。
    e.g.    /const/b+2

----------
- 重复
- 重复前一次使用过的查找模式，只是偏移不同时，你可以把模式省略
- 样的偏移重复查找: 
    /
- 命令 "n" 具有同样的作用。要取消一个以前用过的偏移可以用:
    //

----------
- 反向查找
- 命令 "?" 以相同的方式使用偏移，但你必须以 "?" 来分隔模式和偏移，而非 "/":
	e.g.   ?const?e-2

----------
- 起始位置
- 查找时，通常从光标位置开始。当你规定的是一个行偏移，这可能造成麻烦。
- 当你规定的是一个字符偏移，Vim 将为其作调整。因此，查找会向前或向后跳过几个字符再开始，以便同一个匹配不至于再出现。

#### 27.4 匹配重复性模式 ####
- 星号项 "*" 规定在它前面的项可以重复任意次。
- 如要多次重复整个字符串，那么该字符串必须被组成一个项。组成一项的方法就是在它前面加 "\("，后面加 "\)"
- 要避免匹配空字串，使用 "\+"
- 要匹配一个可选项，用 "\="
    e.g.    /folders\=      匹配 "folder" 和 "folders"

----------
- 指定重复次数
- 匹配某一项的特定次数重复，使用 "\{n,m}" ,在它前面的那个项将被重复 "n" 到 "m" 次

- 匹配尽可能少的字符
- 若要匹配尽可能少的字符，请用"\{-n,m}"
    e.g.    /ab\{-1,3}      匹配 "abbb" 中的 "ab"

- "\{-}"。这个项匹配其前项的重复，重复次数尽可能少，可以等于或大于零。这个项如单独使用，则总是匹配前项的零次重复。当它跟与其它的模式合起来时:
    e.g.    /a.\{-}b        匹配 "axbxb" 中的 "axb"

#### 27.5 多择一 ####
- 在一个查找模式中，"或" 运算符是 "\|"。
- 如要匹配其多次重复，那么整个抉择结构须置于 "\(" 和 "\)" 之间

- 类似的"\&"。它要求两个抉择都与同一位置的文本相符。而最终匹配的则是最后面的那个抉择。
    e.g.    /forever\&...       匹配 "forever" 中的 "for"

#### 27.6 字符范围 ####
- 方括号结构 [] 匹配单个字符。
    e.g.    /[a-z]

- 若要匹配字符 "-" 本身，就得把它放在字符范围的第一或最后的位置上。

----------
- 范围求反
- 为了避免匹配到一个特定的字符，在字符范围首位使用 "^"。这样方括号项 [] 就会匹配任何括号内不包括的字符。
    e.g.    /"[^"]*"

----------
- 预定义范围
- 字符范围:
	项	匹配			        相当于
    \a  字母字符            [a-zA-Z]
	\d	数位			       [0-9]
	\D	非数位			   [^0-9]
	\x	十六进制数位		   [0-9a-fA-F]
	\X	非十六进制数位	   [^0-9a-fA-F]
	\s	空白字符		       [ 	]           (<Tab> 和 <Space>)
	\S	非空白字符		   [^ 	]           (非 <Tab> 和 <Space>)
	\l	小写字母		       [a-z]
	\L	非小写字母		   [^a-z]
	\u	大写字母		       [A-Z]
	\U	非大写字母		   [^A-Z]

- 备注:这些项不能用于 [] 方括号内。因此 "[\d\l]" 不能用来匹配一个数字或一个小写字母。请换用 "\(\d\|\l\)"。

#### 27.7 字符类 ####
- 一个字符类与字符范围相似，不过有个本质的区别: 一个字符类代表的那组字符可以重新定义而无须改动查找模式。
- 文件名字符由 'isfname' 选项来规定。在 Unix 上，该选项的默认值为:
	:set isfname
- 备注:实际上，Unix 允许在文件名里使用几乎所有的字符，包括空格字符。把这些字符包括在 'isfname' 里，在理论上是没错的。但那样就无法在文本中发现一个文件名在哪儿结束。因此选项 'isfname' 的默认值是个折衷方案。
- 字符类有如下这些:
	项	匹配				               选项
	\i	标识符字符			        'isident'
	\I	类似于 \i，但不包括数字字符
	\k	关键词字符			        'iskeyword'
	\K	类似于 \k，但不包括数字字符
	\p	可显示字符			        'isprint'
	\P	类似于 \p，但不包括数字字符
	\f	文件名字符			        'isfname'
	\F	类似于 \f，但不包括数字字符

#### 27.8 匹配换行符 ####
- 用 "\n" 项可以在一个特定的位置查验一个换行符
    e.g.    /the\nword
- 如果还要匹配 "the word"，那么你需要匹配一个空格或一个换行符。这可以用 "\_s" 表示:
    e.g.    /the\_sword
- 若要允许任意数量的空格:
    e.g.    /the\_s\+word
- "\s" 匹配空格字符，"\_s" 匹配空格字符或一个换行符。同理，"\a" 匹配一个字母字符，而 "\_a" 匹配一个字母字符或一个换行符。其它字符类和字符范围都可以通过插入一个 "_" 来更改其范围。
- 备注:"\_.*" 匹配任何字符，直至文件结束。要小心，它会使查找命令执行得非常缓慢。
- "\_[]"，一个包含了换行符的字符范围
    e.g.    /"\_[^"]*"      找寻位于一对双引号之间，可能分隔成数行的文本。

#### 27.9 举例 ####
- 备注:"\<" 和 "\>" 取决于 'iskeyword' 选项。如果这个选项包括 "-" 的话，那么"ident-" 就不匹配了。

### usr_28.txt 折叠 ###
#### 28.1 什么是折叠？ ####
#### 28.2 手动折叠 ####
- 创建折叠
    zf
- 打开折叠:
    zo
- 关闭折叠:
    zc
- 减少折叠:
    zr
- 折叠更多:
    zm
- 全部打开:
    zR
- 关闭所有:
    zM
- 快速禁止折叠:
    zn
- 恢复原来折叠:
    zN
- 切换于两者间:
    zi

#### 28.3 对折叠的操作 ####
- 可以向对待单行一样复制，删除和粘贴折叠。
- 要查看那些已定义的折叠:
	:set foldcolumn=4      这个命令将在窗口左边显示一小栏来标识各个折叠
- 打开所有光标行上的折叠用 zO 
- 关闭所有光标行上的折叠用 zC
- 删除一个光标行上的折叠用 zd
- 删除所有光标行上的折叠用 zD

- 'foldopen' 选项可以修改，为指定的某一类命令打开折叠。
    e.g.    :set foldopen=all
- 临时用一用这个命令，然后把它设回默认值:
	:set foldopen&
- 在移开折叠时自动关闭折叠:
	:set foldclose=all

#### 28.4 存储和恢复折叠 ####
- 保存折叠:
    :mkview
- 稍后回到同一文件时，你可以重新载入这个视图:
    :loadview
- 你可以为一个文件储存多至十个视图
    e.g.    :mkview 3   :loadview 2

#### 28.5 依缩进折叠 ####
- 缩进折叠的方法。这将为每一系列有相同缩进的行创建一个折叠。缩进较多的行将成为嵌套的折叠。
- 设定 'foldmethod' 选项:
	:set foldmethod=indent
- 缩进多少和折叠深度之间的关系倚赖于 'shiftwidth' 选项。
- 使用 |zr| 和 |zm| 命令时，你实际上是在增加或减少 'foldlevel' 选项。你也可以直接设置它:
	:set foldlevel=3

- 有两种方法开启和关闭折叠:
    1. 设定折叠级别。
    这提供了一种极快的 "缩小" 方法来查看文本结构，移动光标，以及重新 "放大" 到具体的文本。
    2. 利用 |zo| 和 |zc| 命令打开和关闭指定的折叠。
    这个方法允许你仅仅打开那些你要打开的折叠，而不影响其它的折叠。

#### 28.6 依标志折叠 ####
- 标志折叠可以精确地控制一个折叠究竟包含哪些行文本。缺点是文本需要改动。
    :set foldmethod=marker
- 每一个编号标志表示一个编号指定级别的折叠的开始。这将使任何较高层次的折叠在此结束。你可以只用编号标志的开始符定义所有的折叠。只有当你要明确地在另一个开始前结束一个折叠时，你才需要加一个标志停止符。

#### 28.7 依语法折叠 ####
- 在语法文件中，你可以加入一些带有 "fold" 参数的语法项。这些语法项将定义折叠区。这要求写一个语法文件，把这些项目加入其中。

#### 28.8 依表达式折叠 ####
- 表达式折叠类似于缩进折叠，但并非利用文本行的缩进，而是调用一个函数来计算一行的折叠级别。当文本的一部分表明那些行属于同一组时，你可以使用这个方法。
    e.g.    :set foldmethod=expr
	        :set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^>].*','',''))

#### 28.9 折叠未被改动的行 ####
- 当你在同一窗口也设定 'diff' 选项时，这种折叠方法就很有用。

#### 28.10 使用哪种折叠办法呢？ ####

### usr_29.txt 在代码间移动 ###
#### 29.1 使用标签 ####
- ":tags" 命令显示你经过的标签列表
- CTRL-T 命令跳转到上一个标签。
-  tag命令接受一个计数参数，用来表示跳转回去的标签个数。CTRL-T 同样可以加上一个计数参数。
    e.g.    :3tag

----------
- 分割窗口
- ":tag" 命令会将当前窗口的文件替换为包含新函数的文件。时查看新旧两个文件:
	:stag tagname
- 分割当前窗口并跳转到光标下的标签:
    CTRL-W ]

----------
- 多个标签文件
- 过设定 'tags' 选项，你可以使用多个相关的标签文件。
    e.g.    :set tags=./tags,./../tags,./*/tags

----------
- 单个标签文件

----------
- 多个匹配
- 跳转到同一个标签的其它匹配处：
    :tnext
- 如果存在很多匹配，你可以选择要跳转到哪一个：
	:tselect tagname
- 这些命令在各匹配的标签间移动：
	:tfirst			     到第一个匹配
	:[count]tprevious	 向前 [count] 个匹配
	:[count]tnext		 向后 [count] 个匹配
	:tlast			     到最后一个匹配

----------
- 猜测标签名
- 命令行补全
- 标签名前面的 "/" 告诉 Vim 这不是一个确定的标签名而是一个模式。
    e.g.    :tselect /^write_

----------
- 标签浏览器
- 可以利用标识符的列表来形成一个目录。

----------
- 相关杂项
- 'tagbsearch' 选项标明标签文件是否经过排序。缺省是假定为标签文件已排序
- 'taglength' 选项可用来告诉 Vim 标签的有效字符个数。

#### 29.2 预览窗口 ####
- 打开一个预览窗口来显示函数
    e.g.    :ptag write_char
- 关闭预览窗口：
	:pclose
- 在预览窗口中编辑一个指定的文件：
    :pedit
- 查找当前文件和任何包含文件中的单词并在预览窗口中显示匹配:
    :psearch
- 用 'previewheight' 选项指定预览窗口打开时的高度。

#### 29.3 在代码间移动 ####
- 在一个 "#ifdef" - "#endif" 块内的某个位置，你可以用下面的命令回到开始处：
	[#
- 跳转到下一个 "#else" 或 "#endif"：
	]#
- 如果光标在最后一行，"[#" 会移动到第一行。中间的 "#ifdef" - "#endif" 块被跳过。

----------
- 在代码块内移动
- 要跳转到外部代码块的开始处，用 "[[" 命令。用 "][" 找到结尾处。
-  "[{" 命令跳转到当前代码块的开始处。它会跳过同一级别的 {} 对。"]}" 跳转到结尾。
- 当编写 C++ 或 Java 代码时，外部代码块是类，而下一级的 {} 是方法。在类内部用"[m" 可以找到前一个方法的开始。"]m" 会找到下一个方法的开始。
- "[]" 反向移动到前一个函数的结尾，"]]" 正向移动到下一个函数的开始。函数的结尾指的是处在第一列的 "}"。
- 可以用 "%" 在匹配的 ()、{} 和 [] 间移动。

----------
- 在括号内移动
- "[(" 和 "])" 命令与 "[{" 和 "]}" 类似，只不过它们适用于 () 对而不是 {} 对。

----------
- 在注释间移动
- 移动到一个注释的开始用 "[/"；向前移动到注释的结尾用 "]/"。这只对 /* - */ 注释有效。

#### 29.4 查找全局标识符 ####
- 想要知道一个变量是被声明为 "int" 还是 "unsigned"。一个快速的方法是使用 "[I" 命令来查找。

----------
- 定位包含文件
- 查看path路径
    :checkpath
    它会列出不能找到的包含文件，以及被找到的包含文件。
- 如果你的工程项目的包含文件都在一个嵌套的目录树下，"**" 就非常有用。它会搜索所有的子目录。
- 查看找到的包含文件：
    :checkpath!

----------
- 跳转到匹配
- "[I" 产生一个每项只有一行文本的列表。如果你想要进一步地查看第一项：
    [<Tab>  或   [ CTRL-I
- "[I" 产生的列表在每行的开头都有一个序号
    e.g.    3[<Tab>

----------
- 相关命令
	[i		只列出第一项匹配
	]I		只列出光标下面的项目
	]i		只列出光标下面的第一项匹配

----------
- 查找宏定义标识符
- 只查找 "#define" 定义的宏，用：
    [D
- "[D" 相关命令：
	[d		只列出第一项匹配
	]D		只列出光标下面的项目
	]d		只列出光标下面的第一项匹配

#### 29.5 查找局部标识符 ####
- 要在当前文件中查找并跳转到光标处单词被首次使用的地方，用：
	gD     提示：Goto Definition。
- 只在当前函数内查找:
    gd

### usr_30.txt 编辑程序 ###
#### 30.1 编译 ####
- Vim 有个 "quickfix" 命令集。通过这些命令，你可在 Vim 内编译程序并能直接跳转到出错位置进行修正。你可以接着重新编译并做修正，直到不再出错为止。
- 运行 "make"
    :make {arguments}
- 回到上一个错误:
	:cprevious
- 光标移到下一个错误所在的行：
	:cnext
- 有时由于空间不够，Vim 会缩短出错信息。如果你想查看详细信息:
    :cc
- 通过 ":clist" 命令得到一个有关所有出错信息的概览:
	:clist
- 要查看所有信息，在命令后加上 "!" :
    e.g.    :clist!
- 一些其它的跳转命令：
	:cfirst		到第一处错误
	:clast		到最后一处错误
	:cc 3		到第三处错误

----------
- 指定编译器
- 通过 'makeprg' 选项可以指定 ":make" 命令启动的程序名。
    e.g.    :set makeprg=nmake
- 可以对这个选项指定参数。
    e.g.    :set makeprg=nmake\ -f\ project.mak
- 可以使用特殊的 Vim 内部关键字。
    e.g.    :set makeprg=make\ %:r.o     用 '%' 来代替当前文件名     = make main.o 

----------
- 旧的出错信息列表
- 查看上一个出错信息列表：(即使没有重编)
    :colder
- 可以通过 ":clist" 和 ":cc {nr}" 命令来跳转到出现警告的地方。
- 要查看下一个出错列表：
	:cnewer
- Vim 可以记住十个出错信息列表。

----------
- 更换编译器
- 需要告诉 Vim 所使用编译器产生的错误信息格式。这可以通过'errorformat' 来设定。
- 尤其是 'errorformat'选项是很繁杂的。为此，Vim 提供一个简便的方法。
    e.g.    :compiler msvc

----------
- 输出重定向
- 如果你的 ":make" 命令不能捕获输出，请检查 'makeef' 和'shellpipe' 选项。选项 'shellquote' 和 'shellxquote' 可能也会起作用。

#### 30.2 C 文件缩进 ####
- 要对 C 或 C 风格如 Java 或 C++ 的程序缩进，请设定 'cindent' 选项。通过 'shiftwidth' 选项，你可以指定下一级的缩进空格数。
    e.g.    :set cindent shiftwidth=4
- 当你的代码没有被正确地排版，或者你插入或删除了某些行时，你需要重新进行代码缩进。操作符 "=" 能完成这项功能，最简单的格式是：
    ==      缩进当前行。
- 重新缩进光标所在代码块：
	=a{
- 重新缩进整个文件：
	gg=G

----------
- 设定缩进风格
- 如果你想使用其它的风格，你可以通过 'cinoptions' 选项来设定。
    e.g.    :set cinoptions+={2     使大括号的缩进向右偏移2格

#### 30.3 自动缩进 ####
- 自动化缩进：
    :filetype indent on
- 关闭自动化缩进：
    :filetype indent off
- 不想为某种特定类型的文件进行缩进：
    1. 建一个只包括下行的文件：    :let b:did_indent = 1
    2. 将其重命名为：              {directory}/indent/{filetype}.vim   {filetype} 是文件类型的名字,对 {directory} 部分，你需要根据你的运行时目录来设定,可通过    set runtimepath 查看输出

#### 30.4 其它缩进 ####
- 最简单的自动缩进通过 'autoindent' 选项来完成，它会延续上一行的缩进。
- 稍微聪明点的是 'smartindent'，这个选项对那些没有缩进文件可用的编程语言很有用。
- 如果 'smartindent' 被设定，会在每个 '{' 处新增一级缩进，并在每个 '}' 处消减。另外，对于 'cinwords' 选项所设定的所有单词也会添加新一级的缩进。所有以 '#'开始的行都会被特殊处理：所有缩进都被清除。

----------
- 修正缩进
- 需要添加或删除一个 'shiftwidth' 宽度的缩进。一个快速的方法是在插入模式下利用 CTRL-D (删除缩进) 和 CTRL-T (增加缩进) 命令。
- 在普通模式下，你可以用 ">>" 和 "<<" 命令来完成缩进的修正。'>' 和 '<' 是操作符，因此你可以使用通常的那三种方式来指定你要缩进的行。一个有用的组合是：
	\>i{           缩进当前 {} 区内的行，'{' 和 '}' 本身并不被缩进。

#### 30.5 制表符和空格 ####
- 'tabstop' 在缺省状态下被设定为 8。最好还是保留 'tabstop' 值不变。

----------
- 混合使用空格和制表符
- 通过设定 'softtabstop' 可以使工作变得更简便。这个选项能使 <Tab> 看起来像是被设定为 'softtabstop' 所指定的值，但实际上使用的确是制表符和空格的组合。
    e.g.    :set softtabstop=4
- <BS> 键总是删除 'softtabstop' 指定的数量。

- 另一种方法是使用 'smarttab' 选项。当它被设定，Vim 对每个在缩进行中的制表符使用'shiftwidth'，而对在第一个非空字符后输入的 <Tab> 使用真的制表符。
- <BS> 键不会像在 'softtabstop' 选项下那样工作。

----------
- 只用空格
- 不想在文件中出现制表符：
    :set expandtab
- 退格键 (<BS>) 每次只能删除一个空格。输入 CTRL-D 会更快些。

----------
- 制表符与空格的相互转换
- 想将制表符转换为空格，可以用 ":retab" 命令。
	:set expandtab
	:%retab
- 所有非空字符后的制表符不会受到影响
    :%retab!
- 空格转化为制表符的命令则恰好相反：
	:set noexpandtab
	:%retab!

#### 30.6 排版注释格式 ####
- 将光标定位到注释开头，然后排版这段注释:
    gq]/        "gq" 是用来排版文本的操作符。"]/" 是移动到注释尾的动作。
- 外一种方法是在可视模式下用 "gq" 排版选中的文本。
- 要使用这些功能，你必须在 'formatoptions' 选项中指定一些标志位：
	r	在插入模式下，输入回车时插入星号。
	o	在普通模式下，使用 "o" 或 "O" 时插入星号。
	c	根据 'textwidth' 将注释分行。

----------
- 定义注释
- 'comments' 选项可以定义注释的样式。Vim 可以分辨单行注释和那些包含开头，中间，结尾三部分的注释。
    e.g.    :set comments=://
- 'comments' 的一般格式是：
	{flags}:{text}
- 不同的条目可以连接在一起，用逗号隔开。
    e.g.    :set comments=n:>,n:!       个识别以 ">" 开头的注释，一个识别以 "!" 开头的注释。两个都设定了 "n" 标志位，这意味着注释可以嵌套。

----------
- 包括三部分的注释
- C语言注释:
    :set comments=s1:/*,mb:*,ex:*/
    开始部分用 "s1:/*" 定义。"s" 表示三部分注释的开始。冒号将标志位与代表注释的特殊字符 "/*" 分开。这里有一个标志位 "1"。它指明注释的中间部分有一个空格位置的偏移。
    "mb:*" 的 "m" 表示这是注释的中间部分。"b" 标志位表示星号后要有空格。否则Vim 会将形如 "*pointer" 的语句视为某个注释的中间部分。
    "ex:*/" 中的 "e" 表示注释的结尾。"x" 标志位表示在 Vim 自动插入星号后，输入"/" 会删除多余的空格。

### usr_31.txt 利用 GUI ###
#### 31.1 文件浏览器 ####
- 窗口分割并编辑另一个文件
    :browse split
- 用 'browsedir' 选项可以改变浏览的启动目录。可能的选项值包括:
	last		使用上次的目录 (缺省)
	buffer		使用当前缓冲区所在的目录
	current		使用当前目录

#### 31.2 确认 ####
- ":confirm" 命令也可以被加在多数编辑其它文件的命令之前。

#### 31.3 菜单快捷键 ####
- 使用 <Alt> 键来操作菜单和使用 <Alt> 键的映射会出现冲突。'winaltkeys' 可以用来告诉 Vim 如何对待 <Alt> 键。
- 缺省值 "menu" ：如果该键组合是一个菜单快捷键那么就不能被作为映射。所有其它的键都可以。
- "no" 表示不使用 <Alt> 键组合来操作菜单。
- "yes" 表示 Vim 会使用 <Alt> 键组合来操作菜单。

#### 31.4 Vim 窗口位置及大小 ####
- 查看当前 Vim 窗口在屏幕上的位置:
    :winpos
- 备注:报告的窗口位置和窗口被移动的位置可能会有小的出入。这是由窗口周围的边框引起的。边框是被窗口管理器加上的
- Vim 窗口的大小是以字符数目计算的。因此它和所使用的字体的大小有关。查看当前的窗口大小:
	:set lines columns
- 改变窗口大小只要改变 'lines' 和/或 'columns' 选项的值:
	:set lines=50
	:set columns=80
- {width} 和 {height} 的单位是字符。{x_offset} 和 {y_offset} 的单位是像素

#### 31.5 杂项 ####
- gvim"-f" 参数代表前台。这样 Vim 就会挂起它启动所在的 shell，直到你编辑完毕并退出为止。

----------
- 推迟启动GUI
    :gui -f

----------
- GVIM启动文件
- 当 gvim 启动时，它会读取 gvimrc 文件。
- 如果出于某种原因你不想使用通常的 gvimrc 文件，你可以利用 "-U" 参数来指定另外的一个:
    gvim -U thisrc ...
- 要完全跳过读取 gvimrc 文件:
	gvim -U NONE ...

### usr_32.txt 撤销树 ###
#### 32.1 撤销到文件写入时的状态 ####
- 恢复到最近写入文件时的状态:
    :earlier 1f
- 往前:
    :later 1f

#### 32.2 为每次改变进行编号 ####
- 当你撤销了一些改变，又进行了一些新的改变，新的改变构成了撤销树的一个分支。
- 可以用 |u| 命令来撤销。
- 用 |CTRL-R| 来重做
- 注意:只有改变被编号，上面显示的文本没有标识符。通常，通过它上方的改变号来引用它。但有时也通过他下方的某个改变之一来引用。

#### 32.3 撤销树内任意跳转 ####
- 用 |:undo| 命令可以跳转到树内任何改变之下的文本。
    e.g.    :undo 2
- 用 |g-| 命令。它在时间点上往后退，也就是说，它不是在树内上下移动，而是回到之前所在的改变。
- 用 |g+| 时间点上往前进
- 可以在 |g-| 和 |g+| 之前加上计数来重复执行。

#### 32.4 时间旅行 ####
- 要看撤销树里有什么分支:
    :undolist       可以看到每个分支上叶结点的编号，还有改变发生的时间。
- :earlier 命令参数可以用"m" 代表分钟，"h" 代表小时，"d" 代表天。
    e.g.    :earlier 10s        回到十秒前
- 要 (再次) 进入未来世界，用 :later 命令:
	:later 1m
- 要看到更多的细节，或者要对信息进行操作，可以用 |undotree()| 函数。要看看它返回什么:
	:echo undotree()


----------
- 以下内容比较冗杂价值不大，故暂不阅读

----------

### usr_40.txt 创建新的命令 ###
### usr_41.txt 编写 Vim 脚本 ###
### usr_42.txt 添加新的菜单 ###
### usr_43.txt 使用文件类型 ###
### usr_44.txt 自定义语法高亮 ###
### usr_45.txt 选择你的语言 ###

## 让 vim 工作 ##
### usr_90.txt 安装 vim ###








