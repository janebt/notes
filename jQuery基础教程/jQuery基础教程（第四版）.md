# jQuery基础教程（第四版）

# 第1章 jQuery入门

## 1.1 jQuery能做什么

仅就其核心特性而言，jQuery能够满足下列需求。

- **取得文档中的元素。**
- **修改页面的外观。**跨浏览器
- **改变文档的内容。**
- **响应用户的交互操作。**jQuery提供了截获形形色色的页面事件的适当方式
- **为页面添加动态效果。**
- **无需刷新页面从服务器获取信息。**jQuery通过消除Ajax的复杂性
- **简化常见的JavaScript任务。**例如迭代和数组操作等

## 1.2 jQuery为什么如此出色

为了在维持各种特性的同时仍然保持紧凑的代码，jQuery采用了如下策略。

- **利用CSS的优势。**将查找页面元素的机制构建于CSS选择符之上
- **支持扩展。**为了避免特性蠕变（feature creep），jQuery将特殊情况下使用的工具归入插件当中。
- **抽象浏览器不一致性。**
- **总是面向集合。**被设计成自动操作对象集合，而不是单独的对象，称作隐式迭代（implicititeration）的技术
- **将多重操作集于一行。**为了避免过度使用临时变量或不必要的代码重复，jQuery在其多数方法中采用了一种称作连缀（chaining）的编程模式。这种模式意味着基于一个对象进行的多数操作的结果，都会返回这个对象自身，以便为该对象应用下一次操作。

## 1.3 第一个jQuery驱动的页面

### 1.3.1 下载jQuery 

### 1.3.2  本书使用jQuery的哪个版本

为了确保在现代浏览器中速度更快，代码更简洁，jQuery从2.0版开始不再支持IE6、IE7和IE8。

> 如果项目中有针对jQuery 1.9之前的版本编写的代码，可以使用jQuery迁移插件（http://jquery.com/upgrade-guide/1.9/#jquery-migrate-plugin）实现与jQuery 1.10兼容。

### 1.3.3  在HTML文档中引入jQuery

紧随常规的HTML开头代码之后的是加载样式表文件的代码。

在引用样式表文件的代码之后，是包含JavaScript文件的代码。注意的是，引用jQuery库文件的`<script>`标签，必须放在引用自定义脚本文件的`<script>`标签之前。否则，在我们编写的代码中将引用不到jQuery框架。

### 1.3.4  编写jQuery代码

#### 1. 查找诗歌文本

jQuery中基本的操作就是选择文档中的某一部分，这是通过$()函数来完成的。通常，该函数需要一个字符串参数，参数中可以包含任何CSS选择符表达式。

#### 2. 加入新类

.addClass()方法，它会将一个CSS类应用到我们选择的页面元素。这个方法唯一的参数就是要添加的类名。

其反方法.removeClass()

#### 3. 执行代码

$()和.addClass()单独插入文档的头部，不会有任何效果。通常，JavaScript代码在浏览器初次遇到它们时就会执行，而在浏览器处理头部时，HTML还不会呈现样式。因此，我们需要将代码延迟到DOM可用时再执行。

通过使用$(document).ready()方法，jQuery支持我们预定在DOM加载完毕后调用某个函数，而不必等待页面中的图像加载。涉及如下功能：

- 尽可能使用浏览器原生的DOM就绪实现，并以window.onload事件处理程序作为后备；
- 可以多次调用$(document).ready()并按照调用它们的顺序执行；
- 即便是在浏览器事件发生之后把函数传给$(document).ready()，这些函数也会执行；
- 异步处理事件的预定，必要时脚本可以延迟执行；
- 通过重复检查一个几乎与DOM同时可用的方法，在较早版本的浏览器中模拟DOM就绪事件。

.ready()方法的参数可以是一个已经定义好的函数的引用，也可以接收一个匿名函数。

### 1.3.5  最终结果

## 1.4  纯JavaScript与jQuery

## 1.5 使用开发工具

## 1.6 小结



# 第2章 选择元素

## 2.1  理解DOM 

## 2.2  使用$()函数

$()函数接受CSS选择符作为参数，返回包含页面中对应元素的jQuery对象。

3种基本的选择符：标签名、ID和类。

| 选  择  符 | CSS            | jQuery           | 说 明                    |
| ------- | -------------- | ---------------- | ---------------------- |
| 标签名     | P {}           | $('p')           | 取得文档中所有的段落             |
| ID      | #some-id {}    | $('#some-id')    | 取得文档中ID为some-id的一个元素   |
| 类       | .some-class {} | $('.some-class') | 取得文档中类为some-class的所有元素 |

在将方法连缀到$()工厂函数后面时，包装在jQuery对象中的元素会被自动、隐式地循环遍历。换句话说，这样就避免了使用for循环之类的显式迭代

## 2.3  CSS选择符

> ### 渐进增强
>
> 负责任的jQuery开发者应该在编写自己的程序时，始终坚持渐进增强（progressive enhancement）和平稳退化（graceful degradation）的理念，做到在JavaScript禁用时，页面仍然能够与启用JavaScript时一样准确地呈现，即使没有那么美观。

### 基于列表项的级别添加样式

嵌套的无序列表只有顶级的项水平排列；

```javascript
$(document).ready(function() { 
	$('#selected-plays > li').addClass('horizontal'); 
});
```

子元素组合符（>）：含义是查找ID为selected-plays的元素（#selected-plays）的子元素（>）中所有的列表项（li）。

要为其他项（非顶级的项）添加样式，有很多种方式。一种方式，就是使用否定式伪类选择符来识别没有horizontal类的所有列表项。

```javascript
$(document).ready(function() { 
    $('#selected-plays > li').addClass('horizontal'); 
    $('#selected-plays li:not(.horizontal)').addClass('sub-level'); 
}); 
```

## 2.4 属性选择符

属性选择符通过HTML元素的属性选择元素

```javascript
//例如，要选择带有alt属性的所有图像元素，可以使用以下代码：
$('img[alt]')
```

### 为链接添加样式

属性选择符使用一种从正则表达式中借鉴来的通配符语法，以^表示值在字符串的开始，以$表示值在字符串的结尾。而且，也是用星号*表示要匹配的值可以出现在字符串中的任意位置，用叹号!表示对值取反。

```javascript
//用来寻找所有带href属性（[href]）且以mailto开头（^="mailto:"]）的锚元素（a）
$(document).ready(function() { 
	$('a[href^="mailto:"]').addClass('mailto'); 
}); 
```

要为所有指向PDF文件的链接添加类，需要使用美元符号（$）而不是脱字符号（^）。这是因为我们要选择所有href属性以.pdf结尾的链接

```javascript
$(document).ready(function() { 
    $('a[href^="mailto:"]').addClass('mailto'); 
    $('a[href$=".pdf"]').addClass('pdflink'); 
});
```

属性选择符也可以组合使用。

## 2.5 自定义选择符

> ### 性能提示 
>
> 只要可能，jQuery就会使用浏览器原生的DOM选择符引擎去查找元素。但在使用自定义选择符的时候，就无法使用速度最快的原生方法了。建议在能够使用原生方法的情况下，就不要频繁地使用自定义选择符，以确保性能。

自定义选择符的语法与CSS中的伪类选择符语法相同，即选择符以冒号（:）开头。

### 2.5.1 每隔一行为表格添加样式

jQuery库中的两个十分有用的自定义选择符是:odd和:even。

```javascript
$(document).ready(function() { 
	$('tr:even').addClass('alt'); 
}); 
```

注意：:eq()选择符、:odd和:even选择符都使用JavaScript内置从0开始的编号方式

如果一个页面上存在另外一个表格，会有影响，解决这个问题的一种方法是使用:nth-child()选择符。这个选择符相对于元素的父元素而非当前选择的所有元素来计算位置，它可以接受数值、odd或even作为参数

```javascript
$(document).ready(function() { 
	$('tr:nth-child(odd)').addClass('alt'); 
}); 
```

注意：:nth-child()是jQuery中唯一从1开始计数的选择符。因此，需要使用odd而不是even参数。

### 2.5.2 基于上下文内容选择元素

:contains()选择符区分大小写

```javascript
//突出显示提到任何一种Henry游戏的所有表格单元
$(document).ready(function() { 
    $('tr:nth-child(odd)').addClass('alt'); 
    $('td:contains(Henry)').addClass('highlight'); 
}); 
```

### 2.5.3 基于表单的选择符

表单选择符

| 选  择  符   | 匹 配                      |
| --------- | ------------------------ |
| :input    | 输入字段、文本区、选择列表和按钮元素       |
| :button   | 按钮元素或type属性值为button的输入元素 |
| :enabled  | 启用的表单元素                  |
| :disabled | 禁用的表单元素                  |
| :checked  | 勾选的单选按钮或复选框              |
| :selected | 选择的选项元素                  |

## 2.6 DOM遍历方法

.filter()的功能十分强大，因为它可以接受函数参数。通过传入的函数，可以执行复杂的测试，以决定相应元素是否应该保留在匹配的集合中。

```javascript
//为所有外部链接添加一个类
$('a').filter(function() { 
	return this.hostname && this.hostname != location.hostname; 
}).addClass('external'); 
```

### 2.6.1 为特定单元格添加样式

.next()方法：只选择下一个最接近的同辈元素

```javascript
//给每个包含Henry的单元格的下一个单元格添加样式
$(document).ready(function() { 
	$('td:contains(Henry)').next().addClass('highlight'); 
});
```

.nextAll()方法：所在单元格后面的全部单元格

.prev()和.prevAll() 是对应方法。

.siblings()能够选择处于相同DOM层次的所有其他元素，无论这些元素处于当前元素之前还是之后。

要在这些单元格中再包含原来的单元格，可以添加.addBack()方法

```javascript
//即包含Henry的那个单元格
$(document).ready(function() { 
    $('td:contains(Henry)').nextAll().addBack() 
    .addClass('highlight'); 
}); 
```

要选择同一组元素，可以采用的选择符和遍历方法的组合很多。可以通过.parent()方法在DOM中上溯一层到达`<tr>`，然后再通过.children()选择该行的所有单元格。

### 2.6.2 连缀

> #### 方法连缀的原理
>
> 几乎所有jQuery方法都会返回一个jQuery对象，因而可连缀调用多个jQuery方法。

在使用连缀时，为照顾到代码的可读性，还可以把一行代码分散到几行来写。

## 2.7访问DOM元素

jQuery提供了.get()方法。要访问jQuery对象引用的第一个DOM元素，可以使用.get(0)。

```javascript
//如果想知道带有id="my-element"属性的元素的标签名
var myTag = $('#my-element').get(0).tagName; 
```

jQuery还为.get()方法提供了一种简写方式。

```javascript
//可以将$('#my-element').get(0)简写为：
var myTag = $('#my-element')[0].tagName; 
```

## 2.8 小结



# 第3章 事件

## 3.1 在页面加载后执行任务

### 3.1.1 代码执行的时机选择

$(document).ready() 和 window.onload事件区别：它们在触发操作的时间上存在着微妙的差异，这种差异只有在加载的资源多到一定程度时才会体现出来。

当文档完全下载到浏览器中时，会触发window.onload事件。这意味着页面上的全部元素对JavaScript而言都是可以操作的，这种情况对编写功能性的代码非常有利，因为无需考虑加载的次序。

通过$(document).ready()注册的事件处理程序，则会在DOM完全就绪并可以使用时调用。虽然这也意味着所有元素对脚本而言都是可以访问的，但是，却不意味着所有关联的文件都已经下载完毕。

> #### 加载样式与执行代码
>
> #### 为了保证JavaScript代码执行以前页面已经应用了样式，最好是在`<head>`元素中把`<link rel="stylesheet">`标签和`<style>`标签放在`<script>`标签前面。

> #### 什么是加载完成
>
> 一般来说，使用$(document).ready()要优于使用onload事件处理程序，但必须要明确的一点是，因为支持文件可能还没有加载完成，所以类似图像的高度和宽度这样的属性此时则不一定会有效。如果需要访问这些属性，可能就得选择实现一个onload事件处理程序（或者是使用jQuery为load事件设置处理程序）。

### 3.1.2 基于一个页面执行多个脚本

```javascript
<body onload="doStuff();"> 
window.onload = doStuff; 
```

第2种方式的优点在于，它能使行为更清晰地从标记中分离出来。

> #### **引用函数与调用函数**
>
> 这里在将函数指定为处理程序时，省略了后面的圆括号，只使用了函数名。如果带着圆括号，函数会被立即调用；没有圆括号，函数名就只是函数的标识符或**函数引用**，可以用于在将来再调用函数。

.onload属性一次只能保存对一个函数的引用，所以不能在现有的行为基础上再增加新行为。通过$(document).ready()机制能够很好地解决这个问题。每次调用这个方法都会向内部的行为队列中添加一个新函数，当页面加载完成后，所有函数都会被执行。而且，这些函数会按照注册它们的顺序依次执行。

### 3.1.3 .ready()的简写形式

$()函数为我们提供了一种简写方式。当给它传递一个函数作为参数时，jQuery会隐式调用.ready()。

```javascript
$(document).ready(function() { 
	//这里是代码……
}); 

//也可以简写成：
$(function() { 
	//这里是代码……
}); 
```

推荐使用较长的形式，更清楚

注：通过window.onload虽然也可以注册多个函数，但却不能保证按顺序执行。

### 3.1.4 向.ready()回调函数中传入参数

可能有必要在同一个页面中使用多个JavaScript库。由于很多库都使用$标识符（因为它简短方便），因此就需要一种方式来避免名称冲突。

jQuery提供了一个jQuery.noConflict()方法，调用该方法可以把对$标识符的控制权让渡还给其他库。使用jQuery.noConflict()方法的一般模式如下：

```javascript
<script src="prototype.js"></script> 
<script src="jquery.js"></script> 
<script> 
	jQuery.noConflict(); 
</script> 
<script src="myscript.js"></script> 
```

首先，包含jQuery之外的库（这里是Prototype）。然后，包含jQuery库，取得对`$`的使用权。接着，调用.noConflict()方法让出`$`，以便将控制权交还给最先包含的库（Prototype）。这样就可以在自定义脚本中使用两个库了——但是，在需要使用jQuery方法时，必须记住要用jQuery而不是$来调用。

在.ready()方法中使用`$`的技巧。我们传递给它的回调函数可以接收一个参数——jQuery对象本身。利用这个参数，可以重新命名jQuery为`$`，而不必担心造成冲突

```javascript
jQuery(document).ready(function($) { 
	//在这里，可以正常使用! 
}); 

//或者，也可以使用刚刚介绍的简写语法：
jQuery(function($) { 
	//使用$的代码
}); 
```

## 3.2 处理简单的事件

### 3.2.1 简单的样式转换器

> #### 渐进增强
>
> 在创建样式转换器时，优秀的Web开发人员应该遵守渐进增强的原则。

.on()方法，可以指定任何DOM事件，并为该事件添加一种行为。

```javascript
$(document).ready(function() { 
  $('#switcher-large').on('click', function() { 
  	$('body').addClass('large'); 
  }); 
}); 
```

### 3.2.2 启用其他按钮

### 3.2.3 利用事件处理程序的上下文

当触发任何事件处理程序时，关键字this引用的都是携带相应行为的DOM元素。通过在事件处理程序中使用$(this)，可以为相应的元素创建jQuery对象，然后就如同使用CSS选择符找到该元素一样对它进行操作。

### 3.2.4 使用事件上下文进一步减少代码

### 3.2.5 简写的事件

jQuery提供了一种简化事件操作的方式——简写事件方法，简写事件方法的原理与对应的.on()调用相同。

其他blur、keydown和scroll等标准的DOM事件，也存在类似前面这样的简写事件。这些简写的事件方法能够把一个事件处理程序绑定到同名事件上面。

### 3.2.6 显示和隐藏高级特性

jQuery为我们提供了一个简便的toggleClass()方法，能够根据相应的类是否存在而添加或删除类

```javascript
$(document).ready(function() { 
  $('#switcher h3').click(function() { 
  	$('#switcher button').toggleClass('hidden'); 
  }); 
});
```

## 3.3 事件传播

jQuery的.hover方法。这个方法可以让我们在鼠标指针进入元素和离开元素时，通过JavaScript来改变元素的样式——事实上是可以执行任意操作。

.hover()方法接受两个函数参数。第一个函数会在鼠标指针进入被选择的元素时执行，而第二个函数会在鼠标指针离开该元素时触发。

使用.hover()也意味着可以避免JavaScript中的事件传播（event propagation）导致的头痛问题。

### 3.3.1 事件的旅程

允许多个元素响应单击事件的一种策略叫做事件捕获。在事件捕获的过程中，事件首先会交给最外层的元素，接着再交给更具体的元素。

另一种相反的策略叫做事件冒泡。即当事件发生时，会首先发送给最具体的元素，在这个元素获得响应机会之后，事件会向上冒泡到更一般的元素。

最终出台的DOM标准规定应该同时使用这两种策略：首先，事件要从一般元素到具体元素逐层捕获，然后，事件再通过冒泡返回DOM树的顶层。

jQuery始终会在模型的冒泡阶段注册事件处理程序

### 3.3.2 事件冒泡的副作用

事件冒泡可能会导致始料不及的行为，特别是在错误的元素响应mouseover或mouseout事件的情况下。

而mouseenter和mouseleave事件，无论是单独绑定，还是在.hover()方法中组合绑定，都可以避免这些冒泡问题。

事件对象可以随意命名，不一定要是event

## 3.4 通过事件对象改变事件的旅程

事件对象是一种DOM结构，它会在元素获得处理事件的机会时传递给被调用的事件处理程序。

### 3.4.1 事件目标

通过.target，可以确定DOM中首先接收到事件的元素（即实际被单击的元素）。而且，我们知道this引用的是处理事件的DOM元素

### 3.4.2 停止事件传播

事件对象还提供了一个.stopPropagation()方法，该方法可以完全阻止事件冒泡。

在IE8及更早版本中则无法安全地使用（需要将事件对象的cancelBubble属性设置为false）

### 3.4.3 阻止默认操作

把单击事件处理程序注册到锚元素（`<a>`），而不是外层的`<div>`上，那么就要面对另外一个问题：当用户单击链接时，浏览器会加载一个新页面。

即便在事件对象上调用.stopPropagation()方法也不能禁止这种默认操作，因为默认操作不是在正常的事件传播流中发生的。在这种情况下，.preventDefault()方法则可以在触发默认操作之前终止事件。

事件传播和默认操作是相互独立的两套机制，在二者任何一方发生时，都可以终止另一方。如果想要同时停止事件传播和默认操作，可以在事件处理程序中返回false，这是对在事件对象上同时调用.stopPropagation()和.preventDefault()的一种简写方式。

### 3.4.4 事件委托

事件委托是利用冒泡的一项高级技术。通过事件委托，可以借助一个元素上的事件处理程序完成很多工作。

.is()方法接收一个选择符表达式，然后用选择符来测试当前的jQuery对象。如果集合中至少有一个元素与选择符匹配，.is()返回true。

> **is()与.hasClass()** 
>
> 要测试元素是否包含某个类，也可以使用另一个简写方法.hasClass()。不过，.is()方法则更灵活一些，它可以测试任何选择符表达式。

### 3.4.5 使用内置的事件委托功能

.on()方法可以接受相应参数实现事件委托

```javascript
$('#switcher').on('click', 'button', function() { 
	...
}); 
```

如果给.on()方法传入的第二个参数是一个选择符表达式，jQuery会把click事件处理程序绑定到#switcher对象，同时比较event.target和选择符表达式（这里的'button'）。如果匹配，jQuery会把this关键字映射到匹配的元素，否则不会执行事件处理程序。

## 3.5 移除事件处理程序

调用.off()方法移除折叠处理程序

```javascript
$(document).ready(function() { 
  $('#switcher').click(function(event) {
 	 ... 
}); 

$('#switcher-narrow, #switcher-large').click(function() { 
  	$('#switcher').off('click'); 
  }); 
}); 
```

### 3.5.1 为事件处理程序添加命名空间

应让对.off()的调用更有针对性，达成目标的一种方式是使用事件命名空间，即在绑定事件时引入附加信息，以便将来识别特定的处理程序。

```javascript
$(document).ready(function() { 
  $('#switcher').on('click.collapse', function(event) { 
  	if (!$(event.target).is('button')) { 
 		 $('#switcher button').toggleClass('hidden'); 
  	} 
}); 

$('#switcher-narrow, #switcher-large').click(function() { 
		$('#switcher').off('click.collapse'); 
	}); 
}); 
```

对于事件处理系统而言，后缀.collapse是不可见的。换句话说，这里仍然会像编写.on('click')一样，让注册的函数响应单击事件。但是，通过附加的命名空间信息，则可以解除对这个特定处理程序的绑定，同时不影响为按钮注册的其他单击处理程序。

### 3.5.2 重新绑定事件

应该在Default按钮被单击时，重新绑定事件处理程序。首先，应该为事件处理程序起个名字，以便多次使用

```javascript
$(document).ready(function() { 
  var toggleSwitcher = function(event) { 
  	if (!$(event.target).is('button')) { 
  		$('#switcher button').toggleClass('hidden'); 
  	} 
  };
  
  $('#switcher').on('click.collapse', toggleSwitcher); 
}); 
```


使用命令函数还有另外一个好处，即不必再使用事件命名空间。因为.off()可以将这个命名函数作为第二个参数，结果只会解除对特定处理程序的绑定。

这样就会遇到另一个问题，当在jQuery中把处理程序绑定到事件时，之前绑定的处理程序仍然有效。可以在用户单击任意按钮时解除绑定，并在确定单击按钮的ID是switcher-default的情况下再重新绑定

对于只需触发一次，随后要立即解除绑定的情况也有一种简写方法——.one()，这个简写方法的用法如下：

```javascript
$('#switcher').one('click', toggleSwitcher); 
```

这样会使切换操作只发生一次，之后就再也不会发生。

## 3.6 模仿用户操作

通过.trigger()方法就可以完成模拟事件的操作

```javascript
$(document).ready(function() { 
	$('#switcher').trigger('click'); 
}); 
```

.trigger()方法提供了一组与.on()方法相同的简写方法。当使用这些方法而不带参数时，结果将是触发操作而不是绑定行为。


键盘事件可以分为两类：直接对键盘按键给出响应的事件（keyup和keydown）和对文本输入给出响应的事件（keypress）。

有一条实践经验是比较可靠的：如果想知道用户按了哪个键，应该侦听keyup或keydown事件；如果想知道用户输入的是什么字符，应该侦听keypress事件。

接下来，需要确定哪个元素应该侦听这个事件。可以利用事件冒泡了——因为可以假设所有键盘事件最终都会冒泡到document元素，所以可以把keyup事件直接绑定到该元素。

最后，需要在keyup处理程序被触发时知道用户按下了哪个键。此时可以检查相应的事件对象，事件对象的.which属性包含着被按下的那个键的标识符。对于字母键而言，这个标识符就是相应大写字母的ASCII值。

## 3.7 小结

本章学习了各种响应用户及浏览器发起事件的方法，包括如何在页面加载时安全地执行代码、如何处理单击链接和悬停按钮时的鼠标事件，以及如何截获按键输入。

此外，我们介绍了事件系统的内部机制，并据以实现了事件委托和改变事件行为。



# 第4章 样式与动画

## 4.1 修改内联CSS 

jQuery提供了.css()方法。

这个方法集getter（获取方法）和setter（设置方法）于一身。为取得某个样式属性的值，可以为这个方法传递一个字符串形式的属性名，然后同样得到一个字符串形式的属性值。要取得多
个样式属性的值，可以传入属性名的数组，得到的则是属性和值构成的对象。对于backgroundColor这样由多个单词构成的属性名，jQuery既可以解释连字符版的CSS表示法（如
background-color），也可以解释驼峰大小写形式（camel-cased）的DOM表示法（如backgroundColor）。

```javascript
//取得单个属性的值
.css('property') 
//返回"value" 

//取得多个属性的值
.css(['property1', 'property-2']) 
//返回{"property1": "value1", "property-2": "value2"} 
```

在设置样式属性时，.css()方法能够接受的参数有两种，一种是为它传递一个单独的样式属性和值，另一种是为它传递一个由属性—值对构成的对象：

```javascript
//单个属性及其值
.css('property', 'value') 

//属性值对构成的对象
.css({ 
property1: 'value1', 
'property-2': 'value2' 
}) 
```

这些键值的集合叫对象字面量，是在代码中直接创建的JavaScript对象。

>**对象字面量**
>一般来说，数字值不需要加引号而字符串值需要加引号。由于属性名是字符串，所以属性通常是需要加引号的。但是，如果对象字面量中的属性名是有效的JavaScript标识符，比如使用驼峰大小写形式的DOM表示法时，则可以省略引号。

使用.css()的方式与前面使用.addClass()的方式相同

### 4.1.1 设置计算的样式属性值

### 4.1.2 带厂商前缀的样式属性

在jQuery中，可以直接使用标准的属性名。如果样式对象中不存在这个属性，jQuery就会依次检测所有带前缀（Webkit、O、Moz、ms）的属性，然后使用第一个找到的那个属性。

## 4.2 隐藏和显示元素

基本的.hide()和.show()方法不带任何参数，这两个方法的作用就是立即隐藏或显示匹配的元素集合，不带任何动画效果。

.hide()方法会将匹配的元素集合的内联style属性设置为display:none。它能够在把display的值变成none之前，记住原先的display值，通常是block、inline或inline-block。

.show()方法会将匹配的元素集合的display属性，恢复为应用display: none之前的可见属性。

## 4.3 效果和时长

当在.show()或.hide()中指定时长（或更准确地说，一个速度）参数时，就会产生动画效果，即效果会在一个特定的时间段内发生。

### 4.3.1 指定显示速度

对于jQuery提供的任何效果，都可以指定两种预设的速度参数：'slow'和'fast'。使用.show('slow')会在600毫秒（0.6秒）内完成效果，而.show('fast')则是200毫秒（0.2秒）。如果传入的是其他字符串，jQuery就会在默认的400毫秒内完成效果。要指定更精确的速度，可以使用毫秒数值。注意，与字符串表示的速度参数名称不同，数值不需要使用引号。

### 4.3.2 淡入和淡出

jQuery也提供了两个更为精细的内置动画方法。如果想在显示整个段落时，只是逐渐地增大其不透明度，那么可以使用.fadeIn('slow')方法。

类似地，要逐渐减少不透明度，可以使用.fadeOut()。

### 4.3.3 滑上和滑下

对于本来就处于文档流之外的元素，比较适合使用淡入和淡出动画。不过，假如某个元素本来就处在文档流中，那再调用.fadeIn()就会导致文档“跳一下”，以便为新元素腾出地方来。但这种跳跃感在用户眼里就不总是那么美观了。

此时，使用jQuery的.slideDown()和.slideUp()方法通常是正确的选择。这两个动画方法仅改变元素的高度。

要实现相反的动画效果，应该调用.slideUp()。

### 4.3.4 切换可见性

jQuery提供了一个.toggle()方法，该方法的作用类似于.show()和.hide()方法，而且与它们一样的是，.toggle()方法时长参数也是可选的。

另一个复合方法是.slideToggle()，该方法通过逐渐增加或减少元素高度来显示或隐藏元素。

## 4.4 创建自定义动画

jQuery还提供了一个强大的.animate()方法，用于创建控制更加精细的自定义动画。

.animate()方法有两种形式，第一种形式接收以下4个参数。

- 一个包含样式属性及值的对象：与.css()方法中的参数类似。
- 可选的时长参数：既可以是预置的字符串，也可以是毫秒数值。
- 可选的缓动（easing）类型。
- 可选的回调函数。

第二种形式接受两个参数，一个属性对象和一个选项对象：

```javascript
.animate({properties}, {options}) 
```

实际上，这里的第二个参数是把第一种形式的第2～4个参数封装在了另一个对象中，同时又添加了两个选项。

### 4.4.1 手工创建效果

.animate()方法针对CSS属性提供了方便简写值：'show'、'hide'和'toggle'，以便在简写方法不适用时提供另一种简化.slideToggle()等内置效果方法的方式。

### 4.4.2 一次给多个属性添加动画效果

使用.animate()方法可以同时修改多个CSS属性。

在可变宽度的布局中，使用jQuery的.outWidth()方法来计算宽度，包括内边距及边框宽度。

#### 注：left属性是计算的数值。这些属性值的单位后缀是可选的，如果不指定，就会默认以px作为单位

#### 通过CSS定位

所有块级元素默认的CSS定位属性都是static，这个值精确地表明：在改变元素的定位属性之前试图移动它们，它们只会保持静止不动。

## 4.5 并发与排队效果

### 4.5.1 处理一组元素

当为同一组元素应用多重效果时，可以通过连缀这些效果轻易地实现排队。

通过使用连缀，可以对其他任何jQuery效果进行排队，而并不限于.animate()方法。

#### 1. 越过队列

要是想在这个`<div>`不透明度减退至一半的同时，把它移动到右侧应该怎么办呢？在这种情况下，第二种形式的.animate()方法又可以派上用场了

第二个参数（即选项对象）包含了queue选项，把该选项设置为false即可让当前动画与前一个动画同时开始。

#### 2. 手工队列

有关为一组元素应用排队效果的最后一个需要注意的问题，就是排队不能自动应用到其他的非效果方法，如.css()，它也会立即执行。把非效果方法添加到队列中的一种方式，就是使用.queue()方法。

```javascript
$(document).ready(function() { 
  $('div.label').click(function() { 
    var paraWidth = $('div.speech p').outerWidth(); 
    var $switcher = $(this).parent(); 
    var switcherWidth = $switcher.outerWidth(); 
    $switcher 
      .css({position: 'relative'}) 
      .fadeTo('fast', 0.5) 
      .animate({ 
      	left: paraWidth - switcherWidth 
      }, { 
        duration: 'slow', 
        queue: false 
      }) 
      .fadeTo('slow', 1.0) 
      .slideUp('slow') 
      .queue(function(next) { 
        $switcher.css({backgroundColor: '#f00'}); 
        next(); 
    }) 
    .slideDown('slow'); 
  });
}); 
```

添加的这个next ()方法可以让队列在中断的地方再接续起来，然后再与后续的.slideDown ('slow')连缀在一起。如果在此不使用next()方法，动画就会中断。

### 4.5.2 处理多组元素

与一组元素的情况不同，当为不同组的元素应用效果时，这些效果几乎会同时发生。


####排队回调函数####
为了对不同元素上的效果实现排队，jQuery为每个效果方法都提供了回调函数。

不过，这里我们需要注意的是，必须搞清楚要滑上的到底是哪个段落，由于.slideDown()方法是通过`$`(this).next()调用的，所以该方法中的一切现在都将`$`(this)视为下一个同辈元素，即第四个段落。可靠地引用$(this)的一种简单方法，就是在.click()方法内部把它保存到一个变量中。

注意，在使用交互的完成回调函数而不是.queue()时，不必在回调中调用next()。

### 4.5. 3 简单概括

随着在应用效果时需要考虑的变化的增多，要记住这些效果是同时发生还是按顺序发生会变得越来越困难。

- 一组元素上的效果：
  - 当在一个.animate()方法中以多个属性的方式应用时，是同时发生的；
  - 当以方法连缀的形式应用时，是按顺序发生的（排队效果）——除非queue选项值为false。
- 多组元素上的效果：
  - 默认情况下是同时发生的；
  - 当在另一个效果方法或者在.queue()方法的回调函数中应用时，是按顺序发生的（排队效果）。

## 4.6 小结



# 第5章 操作DOM

## 5.1 操作属性

.addClass()和.removeClass()方法实际上是在操作DOM中的className属性。

### 5.1.1 非类属性

操作其他一些属性，比如id、rel和title属性。jQuery为此也提供了.attr()和.revoveAttr()方法

.attr()方法也接受一对参数，第一个是属性名，第二个是属性值。更常用的方式还是传入一个包含键值对的对象

**值回调**

要为每个链接设置唯一的id，可以使用jQuery的.css()和.each()方法的另一个特性：值回调。

值回调其实就是给参数传入一个函数，而不是传入具体的值。这个函数会针对匹配的元素集中的每个元素都调用一次，调用后的返回值将作为属性的值。

**值回调的上下文**

就像在事件处理程序中一样，在值回调函数中，this关键字指向每次调用回调时正在操作的那个DOM元素。

### 5.1.2 DOM元素属性

HTML属性与DOM属性有一点区别。HTML属性是指页面标记中放在引号中的值，而DOM属性则是指通过JavaScript能够存取的值。（HTML的class 与 DOM的className）

某些DOM属性，例如nodeName、nodeType、selectedIndex和childNodes，在HTML中没有对应的属性，因此通过.attr()方法就没有办法操作它们。此外，数据类型方面也存在差异，比如HTML中的checked属性是一个字符串，而DOM中的checked属性则是一个布尔值。对于布尔值属性，最后是测试DOM属性而不是HTML属性，以确保跨浏览器的一致行为。

在jQuery中，可以通过.prop()方法取得和设置DOM属性

.prop()方法与.attr()方法没有什么不同，比如它们都可以一次性接受一个包含多个值的对象，也支持值回调函数。

### 5.1.3 表单控件的值

HTML属性与DOM属性差别最大的地方，恐怕就要数表单控件的值了。比如，文本输入框的value属性在DOM中的属性叫defaultValue，DOM中就没有value属性。而选项列表（select）元素呢，其选项的值在DOM中通常是通过selectedIndex属性，或者通过其选项元素的selected属性来取得。

由于存在这些差异，在取得和设置表单控件的值时，最好不要使用.attr()方法。而对于选项列表呢，最好连.prop()方法也不要使用。那使用什么呢，建议使用jQuery提供的.val() 方法

.val()方法也可以接受一个函数作为其setter参数。

## 5.2 DOM树操作

### 5.2.1 重新认识$()函数

### 5.2.2 创建新元素

### 5.2.3 插入新元素

- .insertBefore()在现有元素外部、之前添加内容；
- .prependTo()在现有元素内部、之前添加内容；
- .appendTo()在现有元素内部、之后添加内容；
- .insertAfter()在现有元素外部、之后添加内容。

### 5.2.4 移动元素

记住，即使是在隐式迭代的情况下，插入的顺序也是预定义的，即从DOM树的上方开始向下依次插入。

更加健壮的一种脚注方案应该：

- 为每个标注编号；
- 在正文中标出提取脚注的位置，使用脚注的编号；
- 在文本中的位置上创建一个指向对应脚注的链接，在脚注中创建返回文本位置的链接。

### 5.2.5 包装元素

**显式迭代**

.each()方法就是一个显式迭代器。这个方法接受一个回调函数，这个函数会针对匹配的元素集中的每个元素都调用一次

为了在正文中标记提取脚注的位置，可以利用.each()回调的参数。这个参数表示迭代的次数，从0开始，每迭代一次就加1。

### 5.2.6 使用反向插入方法

像.insertBefore()和.appendTo()这样的插入方法，一般都有一个对应的反向方法。反向方法也执行相同的操作，只不过“目标”和“内容”正好相反。例如append和appendTo

> **插入方法回调**
> 反向插入方法可以接受一个函数作为参数，与.attr()和.css()方法类似。这个传入的函数会针对每个目标元素调用，返回被插入的HTML字符串。在此其实也可以使用这个技术，但由于这样就需要对每个脚注都重复一遍相同的操作，所以还是使用一个.each()方法来得更清晰。

使用数组的.join()方法来构建一个更大的数组

```javascript
var str = 'a' + 'b' + 'c'; 
var str = ['a', 'b', 'c'].join(''); 
```

5.3 复制元素

在复制元素时，需要使用jQuery的.clone()方法，这个方法能够创建任何匹配的元素集合的副本以便将来使用。

在为复制的元素应用一种插入方法之前，这些元素不会出现在文档中。

```javascript
//创建<div class="chapter">中第一段落的副本：
$('div.chapter p:eq(0)').clone(); 
```

> 在默认情况下，.clone()方法不会复制匹配的元素或其后代元素中绑定的事件。不过，可以为这个方法传递一个布尔值参数，将这个参数设置为true，就可以连同事件一起复制，即.clone(true)。

#### 通过复制创建突出引用

通过.clone()方法可以轻而易举地完成这种装饰效果。

## 5.4 内容setter和getter方法

直接用新的HTML代替旧的内容，要用到.html()方法了。
在调用.html()而不传递参数的情况下，这个方法返回匹配的元素中的HTML标记。而传入参数后，元素的内容将被传入的HTML替换掉。在此要注意传入的HTML必须是有效的，而且要对特殊字符进行转义 。

引用一般不会使用原来的字体样式。要想去掉这些HTML标签，就得使用.html()方法的“伙伴”.text(方法。与.html()方法类似，.text()也可以取得匹配元素的内容，或者用新字符串替换匹配元素的内容。但是，与.html()不同的是，.text()始终会取得或设置纯文本内容。在使用.text()取得内容时，所有HTML标签都将被忽略，而所有HTML实体也会被转换成对应的字符。而在通过它设置内容时，诸如<这样的特殊字符，都会被转换成等价的HTML实体。

## 5.5 DOM操作方法的简单归纳

简单地归纳出一些方法，这些方法几乎能够在任何情况下，完成任何任务。

- 要在HTML中创建新元素，使用$()函数。
- 要在每个匹配的元素中插入新元素，使用：
  - .append() 
  - .appendTo() 
  - .prepend() 
  - .prependTo() 
- 要在每个匹配的元素相邻的位置上插入新元素，使用：
  - .after() 
  - .insertAfter() 
  - .before() 
  - .insertBefore() 
- 要在每个匹配的元素外部插入新元素，使用：
  - .wrap() 
  - .wrapAll() 
  - .wrapInner() 
- 要用新元素或文本替换每个匹配的元素，使用：
  - .html() 
  - .text() 
  - .replaceAll() 
  - .replaceWith() 
- 要移除每个匹配的元素中的元素，使用：
  - .empty() 
- 要从文档中移除每个匹配的元素及其后代元素，但不实际删除它们，使用：
  - .remove() 
  - .detach() 

## 5.6小结

使用jQuery的DOM操作方法完成了元素的创建、复制、重组以及内容修饰等操作。

通过在一个网页上应用这些方法，将一组普通的段落转换成了带脚注、突出引用、返回链接以及经过样式化的文本摘录。



# 第6章 通过Ajax发送数据

Ajax（Asynchronous JavaScript and XML，异步JavaScript和XML）。一个Ajax解决方案中涉及如下技术。

- JavaScript：处理与用户及其他浏览器相关事件的交互，解释来自服务器的数据，并将其呈现在页面上。
- XMLHttpRequest：这个对象可以在不中断其他浏览器任务的情况下向服务器发送请求。
- 文本文件：服务器提供的XML、HTML或JSON格式的文本数据。

## 6.1 基于请求加载数据

### 6.1.1追加HTML

Ajax应用程序通常只不过是一个针对HTML代码块的请求。这种被称作AHAH（Asynchronous HTTP and HTML，异步HTTP和HTML）的技术。首先，需要一些供插入用的HTML，我们把这些HTML放在与主文档位于同一目录下的a.html文件中。

我们注意到，a.html并不是一个真正的HTML文档，它不包含`<html>`、`<head>`或者`<body>`，只包含最基本的代码。通常，我们把这种文件叫做片段；它唯一目的就是供插入到其他HTML文档中使用

```javascript
$(document).ready(function() {
  $('#letter-a a').click(function(event) {
  	event.preventDefault();
 	$('#dictionary').load('a.html');
  });
});
```

通过常规的jQuery选择符为HTML片段指定了目标位置，然后将要加载的文件的URL作为参数传递给.load()方法

所有Ajax请求在默认情况下都是异步的。对于必须要延迟到加载完成才能继续的操作，jQuery提供了一个回调函数。

### 6.1.2 操作JavaScript对象

使用jQuery的选择符可以遍历和操作取得的HTML结构，但是还有一种JavaScript内置的数据格式，既能减少数据传输量，也会减少编码量。

#### 1. 取得JSON

JSON规定所有对象键以及所有字符串值，都必须包含在双引号中。而且，函数也不是有效的JSON值。

要取得数据，可以使用`$`.getJSON()方法，这个方法会在取得相应文件后对文件进行处理。在数据从服务器返回后，它只是一个简单的JSON格式的文本字符串。`$`.getJSON()方法会解析这个字符串，并将处理得到的JavaScript对象提供给调用代码。

#### 2. 使用全局jQuery函数

getJSON()是作为全局jQuery对象（由jQuery库定义的jQuery或$对象）的方法定义的。

为了便于理解，我们在这里称其为全局函数；实际上，为了不与其他函数名称发生冲突，这些全局函数使用的是jQuery命名空间。

$.getJSON()函数可以接受第2个参数，这个参数是当加载完成时调用的函数。回调函数也需要一个参数，该参数中保存着返回的数据。

$.each()函数不操作jQuery对象，它以数组或对象作为第一个参数，以回调函数作为第二个参数。此外，还需要将每次循环中数组或对象的当前索引和当前项作为回调函数的两个参数

> **安全的HTML** 
>
> 这种方法要求数据中包含可以直接用来构建HTML的安全内容，例如，数据中不能包含任何< 字符。

尽管JSON格式很简洁，但它却不容许任何错误。所有方括号、花括号、引号和逗号都必须合理且正确地使用，否则文件不会加载。而且，在多数浏览器中，当文件加载失败时我们看不到任何错误信息；脚本只是静默地彻底终止运转。

#### 3. 执行脚本

向页面中注入脚本与加载HTML片段一样简单。但在这种情况下，需要使用全局函数$.getScript()，这个全局函数与它的同辈函数类似，接受一个URL参数以查找脚本文件。

以这种方式取得的脚本会在当前页面的全局环境下执行。这意味着脚本有权访问在全局环境中定义的函数和变量，当然也包括jQuery自身。

### 6.1.3 加载XML文档

加载XML文档很简单，而且与JSON技术也相当接近。

$.get()函数。通常，这个函数只是取得由URL指定的文件，然后将纯文本格式的数据提供给回调函数。但是，在根据服务器提供的MIME类型知道响应的是XML的情况下，提供给回调函数的将是XML DOM树。

可以使用常规的.find()、.filter()及其他遍历方法。

## 6.2 选择数据格式

4种外部数据的格式，当确定在应用程序中使用哪种格式时，应该考虑什么因素呢？


HTML片段：对于将新HTML添加到现有页面中的简单任务来说，无需遍历数据。另一方面，这种数据的结构方式却不一定能够在其他应用程序中得到重用，因为这种外部文件与它们的目标容器必须紧密结合。


JSON文件：结构使它可以方便地被重用。由于现代浏览器调用原生的JSON.parse()就能解析这种格式的文件，所以读取JSON文件的速度非常快。另外，JSON文件中的错误可能会导致页面上的脚本静默地中止运行，甚至还会带来其他的负面影响。

JavaScript文件：能够提供极大的灵活性，但它却不是一种真正的数据存储机制。因为这种文件针对特定的语言，所以不能通过它们将同样的信息提供给完全不同的系统。

XML：这种格式提供可重用的数据仍然还是很常见的。XML格式的文件体积相对较大，所以同其他文件格式相比，解析和操作它们的速度要慢一些。

**结论**
在不需要与其他应用程序共享数据的情况下，以HTML片段提供外部数据一般来说是最简单的。如果数据需要重用，而且其他应用程序也可能因此受到影响，那么在性能和文件大小方面具有优势的JSON通常是不错的选择。而当远程应用程序未知时，XML则能够为良好的互操作性提供最可靠的保证。

## 6.3 向服务器传递数据

### 6.3.1执行GET请求

jQuery$.get()函数的对象来构建查询字符串

与其他Ajax接口唯一的差别是第二个参数，该参数是一个用来构建查询字符串的键和值的对象。

> **返回false还是阻止默认动作**
>
> 在本章的click处理程序中，我们传入了event对象并使用event.preventDefault()而不是return false结束该处理程序。当默认动作是重新加载页面或打开新页面时，我们推荐这种做法。例如，如果click处理程序中包含JavaScript错误，那么在第一行代码中（在碰到错误之前）阻止默认动作就能确保不会提交表单，而且浏览器的错误控制台也会收到错误报告。第3章曾介绍过，return false意味着同时调用event.preventDefault()和event.stopPropagation()。因此要想停止事件冒泡，我们还得再调用后者。

### 6.3.2 执行POST请求

使用POST方法与使用GET方法的HTTP请求几乎是一样的。

通过使用.load()方法还可以进一步简化这些代码，因为.load()方法在接收到包含数据的对象参数时，会默认使用POST方法发送请求。

### 6.3.3 序列化表单

.serialize()方法。这个方法作用于一个jQuery对象，将匹配的DOM元素转换成能够随Ajax请求传递的查询字符串。

## 6.4 为Ajax请求提供不同的内容

要利用jQuery随同Ajax请求一起发送的请求头部。在服务器端代码（这里是PHP）中，我们需要检查X-Requested- With头部。如果存在这个头部而且它的值为XMLHttpRequest，那么就会只发送文档片段；否则，就发送完整的文档。

## 6.5 关注请求

.ajaxStart()和.ajaxStop()方法，通过它们能够为各种与Ajax相关的事件注册回调函数。

当Ajax请求开始且尚未进行其他传输时，会触发.ajaxStart()的回调函数。相反，当最后一次活动请求终止时，则会执行通过.ajaxStop()注册的回调函数。

这些方法都是全局性的

这些方法都与.ready()方法一样，只能由$(document)调用。

在网络连接的速度比较慢时，可以通过这些方法为用户提供一些反馈。

在此基础上继续连缀相应的隐藏行为：

```javascript
$(document).ajaxStart(function() { 
	$loading.show(); 
    }).ajaxStop(function() { 
	$loading.hide(); 
}); 
```

某些观察员方法，如.ajaxError()，会向它们的回调函数发送一个对XMLHttpRequest对象的引用。这样就可以做到区别不同的请求来提供不同的行为。其他更具体的处理可以通过使用低级的$.ajax()函数来完成。

与请求最常见的交互方式是成功（success）回调函数。

.load()方法可以接受一个加载完成时触发的回调函数

## 6.6 错误处理

$.get()和.load()等快捷的Ajax方法并没有提供错误回调参数

除了使用全局的.ajaxError()方法，我们还可以利用jQuery的延迟对象系统。可以给.load()之外的Ajax方法连缀.done()、.always()和.fail()方法，并通过它们添加相应的回调函数即可。

.status属性中包含着服务器返回的状态码。这些代码由HTTP规范定义，当触发.fail()处理程序时，可以根据下表解读错误。

| 响  应  码 | 说 明       |
| ------- | --------- |
| 400     | 请求语法错误    |
| 401     | 未授权       |
| 403     | 禁止访问      |
| 404     | 未发现请求的URL |
| 500     | 服务器内部错误   |

## 6.7 Ajax和事件

通过Ajax生成页面内容时的一个常见问题：即使已经把click处理程序添加到词条元素，只要一单击其他字母，这些处理程序仍然会丢失绑定。

一种常见的解决方案就是在页面内容更新时重新绑定处理程序。但这样做会相当繁琐

另外一种值得推荐的做法是第3章介绍的**事件委托**。在此，事件委托的本质就是把事件处理程序绑定到一个祖先元素，而这个祖先元素始终不变。

## 6.8 安全限制

为了防止各种**跨站点脚本攻击**，一般情况下从提供原始页面的服务器之外的站点请求文档是不可能的。

有许多方式可以绕过上述安全限制，即能够实现通过Ajax请求取得其他站点的数据：

其中一种方法是通过服务器加载远程数据，然后在客户请求时提供给浏览器。这是一种非常有效的手段，因为服务器能够对数据进行预处理。

另一种方法：加载外来JavaScript文件的一种流行方法是根据请求注入`<script>`标签。实际上，$.getScript()方法在检测到其URL参数中包含远程主机时，就会自动采用这种技术；此时，浏览器会执行加载的脚本，但却没有任何机制能够从脚本中取得结果。为此，使用这种技术要求同远程主机进行协作。加载的脚本必须执行某些操作，例如设置一个对本地环境有影响的全局变量。而远程主机上的服务除了发布能够通过这种方式执行的脚本外，还会提供一个API以便同远程脚本进行交互。

另一种方法是使用`<iframe>`这个HTML标签来加载远程数据。可以为`<iframe>`元素指定任何URL作为其获取数据的来源，包括与提供页面的服务器不匹配的URL。因此，第三方服务器上的数据能够轻易地加载到`<iframe>`中，并在当前页面上显示出来。然而，要操作`<iframe>`中的数据，仍然存在同使用`<script>`标签时一样的协作需求；位于`<iframe>`中的脚本需要明确地向父文档中的对象提供数据。****

> **跨域共享资源**
>
> Cross-Origin Resource Sharing（CORS，跨域资源共享）。这项技术要求一个域向另一个域发送的请求中要包含另一个域期待的自定义HTTP头部。接收请求的域如果接受请求，必须返回Access-Control-Allow-Oreigin响应头部。

#### 使用JSONP加载远程数据

使用`<script>`标签从远程获取JavaScript文件的思路，可以变通为从其他服务器取得JSON文件。jQuery直接支持的是JSONP（JSON with Padding，填充式JSON）。

JSONP的格式是把标准JSON文件包装在一对圆括号中，圆括号又前置一个任意字符串。这个字符串，即所谓的P（Padding，填充），由请求数据的客户端来决定。而且，由于有一对圆括号，因此返回的数据在客户端可能会导致一次函数调用，或者是为某个变量赋值——取决于客户端请求中发送的填充字符串。

由于远程文件经过设置以JSONP格式提供数据，因此通过在URL后面添加一个查询字符串，并使用?作为callback参数的占位符就可以获得数据。请求返回之后，jQuery会为我们替换?、解析结果并通过data参数将数据传入成功函数。结果就好像是在处理本地JSON数据一样。

## 6.9 其他工具

### 6.9.1 低级Ajax方法

在内部，jQuery会把一些用于启动Ajax通信的方法都对象为$.ajax()全局函数的一种变体。这个函数不针对任何特定Ajax通信类型，而是接收一个选项对象参数，并根据该参数来决定相应的行为。

$.ajax()接受了一个对象作为参数（或者一个URL字符串作为第一个参数，一个对象作为第二个参数）

用低级的$.ajax()函数时，可以获得下列特殊的好处。

- 避免浏览器缓存来自服务器的响应。非常适合服务器动态生成数据的情况。
- 抑制正常情况下所有Ajax交互都可以触发的全局处理程序（例如通过$.ajaxStart()注册的处理程序）。


- 在远程主机需要认证的情况下，可以提供用户名和密码。

### 6.9.2 修改默认选项

使用$.ajaxSetup()函数可以修改调用Ajax方法时每个选项的默认值。

这个函数与$.ajax()接受相同的选项对象参数，之后的所有Ajax请求都将使用传递给该函数的选项——除非明确覆盖

### 6.9.3 部分加载HTML页面

要去掉页面中多余的内容，可以利用.load()的一些新特性——在指定要加载文档的URL时，也可以提供一个jQuery选择符表达式。如果指定了这个表达式，.load()方法就会利用它查找加载文档的匹配部分。最终，只有匹配的部分才会被插入到页面中。

## 6.10 小结

使用jQuery提供的Ajax方法，在不刷新页面的情况下，从服务器上加载几种不同格式的数据。而且，我们也可以基于请求执行来自服务器的脚本，并且能够向服务器发送数据。

如何处理常见的异步加载技术的问题，例如在加载发生后绑定处理程序，以及从第三方服务器中加载数据。



# 第7章 使用插件

## 7.1 查找插件和帮助

## 7.2 使用插件

### 7.2.1 下载并包含Cycle插件

把文件下载到站点目录之后，需要在文档的<head>中引入这个插件。此时，注意把引入它的代码放在引入jQuery主文件的代码后面，但要位于使用这个插件的脚本前面。

### 7.2.2 调用插件提供的方法

Cycle插件可以作用于页面中的任何一组同辈元素。

通过Cycle插件可以将这个列表转换成可以交互的幻灯片。在DOM中适当的容器上调用.cycle()方法，就可以实现这一转换

```javascript
$(document).ready(function() { 
	$('#books').cycle(); 
}); 
```

### 7.2.3 为插件方法指定参数

可以修改Cycle插件的两个幻灯片之间的播放速度和动画样式，修改幻灯片变换的触发方式，还可以使用回调函数针对动画完成作出响应。

### 7.2.4 修改参数默认值

Cycle其实也遵循了一个常见的模式，那就是把所有默认值放在一个对象中。包含所有默认选项的对象是$.fn.cycle.defaults。

## 7.3 其他形式的插件

### 7.3.1 自定义选择符

支持自定义选择符表达式的插件扩展了jQuery内置选择符引擎的功能，可以让我们以全新的方式查找元素。

### 7.3.2 全局函数插件

Cookie插件提供了读写页面中cookie值的接口。而这个功能是通过$.cookie()函数提供的，这个函数可以取得或设置个别的cookie值。

默认情况下，cookie的值将在会话期间保持，直到关闭浏览器标签页为止。默认情况下，cookie还是与设置它的页面关联的。如果想改变这个默认设置，可以为这个函数提供一个选项对象作为第三个参数。

```javascript
//比如，要想让cookie在整个站点中都可以访问到，而且让它在7天之后再过期，就可以像这样来调用函数
$.cookie('cyclePaused', 'y', {path: '/', expires: 7})。
```

## 7.4 jQuery UI插件库

jQuery UI团队创建了大量核心交互组件及成熟的部件（widget），使用它们可以创造出更加类似桌面应用程序的Web体验。交互式组件包括用于拖动、放置、排序和调整项目大小的方法。当前稳定的部件有按钮、折叠窗格、日期选择器、对话框，等等。此外，jQuery UI还为补充和增强jQuery的核心动画功能提供了相当多的高级效果。

### 7.4.1 效果

jQuery UI中的效果（effect）模块由一个核心文件和一组独立的效果文件组成。

#### 1. 颜色动画

在文档中引用核心效果文件的情况下，扩展的.animate()方法可以接受另外一些样式属性，例如borderTopColor、backgroundColor和color。

#### 2. 基于类的动画

三个操作CSS类的方法：.addClass()、.removeClass()和.toggleClass()。在jQuery UI中经过扩展，都可以接受第二个可选的参数，用于控制动画时长。

#### 3. 高级缓动函数

jQuery在某个时长内不会以稳定的速度来执行动画。例如在1秒的开始和结尾，元素的高度变化比较慢，而在这1秒的中间，高度变化比较快。这种速度的变化就是缓动，缓动有助于让动画更流畅、更自然。

高级缓动函数可以改变加速或减速曲线，以产生与众不同的结果。

easeInExpo函数会让动画速度以指数方式加快，最终的动画速度要数倍于开始时的速度。

#### 4. 其他效果

变换都可以通过调用.effect()方法实现，这个方法是jQuery UI添加的。对于那些隐藏和显示元素的动画，可以视情况调用.show()、.hide()和.toggle()方法。

jQuery UI提供的效果可以满足各种不同的需求。比如，transfer和size可以用来改变元素的形状和位置，explode和puff可以产生更吸引人的隐藏动画，而pulsate和shake则可以让元素更吸引眼球。

### 7.4.2 交互组件

jQuery UI中的交互式组件就是一组行为，可以跟自定义代码结合起来生成复杂的交互式应用。

为元素应用交互行为非常简单，只需要在元素上调用与组件同名的方法即可。

> **其他交互式组件**
>
> jQuery UI还包括其他交互式组件，比如Draggable、Droppable和Sortable。

### 7.4.3 部件

除了交互式组件之外，jQuery UI库中还提供了一批可靠的用户界面部件。无论从外观还是功能上看，这些“开箱即用”的部件都非常类似我们熟悉的桌面应用程序中的相应元素。

Button部件

Slider部件就引入了一个全新的表单元素，它与HTML5的range元素类似，但却能兼容所有主流的浏览器。

为了响应滑动条的值的变化，可以绑定一个由滑动条触发的自定义事件。这个事件名为slide，虽然它不是原生JavaScript事件，但在jQuery代码中，它就像是原生事件一样。而且，监听这种事件也不用显式地调用.on()，只要把事件处理程序传递给.slider()方法即可

无论什么时候调用slide回调函数，其参数ui中都会保存着部件相关的信息，包括滑动条当前的值。把这个值传递给Cycle插件，就可以实现通过滑动条控制幻灯片了。

在幻灯变换时更新滑动条部件。要实现相反方向的通信，可以使用Cycle的before回调函数，这个函数会在每次幻灯变换时触发

> **其他部件**
>
> jQuery UI的Datepicker、Dialog、Tabs以及Accordion等部件都有一些可以配置的选项、事件和方法。

### 7.4.4 jQuery UI主题卷轴

jQuery UI库最近增添的一项名为ThemeRoller（主题卷轴）的功能，这是一个面向UI部件的于Web的交互式主题引擎。有了ThemeRoller，就可以在瞬间创建出高度自定义、专业化的元素。

## 7.5 jQuery Mobile插件库

### 7.5.1 HTML5自定义数据属性

jQuery Mobile交互最常见的方法还是使用HTML5的data-*属性。

HTML5规范允许我们在元素中插入任何需要的属性，只要该属性前缀data-即可。这种属性在页面渲染期间会被忽略，但jQuery脚本却可以访问它们。

> jQuery Mobile需要找到一些自定义的数据属性。

### 7.5.2 移动导航

jQuery Mobile中最重要的一个功能，就是把页面中的链接转换成Ajax驱动的导航。转换之后，导航将具有一些简单的动画效果，同时还能保留标准的浏览器历史记录。

特别要注意，这里添加了一个`<meta>`标签，用于定义页面的视口（viewport）。这个声明是告诉浏览器将其页面内容缩放到恰好填满设备的宽度。

为了创建导航，jQuery Mobile需要理解页面结构。为此，我们要使用data-role属性来提供这些信息

### 7.5.3 一个文档支持多个页面

除了能通过Ajax加载其他文档，jQuery Mobile还可以基于包含所有内容的单个文档实现同样的导航功能。为演示这一点，只要在文档链接中使用标准的#符号，同时就像标记独立文档一样使用data-role="page"属性标记那些内容区块

### 7.5.4 交互式元素

jQuery Mobile中的大部分组件都是交互式元素。折叠式区块、可切换开关、幻灯片式面板，以及响应式表格，都是交互式元素的例子。

> jQuery UI与jQuery Mobile有相当数量的元素是重复的。不推荐在一个页面中同时使用它们，毕竟最重要的部件它们各自都有。

#### 1. 列表视图

通过jQuery Mobile很容易将页面中的列表转换成移动应用中的列表。

```javascript
<ul data-role="listview" data-inset="true" data-filter="true"> 
```

添加的data-role="listview"告诉jQuery Mobile把列表中的链接转换成适合手指触摸的大按钮。而data-inset="true"则用于给列表添加一个漂亮的边框。可以进一步添加筛选搜索框，以便通过关键词来筛选（减少）列表项。

#### 2. 工具栏按钮

某些情况下，jQuery Mobile甚至会帮我们创建原来没有的按钮。

例如，屏幕左上角的Back，点击可以返回上一层。只要给页面中的`<div>`元素添加data-add-back-btn属性，就可以得到这么一个按钮：

```javascript
<div data-role="page" data-add-back-btn="true"> 
```

### 7.5.5 高级功能

- 移动优化的事件。在页面引用jQuery Mobile后，jQuery代码就可以访问一些特殊的事件，比如tap、taphold和swipe。这些事件的处理程序同样以.on()方法绑定，与绑定其他事件一样。其中，taphold和swipe默认的配置（包括触摸时长）可以通过`$.event. special.taphold`和`$.event.special.swipe`对象来修改。除了基于触摸的事件，jQuery Mobile还支持能响应滚动、屏幕翻转和页面导航不同阶段的特殊事件，以及一组虚拟的鼠标事件，能够同时响应鼠标和触摸操作。
- 主题定制。与jQuery UI一样，jQuery Mobile也提供ThemeRoller用于定制部件的外观。
- PhoneGap集成。使用PhoneGap（Cordova）很容易将通过jQuery Mobile构建的网站转换成原生应用，从而能够访问移动设备的API（相机、加速计和地理定位等）和应用商店。通过`$.support.cors`和`$.mobile.allowCrossDomainPages`属性，甚至可以访问不包含在应用中的页面，比如包含在远程服务器中的页面。

## 7.6小结

本章介绍了在网页中整合第三方插件的各种方式。其中，着重讨论了Cycle、jQuery UI和jQuery Mobile，并展示了在其他插件中同样会遇到的一些模式。



# 第8章 开发插件

## 8.1 在插件中使用$别名

不能假设`$`别名一定可用。对于代码比较长的插件来说，很多开发人员都觉得不能使用$别名会导致代码难以理解。为了解决这个问题，我们可以在插件的作用域内定义这个快捷方式，方法就是定义一个函数并马上调用它。这种定义并立即调用函数的语法通常被称为立即调用的函数表达式（IIFE，Immediately Invoked Function Expression）：

```javascript
(function($) { 
	//在这里添加代码
})(jQuery); 
```

这个包装函数只接收一个参数，我们通过这个参数传入了jQuery对象。这个参数的名字是$，
因此在这个函数内部，使用$别名就不会有冲突了。

## 8.2 添加新的全局函数

 所谓**全局函数**，实际上就是jQuery对象的方法，但从实践的角度上看，它们是位于jQuery命名空间内部的函数。

核心jQuery库提供的很多全局函数都是**实用方法**；所谓实用方法，就是一些常用功能的快捷方式，但即使手工编写同样功能的代码也不是很难。数组处理方法$.each()、$.map()和$.grep()都是实用方法。

#### 添加多个函数

#### 1. 扩展全局jQuery对象

利用`$.extend()`函数，还可以通过另外一种语法来定义全局函数 

```javascript
(function($) { 
  $.extend({
      sum: function(array) { 
          ...
      },
      average: function(array) {
          ...
      }
  });
})(jQuery);
```

这样调用$.extend()就可以给全局jQuery对象添加属性（如果原来有相同的属性，就会替换原来的属性）。

#### 2. 使用命名空间隔离函数

为了避免冲突，最好的办法是把属于一个插件的全局函数都封装到一个对象中

```javascript
(function($) { 
  $.mathUtils = { 
  	...
  }; 
})(jQuery); 
```

这个模式的本质是为所有的全局函数又创建了一个命名空间，叫做jQuery.mathUtils。

在调用它们时就必须得加上插件的名字了：

```javascript
$.mathUtils.sum(sum); 
$.mathUtils.average(average); 
```

> **选择命名空间** 
>
> 对于仅限于个人使用的函数，一般来说还是把它保存在项目的命名空间中最方便。换句话说，不要保存在jQuery命名空间中，而要选择一个我们自己的全局对象。

## 8.3 添加jQuery对象方法

添加全局函数需要以新方法来扩展jQuery对象。添加实例方法也与此类似，但扩展的却是jQuery.fn对象：

```javascript
jQuery.fn.myMethod = function() { 
	alert('Nothing happens.'); 
}; 
```

> jQuery.fn对象是jQuery.prototype的别名，使用别名是出于简洁的考虑。

一个合理的实例方法应该包含对它的上下文的操作。

### 8.3.1 对象方法的上下文

在任何插件方法内部，关键字this引用的都是当前的jQuery对象。

### 8.3.2 隐式迭代

要在无论匹配多个元素的情况下都保证行为正确，最简单的方式就是始终在方法的上下文上调用.each()方法；这样就会执行隐式迭代，而执行隐式迭代对于维护插件与内置方法的一致性是至关重要的。

在调用的.each()方法内部，this依次引用每个DOM元素

> **this的含义**
>
> 注意！在对象方法体内，关键字this引用的是一个jQuery对象，但在每次调用的.each()方法中，this引用的则是一个DOM元素。

### 8.3.3 方法连缀

返回的jQuery对象通常就是this所引用的对象。如果我们使用.each()迭代遍历this，那么可以只返回迭代的结果

## 8.4 提供灵活的方法参数

### 8.4.1  参数对象

作为一种向插件用户公开选项的方式，对象要比刚刚使用的参数列表更加友好。对象会为每个参数提供一个有意义的标签，同时也会让参数次序变得无关紧要。而且，只要有可能通过插件来模仿jQuery API，就应该使用对象来提高一致性和易用性

### 8.4.2  默认参数值

实用函数$.extend()可以用接受的opts对象参数覆盖defaults中的选项，并保持选项对象中未指定的默认项不变。

```
var defaults = { 
  copies: 5, 
  opacity: 0.1 
}; 
var options = $.extend(defaults, opts);
```

$.extend()方法甚至可以接受null值

### 8.4.3 回调函数

要在方法中使用回调函数，需要接受一个函数对象作为参数，然后在方法中适当的位置上调用该函数。

### 8.4.4 可定制的默认值

要支持默认值的可定制，需要把它们从方法定义中移出，然后放到外部代码可以访问的地方

```javascript
(function($) { 
  $.fn.shadow = function(opts) { 
    var options = $.extend({}, $.fn.shadow.defaults, opts); 
    	// ... 
    }; 
  	$.fn.shadow.defaults = { 
    	//...
    } 
  }; 
})(jQuery); 
```

由于现在所有对.shadow()的调用都要重用defaults对象，因此不能让`$.extend()`修改它。我们就在此将一个空对象（{}）作为`$.extend()`的第一个参数，让这个新对象成为被修改的目标。

## 8.5 使用jQuery UI部件工厂创建插件

jQuery UI库的核心包含了一个工厂方法，叫`$.widget()`

使用部件工厂创建的插件具有很多不错的特性。只要编写少量代码，就可以额外获得这些功能（甚至更多）：

- 插件具有了“状态”，可以检测、修改甚至在应用之后完全颠覆插件的原始效果；
- 自动将用户提供的选项与定制的选项合并到一起；
- 多个插件方法无缝组合为一个jQuery方法，这个方法接受一个表明要调用哪个子方法的字符串；
- 插件触发的自定义事件处理程序可以访问部件实例的数据。

### 8.5.1 创建部件

每次调用`$.widget()`都会通过部件工厂创建一个jQuery UI插件。这个函数接受部件的名称和一个包含部件属性的对象作为参数。部件名称必须带命名空间

```javascript
(function($) { 
  $.widget('ljq.tooltip', { 
    _create: function() {
    	//...
    } 
  }); 
})(jQuery); 
```

> 部件属性（如_create()）以下划线开头，表示私有。

.on()调用中还涉及了另一个新语法：把处理程序传递给$.proxy()函数。这个函数会修改方法中this的指向。

### 8.5.2 销毁部件

一个内置的子方法是destroy。

> 注意，这一次的destroy前面并没有加下划线，这是因为它是一个可以过.tooltip('destroy')调用的公有子方法。

### 8.5.3 启用和禁用部件

内置的enable和disable子方法可以帮我们实现部件的启用和禁用，方法是将this.options.disabled的值设置为true或false。

### 8.5.4 接受部件选项

> **对选项变化作出响应** 
>
> 如果需要立即对选项变化作出响应，可以在部件中添加一个`_setOption`函数，这个函数负责处理变化，然后调用`_setOption`的默认实现。

### 8.5.5 添加子方法

有时候我们可能想为自己插件的用户提供更多“挂钩”。前面已经介绍过如何在部件中创建私有函数，实际上创建公有函数（也就是子方法）也一样，唯一的区别在于部件的属性名不以下划线开头。

### 8.5.6 触发部件事件

真正的好插件不仅自己扩展jQuery，而且还能为其他代码提供机制来扩展它。提供这种扩展能力的方法之一就是支持与插件相关的一组自定义事件。

## 8.6 插件设计建议

- 为避免`$`别名与其他库发生冲突，可以使用jQuery，或者在立即调用的函数表达式（IIFE）中传入`$`，使其成为一个局部变量。
- 无论是以`$.myPlugin`的方式扩展jQuery，还是以`$.fn.myPlugin`的方式扩展jQuery的原型，给`$`命名空间添加的属性都不要超过一个。更多的公有方法和属性应该添加到插件的命名空间中。
- 别忘了为插件提供一个默认选项的对象：`$.fn.myPlugin.defaults = {size: 'large'}`。
- 要允许插件用户有选择地覆盖任何默认选项，包括影响后续方法的调用(`$.fn.myPlugin. defaults.size = 'medium';`）和单独调用（`$('div').myPlugin ({size: 'small'});`）。
- 多数情况下，扩展jQuery原型时（`$.fn.myPlugin`）要返回this，以便插件用户通过连缀语法调用其他jQuery方法（如`$('div').myPlugin().find('p').addClass('foo')`）。
- 在扩展jQuery原型时（`$.fn.myPlugin`），通过调用this.each()强制执行隐式迭代。
- 合适的时候，利用回调函数支持灵活地修改插件行为，从而不必修改插件代码。
- 如果插件是为了实现用户界面元素，或者需要跟踪元素的状态，使用jQuery UI部件工厂来创建。
- 利用QUnit等测试框架为自己的插件维护一组自动的单元测试，以确保插件能够按预期工作。
- 使用Git或其他版本控制系统跟踪代码的版本。
- 在把自己的插件提供给别人使用时，务必明确许可条款。建议考虑使用MIT许可，这也是jQuery使用的许可。

#### 分发插件

还应该在分发插件之前，给它配上完整的文档。可以选择一种恰当的文档格式，也可以利用现有的文档标准，例如JSDoc、doco和dox等。

## 8.7小结



# 第9章 高级选择符与遍历

## 9.1 深入选择与遍历

### 9.1.1 动态筛选表格内容

第一步，就是隐藏所有不包含相关主题的表格行

```javascript
#news tr:has(td):not(:contains("topic")) 
```

> **选择符与遍历方法**
>
> 使用选择符还是使用与其对应的遍历方法，最终可能会导致性能上的差异。

### 9.1.2 为表格行添加条纹效果

为表格中的行交替应用不同颜色的方式：

使用:even和:odd自定义选择符可以迅速实现这一效果，而使用CSS原生的:nth-child()伪类也可以实现同样的效果

```javascript
$(document).ready(function() { 
	$('#news').find('tr:nth-child(even)').addClass('alt'); 
});
```

如果想实现更复杂一些的行条纹，可以尝试每两行一组地应用alt类。因为没有再使用`:nth-child()`伪类，所以交替效果不会在每个`<tbody>`元素中分别开始。同时，为了保证外观的一致，还要跳过表格中的标题行。

```javascript
$(document).ready(function() {
  $('#news tbody').each(function() {
    $(this).children().has('td').filter(function(index) {
    	return (index % 4) < 2;
    }).addClass('alt');
  });
});
```

### 9.1.3 组合筛选与条纹

为了让筛选与条纹可以完美地共存，必须在每次筛选之后重新应用条纹效果。此外，在应用alt类的时候，还要考虑某些行当前是否隐藏了。

这里用到的伪类:visible（及其对应的伪类`:hidden`）非常重要，它会排除由于各种原因隐藏的元素，包括display值为none以及width和height属性被设置为0。

### 9.1.4 更多选择符与遍历方法

所有选择符的介绍：http://api.jquery.com/category/selectors/，而这里有遍历方法的介绍：http://api.jquery.com/category/traversing/。

## 9.2 定制与优化选择符

### 9.2.1 编写定制的选择符插件

提高代码可读性的一种方式是自定义选择符表达式。

最容易添加的选择符是伪类，也就是以冒号开头的选择符表达式，比如:checked或:nth-child()。

在使用选择符表达式查找元素的时候，jQuery会在一个内部的对象expr中取得JavaScript代码。这个对象中的值与我们传入到.filter()或.not()中的筛选函数非常相似，当且仅当取得的函数返回true的情况下，才会让每个元素包含在结果集中。使用$.extend()函数可以为这个对象添加新的表达式。

```javascript
(function($) {
  .extend(.expr[':'], {
    group: function(element, index, matches, set) {
      var num = parseInt(matches[3], 10);
      if (isNaN(num)) {
        return false;
      }
    	return index % (num * 2) <num;
    }
  });
})(jQuery);
```

以上代码告诉jQuery：group是一个有效的字符串，可以放在一个冒号的后面构成选择符表达式。而在遇到这个选择符表达式的时候，应该调用给定的函数，用以决定相应的元素是否应该包含在结果集中。

这个被求值的函数一共接收了4个参数。

- element：当前考虑的DOM元素。这个参数对于大多数选择符都是必须的，但我们这个选择符则不需要。
- index：DOM元素在结果集中的索引。
- matches：数组，包含用于解析这个选择符的正则表达式的解析结果。一般来说，matches[3]是这个数组中唯一有用的值；假设有一个选择符的形式为:group(b)，则matches[3]中包含的值就是b，也就是括号中的文本。
- set：匹配到当前元素的整个DOM元素集合。这个参数很少用。

伪类选择符需要使用包含在这4个参数中的信息，决定当前元素是否应该包含在结果集中。

### 9.2.2 选择符的性能问题

在规划任何Web项目的时候，都需要考虑项目周期、维护代码的难易程度和效率，以及用户使用网站过程中的性能等问题。

选择符及遍历的性能问题经常是解决用户感觉网页反应迟钝的一个突破口。


>为了真正提升性能，最好反复思考自己假定的条件，然后在使jsPerf（http://jsperf.com/）等工具实际测量之后，再动手编写优化代码。

#### 1. Sizzle的选择符实现

在把一个选择符表达式传递给$()函数时，jQuery的Sizzle引擎会解析这个表达式，并确定如何收集该表达式所表示的元素。

在最本质的层次上，Sizzle会应用浏览器支持的最高效的原生DOM方法取得nodeList。这个节点列表是一个包含DOM元素的类似数组的对象，jQuery最终会将这个对象转换成真正的数组，并将其添加到jQuery对象中。下面就是jQuery内部使用的几个DOM方法，同时给出了支持它们的浏览器及版本。

| 方 法                       | 选择目标                 | 支持的浏览器                      |
| ------------------------- | -------------------- | --------------------------- |
| .getElementById()         | 取得ID与给定的字符串匹配的一个元素   | 全部                          |
| .getElementsByTagName()   | 取得标签名与给定的字符串匹配的所有元素  | 全部                          |
| .getElementsByClassName() | 取得某个类名与给定的字符串匹配的所有元素 | IE 9+、Firefox 3+、Safari 4+、 |
| .querySelectorAll()       | 取得与给定的选择符表达式匹配的所有元素  | IE 8+、Firefox 3.5+、Safari   |

在这些方法都不能处理某个选择符表达式的情况下，Sizzle会退而求其次地循环遍历已经收集到的所有元素，并根据这个表达式来测试每一个元素。

具体来说，假如没有现成的DOM方法可以拿来处理这个选择符表达式，Sizzle就会使用document.getElementsByTagName('*')来取得文档中的全部元素，然后再遍历并测试每个元素。

与使用任何一个原生DOM方法相比，这种遍历和测试每个元素的方法十分影响性能。好就好在，所有现代浏览器的最新版本都开始原生支持.querySelectorAll()方法了，此时Sizzle就会在其他（也许更快的）原生方法不可用的情况下使用这个方法。但也有一个例外：如果选择符表达式中包含自定义的jQuery选择符（例如:eq()、:odd或:even），而这些选择符并没有对应的CSS版本，那Sizzle也别无选择，只能循环加测试了。

#### 2. 测试选择符的速度

用来测试的现代浏览器（Chrome 26、Firefox 20和Safari 6）由于支持选择符可以利的.querySelectorAll()方法，平均速度比使用jQuery自定义选择符快得多

在不支持.querySelectorAll()的浏览器（如IE7）中，这两个选择符的速度几乎相同。因为这时候两个选择符都会强迫jQuery遍历页面中的每一个元素，并逐个进行测试

`$('input:eq(1)')` 和`$('input').eq(1)`，后者速度比前者快很多

一条通用的经验法则：要尽可能使用CSS规范中规定的选择符，除非没有可使用jQuery的自定义选择符。同样，在修改选择符之前，也要记住只在确实有必要提升性能的情况下再去提升。

## 9.3 DOM遍历背后的秘密

每当我们从一个（组）DOM元素转移到另一个（组）DOM元素时，jQuery都会留意我们移动的路线并留下“面包屑”，以便我们在必要时能够找到“回家”的路。

### 9.3.1 jQuery对象属性

通过`$()`函数得到的对象里面还隐藏着其他一些属性。

比如.context属性中包含着一个DOM节点（通常是document）的引用，搜索就是从这个节点开始的；比如.selector属性中保存着创建最终对象的选择符表达式。在调用`.on()`等事件委托方法时，这两个属性就会派上用场。在调用某个DOM遍历方法时，则会用上第三个属性：`.prevObject`。这个属性中保存着调用遍历方法的那个jQuery对象。

### 9.3.2 DOM元素栈

每个jQuery对象都有一个`.prevObject`属性指向前一个对象。这样，就有了一个实现了栈的列表结构。

`.end()`和`.addBack()`方法就是用来操作这个栈的。

`.end()`方法只是简单地从栈中弹出一个元素，结果就是栈的最上方保存着与`.prevObject`属性中相同的引用。

调用`.addBack()`时，jQuery会在栈中回溯一个位置，把两个位置上的元素集组合起来。

### 9.3.3 编写DOM遍历方法插件

可以通过为$.fn添加属性的方式来向jQuery中添加遍历方法。

> **处理嵌套的表格**
>
> 为了支持表格嵌套，需要确定是否存在`<tbody>`标签，并在DOM树中上下移动适当的位置

`.pushStack()`方法接收一批DOM元素，并将它们添加到栈中，以便接下来对`.addBack()`和`.end()`的调用能够准确无误地执行。

### 9.3.4 DOM遍历的性能问题

最低限度地重复选择符和遍历方法则始终是值得提倡的，有两个策略值得讨论，那就是连缀和缓存对象。

#### 1. 使用连缀来改进性能

事实上，使用连缀还有可能带来性能上的提升，而关键则是利用它来减少重复。（比如：利用栈的技术）

#### 2. 使用缓存来改进性能

考虑到使用选择符和遍历方法的性能问题，缓存的目标可以确定为把jQuery对象保存在一个变量中，以便将来使用时不再重新创建同样的对象。

与连缀的方法相比，缓存方式稍嫌冗长，因为额外创建了一个用于保存jQuery对象的变量。但从另一个角度来看，这种方式在代码中可以完全分离选中元素的两次操作

## 9.4 小结



# 第10章 高级事件处理

## 10.1 再谈事件

### 10.1.1 追加数据页面

在单击More Photos链接时，需要执行一次Ajax请求，加载下一组照片并将它们追加到`<div id="gallery">`。


此外，还要更新More Photos链接的目标，让它指向包含下一组照片的页面。


>**渐进增强**
>这个示例可以离线使用，不需要Web服务器。在实际应用当中，相关数据可能会保存在一个数据库里。
>此外，还需要考虑使用HTML5的历史记录API，让用户能够把我们用Ajax加载的内容保存为书签。

### 10.1.2 悬停时显示数据

首先，为了显示这些信息，可以使用.hover()方法。

由于两个处理程序中有一部分代码完全相同，因此可以把它们组合起来以减少冗余的代码。比如，可以为mouseenter和mouseleave绑定同一个处理程序，只在两个事件名称之间加一个空格即可。


但有一个例外，那就是当用户单击More Photos链接加载了更多照片时，新加载的照片不会响应那两个事件。事件处理程序只会添加到调用.on()方法时已经存在的元素上。像通过Ajax调用这样后来添加的元素，不会绑定那些事件。当前，我们针对这个问题给出了两个解决方案：一是在加载了
新内容之后，“重新绑定”事件处理程序；二是一开始就把事件绑定到包含元素上，不依赖于事件冒泡。后一个解决方案，叫做事件委托。

## 10.2 事件委托

前面提到，为了实现事件委托，我们需要检测event对象的target属性，以便知道事件目标是不是我们想要触发行为的那个元素。事件目标，指的是接收到事件的那个最里面、最深层的元素。对于目前的示例程序而言，`<div class="photo">`元素不可能成为事件目标，因为它还包含着其他元素，比如图像和图像的信息。我们需要使用.closest()方法，这个方法可以沿DOM树向上一层一层移动，直至找到与给定的选择符表达式匹配的那个元素。如果没有找到这个元素，那它就会像其他DOM遍历方法一样，返回一个“空的”jQuery对象。

注意，还需要把事件的类型由mouseenter和mouseleave改为mouseover和mouseout。因为前两个事件只有在鼠标最先进入和最后离开`<div id="gallery">`时才会触发，而我们需要在鼠标进入这个包含`<div>`内部的任何照片时都触发处理程序。然而，使用后两个事件又会引入另外一个问题，即必须额外再检测event对象的relatedTarget属性，否则`<div class="details">`就会反复淡入淡出。

### 10.2.1 使用jQuery的委托方法

jQuery的.on()方法内置了委托管理能力。

```javascript
$(document).ready(function() {
  $('#gallery').on('mouseenter mouseleave', 'div.photo',
    function(event) {
     ...
    }
  });
});
```

在把'div.photo'作为第二个参数的情况下，.on()方法会把this关键字映射为'#gallery'中与该选择符匹配的元素。

> 有些开发人员使用.delegate()和.undelegate()方法，虽然语法不同，但作用是一样的。

### 10.2.2 选择委托的作用域

实际上，照片元素的任何祖先元素都可以作为这个委托的作用域。

在安排事件委托时，把处理程序绑定到document很方便。因为所有元素都是document的后代，这样不用担心是否会选错容器。可是，这种方便也需要牺牲一定的性能。如果DOM嵌套结构很深，事件冒泡通过大量祖先元素也会导致较大的性能损失。

### 10.2.3 早委托

一般来说，只有当相应的DOM元素加载完毕，才能给它绑定事件处理程序。这就是为什么我们通常都把代码放到`$(document).ready()`内部的原因。

可是，document元素是随着页面加载几乎立即就可以调用的，把处理程序绑定到document不用再等到完整的DOM构建结束。

> **立即被调用的函数表达式**
>
> 我们使用了立即调用的函数表达式（IIFE）来取代$(document).ready()。IIFE形同第8章讨论过的闭包，可以在同一个页面中使用其他脚本时，避免可能的函数或变量的命名冲突（因为变量都被“限定”在了函数中）。

## 10.3 自定义事件

.on()方法对应着一个函数的定义，而.trigger()方法对应着一次函数调用。

### 10.3.1 无穷滚动

所谓无穷滚动，是一种让用户控制滚动条来加载内容的流行技术，即当到达目前加载的内容底部时，就会自动取得新内容。

### 10.3.2 自定义事件参数

在触发自定义事件时，我们也可以给任何注册的事件处理程序传入额外的信息。这种技术就叫做自定义事件参数。

任何事件处理程序的第一个参数是由jQuery增强和扩展之后的DOM事件对象。在这个参数之后，我们可以根据需要传递任意数量的参数。


这个自定义事件参数在调用和接收的任何一端都是可选的。都不会出错。

## 10.4 节流事件

无穷滚动功能的主要问题是性能。由于某些浏览器中的scroll事件会在窗口滚动期间重复触发，因此计算过程会不断累积。浏览器中有几个原生事件都会频繁触发。最常见的事件有scroll、resize和mousemove。

为了解决这个问题，就需要节流事件。这个技术会限制一些无谓的计算，即不是每次事件发生都
计算，而是选择在部分事件发生时计算。

使用JavaScript的setTimeout函数，延迟250毫秒再调用它。更重要的是，我们会在执行任何代码之前先检查当前运行的计时器。

#### 其他节流方案

这个轮询式的方案会调用JavaScript的setInterval()函数，每250毫秒检查一次scrolled变量的状态。不管什么时候发生滚动事件，scrolled都会被设置为true，以确保在下一次轮询时调用checkScrollPosition()。

>在频繁重复的事件发生期间限制处理次数的第三种技术叫**消除抖动**（debouncing）。这种技术是以电子开关重复发送信号必需的后处理技术命名的，可以确保在发生多个事件的情况下，最终只会有一个事件实际地起作用。

## 10.5 扩展事件

可以创建一个特殊的新事件，用它来封装相应的节流技术。为了实现一个事件的特殊行为，需要为`$.event.special`对象添加属性。这个属性的键是我们的事件名称，而它的值本身是一个对象。这个特殊的事件对象包含可以在不同时刻调用的回调函数：

1. add会在每次为当前事件绑定处理程序时调用；
2. remove会在每次为当前事件删除处理程序时调用；
3. setup会在为当前事件绑定处理程序，且没有为元素的这个事件绑定其他处理程序时调用；
4. teardown是setup的反操作，会在某个元素删除这个事件的最后一个处理程序时调用；
5. _default是当前事件的默认行为，在没有被事件处理程序阻止的情况下会执行。

### 深入学习特殊事件

创建特殊事件其他可能的应用包括：

- 修改事件对象，以便事件处理程序可以使用不同的信息；
- 让DOM中的某个地方发生的事件触发与不同元素关联的行为；
- 对新的浏览器特有的非标准DOM事件作出响应，让jQuery代码像处理标准事件一样处理它们；
- 改变处理事件冒泡和事件委托的方式。

## 10.6 小结

本章介绍了事件系统的几个方面，包括事件委托方法、自定义事件和事件扩展API。同时，还讨论了如何避免事件委托以及频繁触发事件的一些陷阱。



# 第11章 高级效果

## 11.1 再谈动画

鼠标悬停动画。

## 11.2 观测及中断动画

存在问题：一个给定元素的动画会逐一被添加到一个队列中，然后再依次调用。第一个动画会立即被调用，在指定时间内完成，然后从队列中移除。此时，第二个动画又排在了第一位，于是接着被调用，完成，移除，以此类推，直至队列为空。

很多情况下，jQuery中这个叫做fx的动画队列都不会给我们带来问题。不过，在遇到像我们前面例子中这种悬停动画时，就要跟这个队列斗斗智了。

### 11.2.1 确定动画状态

若要避免产生不合需要的动画队列，一种方式是使用jQuery自定义的:animated选择符。

在mouseenter/mouseleave事件处理程序中，可以使用这个选择符来检测图像，看它当前是否正处于动画的过程中。


现在的动画仍然还需要改进。当鼠标快速进入和离开`<div>`时，图像仍然会完成整个mouseenter动画（增大），然后才开始mouseleave动画（缩小）。但测试`:animated`伪类又引入了一个更大的问题：如果鼠标进入`<div>`时，图像正在“缩小”，那么此后的图像也不会再增大了。只有当动画完成之后发生的mouseenter和mouseleave事件，才会引发另一次动画。这说明，尽管`:animated`选择符适用于在某些情况下检测动画状态，但在我们这里还不够。

### 11.2.2 中止运行的动画

.stop()方法能在动画运行过程中让动画立即停止。

#### 中止动画的注意事项

`.stop()`方法默认情况下会在动画的当前位置中止动画，在动画之前，这些简写的动画方法会确定最终的值，然后动态变化到该值。比如说，如果使用`.stop()`在`.slideDown()`动画的中途将其中止，然后调用`.slideUp()`。那么下次再在同一个元素上调用.slideDown()时，就只会向下滑动到上一次停止时的高度。

为了解决这个问题，`.stop()`方法可以接收两个布尔值参数（true/false），其中第二个参数叫goToEnd。如果把这个参数设置为true，那么当前动画不仅会停止，而且会立即跳到最终值。

更好的办法是把最终值保存在一个变量中，使用`.animate()`显式变化到该值，而不要依赖jQuery确定的值。

> jQuery还有一个方法可以中断动画：`.finish()`。这个方法与`.stop(true, true)`效果类似，因为它会清除排队的动画并使当前动画跳到最终值。不过，与`.stop(true, true)`不同的是，它也会使所有排队的动画都跳到各自的最终值。

## 11.3 全局效果属性

### 11.3.1 禁用所有效果

为了实现这个功能，只要简单地把`$.fx.off`属性设置为true即可。

### 11.3.2 定义效果时长

`$.fx`对象还有一个speeds属性。这个属性本身是一个对象，包含三个属性，通过jQuery核心源代码中这一小段可以看出来：

```javascript
speeds: { 
  slow: 600, 
  fast: 200, 
  //默认速度
  _default: 400 
} 
```

每次调用一个动画方法，jQuery都要通过以下步骤来确定效果的持续时间。

1. 检测`$.fx.off`是否为true。如果是则持续时间为0。
2. 检测传入的持续时间是否为数值；如果是，则将持续时间设置为该毫秒数。
3. 检测传入的持续时间是否与`$.fx.speeds`的某个属性键匹配。如果是，则将持续时间设置为该属性的值。


4. 如果前面检测未发现传入持续时间参数，则将持续时间设置为`$.fx.speeds._default`的值。

注意，调用的`.fadeOut()`方法也使用了前面定义的比较快的250毫秒持续时间。这个默认值对jQuery所有的预置效果都是有效的，就像它对前面那个`.animate()`方法起作用一样。

## 11.4 多属性缓动

只要把top属性的缓动函数修改为easeInQuart，就可以改变一下效果；也就是让元素以曲线的方式运动，而不是径直地出来。

使用非swing和linear的任何缓动函数都需要插件。

通过specialEasing选项可以为每个要应用动画的属性设置不同的加速度曲线。任何没有包含在这个选项中的属性，都会使用easing选项中指定的缓动函数——如果提供了的话；否则，就要使用默认的swing函数。

## 11.5 使用延迟对象

延迟对象用以封装一个需要花一定时间才能完成的操作。

通过调用`$.Deferred()`构造函数可以创建一个新的延迟对象。有了延迟对象之后，就可以执行长时间的操作，然后在成功或不成功的情况下调用这个对象的`.resolve()`或`.reject()`方法。不过，很少需要手工调用这两个方法。

每一个延迟对象都会向其他代码**承诺**（promise）提供数据。这个承诺以另一个对象的形式来兑现，这个对象也有自己的一套方法。对于任何延迟对象，调用它的`.promise()`方法就可以取得其承诺对象。然后，通过调用这个承诺对象的各种方法，就可以添加在各种承诺兑现时调用的处理程序。

- 通过.done()方法添加的处理程序会在延迟对象被成功解决之后调用。
- 通过.fail()方法添加的处理程序会在延迟对象被拒绝之后调用。
- 通过.always()方法添加的处理程序会在延迟对象完成其任务（无论解决或拒绝）时调用。

这些处理程序与回调函数还是有一些重要的区别：

- 承诺的处理程序只会被调用一次，因为延迟对象不能解决两次。
- 而且，如果在我们添加承诺处理程序时延迟对象已经解决，那么就会立即调用这个处理程序。

#### 动画承诺

特别地，我们可以使用这个承诺对象在匹配元素上的所有动画运行完成后再执行某项操作。

使用`$.extend()`方法将始终保持不变的基本样式与根据不同成员位置变化的top和left属性合并在一起。然后，就是使用`.css()`来设置其开始样式，再使用`.animate()`来设置最终样式了。

第4章曾介绍过，jQuery动画方法的回调函数会在集合中每个元素的动画完成之后被调用。现在，我们想在其他`<div>`元素出现之后再显示成员的简介。这要是在jQuery引入`.promise()`方法之前，就是一个非常麻烦的任务。因为需要在每次执行回调函数时，都要倒减元素的个数，直至最后一次执行回调函数，然后才能执行简介的动画代码。而现在，只要在showDetails()函数中简单地把`.promise()`和`.done()`方法连缀在`.each()`方法之后即可。

## 11.6 精细地控制动画

jQuery 1.8重写了这个模块之后，又给高级开发人员提供了一些精细控制各种效果的手段，甚至可以让我们修改底层的动画引擎。比如，除了duration和easing选项之外，`.animate()`方法还提供了两个回调选项：

```javascript
$('#mydiv').animate({
  height: '200px',
  width: '400px'
  }, {
  step: function(now, tween) {
    //监控高度和宽度，
    //调整补间属性
  },
  progress: function(animation, progress, remainingMs) {
  }
});
```

在动画过程中，这里的setup()函数大约每13毫秒会针对每个动画属性被调用一次。这样，我们就可以调整tween对象的属性，比如终止值、缓动类型，或者根据传入的now参数中属性的当前值修改实际的动画属性。

类似地，progress()函数在动画生命周期中也会被多次调用：

- 它与setup()的区别在于，它只会在动画的每一步针对每个元素被调用一次，与多少属性产生动画效果无关；
- 它提供了动画其他方面的调整选项，包括动画的承诺对象、进度（0到1之间的一个值）和动画剩余的毫秒数。

jQuery所有的动画都使用JavaScript的计时函数setTimeout()来重复调用函数。默认间隔时间为13毫秒，每次调用都会修改样式属性的值。

有些现代浏览器支持比setTimeout()更好的requestAnimationFrame()函数，使用这个函数不仅控制更精确（因此动画也更平顺），而且在移动设备上还能节省电量消耗。不管浏览器标签页是否活动，setTimeout()始终都不会停止运行。而requestAnimationFrame()函数则会在标签页不可见的时候暂停执行，因而更省电。

jQuery动画的Corey Frang写了一个用requestAnimationFrame()替代setTimeout()的插件（只要浏览器支持就替换）。这个插件会修改$.fx对象的两个方法：.timer()和.stop()。


对于动画而言，一般都应该使用requestAnimationFrame()替代setTimeout()。不过，由于在代码中同时使用这两者可能会引发冲突，jQuery核心库并没有实现requestAnimationFrame()。


jQuery动画系统最底层的方法是`$.Animation()`和`$.Tween()`函数。这两个函数及其对应的对象可以用来调整动画的每个可能的方面。比如，可以使用`$.Animation()`来创建动画滤清器（prefilter）。

## 11.7 小结

现在，我们知道了怎样单独控制每个动画属性的加速和减速，甚至在必要时单独地或全面地停止动画效果。讲到了jQuery效果库内部定义的几个属性，以及如何更改这些属性以适应我们的需求。本章还介绍了jQuery的延迟对象系统。最后，我们又学习了jQuery为高级程序员提供的精细控制动画效果的手段。



# 第12章 高级DOM操作

## 12.1 排序表格行

### 12.1.1 服务器端排序

经常可以看到类似下面的用户界面：让用户点击表头（`<th>`）中的链接来按照指定的列排序表格数据。这些链接都指向当前页面，但后面附加的查询字符串则用来表示作为排序依据的列：

```html
<table id="my-data"> 
  <thead> 
    <tr> 
      <th class="name"> 
      	<a href="index.php?sort=name">Name</a>
      </th> 
      <th class="date"> 
      	<a href="index.php?sort=date">Date</a> 
      </th> 
    </tr> 
  </thead> 
  <tbody> 
  	... 
  </tbody> 
</table> 
```

### 12.1.2 Ajax排序

可以通过jQuery把那些链接转换为Ajax请求：

```javascript
$(document).ready(function() { 
  $('#my-data th a').click(function(event) { 
  	event.preventDefault(); 
  	$('#my-data tbody').load($(this).attr('href')); 
  }); 
});
```

### 12.1.3 JavaScript排序

可行的方案就是在浏览器中使用JavaScript客户端脚本和jQuery的DOM操作方法来排序。包括：

- 根据从HTML内容中提取的内容排序；
- 根据HTML5自定义数据属性排序；
- 根据表格数据的JSON表示排序。

## 12.2 移动和插入元素

从最简单的地方着手——为表头加链接。

### 12.2.1 为已有的文本添加链接

`.wrapInner()`方法，这个方法会把一个新元素（在这里就是`<a>`元素）放到匹配元素的内部，同时包含匹配元素的子元素。


首先（使用`.slice()`方法）跳过每个表格的第一个`<th>`元素。

### 12.2.2 简单的JavaScript数组排序

JavaScript内置的.sort()方法。这个方法会对数组元素进行就地排序，可以接受一个比较函数作为参数。这个比较函数比较数组中的两个元素，根据哪个元素应该在排序后的数组中排在前面返回正值或负值。

### 12.2.3 对DOM元素排序


在找到被单击的表头单元格的索引之后，取得了包含所有数据行的数组。使用`.get()`方法将jQuery对象转换为DOM节点数组。之所以要这样做，是因为jQuery对象本身虽然与数组类似，但它却没有`.pop()`或`.shift()`等原生的数组方法。

> jQuery 内部确实定义了一些与原生数组方法类似的方法。例如，`.sort()`、`.push()`和`.splice()`都是jQuery对象的方法。不过，这些方法都是内部使用的，并没有在文档中公开出来。总之，不能在jQuery对象上调用它们。

通过调用`.index()`方法返回的列索引，我们知道应该查找哪个单元格。而使用jQuery的`$.trim()`方法删掉文本内容前后的空格，之后再将它们转换成全部大写。

## 12.3 在DOM元素中保存数据


>**数组排序的性能**
>JavaScript实际使用的排序算法在标准中没有定义。

要解决比较函数造成的排序速度慢的问题，就需要预先计算要比较的关键字。换句话说，可以在一开始的循环中完成大部分费时的工作，并使用jQuery的`.data()`方法（用于设置和取得与页面元素相关的任意信息）把计算结果保存起来。

这里的`.data()`方法，再加上对应的`.removeData()`方法所提供的数据存储机制，可以非常方便地替代所谓的扩展属性（expando property）或其他直接添加给DOM元素的非标准属性。使用`.data()`而不是扩展属性可以避免在IE早期版本中导致内存泄漏。

### 12.3.1 执行预先计算

通过把标签中的排序关键字放到以前计算的关键字前头，可以实现以按姓排序为主，以按单元格中的整个字符串排序为辅的操作。

### 12.3.2 存储非字符串数据

之所以要对parseFloat()返回的结果进行检查，是因为如果不能从文本中解析出数字，该函数就会返回NaN，而这将会对`.sort()`函数造成严重破坏，所以需要将任何非数值设置为0。

表格中的日期只包含月和年，但Date.parse()方法需要一个完整的日期，因此我们前置了一个1，以便补足月和年前面的日（“September 2010”会变成“1 September 2010”）。

### 12.3.3 变换排序方向

当用户单击一个已经排序的表格列时，应该反转当前的排序次序。

## 12.4 使用HTML5自定义数据属性

通过让服务器输出带有HTML5 data-*属性的HTML，可以让代码更加有效。

为取得自定义数据属性，需要把属性名中data-之后的部分传给`.data()`方法。

使用像这里这样的数据属性的一个最大好处是，这些值可以输出为不同于表格单元格内容的形式。换句话说，我们对前面第一个表格所做的细节处理——把字符串转换为全部大写、改变日期的格式以及把价格转换为数值，都已经被处理好了。

## 12.5 使用JSON排序和构建行

首先，我们来编写两个函数：buildRow()和buildRows()。前者用于构建表格中的一行，后者使用`$.map()`循环遍历数据集中的所有行，在每一行数据上调用buildRow()。

虽然这里用一个函数也可以达到相同的目的，但使用两个独立的函数则可以方便我们在某个时刻单独地构建和插入一个表格行。这两个函数会从一次Ajax请求的响应取得数据

```javascript
$.getJSON('books.json', function(json) {
  $(document).ready(function() {
  	var table3 = ('#t-3');
  	$table3.find('tbody').html(buildRows(json));
  });
});
```

关于这段代码，有几个地方需要说明一下。首先，这两个函数是在`$(document).ready()`外部定义的。通过等待`$.getJSON()`的回调函数调用`$(document).ready()`，可以让部分代码不必依赖于DOM而提前执行。

而在`$.each()`循环后面，又将生成的数组的值通过一个逗号和一个空格连接起来，得到了一个格式规范的名字列表。确保HTML字符串安全的一种方式就是在服务器上处理它们，比如把所有<转换成<、把>转换成>、把&转换成& ，等等。

### 12.5.1 修改JSON对象

通过给这个函数传入JSON数据，我们为表示每一行的对象又添加了两个属性：authorsFormatted和titleFormatted。这两个属性将用于显示表格内容，而原始的authors和title属性则用于排序。

当我们在`$.getJSON()`的回调函数中调用这个preRows()函数后，我们把修改后的JSON对象保存在变量rows中，然后基于这个修改后的对象进行排序和构建。这意味着还必须修改buildRow()函数，使其在提前准备数据的基础上能够变得更加简洁

### 12.5.2 按需重新构建内容

如何修改列标题和编写排序的代码

唯一的明显区别是这里的每次排序只向DOM中插入一次元素。

从性能的角度来看，重复性的DOM插入操作是非常费时间的，需要插入的表格行越多，效率就越低。

## 12.6 高级属性操作

可以使用`.attr()`、`.prop()`和`.css()`等简单的方法，以及`.addClass()`、`.css()`和`.val()`等方便的快捷方法，还可以使用像`.animate()`这样封装了复杂行为的方法。不过，即便是简单的方法都在后台帮我们完成了很多工作。

### 12.6.1 简捷地创建元素

我们在jQuery代码中创建元素时经常会把HTML字符串传递给`$()`函数，或者传递给其他DOM插入函数。但有时候，这种方式也不是最理想的，需要创建相应的元素然后连缀其他jQuery方法对它进行修改。不过，除了这种标准的技术之外，$()函数还提供了一种很有吸引力的语法。

假设我们要在文档中的每个表格前面都加上一个标题。可以使用`.each()`循环每一个表格，然后为每个表格创建适当的标题。

```javascript
$(document).ready(function() { 
  $('table').each(function(index) { 
    var $table = $(this); 
    $('<h3></h3>', { 
      id: 'table-title-' + index,
        'class': 'table-title', 
      text: 'Table ' + (index + 1), 
      data: {'index': index}, 
      click: function(event) { 
      	event.preventDefault(); 
      	$table.fadeToggle(); 
      }, 
       css: {glowColor: '#00ff00'} 
    }).insertBefore($table); 
  }); 
}); 
```

为$()函数传递选项对象作为第二个参数，与先创建元素再将该对象传递给.attr()方法的结果是一样的。

简写的`$()`语法之所以可以处理这些，是因为它首先检查是否存在给定名字的jQuery方法，如果是就会调用相应的方法，而不是设置相应的属性。

> 鉴于jQuery为方法赋予了比属性名更高的优先级，因此我们必须自己注意那些容易存在歧义的情况。比如，`<input>`元素的size属性就不能以这种方式来设置，因为还有一个`.size()`方法存在。

简写的`$()`函数以及`.attr()`方法通过使用挂钩（hook），还能够处理很多额外的DOM属性。

### 12.6.2 DOM创建挂钩

通过定义适当的挂钩，可以扩展很多取得和设置属性的jQuery方法，从而满足某些特殊情况下的需要。

这些挂钩实际上是jQuery命名空间中的数组，比如`$.cssHooks`、`$.attrHooks`。

一般来说，挂钩是保存着get和set方法的对象，前者用于取得请求的值，后者的作用则是提供新值。

以下是其他几种挂钩。

| 挂钩类型        | 修改的方法   | 示例用法                              |
| ----------- | ------- | --------------------------------- |
| $.attrHooks | .attr() | 阻止元素的type属性被修改                    |
| $.cssHooks  | .css()  | 对Internet Explorer中的opacity进行特殊处理 |
| $.propHooks | .prop() | 纠正Safari中selected属性的行为            |
| $.valHooks  | .val()  | 支持单选按钮和复选框跨浏览器报告一致的值              |

#### 编写CSS挂钩

一个挂钩由针对元素的get方法和set方法构成。

> **查找挂钩**
>
> 仅向读者推荐Brandon Aaron开发的CSS挂钩：https://github.com/brandonaaron/jquery-cssHooks。

## 12.7 小结

本章我们解决了一个常见的开发问题——数据表格排序。从三个不同角度阐述了实现表格排序的方法，分别展示了各自的优劣势。与此同时，我们也进一步掌握了原来学习过的DOM操作技术，同时探索了使用`.data()`方法与HTML5的数据属性在DOM元素上设置相关数据的新方式。此外，本章还揭开了一些DOM修改的底层机制，向大家展示了如何根据需要扩展这些机制。



# 第13章 高级Ajax

## 13.1 渐进增强与Ajax

大量运用Ajax的应用经常会面临用户不能使用JavaScript的风险。为了避免这种风险，可以先使用表单构建一个传统的客户端-服务器页面，而在JavaScript可用的情况下再修改表单，提供更有效的交互方式。

#### 收获JSONP数据

在请求JSONP数据时，需要提供一个特殊的查询字符串参数，发送请求的脚本就是通过该参数来收获数据的。JSONP服务器可以在认为合适的任何时候调用该参数。对于jQuery API站点而言，这个参数（也是默认的名字）是callback。

```javascript
$.ajax({ 
  url: 'http://book.learningjquery.com/api/', 
  dataType: 'jsonp', 
  data: { 
  	title: $('#title').val() 
  }, 
  success: function(data) { 
  	console.log(data); 
  } 
}); 
```

## 13.2 处理Ajax错误

$.ajax()函数可以接收一个名为error的回调函数

触发这个错误回调函数的情况有很多种。下面列出了其中的一些错误。

- 服务器返回了错误状态码，例如403 Forbidden、404 Not Found或500 Internet Server Error。
- 服务器返回了间接的状态码，例如301 Moved Permanently。状态码为304 Not Modified的
  异常不会触发错误，因为浏览器可以正确地处理这种情况。
- 服务器返回的数据不能按照指定方式正确解析（例如，在dataType指定为json时，返回的不是有效的JSON数据）。
- XMLHttpRequest对象调用了`.abort()`方法。

如果服务器返回错误，那么通过传递给错误回调函数的jqXHR对象的`.status`属性，可以检测到该错误。换句话说，使用`jaXHR.status`的值可以对不同的错误给出不同的响应。

在没有既定的服务器端超时机制的情况下，我们可以在客户端强制设定请求的超时。通过给timeout选项传递一个以毫秒表示的时间值，就相当于告诉`$.ajax()`:如果响应在多长时间内没有返回，那么就调用它自己的`.abort()`方法

## 13.3 jqXHR对象

在发出Ajax请求时，jQuery会帮我们确定取得数据的最佳方式。可用的方式包括标准的XMLHttpRequest对象、微软的ActiveX对象XMLHTTP，或者`<script>`标签。

需要一个公共的接口与这些通信交互。jqXHR对象提供了这种接口：在XMLHttpRequest对象可用的情况下，封装该对象的行为；在XMLHttpRequest对象不可用的情况下，则尽可能模拟它。这个对象提供给我们的属性和方法包括：

- 包含返回数据的`.responseText`或`.responseXML`；
- 包含状态码和状态描述的`.status`和`.statusText`；
- 操作与请求一起发送的HTTP头部的`.setRequestHeader()`；
- 提早中断通信的`.abort()`。

### 13.3.1 Ajax承诺

与标准的XMLHttpRequest对象相比，jqXHR对象有一点非常值得重视，那就是它也是一个**承诺对象**。可以通过它来设置在某个操作完成后触发的回调函数。Ajax调用就是这样一种操作，而jqXHR对象提供了延迟对象所承诺的方法。

使用这些承诺对象的方法，可以重写`$.ajax()`调用，替换success和error回调函数

这两个承诺方法的确是有好处的：

- 可以多次调用这两个方法，根据需要添加多个处理程序。
- 如果把调用`$.ajax()`的结果保存在一个变量中，那么就可以考虑代码的可读性，在后面再添加处理程序。
- 如果在添加处理程序的时候Ajax操作已经完成，就会立即调用该处理程序。
- 最好采用与jQuery库中其他代码一致的语法

使用承诺方法的另一个好处是可以在请求期间添加一个加载指示器，然后在请求完成时或在其他情况下隐藏它。这时候，使用.always()方法就非常方便。

### 13.3.2 缓存响应

为了避免重复发送Ajax请求，能够利用承诺对象的属性，那就非常简单了。

首先，如果以前没有查询过，那么可能会发送Ajax请求。

如果以前执行过这个查询，那么jqXHR对象已经保存在api里面了。这一次不会执行新的查询，但我们仍然可以在保存的对象上调用承诺方法。而这会给该对象添加新的处理程序，由于作为延迟对象它已经被解决了，所以会立即触发相关的处理程序。

## 13.4 截流Ajax请求

实现搜索功能时，越来越常见的一个功能是在用户输入过程动态地列出搜索结果来。

```javascript
$('#title').on('keyup', function(event) { 
	$ajaxForm.triggerHandler('submit'); 
}); 
```

如果用户连续输入的速度很快，那么就会通过网络发送很多请求。通过缓存请求的结果，我们已经节省了一些请求了。不过，通过**截流请求**，还能够进一步减少服务器的负担。

```javascript
//每一次击键动作都会重置该计时器，只有用户停止击键的时间超过预定的300毫秒后，才会触发submit处理程序并发送Ajax请求。
var searchTimeout, 
  searchDelay = 300; 
	
$('#title').on('keyup', function(event) { 
  clearTimeout(searchTimeout); 
  searchTimeout = setTimeout(function() { 
  	$ajaxForm.triggerHandler('submit'); 
  }, searchDelay); 
}); 
```

## 13.5 扩展Ajax功能

### 13.5.1 数据类型转换器

通过`$.ajaxSetup()`函数，也可以为`$.ajax()`添加它能够请求和解释的各种数据类型。

例子：一个能够解释YAML数据格式的转换器。

可以给jQuery附加一个已有的YAML解析器，比如Diogo Costa开发的，从而让`$.ajax()`能够解析这种格式。

要定义一种新的Ajax数据类型，需要给`$.ajaxSetup()`传递三个参数：accepts、contents和converters。其中，accepts属性会添加发送到服务器的头部信息，声明我们的脚本可以理解的特定MIME类型；contents属性处理数据交换的另一方，它提供一个与响应的MIME类型进行匹配的正则表达式，以尝试自动检测这个元数据当中的数据类型。最后，converters中包含解析返回数据的函数。


`$.ajax()`读取了一个YAML文件并将数据库声明为yaml。因为到来的数据会按照text格式解析，jQuery需要一种机制能把一种数据类型转换为另一种数据类型。converters的'text yaml'告诉jQuery，这个转换函数以text格式接收数据，然后以yaml格式重新解析。在转换函数内部，我们把文本内容记录到控制台中，以便验证这个函数能够被正确调用。要实际地执行转换，需要加载第三方的YAML解析库（yaml.js）并调用其方法。


这里要注意的是，在插入类别名的时候，需要把相应的代码放在`$(doucment).ready()`调用中。Ajax操作可能会立即运行，无需访问DOM，但当结果返回后，必须等到DOM可用才能继续操作。以这种方式来编写代码，可以让它尽可能早地运行，从而增强用户对页面加载时间的感知速度。

```javascript
$(document).on('click', '#categories a', function(event) {
  event.preventDefault();
  $(this).parent().toggleClass('active')
  	.siblings('.active').removeClass('active');
  $('#ajax-form').triggerHandler('submit');
});
```

通过把click处理程序绑定到文档并使用事件委托，可以避免某些耗时的重复性操作。而且，可以马上运行这些代码，而不必等待Ajax调用完成。

### 13.5.2 Ajax预过滤器

通过`$.ajaxPrefilter()`函数可以添加预过滤器。所谓预过滤器，就是一些回调函数，它们可以在发送请求之前对请求进行过滤。预过滤器会在`$.ajax()`修改或使用它的任何选项之前调用，因此通过预过滤器可以修改这些选项或基于新的、自定义选项发送请求。

预过滤器通过返回要使用的数据类型，也可以操作请求的数据类型。

### 13.5.3 替代传输方式

jQuery在适当的时候会使用XMLHttpRequest、ActiveX或`<script>`标签来处理Ajax事务。可扩展这种传输（transport）机制。

这种传输机制依赖于一个对象来实际地负责Ajax数据的传输。新的传输对象定义为工厂函数，返回一个带有`.send()`和`.abort()`方法的对象。其中，.send()方法负责发送请求、处理响应并把数据发送给回调函数。而`.abort()`方法会立即停止请求。


可以使加载图像的处理方式会与其他Ajax请求的处理方式相同，这样会让代码在内部更好地保持一致。


在定义传输对象时，首先需要向`$.ajaxTransport()`传入一个数据类型。这是告诉jQuery什么时候该使用我们的传输方式，而不是使用内置的机制。然后，再提供一个函数，该函数能够返回带有相应的`.send()`和`.abort()`方法的新传输对象。

对这个img传输对象，`.send()`方法需要创建一个新的`<img>`元素，并为它设置src特性。这个特性的值来自settings.url，是由jQuery通过$.ajax()调用传入的。浏览器在创建这个`<img>`元素时，会加载引用的图像文件，因此在这里需要检查什么时候加载完成，然后触发完成回调函数。

在检测到图像加载完成后（可能成功、完成，也可能出错），调用callback()函数，callback()函数再调用传递给`.send()`的complete()函数。这样，`$.ajax()`就能对图像的加载给出响应。

对于停止加载的处理就要简单多了。这里的.abort()方法要做的就是一些清理工作，它只需要在创建了`<img>`元素的情况下把该元素删除即可。


要使用自定义的传输机制，需要给`$.ajax()`提供一个对应的dataType值。

## 13.6小结

学习了如何在页面中营造更加流畅的用户体验，如何根据需要获取外部资源，同时也关注了错误处理、缓存以及截流等技术。随后，我们又学习了Ajax框架的内部运行机制，包括承诺、传输、预先筛选和转换器。最后还学习了如何根据我们的需求扩展传输机制。



# 附录 A  JavaScript闭包

本附录将探讨如此内容：

- JavaScript在其他函数中定义函数的能力；
- 传递函数对象的方式；
- 在函数内部和外部定义的变量的作用域；
- 由变量作用域及闭包导致的常见问题；
- 在jQuery中使用函数；
- 函数交互导致的内存问题。

## A.1 创建内部函数

JavaScript支持内部函数声明。

支持内部函数的语言，则允许开发者在必要的地方集合小型实用函数，以避免污染命名空间。所谓内部函数，就是定义在另一个函数中的函数。

在outerFn()内部调用innerFn()是有效的，而在outerFn()外部调用innerFn()则是无效的。

```javascript
//js错误
function outerFn() { 
  console.log('Outer function'); 
  function innerFn() { 
  	console.log('Inner Function'); 
  } 
} 
console.log('innerFn():'); 
innerFn(); 
```

这种技术特别适合于小型、单用途的函数。例如，递归但却带有非递归API包装的算法通常最适合通过内部函数来表达。

### A.1.1 在任何地方调用内部函数

JavaScript允许开发人员像传递任何类型的数据一样传递函数。也就是说，JavaScript中的内部函数能够逃脱定义它们的外部函数。

逃脱的方式有很多种。例如，可以将内部函数指定给一个全局变量：

```javascript
var globalVar; 
function outerFn() { 
  console.log('Outer function'); 
  function innerFn() { 
  	console.log('Inner function'); 
  } 
  globalVar = innerFn; 
} 
console.log('outerFn():'); 
outerFn(); 
console.log('globalVar():'); 
globalVar(); 
```

注意，此时在outerFn()外部直接调用innerFn()仍然会导致错误！

也可以通过在父函数中返回值来“营救出”内部函数的引用：

```javascript
function outerFn() { 
console.log('Outer function'); 
  function innerFn() { 
  	console.log('Inner function'); 
  } 
 	return innerFn; 
} 
console.log('var fnRef = outerFn():'); 
var fnRef = outerFn(); 
console.log('fnRef():'); 
fnRef(); 
```

这种即使在离开函数作用域的情况下仍然能够通过引用调用内部函数的事实，意味着只要存在调用这些内部函数的可能，JavaScript就需要保留被引用的函数。

而且，JavaScript运行时需要跟踪引用这个内部函数的所有变量，直至最后一个变量废弃，JavaScript的垃圾收集器才能出面释放相应的内存空间。

### A.1.2 理解变量作用域

内部函数当然也可以拥有自己的变量，只不过这些变量都被限制在内部函数的作用域中：内部函数可以像其他函数一样引用全局变量

但是，如果这个变量是父函数的局部变量又会怎样呢

```javascript
function outerFn() { 
  var outerVar = 0; 
  function innerFn() { 
    outerVar++; 
    console.log('outerVar = ' + outerVar); 
} 
  return innerFn; 
} 

var fnRef = outerFn(); 
fnRef(); 
fnRef(); 
var fnRef2 = outerFn(); 
fnRef2(); 
fnRef2(); 

//这一次，对内部函数的调用会产生有意思的行为：
outerVar = 1 
outerVar = 2 
outerVar = 1 
outerVar = 2 
```


当内部函数在定义它的作用域的外部被引用时，就创建了该内部函数的一个闭包。在这种情况下，我们称既不是内部函数局部变量，也不是其参数的变量为**自由变量**，称外部函数的调用环境为**封闭闭包的环境**。从本质上讲，如果内部函数引用了位于外部函数中的变量，相当于授权该变量能够被延迟使用。因此，当外部函数调用完成后，这些变量的内存不会被释放，因为闭包仍然需要使用它们。

## A.2 处理闭包之间的交互

这在本质上是创建了一个新对象，自由变量就是这个对象的实例变量，而闭包就是这个对象的实例方法。而且，这些变量也是私有的，因为不能在封装它们的作用域外部直接引用这些变量，从而确保了面向对象的数据专有特性。

## A.3 在jQuery中创建闭包

内部函数很容易就会变成闭包。

### A.3.1 `$(document).ready()`的参数

当创建了一个函数并把它传递给`.ready()`之后，这个函数的引用就会被保存为全局jQuery对象的一部分。在稍后的某个时间——当DOM就绪时，这个引用就会被调用。
由于我们通常把`$(document).ready()`放在代码结构的顶层，因而这个函数不会成为闭包。但是，我们的代码通常都是在这个函数内部编写的，所以这些代码都处于一个内部函数中。

把大多数jQuery代码都放在一个函数体中是很有用的，因为这样可以避免某些命名空间冲突。例如，正是这个特性可以使我们通过调用`jQuery.noConflict()`为其他库释放简写方式`$`，但我们仍然能够定义在`$(document).ready()`中使用的局部简写方式。

### A.3.2 绑定事件处理程序

`.ready()`结构通常用于包装其他的jQuery代码，包括事件处理程序的赋值。因为处理程序是函数，它们也就变成了内部函数；而且，因为这些内部函数会被保存并在以后调用，于是它们也会创建闭包。

### A.3.3 在循环中绑定处理程序

鉴于闭包的独特运行方式，在循环中绑定处理程序需要一些特殊的技巧。

```javascript
$(document).ready(function() {
  for (var i = 0; i < 5; i++) {
    $('<div>Print ' + i + '</div>')
    .click(function() {
    	console.log(i);
    }).insertBefore('#results');
  }
});
//每个click处理程序最终引用的i都相同，都等于单击事件实际发生时i的最终值（5）。
```

解决这个问题的方式有很多。首先，可以使用jQuery的`$.each()`函数来代替for循环：

```javascript
$(document).ready(function() {
  $.each([0, 1, 2, 3, 4], function(index, value) {
    $('<div>Print ' + value + '</div>')
    .click(function() {
    	console.log(value);
    }).insertBefore('#results');
  });
});
//因为函数的参数类似于在函数中定义的变量，所以每次循环的value实际上都是不同的变量。结果，每个click处理程序都指向一个不同的value变量，因而每次单击输出的值会与元素的标签文本匹配。
```

同样利用函数参数的这个特性，不必使用`$.each()`也可以解决这个问题。在for循环内部，可以定义并执行一个新函数，让它负责把变量i的值分配到不同的变量中去：

```javascript
$(document).ready(function() {
  for (var i = 0; i < 5; i++) {
    (function(value) {
      $('<div>Print ' + value + '</div>')
      .click(function() {
      	console.log(value);
      }).insertBefore('#results');
    })(i);
  }
});
//它的名字叫立即调用的函数表达式（IIFE），前面曾在调用$.noConflict()之后利用它为jQuery对象重新定义别名$。
```

最后，还可以使用jQuery的事件系统换个角度来解决这个问题。我们知道，`.on()`方法接受一个对象参数，该参数以`event.data`的形式传入事件处理程序中：

```javascript
$(document).ready(function() {
  for (var i = 0; i < 5; i++) {
    $('<div>Print ' + i + '</div>')
    .on('click', {value: i}, function(event) {
    	console.log(event.data.value);
    }).insertBefore('#results');
  }
});
//因为event是函数的参数，每次调用处理程序时它都是一个独立的实例，而不是在所有调用中共享的一个值。
```

### A.3.4 命名及匿名函数

无论命名函数还是匿名函数，都可以用来创建闭包。

```javascript
$(document).ready(function() {
  $('input').each(function(index) {
    $(this).click(function(event) {
      event.preventDefault();
      console.log('index = ' + index);
    });
  });
});
```

## A.4 应对内存泄漏的风险

JavaScript使用一种称为垃圾收集的技术来管理分配给它的内存。JavaScript是一种高级语言，它一般是通过后台来维护这种引用计数系统。

### A.4.1 避免意外的引用循环

闭包可能会导致在不经意间创建引用循环。

```javascript
function outerFn() {
  var outerVar = {};
  function innerFn() {
  	console.log(outerVar);
  }
  outerVar.fn = innerFn;
  return innerFn;
};
```

```javascript
function outerFn() {
  var outerVar = {};
  function innerFn() {
  	console.log('hello');
  }
  outerVar.fn = innerFn;
  return innerFn;
};
//即使innerFn()不再引用outerVar，outerVar也仍然位于innerFn()的封闭环境中。由于闭包的原因，位于outerFn()中的所有变量都隐含地被innerFn()所引用
```

### A.4.2 控制DOM与JavaScript的循环

上述这些情况通常不是什么问题，因为JavaScript能够检测到这些情况并在它们孤立时将其清除。


然而，旧版本IE中存在一种难以处理的引用循环问题。当一个循环中同时包含DOM元素和常规JavaScript对象时，IE无法释放任何一个对象——因为这两类对象是由不同的内存管理程序负责管理的。换句话说，除非关闭浏览器，否则这种循环在IE中永远得不到释放。

导致这种循环的一个常见原因是简单的事件处理

```javascript
$(document).ready(function() {
  var button = document.getElementById('button-1');
  button.onclick = function() {
    console.log('hello');
    return false;
  };
});
```

当指定单击事件处理程序时，就创建了一个在其封闭的环境中包含button变量的闭包。而且，现在的button也包含一个指向闭包（onclick属性自身）的引用。这样，就导致了在IE中即使离开当前页面也不会释放这个循环。

为了释放内存，就需要断开循环引用，例如在关闭窗口关删除onclick属性（此时必须注意不要在window及其onunload处理程序间引入新的循环）。另外，也可以**重写代码来避免这种闭包：**

```javascript
function hello() {
  console.log('hello');
  return false;
}
$(document).ready(function() {
  var button = document.getElementById('button-1');
  button.onclick = hello;
});
//因为hello()函数不再包含button，引用就成了单向的（从button到hello）、不存在循环，所以就不会造成内存泄漏了。
```

**用jQuery化解引用循环**

```javascript
$(document).ready(function() {
  var $button = $('#button-1');
  $button.click(function(event) {
    event.preventDefault();
    console.log('hello');
  });
});
```

jQuery会手动释放自己指定的所有事件处理程序。只要坚持使用jQuery的事件绑定方法，就无需为这种特定的常见原因导致的内存泄漏而担心。

但是，只要是将JavaScript对象指定给DOM元素，就可能在旧版本IE中导致内存泄漏。jQuery只是有助于减少发生这种情况的可能性。

有鉴于此，jQuery为我们提供了另一个避免这种泄漏的工具。使用`.data()`方法可以像使用**扩展属性（expando）**一样，将信息附加到DOM元素。由于这里的数据并非直接保存在扩展属性中（jQuery使用一个内部对象并通过它创建的ID来保存这里所说的数据），因此永远也不会构成引用循环，从而有效回避了内存泄漏问题。无论什么时候，当我们觉得扩展属性好像是一种方便的数据存储机制时，都应该首选`.data()`这种更安全可靠的替代方案。

## A.5 小结

JavaScript闭包是一种强大的语言特性。通过使用这个语言特性来隐藏变量，可以避免覆盖其他地方使用的同名变量。由于jQuery经常依赖于把函数作为方法的参数，所以在编写jQuery代码时也会经常在不经意间创建闭包。理解闭包有助于编写出更有效也更简洁的代码，如果再加上一些小心并利用好jQuery内置的安全措施，则可以有效地防止闭包可能引发的内存泄漏问题。



# 附录B 使用QUnit测试JavaScript

## B.1 下载QUnit

可以在官方网站下载QUnit框架，地址为：http://qunitjs.com/。

## B.2 设置文档

下载了QUnit文件之后，接下来要设置HTML测试文档。在典型的项目中，这个文件叫
index.html，而且与qunit.js和qunit.css放在相同的测试文件夹中。不过，我们这里把这个测试文件
放在一个父目录中。

这个文档的`<head>`元素中包含一个`<link>`标签，用于链接CSS文件；还包含几个`<script>`标签，用于加载jQuery、QUnit、要测试的JavaScript文件（B.js），以及测试文件（test/test.js）。文档的`<body>`标签中包含两个主要元素，每个元素的ID将由QUnit用来运行测试和显示结果。

## B.3 组织测试

QUnit提供两个级别的分组，分别以它们的函数调用命名：module()和test()。其中，module类似于通用的类别，测试将在该类别下运行；而test实际上是一组接收回调函数的测试，在这些回调函数中运行相应测试的特定单元测试。

在这里，我们要把测试按照每一章的主题组织起来，把代码放到test/test.js文件中：

```javascript
module('Selecting');
test('Child Selector', function() {
  ok(true, 'Placeholder is entered');
});
test('Attribute Selectors', function() {
  ok(true, 'Placeholder is entered');
});
module('Ajax');
```

虽然不一定非要把测试文件按照这个测试结构来组织，但最好还是对整个结构有一个大致的概念。除了module()和test()之外，我们还在每个测试中插入了一个断言占位语句。即便有一个断言测试失败，QUnit都会抛出错误。

因为QUnit默认会在文档加载完成之后才会运行测试，所以我们的模块还有测试都不需要放在`$(document).ready()`调用中。

## B.4 添加和运行测试

在测试驱动的开发中，需要在编写代码之前编写测试。这样一来，在看到测试失败之后，开始添加新的代码，然后再让测试通过，验证新代码实现了应有的功能。

首先，我们来测试第2章用到的子选择符，为`<ul id="selected-plays">`的所有子元素`<li>`添加horizontal类：

```javascript
test('Child Selector', function() {
  expect(1);
  var topLis = $('#selected-plays > li.horizontal');
  equal(topLis.length, 3, 'Top LIs have horizontal class');
});
```

这里实际上加入了两个测试。第一个是expect()测试，它告诉QUnit我们想在这个测试集中运行多少个测试。然后，因为我们想要测试在页面中选择元素的能力，所以使用equal()测试来比较顶级`<li>`元素与数值3。如果这两个值相等，测试通过且通过的次数会加1。

另一种测试方式：ok()。这个测试接收两个参数：一个应该被求值为true的表达式和一个描述。module()接收可选的第二个参数，这个参数是一个对象，可以包含setup()和teardown()函数。在这两个函数中，可以使用this关键字为模块中的所有测试一次性地指定变量。


ok()测试和equal()测试失败时不同的输出。前者只显示测试的标签和来源，后者还会详细列出期待的结果。鉴于equal()比ok()提供的测试失败的细节更多，因此应该优先使用它。

#### **异步测试**

测试异步JavaScript，比如Ajax请求，核心在于当异步测试开始时，测试必须暂停；而当异步请求完成时，测试必须恢复。这种情况我们还是比较熟悉的，在效果队列、Ajax回调函数以及承诺对象中，都存在这种异步操作。在QUnit中，我们要使用一个特殊的测试集，它的名字叫asyncTest()。这个测试集与常规的test()测试集很相似；不同的是，在我们调用一个特殊的start()函数恢复它们之前，它们会暂停运行。

```javascript
asyncTest('JSON', function() {
  expect(2);
  var backbite = {
    "term": "BACKBITE",
    "part": "v.t.",
    "definition": "To speak of a man as you find him when he can't find you."
  };
  $.getJSON('b.json', function(json, textStatus) {
    equal(textStatus, 'success', 'Request successful');
    deepEqual(json[1], backbite,
    'result array matches "backbite" map');
  }).always(function() {
  	start();
  });
});
```

为了测试响应的值，这里又使用了一个函数：deepEqual()。正常情况下，在比较两个对象时，除非它们引用的是相同的内存地址，否则不会判定它们相等。但如果我们想比较的是它们的内容，那么使用deepEqual()很合适。这个函数会遍历两个对象，确保它们拥有相同的属性，而且每个属性都有相同的值。

## B.5 其他测试类型

QUnit也提供了其他一些测试函数。有一些函数，比如notEqual()和notDeepEqual()只不过是我们用过的函数的逆运算，而另外一些函数，比如strictEqual()和throws()则具有更加特定的用途。

## B.6 最佳实践

在测试通过但仍然出现错误的情况下，正确的反应不是立即修复问题，而是首先针对失败的行为编写一个新测试。这样一来，不仅可以验证在修复代码之后是否解决了问题，而且也添加了一个可以在将来避免回归的测试。

除了进行单元测试之外，QUnit还可以用于**功能测试**。单元测试主要是为了验证代码单元（方法和函数）的操作是否正确，而功能测试则是为了确保用户输入能够在界面上得到响应。

> 可以将dominator.js（http://mwbrooks.github.io/dominator.js/）和FuncUnit（http://funcunit.com/）等功能测试框架与QUnit一起使用，从而简化编写功能测试和模拟事件的工作。如果想在不同浏览器中实现自动化测试，可以再选择Selenium（http://seleniumhq.org）等专用的功能测试框架。

## B.7 小结

通过测试小型、具体的代码单元，可以在项目变复杂的时候减少很多问题。与此同时，还可以更加有效地对整个项目进行回归测试，从而节省大量宝贵的开发时间。



# 附录C 简明参考

## C.1 选择符表达式

### C.1.1 简单的CSS选择符

| 选  择  符 | 匹 配                |
| ------- | ------------------ |
| *       | 所有元素               |
| #id     | 带有给定ID的元素          |
| element | 给定类型的所有元素          |
| .class  | 带有给定类的所有元素         |
| a, b    | 与a或b匹配的元素          |
| a b     | 作为a后代的b匹配的元素       |
| a > b   | 作为a子元素的b匹配的元素      |
| a + b   | 作为a后面直接同辈元素的b匹配的元素 |
| a ~ b   | 作为a后面同辈的b匹配的元素     |

### C.1.2 在同辈元素间定位

| 选  择  符             | 匹 配                                      |
| ------------------- | ---------------------------------------- |
| :nth-child(index)   | 作为其父元素第index个子元素的元素（从1开始计数）              |
| :nth-child(even)    | 作为其父元素第偶数个子元素的元素（从1开始计数）                 |
| :nth-child(odd)     | 作为其父元素第奇数个子元素的元素（从1开始计数）                 |
| :nth-child(formula) | 作为其父元素第n个子元素的元素（从1开始计数）。formula（公式）的格式为an+b，a、b为整数 |
| :nth-last-child()   | 与:nth-child()相同，只不过是从最后一个元素开始倒计数         |
| :first-child        | 作为其父元素第一个子元素的元素                          |
| :last-child         | 作为其父元素最后一个子元素的元素                         |
| :only-child         | 作为其父元素唯一一个子元素的元素                         |
| :nth-of-type()      | 与:nth-child()相同，只不过只计相同元素                |
| :nth-last-of-type() | 与:nth-of-type()相同，只不过是从最后一个元素开始倒计数       |
| :first-of-type      | 同名的同辈元素中的第一个元素                           |
| :last-of-type       | 同名的同辈元素中的最后一个元素                          |
| :only-of-type       | 没有同名的同辈元素的元素                             |

### C.1.3 在匹配的元素间定位

| 选  择  符    | 匹 配                              |
| ---------- | -------------------------------- |
| :first     | 结果集中的第一个元素                       |
| :last      | 结果集中的最后一个元素                      |
| :not(a)    | 结果集中与a不匹配的所有元素                   |
| :even      | 结果集中的偶数元素（从0开始计数）                |
| :odd       | 结果集中的奇数元素（从0开始计数）                |
| :eq(index) | 结果集中索引为index的元素（从0开始计数）          |
| :gt(index) | 结果集中所有位于给定索引之后（大于该索引）的元素（从0开始计数） |
| :lt(index) | 结果集中所有位于给定索引之前（小于该索引）的元素（从0开始计数） |

### C.1.4 属性

| 选  择  符          | 匹 配                                    |
| ---------------- | -------------------------------------- |
| [attr]           | 带有属性attr的元素                            |
| [attr="value"]   | attr属性的值为value的元素                      |
| [attr!="value"]  | attr属性的值不为value的元素                     |
| [attr^="value"]  | attr属性的值以value开头的元素                    |
| [attr$="value"]  | attr属性的值以value结尾的元素                    |
| [attr*="value"]  | attr属性的值包含子字符串value的元素                 |
| [attr~="value"]  | attr属性的值是空格分隔的多个字符串，其中一个字符串的值为value的元素 |
| [attr\|="value"] | attr属性的值等于value或者以value开头后跟一个连字符的元素    |

#### C.1.5 表单

| 选  择  符   | 匹 配                                      |
| --------- | ---------------------------------------- |
| :input    | 所有`<input>`、`<select>`、`<textarea>`和`<button>`元素 |
| :input    | 所有`<input>`、`<select>`、`<textarea>`和`<button>`元素 |
| :password | type="password"的`<input>`元素              |
| :file x   | type="file"的`<input>`元素                  |
| :radio    | type="radio"的`<input>`元素                 |
| :checkbox | type="checkbox"的`<input>`元素              |
| :submit   | type="submit"的`<input>`元素                |
| :image    | type="image"的`<input>`元素                 |
| :reset    | type="reset"的`<input>`元素                 |
| :button   | type="button"的`<input>`元素及`<button>`元素   |
| :enabled  | 启用的表单元素                                  |
| :disabled | 禁用的表单元素                                  |
| :checked  | 选中的复选框和单选按钮元素                            |
| :selected | 选中的`<option>`元素                          |

### C.1.6 其他自定义选择符

| 选  择  符         | 匹 配                                      |
| --------------- | ---------------------------------------- |
| :root           | 文档的根元素                                   |
| :header         | 标题元素（如`<h1>`、`<h2>`）                     |
| :animated       | 其动画正在播放的元素                               |
| :contains(text) | 包含给定文本text的元素                            |
| :empty          | 不包含子节点的元素                                |
| :has(a)         | 后代元素中至少有一个与a匹配的元素                        |
| :parent         | 包含子节点的元素                                 |
| :hidden         | 隐藏的元素，包括通过CSS隐藏的元素及`<input type="hidden" />` |
| :visible        | 与:hidden匹配的元素相反                          |
| :focus          | 获得键盘焦点的元素                                |
| :lang(language) | 具有给定（在元素的lang属性或`<meta>`标签中声明的）语言代码的元素   |
| :target         | URI标识符指向的目标元素                            |

## C.2 DOM遍历方法

### C.2.1 筛选元素

| 遍历方法                 | 返回的jQuery对象中包含          |
| -------------------- | ----------------------- |
| .filter(selector)    | 与给定的选择符selector匹配的选中元素  |
| .filter(callback)    | 回调函数callback返回true的选中元素 |
| .eq(index)           | 从0开始计数的第index个选中元素      |
| .first()             | 选中元素中的第一个元素             |
| .last()              | 选中元素中的最后一个元素            |
| .slice(start, [end]) | 从0开始计数的给定范围内的选中元素       |
| .not(selector)       | 选中元素中与给定选择符不匹配的元素       |
| .has(selector)       | 选中元素中有后代匹配给定选择符的元素      |

### C.2.2 后代元素

| 遍历方法                  | 返回的jQuery对象中包含              |
| --------------------- | --------------------------- |
| .find(selector)       | 与给定选择符selector匹配的后代元素       |
| .contents()           | 子节点（包括文本节点）                 |
| .children([selector]) | 子节点，可以传入可选的选择符selector进一步筛选 |

### C.2.3 同辈元素

| 遍历方法                            | 返回的jQuery对象中包含                           |
| ------------------------------- | ---------------------------------------- |
| .next([selector])               | 每个选中元素紧邻的下一个同辈元素，可以传入可选的选择符selector进一步筛选 |
| .nextAll([selector])            | 每个选中元素之后的所有同辈元素，可以传入可选的选择符selector进一步筛选  |
| .nextUntil([selector],[filter]) | 每个选中元素之后、直至但不包含第一个匹配selector元素的同辈元素，可以传入可选的选择符filter进一步筛选 |
| .prev([selector])               | 每个选中元素紧邻的上一个同辈元素，可以传入可选的选择符selector进一步筛选 |
| .prevAll([selector])            | 每个选中元素之前的所有同辈元素，可以传入可选的选择符selector进一步筛选  |
| .prevUntil([selector],[filter]) | 每个选中元素之前、直至但不包含第一个匹配selector元素的同辈元素，可以传入可选的选择符filter进一步筛选 |
| .siblings([selector])           | 所有同辈元素，可以传入可选的选择符selector进一步筛选           |

### C.2.4 祖先元素

| 遍历方法                               | 返回的jQuery对象中包含                           |
| ---------------------------------- | ---------------------------------------- |
| .parent([selector])                | 每个选中元素的父元素，可以传入可选的选择符selector进一步筛选       |
| .parents([selector])               | 每个选中元素的所有祖先元素，可以传入可选的选择符selector进一步筛选    |
| .parentsUntil([selector],[filter]) | 每个选中元素的所有祖先元素，直至但不包含第一个匹配selector的祖先元素，可以传入可选的选择符filter进一步筛选 |
| .closest(selector)                 | 与选择符selector匹配的第一个元素，遍历路径从选中元素开始，沿DOM树向上在其中祖先节点中的查找 |
| .offsetParent()                    | 第一个选中元素被定位的父元素（如，通过relative或absolute定位）  |

### C.2.5 集合操作

| 遍历方法                 | 返回的jQuery对象中包含               |
| -------------------- | ---------------------------- |
| .add(selector)       | 选中的元素，加上与给定选择符匹配的元素          |
| .addBack()           | 选中的元素，加上内部jQuery栈中之前选中的那一组元素 |
| .end()               | 内部jQuery栈中之前选中的元素            |
| .map(callback)       | 对每个选中元素调用回调函数callback之后的结果   |
| .pushStack(elements) | 指定的元素                        |

### C.2.6 操作选中的元素

| 遍历方法            | 说 明                        |
| --------------- | -------------------------- |
| .is(selector)   | 确定匹配的元素中是否有传入的选择符匹配的元素     |
| .index()        | 取得匹配元素相对于其同辈元素的索引          |
| .index(element) | 取得匹配元素中与指定元素对应的DOM节点的索引    |
| $.contains(a,b) | 确定DOM节点b是否包含DOM节点a         |
| .each(callback) | 迭代匹配的元素，针对每个元素执行callback函数 |
| .length         | 取得匹配元素的数量                  |
| .get()          | 取得与匹配元素对应的DOM节点的列表         |
| .get(index)     | 取得匹配元素中与指定索引对应的DOM节点       |
| .toArray()      | 取得与匹配元素对应的DOM节点的列表         |

## C.3 事件方法

### C.3.1 绑定

| 事件方法                                     | 说 明                                      |
| ---------------------------------------- | ---------------------------------------- |
| .ready(handler)                          | 绑定在DOM和CSS完全加载后调用的处理程序handler            |
| .on(type, [selector],[data], handler)    | 绑定在给定类型的事件type发送到元素时调用的处理程序handler；如果提供了selector则执行事件委托 |
| .on(events, [selector] , [data])         | 根据events对象中的事件绑定多个事件处理程序                 |
| .off(type, [selector], [handler])        | 解除元素上绑定的处理程序                             |
| .bind(type, [data], handler)             | 绑定在给定类型的事件type发送到元素时调用的处理程序handler；一般都用.on()代替 |
| .one(type, [data], handler)              | 绑定在给定类型的事件type发送到元素时调用的处理程序handler，并在handler被调用后立即解除绑定 |
| .unbind([type], [handler])               | 解除元素上绑定的处理程序（可以指定事件类型或处理程序，不指定则解除所有绑定）   |
| .delegate(selector, type, [data],handler) | 绑定当给定事件发送到与selector匹配的后代元素后调用的处理程序       |
| .delegate(selector, handlers)            | 绑定当给定事件发送到与selector匹配的后代元素后调用的处理程序       |
| .undelegate(selector, type, [handler])   | 解除之前通过.delegate()绑定的到元素上的处理程序            |

# jQuery基础教程（第四版）

# 第1章 jQuery入门

## 1.1 jQuery能做什么

仅就其核心特性而言，jQuery能够满足下列需求。

- **取得文档中的元素。**
- **修改页面的外观。**跨浏览器
- **改变文档的内容。**
- **响应用户的交互操作。**jQuery提供了截获形形色色的页面事件的适当方式
- **为页面添加动态效果。**
- **无需刷新页面从服务器获取信息。**jQuery通过消除Ajax的复杂性
- **简化常见的JavaScript任务。**例如迭代和数组操作等

## 1.2 jQuery为什么如此出色

为了在维持各种特性的同时仍然保持紧凑的代码，jQuery采用了如下策略。

- **利用CSS的优势。**将查找页面元素的机制构建于CSS选择符之上
- **支持扩展。**为了避免特性蠕变（feature creep），jQuery将特殊情况下使用的工具归入插件当中。
- **抽象浏览器不一致性。**
- **总是面向集合。**被设计成自动操作对象集合，而不是单独的对象，称作隐式迭代（implicititeration）的技术
- **将多重操作集于一行。**为了避免过度使用临时变量或不必要的代码重复，jQuery在其多数方法中采用了一种称作连缀（chaining）的编程模式。这种模式意味着基于一个对象进行的多数操作的结果，都会返回这个对象自身，以便为该对象应用下一次操作。

## 1.3 第一个jQuery驱动的页面

### 1.3.1 下载jQuery

### 1.3.2  本书使用jQuery的哪个版本

为了确保在现代浏览器中速度更快，代码更简洁，jQuery从2.0版开始不再支持IE6、IE7和IE8。

> 如果项目中有针对jQuery 1.9之前的版本编写的代码，可以使用jQuery迁移插件（[http://jquery.com/upgrade-guide/1.9/#jquery-migrate-plugin](http://jquery.com/upgrade-guide/1.9/#jquery-migrate-plugin)）实现与jQuery 1.10兼容。

### 1.3.3  在HTML文档中引入jQuery

紧随常规的HTML开头代码之后的是加载样式表文件的代码。

在引用样式表文件的代码之后，是包含JavaScript文件的代码。注意的是，引用jQuery库文件的``标签，必须放在引用自定义脚本文件的``标签之前。否则，在我们编写的代码中将引用不到jQuery框架。

### 1.3.4  编写jQuery代码

#### 1. 查找诗歌文本

jQuery中基本的操作就是选择文档中的某一部分，这是通过$()函数来完成的。通常，该函数需要一个字符串参数，参数中可以包含任何CSS选择符表达式。

#### 2. 加入新类

.addClass()方法，它会将一个CSS类应用到我们选择的页面元素。这个方法唯一的参数就是要添加的类名。

其反方法.removeClass()

#### 3. 执行代码

$()和.addClass()单独插入文档的头部，不会有任何效果。通常，JavaScript代码在浏览器初次遇到它们时就会执行，而在浏览器处理头部时，HTML还不会呈现样式。因此，我们需要将代码延迟到DOM可用时再执行。

通过使用$(document).ready()方法，jQuery支持我们预定在DOM加载完毕后调用某个函数，而不必等待页面中的图像加载。涉及如下功能：

- 尽可能使用浏览器原生的DOM就绪实现，并以window.onload事件处理程序作为后备；
- 可以多次调用$(document).ready()并按照调用它们的顺序执行；
- 即便是在浏览器事件发生之后把函数传给$(document).ready()，这些函数也会执行；
- 异步处理事件的预定，必要时脚本可以延迟执行；
- 通过重复检查一个几乎与DOM同时可用的方法，在较早版本的浏览器中模拟DOM就绪事件。

.ready()方法的参数可以是一个已经定义好的函数的引用，也可以接收一个匿名函数。

### 1.3.5  最终结果

## 1.4  纯JavaScript与jQuery

## 1.5 使用开发工具

## 1.6 小结

# 第2章 选择元素

## 2.1  理解DOM

## 2.2  使用$()函数

$()函数接受CSS选择符作为参数，返回包含页面中对应元素的jQuery对象。

3种基本的选择符：标签名、ID和类。

| 选  择  符 | CSS            | jQuery           | 说 明                    |
| ------- | -------------- | ---------------- | ---------------------- |
| 标签名     | P {}           | $('p')           | 取得文档中所有的段落             |
| ID      | #some-id {}    | $('#some-id')    | 取得文档中ID为some-id的一个元素   |
| 类       | .some-class {} | $('.some-class') | 取得文档中类为some-class的所有元素 |

在将方法连缀到$()工厂函数后面时，包装在jQuery对象中的元素会被自动、隐式地循环遍历。换句话说，这样就避免了使用for循环之类的显式迭代

## 2.3  CSS选择符

> ### 渐进增强
>
> 负责任的jQuery开发者应该在编写自己的程序时，始终坚持渐进增强（progressive enhancement）和平稳退化（graceful degradation）的理念，做到在JavaScript禁用时，页面仍然能够与启用JavaScript时一样准确地呈现，即使没有那么美观。

### 基于列表项的级别添加样式

嵌套的无序列表只有顶级的项水平排列；

```
$(document).ready(function() { 
```

```
    $('#selected-plays > li').addClass('horizontal'); 
```

```
});
```

子元素组合符（>）：含义是查找ID为selected-plays的元素（#selected-plays）的子元素（>）中所有的列表项（li）。

要为其他项（非顶级的项）添加样式，有很多种方式。一种方式，就是使用否定式伪类选择符来识别没有horizontal类的所有列表项。

```

```

```
$(document).ready(function() { 
```

```
    $('#selected-plays > li').addClass('horizontal'); 
```

```
    $('#selected-plays li:not(.horizontal)').addClass('sub-level'); 
```

```
}); 
```

## 2.4 属性选择符

属性选择符通过HTML元素的属性选择元素

```

```

```
//例如，要选择带有alt属性的所有图像元素，可以使用以下代码：
```

```
$('img[alt]')
```

### 为链接添加样式

属性选择符使用一种从正则表达式中借鉴来的通配符语法，以^表示值在字符串的开始，以$表示值在字符串的结尾。而且，也是用星号*表示要匹配的值可以出现在字符串中的任意位置，用叹号!表示对值取反。

```

```

```
//用来寻找所有带href属性（[href]）且以mailto开头（^="mailto:"]）的锚元素（a）
```

```
$(document).ready(function() { 
```

```
    $('a[href^="mailto:"]').addClass('mailto'); 
```

```
}); 
```

要为所有指向PDF文件的链接添加类，需要使用美元符号（$）而不是脱字符号（^）。这是因为我们要选择所有href属性以.pdf结尾的链接

```

```

```
$(document).ready(function() { 
```

```
    $('a[href^="mailto:"]').addClass('mailto'); 
```

```
    $('a[href$=".pdf"]').addClass('pdflink'); 
```

```
});
```

属性选择符也可以组合使用。

## 2.5 自定义选择符

> ### 性能提示
>
> 只要可能，jQuery就会使用浏览器原生的DOM选择符引擎去查找元素。但在使用自定义选择符的时候，就无法使用速度最快的原生方法了。建议在能够使用原生方法的情况下，就不要频繁地使用自定义选择符，以确保性能。

自定义选择符的语法与CSS中的伪类选择符语法相同，即选择符以冒号（:）开头。

### 2.5.1 每隔一行为表格添加样式

jQuery库中的两个十分有用的自定义选择符是:odd和:even。

```

```

```
$(document).ready(function() { 
```

```
    $('tr:even').addClass('alt'); 
```

```
}); 
```

注意：:eq()选择符、:odd和:even选择符都使用JavaScript内置从0开始的编号方式

如果一个页面上存在另外一个表格，会有影响，解决这个问题的一种方法是使用:nth-child()选择符。这个选择符相对于元素的父元素而非当前选择的所有元素来计算位置，它可以接受数值、odd或even作为参数

```

```

```
$(document).ready(function() { 
```

```
    $('tr:nth-child(odd)').addClass('alt'); 
```

```
}); 
```

注意：:nth-child()是jQuery中唯一从1开始计数的选择符。因此，需要使用odd而不是even参数。

### 2.5.2 基于上下文内容选择元素

:contains()选择符区分大小写

```

```

```
//突出显示提到任何一种Henry游戏的所有表格单元
```

```
$(document).ready(function() { 
```

```
    $('tr:nth-child(odd)').addClass('alt'); 
```

```
    $('td:contains(Henry)').addClass('highlight'); 
```

```
}); 
```

### 2.5.3 基于表单的选择符

表单选择符

| 选  择  符   | 匹 配                      |
| --------- | ------------------------ |
| :input    | 输入字段、文本区、选择列表和按钮元素       |
| :button   | 按钮元素或type属性值为button的输入元素 |
| :enabled  | 启用的表单元素                  |
| :disabled | 禁用的表单元素                  |
| :checked  | 勾选的单选按钮或复选框              |
| :selected | 选择的选项元素                  |

## 2.6 DOM遍历方法

.filter()的功能十分强大，因为它可以接受函数参数。通过传入的函数，可以执行复杂的测试，以决定相应元素是否应该保留在匹配的集合中。

```

```

```
//为所有外部链接添加一个类
```

```
$('a').filter(function() { 
```

```
    return this.hostname && this.hostname != location.hostname; 
```

```
}).addClass('external'); 
```

### 2.6.1 为特定单元格添加样式

.next()方法：只选择下一个最接近的同辈元素

```

```

```
//给每个包含Henry的单元格的下一个单元格添加样式
```

```
$(document).ready(function() { 
```

```
    $('td:contains(Henry)').next().addClass('highlight'); 
```

```
});
```

.nextAll()方法：所在单元格后面的全部单元格

.prev()和.prevAll() 是对应方法。

.siblings()能够选择处于相同DOM层次的所有其他元素，无论这些元素处于当前元素之前还是之后。

要在这些单元格中再包含原来的单元格，可以添加.addBack()方法

```

```

```
//即包含Henry的那个单元格
```

```
$(document).ready(function() { 
```

```
    $('td:contains(Henry)').nextAll().addBack() 
```

```
    .addClass('highlight'); 
```

```
}); 
```

要选择同一组元素，可以采用的选择符和遍历方法的组合很多。可以通过.parent()方法在DOM中上溯一层到达，然后再通过.children()选择该行的所有单元格。

### 2.6.2 连缀

> #### 方法连缀的原理
>
> 几乎所有jQuery方法都会返回一个jQuery对象，因而可连缀调用多个jQuery方法。

在使用连缀时，为照顾到代码的可读性，还可以把一行代码分散到几行来写。

## 2.7访问DOM元素

jQuery提供了.get()方法。要访问jQuery对象引用的第一个DOM元素，可以使用.get(0)。

```

```

```
//如果想知道带有id="my-element"属性的元素的标签名
```

```
var myTag = $('#my-element').get(0).tagName; 
```

jQuery还为.get()方法提供了一种简写方式。

```

```

```
//可以将$('#my-element').get(0)简写为：
```

```
var myTag = $('#my-element')[0].tagName; 
```

## 2.8 小结

# 第3章 事件

## 3.1 在页面加载后执行任务

### 3.1.1 代码执行的时机选择

$(document).ready() 和 window.onload事件区别：它们在触发操作的时间上存在着微妙的差异，这种差异只有在加载的资源多到一定程度时才会体现出来。

当文档完全下载到浏览器中时，会触发window.onload事件。这意味着页面上的全部元素对JavaScript而言都是可以操作的，这种情况对编写功能性的代码非常有利，因为无需考虑加载的次序。

通过$(document).ready()注册的事件处理程序，则会在DOM完全就绪并可以使用时调用。虽然这也意味着所有元素对脚本而言都是可以访问的，但是，却不意味着所有关联的文件都已经下载完毕。

> #### 加载样式与执行代码
>
> #### 为了保证JavaScript代码执行以前页面已经应用了样式，最好是在``元素中把``标签和``标签放在``标签前面。

> #### 什么是加载完成
>
> 一般来说，使用$(document).ready()要优于使用onload事件处理程序，但必须要明确的一点是，因为支持文件可能还没有加载完成，所以类似图像的高度和宽度这样的属性此时则不一定会有效。如果需要访问这些属性，可能就得选择实现一个onload事件处理程序（或者是使用jQuery为load事件设置处理程序）。

### 3.1.2 基于一个页面执行多个脚本

```

```

```
<body onload="doStuff();"> 
```

```
window.onload = doStuff; 
```

第2种方式的优点在于，它能使行为更清晰地从标记中分离出来。

> #### **引用函数与调用函数**
>
> 这里在将函数指定为处理程序时，省略了后面的圆括号，只使用了函数名。如果带着圆括号，函数会被立即调用；没有圆括号，函数名就只是函数的标识符或**函数引用**，可以用于在将来再调用函数。

.onload属性一次只能保存对一个函数的引用，所以不能在现有的行为基础上再增加新行为。通过$(document).ready()机制能够很好地解决这个问题。每次调用这个方法都会向内部的行为队列中添加一个新函数，当页面加载完成后，所有函数都会被执行。而且，这些函数会按照注册它们的顺序依次执行。

### 3.1.3 .ready()的简写形式

$()函数为我们提供了一种简写方式。当给它传递一个函数作为参数时，jQuery会隐式调用.ready()。

```
$(document).ready(function() { 
```

```
    //这里是代码……
```

```
}); 
```

```

```

```
//也可以简写成：
```

```
$(function() { 
```

```
    //这里是代码……
```

```
}); 
```

推荐使用较长的形式，更清楚

注：通过window.onload虽然也可以注册多个函数，但却不能保证按顺序执行。

### 3.1.4 向.ready()回调函数中传入参数

可能有必要在同一个页面中使用多个JavaScript库。由于很多库都使用$标识符（因为它简短方便），因此就需要一种方式来避免名称冲突。

jQuery提供了一个jQuery.noConflict()方法，调用该方法可以把对$标识符的控制权让渡还给其他库。使用jQuery.noConflict()方法的一般模式如下：

```

```

```
<script src="prototype.js"></script> 
```

```
<script src="jquery.js"></script> 
```

```
<script> 
```

```
    jQuery.noConflict(); 
```

```
</script> 
```

```
<script src="myscript.js"></script> 
```

首先，包含jQuery之外的库（这里是Prototype）。然后，包含jQuery库，取得对`$`的使用权。接着，调用.noConflict()方法让出`$`，以便将控制权交还给最先包含的库（Prototype）。这样就可以在自定义脚本中使用两个库了——但是，在需要使用jQuery方法时，必须记住要用jQuery而不是$来调用。

在.ready()方法中使用`$`的技巧。我们传递给它的回调函数可以接收一个参数——jQuery对象本身。利用这个参数，可以重新命名jQuery为`$`，而不必担心造成冲突

```

```

```
jQuery(document).ready(function($) { 
```

```
    //在这里，可以正常使用! 
```

```
}); 
```

```

```

```
//或者，也可以使用刚刚介绍的简写语法：
```

```
jQuery(function($) { 
```

```
    //使用$的代码
```

```
}); 
```

## 3.2 处理简单的事件

### 3.2.1 简单的样式转换器

> #### 渐进增强
>
> 在创建样式转换器时，优秀的Web开发人员应该遵守渐进增强的原则。

.on()方法，可以指定任何DOM事件，并为该事件添加一种行为。

```

```

```
$(document).ready(function() { 
```

```
  $('#switcher-large').on('click', function() { 
```

```
    $('body').addClass('large'); 
```

```
  }); 
```

```
}); 
```

### 3.2.2 启用其他按钮

### 3.2.3 利用事件处理程序的上下文

当触发任何事件处理程序时，关键字this引用的都是携带相应行为的DOM元素。通过在事件处理程序中使用$(this)，可以为相应的元素创建jQuery对象，然后就如同使用CSS选择符找到该元素一样对它进行操作。

### 3.2.4 使用事件上下文进一步减少代码

### 3.2.5 简写的事件

jQuery提供了一种简化事件操作的方式——简写事件方法，简写事件方法的原理与对应的.on()调用相同。

其他blur、keydown和scroll等标准的DOM事件，也存在类似前面这样的简写事件。这些简写的事件方法能够把一个事件处理程序绑定到同名事件上面。

### 3.2.6 显示和隐藏高级特性

jQuery为我们提供了一个简便的toggleClass()方法，能够根据相应的类是否存在而添加或删除类

```

```

```
$(document).ready(function() { 
```

```
  $('#switcher h3').click(function() { 
```

```
    $('#switcher button').toggleClass('hidden'); 
```

```
  }); 
```

```
});
```

## 3.3 事件传播

jQuery的.hover方法。这个方法可以让我们在鼠标指针进入元素和离开元素时，通过JavaScript来改变元素的样式——事实上是可以执行任意操作。

.hover()方法接受两个函数参数。第一个函数会在鼠标指针进入被选择的元素时执行，而第二个函数会在鼠标指针离开该元素时触发。

使用.hover()也意味着可以避免JavaScript中的事件传播（event propagation）导致的头痛问题。

### 3.3.1 事件的旅程

允许多个元素响应单击事件的一种策略叫做事件捕获。在事件捕获的过程中，事件首先会交给最外层的元素，接着再交给更具体的元素。

另一种相反的策略叫做事件冒泡。即当事件发生时，会首先发送给最具体的元素，在这个元素获得响应机会之后，事件会向上冒泡到更一般的元素。

最终出台的DOM标准规定应该同时使用这两种策略：首先，事件要从一般元素到具体元素逐层捕获，然后，事件再通过冒泡返回DOM树的顶层。

jQuery始终会在模型的冒泡阶段注册事件处理程序

### 3.3.2 事件冒泡的副作用

事件冒泡可能会导致始料不及的行为，特别是在错误的元素响应mouseover或mouseout事件的情况下。

而mouseenter和mouseleave事件，无论是单独绑定，还是在.hover()方法中组合绑定，都可以避免这些冒泡问题。

事件对象可以随意命名，不一定要是event

## 3.4 通过事件对象改变事件的旅程

事件对象是一种DOM结构，它会在元素获得处理事件的机会时传递给被调用的事件处理程序。

### 3.4.1 事件目标

通过.target，可以确定DOM中首先接收到事件的元素（即实际被单击的元素）。而且，我们知道this引用的是处理事件的DOM元素

### 3.4.2 停止事件传播

事件对象还提供了一个.stopPropagation()方法，该方法可以完全阻止事件冒泡。

在IE8及更早版本中则无法安全地使用（需要将事件对象的cancelBubble属性设置为false）

### 3.4.3 阻止默认操作

把单击事件处理程序注册到锚元素（`[`](undefined)），而不是外层的``上，那么就要面对另外一个问题：当用户单击链接时，浏览器会加载一个新页面。

即便在事件对象上调用.stopPropagation()方法也不能禁止这种默认操作，因为默认操作不是在正常的事件传播流中发生的。在这种情况下，.preventDefault()方法则可以在触发默认操作之前终止事件。

事件传播和默认操作是相互独立的两套机制，在二者任何一方发生时，都可以终止另一方。如果想要同时停止事件传播和默认操作，可以在事件处理程序中返回false，这是对在事件对象上同时调用.stopPropagation()和.preventDefault()的一种简写方式。

### 3.4.4 事件委托

事件委托是利用冒泡的一项高级技术。通过事件委托，可以借助一个元素上的事件处理程序完成很多工作。

.is()方法接收一个选择符表达式，然后用选择符来测试当前的jQuery对象。如果集合中至少有一个元素与选择符匹配，.is()返回true。

> **is()与.hasClass()** 
>
> 要测试元素是否包含某个类，也可以使用另一个简写方法.hasClass()。不过，.is()方法则更灵活一些，它可以测试任何选择符表达式。

### 3.4.5 使用内置的事件委托功能

.on()方法可以接受相应参数实现事件委托

```

```

```
$('#switcher').on('click', 'button', function() { 
```

```
    ...
```

```
}); 
```

如果给.on()方法传入的第二个参数是一个选择符表达式，jQuery会把click事件处理程序绑定到#switcher对象，同时比较event.target和选择符表达式（这里的'button'）。如果匹配，jQuery会把this关键字映射到匹配的元素，否则不会执行事件处理程序。

## 3.5 移除事件处理程序

调用.off()方法移除折叠处理程序

```

```

```
$(document).ready(function() { 
```

```
  $('#switcher').click(function(event) {
```

```
     ... 
```

```
}); 
```

```

```

```
$('#switcher-narrow, #switcher-large').click(function() { 
```

```
    $('#switcher').off('click'); 
```

```
  }); 
```

```
}); 
```

### 3.5.1 为事件处理程序添加命名空间

应让对.off()的调用更有针对性，达成目标的一种方式是使用事件命名空间，即在绑定事件时引入附加信息，以便将来识别特定的处理程序。

```

```

```
$(document).ready(function() { 
```

```
  $('#switcher').on('click.collapse', function(event) { 
```

```
    if (!$(event.target).is('button')) { 
```

```
         $('#switcher button').toggleClass('hidden'); 
```

```
    } 
```

```
}); 
```

```

```

```
$('#switcher-narrow, #switcher-large').click(function() { 
```

```
        $('#switcher').off('click.collapse'); 
```

```
    }); 
```

```
}); 
```

对于事件处理系统而言，后缀.collapse是不可见的。换句话说，这里仍然会像编写.on('click')一样，让注册的函数响应单击事件。但是，通过附加的命名空间信息，则可以解除对这个特定处理程序的绑定，同时不影响为按钮注册的其他单击处理程序。

### 3.5.2 重新绑定事件

应该在Default按钮被单击时，重新绑定事件处理程序。首先，应该为事件处理程序起个名字，以便多次使用

```

```

```
$(document).ready(function() { 
```

```
  var toggleSwitcher = function(event) { 
```

```
    if (!$(event.target).is('button')) { 
```

```
        $('#switcher button').toggleClass('hidden'); 
```

```
    } 
```

```
  };
```

```
  
```

```
  $('#switcher').on('click.collapse', toggleSwitcher); 
```

```
}); 
```

使用命令函数还有另外一个好处，即不必再使用事件命名空间。因为.off()可以将这个命名函数作为第二个参数，结果只会解除对特定处理程序的绑定。

这样就会遇到另一个问题，当在jQuery中把处理程序绑定到事件时，之前绑定的处理程序仍然有效。可以在用户单击任意按钮时解除绑定，并在确定单击按钮的ID是switcher-default的情况下再重新绑定

对于只需触发一次，随后要立即解除绑定的情况也有一种简写方法——.one()，这个简写方法的用法如下：

```

```

```
$('#switcher').one('click', toggleSwitcher); 
```

这样会使切换操作只发生一次，之后就再也不会发生。

## 3.6 模仿用户操作

通过.trigger()方法就可以完成模拟事件的操作

```

```

```
$(document).ready(function() { 
```

```
    $('#switcher').trigger('click'); 
```

```
}); 
```

.trigger()方法提供了一组与.on()方法相同的简写方法。当使用这些方法而不带参数时，结果将是触发操作而不是绑定行为。

键盘事件可以分为两类：直接对键盘按键给出响应的事件（keyup和keydown）和对文本输入给出响应的事件（keypress）。

有一条实践经验是比较可靠的：如果想知道用户按了哪个键，应该侦听keyup或keydown事件；如果想知道用户输入的是什么字符，应该侦听keypress事件。

接下来，需要确定哪个元素应该侦听这个事件。可以利用事件冒泡了——因为可以假设所有键盘事件最终都会冒泡到document元素，所以可以把keyup事件直接绑定到该元素。

最后，需要在keyup处理程序被触发时知道用户按下了哪个键。此时可以检查相应的事件对象，事件对象的.which属性包含着被按下的那个键的标识符。对于字母键而言，这个标识符就是相应大写字母的ASCII值。

## 3.7 小结

本章学习了各种响应用户及浏览器发起事件的方法，包括如何在页面加载时安全地执行代码、如何处理单击链接和悬停按钮时的鼠标事件，以及如何截获按键输入。

此外，我们介绍了事件系统的内部机制，并据以实现了事件委托和改变事件行为。

# 第4章 样式与动画

## 4.1 修改内联CSS

jQuery提供了.css()方法。

这个方法集getter（获取方法）和setter（设置方法）于一身。为取得某个样式属性的值，可以为这个方法传递一个字符串形式的属性名，然后同样得到一个字符串形式的属性值。要取得多个样式属性的值，可以传入属性名的数组，得到的则是属性和值构成的对象。对于backgroundColor这样由多个单词构成的属性名，jQuery既可以解释连字符版的CSS表示法（如background-color），也可以解释驼峰大小写形式（camel-cased）的DOM表示法（如backgroundColor）。

```

```

```
//取得单个属性的值
```

```
.css('property') 
```

```
//返回"value" 
```

```

```

```
//取得多个属性的值
```

```
.css(['property1', 'property-2']) 
```

```
//返回{"property1": "value1", "property-2": "value2"} 
```

在设置样式属性时，.css()方法能够接受的参数有两种，一种是为它传递一个单独的样式属性和值，另一种是为它传递一个由属性—值对构成的对象：

```

```

```
//单个属性及其值
```

```
.css('property', 'value') 
```

```

```

```
//属性值对构成的对象
```

```
.css({ 
```

```
property1: 'value1', 
```

```
'property-2': 'value2' 
```

```
}) 
```

这些键值的集合叫对象字面量，是在代码中直接创建的JavaScript对象。

> **对象字面量**一般来说，数字值不需要加引号而字符串值需要加引号。由于属性名是字符串，所以属性通常是需要加引号的。但是，如果对象字面量中的属性名是有效的JavaScript标识符，比如使用驼峰大小写形式的DOM表示法时，则可以省略引号。

使用.css()的方式与前面使用.addClass()的方式相同

### 4.1.1 设置计算的样式属性值

### 4.1.2 带厂商前缀的样式属性

在jQuery中，可以直接使用标准的属性名。如果样式对象中不存在这个属性，jQuery就会依次检测所有带前缀（Webkit、O、Moz、ms）的属性，然后使用第一个找到的那个属性。

## 4.2 隐藏和显示元素

基本的.hide()和.show()方法不带任何参数，这两个方法的作用就是立即隐藏或显示匹配的元素集合，不带任何动画效果。

.hide()方法会将匹配的元素集合的内联style属性设置为display:none。它能够在把display的值变成none之前，记住原先的display值，通常是block、inline或inline-block。

.show()方法会将匹配的元素集合的display属性，恢复为应用display: none之前的可见属性。

## 4.3 效果和时长

当在.show()或.hide()中指定时长（或更准确地说，一个速度）参数时，就会产生动画效果，即效果会在一个特定的时间段内发生。

### 4.3.1 指定显示速度

对于jQuery提供的任何效果，都可以指定两种预设的速度参数：'slow'和'fast'。使用.show('slow')会在600毫秒（0.6秒）内完成效果，而.show('fast')则是200毫秒（0.2秒）。如果传入的是其他字符串，jQuery就会在默认的400毫秒内完成效果。要指定更精确的速度，可以使用毫秒数值。注意，与字符串表示的速度参数名称不同，数值不需要使用引号。

### 4.3.2 淡入和淡出

jQuery也提供了两个更为精细的内置动画方法。如果想在显示整个段落时，只是逐渐地增大其不透明度，那么可以使用.fadeIn('slow')方法。

类似地，要逐渐减少不透明度，可以使用.fadeOut()。

### 4.3.3 滑上和滑下

对于本来就处于文档流之外的元素，比较适合使用淡入和淡出动画。不过，假如某个元素本来就处在文档流中，那再调用.fadeIn()就会导致文档“跳一下”，以便为新元素腾出地方来。但这种跳跃感在用户眼里就不总是那么美观了。

此时，使用jQuery的.slideDown()和.slideUp()方法通常是正确的选择。这两个动画方法仅改变元素的高度。

要实现相反的动画效果，应该调用.slideUp()。

### 4.3.4 切换可见性

jQuery提供了一个.toggle()方法，该方法的作用类似于.show()和.hide()方法，而且与它们一样的是，.toggle()方法时长参数也是可选的。

另一个复合方法是.slideToggle()，该方法通过逐渐增加或减少元素高度来显示或隐藏元素。

## 4.4 创建自定义动画

jQuery还提供了一个强大的.animate()方法，用于创建控制更加精细的自定义动画。

.animate()方法有两种形式，第一种形式接收以下4个参数。

- 一个包含样式属性及值的对象：与.css()方法中的参数类似。
- 可选的时长参数：既可以是预置的字符串，也可以是毫秒数值。
- 可选的缓动（easing）类型。
- 可选的回调函数。

第二种形式接受两个参数，一个属性对象和一个选项对象：

```

```

```
.animate({properties}, {options}) 
```

实际上，这里的第二个参数是把第一种形式的第2～4个参数封装在了另一个对象中，同时又添加了两个选项。

### 4.4.1 手工创建效果

.animate()方法针对CSS属性提供了方便简写值：'show'、'hide'和'toggle'，以便在简写方法不适用时提供另一种简化.slideToggle()等内置效果方法的方式。

### 4.4.2 一次给多个属性添加动画效果

使用.animate()方法可以同时修改多个CSS属性。

在可变宽度的布局中，使用jQuery的.outWidth()方法来计算宽度，包括内边距及边框宽度。

#### 注：left属性是计算的数值。这些属性值的单位后缀是可选的，如果不指定，就会默认以px作为单位

#### 通过CSS定位

所有块级元素默认的CSS定位属性都是static，这个值精确地表明：在改变元素的定位属性之前试图移动它们，它们只会保持静止不动。

## 4.5 并发与排队效果

### 4.5.1 处理一组元素

当为同一组元素应用多重效果时，可以通过连缀这些效果轻易地实现排队。

通过使用连缀，可以对其他任何jQuery效果进行排队，而并不限于.animate()方法。

#### 1. 越过队列

要是想在这个``不透明度减退至一半的同时，把它移动到右侧应该怎么办呢？在这种情况下，第二种形式的.animate()方法又可以派上用场了

第二个参数（即选项对象）包含了queue选项，把该选项设置为false即可让当前动画与前一个动画同时开始。

#### 2. 手工队列

有关为一组元素应用排队效果的最后一个需要注意的问题，就是排队不能自动应用到其他的非效果方法，如.css()，它也会立即执行。把非效果方法添加到队列中的一种方式，就是使用.queue()方法。

```

```

```
$(document).ready(function() { 
```

```
  $('div.label').click(function() { 
```

```
    var paraWidth = $('div.speech p').outerWidth(); 
```

```
    var $switcher = $(this).parent(); 
```

```
    var switcherWidth = $switcher.outerWidth(); 
```

```
    $switcher 
```

```
      .css({position: 'relative'}) 
```

```
      .fadeTo('fast', 0.5) 
```

```
      .animate({ 
```

```
        left: paraWidth - switcherWidth 
```

```
      }, { 
```

```
        duration: 'slow', 
```

```
        queue: false 
```

```
      }) 
```

```
      .fadeTo('slow', 1.0) 
```

```
      .slideUp('slow') 
```

```
      .queue(function(next) { 
```

```
        $switcher.css({backgroundColor: '#f00'}); 
```

```
        next(); 
```

```
    }) 
```

```
    .slideDown('slow'); 
```

```
  });
```

```
}); 
```

添加的这个next ()方法可以让队列在中断的地方再接续起来，然后再与后续的.slideDown ('slow')连缀在一起。如果在此不使用next()方法，动画就会中断。

### 4.5.2 处理多组元素

与一组元素的情况不同，当为不同组的元素应用效果时，这些效果几乎会同时发生。

#### 排队回调函数

为了对不同元素上的效果实现排队，jQuery为每个效果方法都提供了回调函数。

不过，这里我们需要注意的是，必须搞清楚要滑上的到底是哪个段落，由于.slideDown()方法是通过`$`(this).next()调用的，所以该方法中的一切现在都将`$`(this)视为下一个同辈元素，即第四个段落。可靠地引用$(this)的一种简单方法，就是在.click()方法内部把它保存到一个变量中。

注意，在使用交互的完成回调函数而不是.queue()时，不必在回调中调用next()。

### 4.5. 3 简单概括

随着在应用效果时需要考虑的变化的增多，要记住这些效果是同时发生还是按顺序发生会变得越来越困难。

- 一组元素上的效果：
  - 当在一个.animate()方法中以多个属性的方式应用时，是同时发生的；
  - 当以方法连缀的形式应用时，是按顺序发生的（排队效果）——除非queue选项值为false。
- 多组元素上的效果：
  - 默认情况下是同时发生的；
  - 当在另一个效果方法或者在.queue()方法的回调函数中应用时，是按顺序发生的（排队效果）。

## 4.6 小结

# 第5章 操作DOM

## 5.1 操作属性

.addClass()和.removeClass()方法实际上是在操作DOM中的className属性。

### 5.1.1 非类属性

操作其他一些属性，比如id、rel和title属性。jQuery为此也提供了.attr()和.revoveAttr()方法

.attr()方法也接受一对参数，第一个是属性名，第二个是属性值。更常用的方式还是传入一个包含键值对的对象

**值回调**

要为每个链接设置唯一的id，可以使用jQuery的.css()和.each()方法的另一个特性：值回调。

值回调其实就是给参数传入一个函数，而不是传入具体的值。这个函数会针对匹配的元素集中的每个元素都调用一次，调用后的返回值将作为属性的值。

**值回调的上下文**

就像在事件处理程序中一样，在值回调函数中，this关键字指向每次调用回调时正在操作的那个DOM元素。

### 5.1.2 DOM元素属性

HTML属性与DOM属性有一点区别。HTML属性是指页面标记中放在引号中的值，而DOM属性则是指通过JavaScript能够存取的值。（HTML的class 与 DOM的className）

某些DOM属性，例如nodeName、nodeType、selectedIndex和childNodes，在HTML中没有对应的属性，因此通过.attr()方法就没有办法操作它们。此外，数据类型方面也存在差异，比如HTML中的checked属性是一个字符串，而DOM中的checked属性则是一个布尔值。对于布尔值属性，最后是测试DOM属性而不是HTML属性，以确保跨浏览器的一致行为。

在jQuery中，可以通过.prop()方法取得和设置DOM属性

.prop()方法与.attr()方法没有什么不同，比如它们都可以一次性接受一个包含多个值的对象，也支持值回调函数。

### 5.1.3 表单控件的值

HTML属性与DOM属性差别最大的地方，恐怕就要数表单控件的值了。比如，文本输入框的value属性在DOM中的属性叫defaultValue，DOM中就没有value属性。而选项列表（select）元素呢，其选项的值在DOM中通常是通过selectedIndex属性，或者通过其选项元素的selected属性来取得。

由于存在这些差异，在取得和设置表单控件的值时，最好不要使用.attr()方法。而对于选项列表呢，最好连.prop()方法也不要使用。那使用什么呢，建议使用jQuery提供的.val() 方法

.val()方法也可以接受一个函数作为其setter参数。

## 5.2 DOM树操作

### 5.2.1 重新认识$()函数

### 5.2.2 创建新元素

### 5.2.3 插入新元素

- .insertBefore()在现有元素外部、之前添加内容；
- .prependTo()在现有元素内部、之前添加内容；
- .appendTo()在现有元素内部、之后添加内容；
- .insertAfter()在现有元素外部、之后添加内容。

### 5.2.4 移动元素

记住，即使是在隐式迭代的情况下，插入的顺序也是预定义的，即从DOM树的上方开始向下依次插入。

更加健壮的一种脚注方案应该：

- 为每个标注编号；
- 在正文中标出提取脚注的位置，使用脚注的编号；
- 在文本中的位置上创建一个指向对应脚注的链接，在脚注中创建返回文本位置的链接。

### 5.2.5 包装元素

**显式迭代**

.each()方法就是一个显式迭代器。这个方法接受一个回调函数，这个函数会针对匹配的元素集中的每个元素都调用一次

为了在正文中标记提取脚注的位置，可以利用.each()回调的参数。这个参数表示迭代的次数，从0开始，每迭代一次就加1。

### 5.2.6 使用反向插入方法

像.insertBefore()和.appendTo()这样的插入方法，一般都有一个对应的反向方法。反向方法也执行相同的操作，只不过“目标”和“内容”正好相反。例如append和appendTo

> **插入方法回调**反向插入方法可以接受一个函数作为参数，与.attr()和.css()方法类似。这个传入的函数会针对每个目标元素调用，返回被插入的HTML字符串。在此其实也可以使用这个技术，但由于这样就需要对每个脚注都重复一遍相同的操作，所以还是使用一个.each()方法来得更清晰。

使用数组的.join()方法来构建一个更大的数组

```

```

```
var str = 'a' + 'b' + 'c'; 
```

```
var str = ['a', 'b', 'c'].join(''); 
```

5.3 复制元素

在复制元素时，需要使用jQuery的.clone()方法，这个方法能够创建任何匹配的元素集合的副本以便将来使用。

在为复制的元素应用一种插入方法之前，这些元素不会出现在文档中。

```

```

```
//创建<div class="chapter">中第一段落的副本：
```

```
$('div.chapter p:eq(0)').clone(); 
```

> 在默认情况下，.clone()方法不会复制匹配的元素或其后代元素中绑定的事件。不过，可以为这个方法传递一个布尔值参数，将这个参数设置为true，就可以连同事件一起复制，即.clone(true)。

#### 通过复制创建突出引用

通过.clone()方法可以轻而易举地完成这种装饰效果。

## 5.4 内容setter和getter方法

直接用新的HTML代替旧的内容，要用到.html()方法了。在调用.html()而不传递参数的情况下，这个方法返回匹配的元素中的HTML标记。而传入参数后，元素的内容将被传入的HTML替换掉。在此要注意传入的HTML必须是有效的，而且要对特殊字符进行转义 。

引用一般不会使用原来的字体样式。要想去掉这些HTML标签，就得使用.html()方法的“伙伴”.text(方法。与.html()方法类似，.text()也可以取得匹配元素的内容，或者用新字符串替换匹配元素的内容。但是，与.html()不同的是，.text()始终会取得或设置纯文本内容。在使用.text()取得内容时，所有HTML标签都将被忽略，而所有HTML实体也会被转换成对应的字符。而在通过它设置内容时，诸如<这样的特殊字符，都会被转换成等价的HTML实体。

## 5.5 DOM操作方法的简单归纳

简单地归纳出一些方法，这些方法几乎能够在任何情况下，完成任何任务。

- 要在HTML中创建新元素，使用$()函数。
- 要在每个匹配的元素中插入新元素，使用：
  - .append() 
  - .appendTo() 
  - .prepend() 
  - .prependTo() 
- 要在每个匹配的元素相邻的位置上插入新元素，使用：
  - .after() 
  - .insertAfter() 
  - .before() 
  - .insertBefore() 
- 要在每个匹配的元素外部插入新元素，使用：
  - .wrap() 
  - .wrapAll() 
  - .wrapInner() 
- 要用新元素或文本替换每个匹配的元素，使用：
  - .html() 
  - .text() 
  - .replaceAll() 
  - .replaceWith() 
- 要移除每个匹配的元素中的元素，使用：
  - .empty() 
- 要从文档中移除每个匹配的元素及其后代元素，但不实际删除它们，使用：
  - .remove() 
  - .detach() 

## 5.6小结

使用jQuery的DOM操作方法完成了元素的创建、复制、重组以及内容修饰等操作。

通过在一个网页上应用这些方法，将一组普通的段落转换成了带脚注、突出引用、返回链接以及经过样式化的文本摘录。

# 第6章 通过Ajax发送数据

Ajax（Asynchronous JavaScript and XML，异步JavaScript和XML）。一个Ajax解决方案中涉及如下技术。

- JavaScript：处理与用户及其他浏览器相关事件的交互，解释来自服务器的数据，并将其呈现在页面上。
- XMLHttpRequest：这个对象可以在不中断其他浏览器任务的情况下向服务器发送请求。
- 文本文件：服务器提供的XML、HTML或JSON格式的文本数据。

## 6.1 基于请求加载数据

### 6.1.1追加HTML

Ajax应用程序通常只不过是一个针对HTML代码块的请求。这种被称作AHAH（Asynchronous HTTP and HTML，异步HTTP和HTML）的技术。首先，需要一些供插入用的HTML，我们把这些HTML放在与主文档位于同一目录下的a.html文件中。

我们注意到，a.html并不是一个真正的HTML文档，它不包含``、``或者``，只包含最基本的代码。通常，我们把这种文件叫做片段；它唯一目的就是供插入到其他HTML文档中使用

```

```

```
$(document).ready(function() {
```

```
  $('#letter-a a').click(function(event) {
```

```
    event.preventDefault();
```

```
    $('#dictionary').load('a.html');
```

```
  });
```

```
});
```

通过常规的jQuery选择符为HTML片段指定了目标位置，然后将要加载的文件的URL作为参数传递给.load()方法

所有Ajax请求在默认情况下都是异步的。对于必须要延迟到加载完成才能继续的操作，jQuery提供了一个回调函数。

### 6.1.2 操作JavaScript对象

使用jQuery的选择符可以遍历和操作取得的HTML结构，但是还有一种JavaScript内置的数据格式，既能减少数据传输量，也会减少编码量。

#### 1. 取得JSON

JSON规定所有对象键以及所有字符串值，都必须包含在双引号中。而且，函数也不是有效的JSON值。

要取得数据，可以使用`$`.getJSON()方法，这个方法会在取得相应文件后对文件进行处理。在数据从服务器返回后，它只是一个简单的JSON格式的文本字符串。`$`.getJSON()方法会解析这个字符串，并将处理得到的JavaScript对象提供给调用代码。

#### 2. 使用全局jQuery函数

getJSON()是作为全局jQuery对象（由jQuery库定义的jQuery或$对象）的方法定义的。

为了便于理解，我们在这里称其为全局函数；实际上，为了不与其他函数名称发生冲突，这些全局函数使用的是jQuery命名空间。

$.getJSON()函数可以接受第2个参数，这个参数是当加载完成时调用的函数。回调函数也需要一个参数，该参数中保存着返回的数据。

$.each()函数不操作jQuery对象，它以数组或对象作为第一个参数，以回调函数作为第二个参数。此外，还需要将每次循环中数组或对象的当前索引和当前项作为回调函数的两个参数

> **安全的HTML** 
>
> 这种方法要求数据中包含可以直接用来构建HTML的安全内容，例如，数据中不能包含任何< 字符。

尽管JSON格式很简洁，但它却不容许任何错误。所有方括号、花括号、引号和逗号都必须合理且正确地使用，否则文件不会加载。而且，在多数浏览器中，当文件加载失败时我们看不到任何错误信息；脚本只是静默地彻底终止运转。

#### 3. 执行脚本

向页面中注入脚本与加载HTML片段一样简单。但在这种情况下，需要使用全局函数$.getScript()，这个全局函数与它的同辈函数类似，接受一个URL参数以查找脚本文件。

以这种方式取得的脚本会在当前页面的全局环境下执行。这意味着脚本有权访问在全局环境中定义的函数和变量，当然也包括jQuery自身。

### 6.1.3 加载XML文档

加载XML文档很简单，而且与JSON技术也相当接近。

$.get()函数。通常，这个函数只是取得由URL指定的文件，然后将纯文本格式的数据提供给回调函数。但是，在根据服务器提供的MIME类型知道响应的是XML的情况下，提供给回调函数的将是XML DOM树。

可以使用常规的.find()、.filter()及其他遍历方法。

## 6.2 选择数据格式

4种外部数据的格式，当确定在应用程序中使用哪种格式时，应该考虑什么因素呢？

HTML片段：对于将新HTML添加到现有页面中的简单任务来说，无需遍历数据。另一方面，这种数据的结构方式却不一定能够在其他应用程序中得到重用，因为这种外部文件与它们的目标容器必须紧密结合。

JSON文件：结构使它可以方便地被重用。由于现代浏览器调用原生的JSON.parse()就能解析这种格式的文件，所以读取JSON文件的速度非常快。另外，JSON文件中的错误可能会导致页面上的脚本静默地中止运行，甚至还会带来其他的负面影响。

JavaScript文件：能够提供极大的灵活性，但它却不是一种真正的数据存储机制。因为这种文件针对特定的语言，所以不能通过它们将同样的信息提供给完全不同的系统。

XML：这种格式提供可重用的数据仍然还是很常见的。XML格式的文件体积相对较大，所以同其他文件格式相比，解析和操作它们的速度要慢一些。

**结论**在不需要与其他应用程序共享数据的情况下，以HTML片段提供外部数据一般来说是最简单的。如果数据需要重用，而且其他应用程序也可能因此受到影响，那么在性能和文件大小方面具有优势的JSON通常是不错的选择。而当远程应用程序未知时，XML则能够为良好的互操作性提供最可靠的保证。

## 6.3 向服务器传递数据

### 6.3.1执行GET请求

jQuery$.get()函数的对象来构建查询字符串

与其他Ajax接口唯一的差别是第二个参数，该参数是一个用来构建查询字符串的键和值的对象。

> **返回false还是阻止默认动作**
>
> 在本章的click处理程序中，我们传入了event对象并使用event.preventDefault()而不是return false结束该处理程序。当默认动作是重新加载页面或打开新页面时，我们推荐这种做法。例如，如果click处理程序中包含JavaScript错误，那么在第一行代码中（在碰到错误之前）阻止默认动作就能确保不会提交表单，而且浏览器的错误控制台也会收到错误报告。第3章曾介绍过，return false意味着同时调用event.preventDefault()和event.stopPropagation()。因此要想停止事件冒泡，我们还得再调用后者。

### 6.3.2 执行POST请求

使用POST方法与使用GET方法的HTTP请求几乎是一样的。

通过使用.load()方法还可以进一步简化这些代码，因为.load()方法在接收到包含数据的对象参数时，会默认使用POST方法发送请求。

### 6.3.3 序列化表单

.serialize()方法。这个方法作用于一个jQuery对象，将匹配的DOM元素转换成能够随Ajax请求传递的查询字符串。

## 6.4 为Ajax请求提供不同的内容

要利用jQuery随同Ajax请求一起发送的请求头部。在服务器端代码（这里是PHP）中，我们需要检查X-Requested- With头部。如果存在这个头部而且它的值为XMLHttpRequest，那么就会只发送文档片段；否则，就发送完整的文档。

## 6.5 关注请求

.ajaxStart()和.ajaxStop()方法，通过它们能够为各种与Ajax相关的事件注册回调函数。

当Ajax请求开始且尚未进行其他传输时，会触发.ajaxStart()的回调函数。相反，当最后一次活动请求终止时，则会执行通过.ajaxStop()注册的回调函数。

这些方法都是全局性的

这些方法都与.ready()方法一样，只能由$(document)调用。

在网络连接的速度比较慢时，可以通过这些方法为用户提供一些反馈。

在此基础上继续连缀相应的隐藏行为：

```

```

```
$(document).ajaxStart(function() { 
```

```
    $loading.show(); 
```

```
    }).ajaxStop(function() { 
```

```
    $loading.hide(); 
```

```
}); 
```

某些观察员方法，如.ajaxError()，会向它们的回调函数发送一个对XMLHttpRequest对象的引用。这样就可以做到区别不同的请求来提供不同的行为。其他更具体的处理可以通过使用低级的$.ajax()函数来完成。

与请求最常见的交互方式是成功（success）回调函数。

.load()方法可以接受一个加载完成时触发的回调函数

## 6.6 错误处理

$.get()和.load()等快捷的Ajax方法并没有提供错误回调参数

除了使用全局的.ajaxError()方法，我们还可以利用jQuery的延迟对象系统。可以给.load()之外的Ajax方法连缀.done()、.always()和.fail()方法，并通过它们添加相应的回调函数即可。

.status属性中包含着服务器返回的状态码。这些代码由HTTP规范定义，当触发.fail()处理程序时，可以根据下表解读错误。

| 响  应  码 | 说 明       |
| ------- | --------- |
| 400     | 请求语法错误    |
| 401     | 未授权       |
| 403     | 禁止访问      |
| 404     | 未发现请求的URL |
| 500     | 服务器内部错误   |

## 6.7 Ajax和事件

通过Ajax生成页面内容时的一个常见问题：即使已经把click处理程序添加到词条元素，只要一单击其他字母，这些处理程序仍然会丢失绑定。

一种常见的解决方案就是在页面内容更新时重新绑定处理程序。但这样做会相当繁琐

另外一种值得推荐的做法是第3章介绍的**事件委托**。在此，事件委托的本质就是把事件处理程序绑定到一个祖先元素，而这个祖先元素始终不变。

## 6.8 安全限制

为了防止各种**跨站点脚本攻击**，一般情况下从提供原始页面的服务器之外的站点请求文档是不可能的。

有许多方式可以绕过上述安全限制，即能够实现通过Ajax请求取得其他站点的数据：

其中一种方法是通过服务器加载远程数据，然后在客户请求时提供给浏览器。这是一种非常有效的手段，因为服务器能够对数据进行预处理。

另一种方法：加载外来JavaScript文件的一种流行方法是根据请求注入``标签。实际上，$.getScript()方法在检测到其URL参数中包含远程主机时，就会自动采用这种技术；此时，浏览器会执行加载的脚本，但却没有任何机制能够从脚本中取得结果。为此，使用这种技术要求同远程主机进行协作。加载的脚本必须执行某些操作，例如设置一个对本地环境有影响的全局变量。而远程主机上的服务除了发布能够通过这种方式执行的脚本外，还会提供一个API以便同远程脚本进行交互。

另一种方法是使用``这个HTML标签来加载远程数据。可以为``元素指定任何URL作为其获取数据的来源，包括与提供页面的服务器不匹配的URL。因此，第三方服务器上的数据能够轻易地加载到``中，并在当前页面上显示出来。然而，要操作``中的数据，仍然存在同使用``标签时一样的协作需求；位于``中的脚本需要明确地向父文档中的对象提供数据。****

> **跨域共享资源**
>
> Cross-Origin Resource Sharing（CORS，跨域资源共享）。这项技术要求一个域向另一个域发送的请求中要包含另一个域期待的自定义HTTP头部。接收请求的域如果接受请求，必须返回Access-Control-Allow-Oreigin响应头部。

#### 使用JSONP加载远程数据

使用``标签从远程获取JavaScript文件的思路，可以变通为从其他服务器取得JSON文件。jQuery直接支持的是JSONP（JSON with Padding，填充式JSON）。

JSONP的格式是把标准JSON文件包装在一对圆括号中，圆括号又前置一个任意字符串。这个字符串，即所谓的P（Padding，填充），由请求数据的客户端来决定。而且，由于有一对圆括号，因此返回的数据在客户端可能会导致一次函数调用，或者是为某个变量赋值——取决于客户端请求中发送的填充字符串。

由于远程文件经过设置以JSONP格式提供数据，因此通过在URL后面添加一个查询字符串，并使用?作为callback参数的占位符就可以获得数据。请求返回之后，jQuery会为我们替换?、解析结果并通过data参数将数据传入成功函数。结果就好像是在处理本地JSON数据一样。

## 6.9 其他工具

### 6.9.1 低级Ajax方法

在内部，jQuery会把一些用于启动Ajax通信的方法都对象为$.ajax()全局函数的一种变体。这个函数不针对任何特定Ajax通信类型，而是接收一个选项对象参数，并根据该参数来决定相应的行为。

$.ajax()接受了一个对象作为参数（或者一个URL字符串作为第一个参数，一个对象作为第二个参数）

用低级的$.ajax()函数时，可以获得下列特殊的好处。

- 避免浏览器缓存来自服务器的响应。非常适合服务器动态生成数据的情况。
- 抑制正常情况下所有Ajax交互都可以触发的全局处理程序（例如通过$.ajaxStart()注册的处理程序）。


- 在远程主机需要认证的情况下，可以提供用户名和密码。

### 6.9.2 修改默认选项

使用$.ajaxSetup()函数可以修改调用Ajax方法时每个选项的默认值。

这个函数与$.ajax()接受相同的选项对象参数，之后的所有Ajax请求都将使用传递给该函数的选项——除非明确覆盖

### 6.9.3 部分加载HTML页面

要去掉页面中多余的内容，可以利用.load()的一些新特性——在指定要加载文档的URL时，也可以提供一个jQuery选择符表达式。如果指定了这个表达式，.load()方法就会利用它查找加载文档的匹配部分。最终，只有匹配的部分才会被插入到页面中。

## 6.10 小结

使用jQuery提供的Ajax方法，在不刷新页面的情况下，从服务器上加载几种不同格式的数据。而且，我们也可以基于请求执行来自服务器的脚本，并且能够向服务器发送数据。

如何处理常见的异步加载技术的问题，例如在加载发生后绑定处理程序，以及从第三方服务器中加载数据。

# 第7章 使用插件

## 7.1 查找插件和帮助

## 7.2 使用插件

### 7.2.1 下载并包含Cycle插件

把文件下载到站点目录之后，需要在文档的<head>中引入这个插件。此时，注意把引入它的代码放在引入jQuery主文件的代码后面，但要位于使用这个插件的脚本前面。

### 7.2.2 调用插件提供的方法

Cycle插件可以作用于页面中的任何一组同辈元素。

通过Cycle插件可以将这个列表转换成可以交互的幻灯片。在DOM中适当的容器上调用.cycle()方法，就可以实现这一转换

```

```

```
$(document).ready(function() { 
```

```
    $('#books').cycle(); 
```

```
}); 
```

### 7.2.3 为插件方法指定参数

可以修改Cycle插件的两个幻灯片之间的播放速度和动画样式，修改幻灯片变换的触发方式，还可以使用回调函数针对动画完成作出响应。

### 7.2.4 修改参数默认值

Cycle其实也遵循了一个常见的模式，那就是把所有默认值放在一个对象中。包含所有默认选项的对象是$.fn.cycle.defaults。

## 7.3 其他形式的插件

### 7.3.1 自定义选择符

支持自定义选择符表达式的插件扩展了jQuery内置选择符引擎的功能，可以让我们以全新的方式查找元素。

### 7.3.2 全局函数插件

Cookie插件提供了读写页面中cookie值的接口。而这个功能是通过$.cookie()函数提供的，这个函数可以取得或设置个别的cookie值。

默认情况下，cookie的值将在会话期间保持，直到关闭浏览器标签页为止。默认情况下，cookie还是与设置它的页面关联的。如果想改变这个默认设置，可以为这个函数提供一个选项对象作为第三个参数。

```

```

```
//比如，要想让cookie在整个站点中都可以访问到，而且让它在7天之后再过期，就可以像这样来调用函数
```

```
$.cookie('cyclePaused', 'y', {path: '/', expires: 7})。
```

## 7.4 jQuery UI插件库

jQuery UI团队创建了大量核心交互组件及成熟的部件（widget），使用它们可以创造出更加类似桌面应用程序的Web体验。交互式组件包括用于拖动、放置、排序和调整项目大小的方法。当前稳定的部件有按钮、折叠窗格、日期选择器、对话框，等等。此外，jQuery UI还为补充和增强jQuery的核心动画功能提供了相当多的高级效果。

### 7.4.1 效果

jQuery UI中的效果（effect）模块由一个核心文件和一组独立的效果文件组成。

#### 1. 颜色动画

在文档中引用核心效果文件的情况下，扩展的.animate()方法可以接受另外一些样式属性，例如borderTopColor、backgroundColor和color。

#### 2. 基于类的动画

三个操作CSS类的方法：.addClass()、.removeClass()和.toggleClass()。在jQuery UI中经过扩展，都可以接受第二个可选的参数，用于控制动画时长。

#### 3. 高级缓动函数

jQuery在某个时长内不会以稳定的速度来执行动画。例如在1秒的开始和结尾，元素的高度变化比较慢，而在这1秒的中间，高度变化比较快。这种速度的变化就是缓动，缓动有助于让动画更流畅、更自然。

高级缓动函数可以改变加速或减速曲线，以产生与众不同的结果。

easeInExpo函数会让动画速度以指数方式加快，最终的动画速度要数倍于开始时的速度。

#### 4. 其他效果

变换都可以通过调用.effect()方法实现，这个方法是jQuery UI添加的。对于那些隐藏和显示元素的动画，可以视情况调用.show()、.hide()和.toggle()方法。

jQuery UI提供的效果可以满足各种不同的需求。比如，transfer和size可以用来改变元素的形状和位置，explode和puff可以产生更吸引人的隐藏动画，而pulsate和shake则可以让元素更吸引眼球。

### 7.4.2 交互组件

jQuery UI中的交互式组件就是一组行为，可以跟自定义代码结合起来生成复杂的交互式应用。

为元素应用交互行为非常简单，只需要在元素上调用与组件同名的方法即可。

> **其他交互式组件**
>
> jQuery UI还包括其他交互式组件，比如Draggable、Droppable和Sortable。

### 7.4.3 部件

除了交互式组件之外，jQuery UI库中还提供了一批可靠的用户界面部件。无论从外观还是功能上看，这些“开箱即用”的部件都非常类似我们熟悉的桌面应用程序中的相应元素。

Button部件

Slider部件就引入了一个全新的表单元素，它与HTML5的range元素类似，但却能兼容所有主流的浏览器。

为了响应滑动条的值的变化，可以绑定一个由滑动条触发的自定义事件。这个事件名为slide，虽然它不是原生JavaScript事件，但在jQuery代码中，它就像是原生事件一样。而且，监听这种事件也不用显式地调用.on()，只要把事件处理程序传递给.slider()方法即可

无论什么时候调用slide回调函数，其参数ui中都会保存着部件相关的信息，包括滑动条当前的值。把这个值传递给Cycle插件，就可以实现通过滑动条控制幻灯片了。

在幻灯变换时更新滑动条部件。要实现相反方向的通信，可以使用Cycle的before回调函数，这个函数会在每次幻灯变换时触发

> **其他部件**
>
> jQuery UI的Datepicker、Dialog、Tabs以及Accordion等部件都有一些可以配置的选项、事件和方法。

### 7.4.4 jQuery UI主题卷轴

jQuery UI库最近增添的一项名为ThemeRoller（主题卷轴）的功能，这是一个面向UI部件的于Web的交互式主题引擎。有了ThemeRoller，就可以在瞬间创建出高度自定义、专业化的元素。

## 7.5 jQuery Mobile插件库

### 7.5.1 HTML5自定义数据属性

jQuery Mobile交互最常见的方法还是使用HTML5的data-*属性。

HTML5规范允许我们在元素中插入任何需要的属性，只要该属性前缀data-即可。这种属性在页面渲染期间会被忽略，但jQuery脚本却可以访问它们。

> jQuery Mobile需要找到一些自定义的数据属性。

### 7.5.2 移动导航

jQuery Mobile中最重要的一个功能，就是把页面中的链接转换成Ajax驱动的导航。转换之后，导航将具有一些简单的动画效果，同时还能保留标准的浏览器历史记录。

特别要注意，这里添加了一个``标签，用于定义页面的视口（viewport）。这个声明是告诉浏览器将其页面内容缩放到恰好填满设备的宽度。

为了创建导航，jQuery Mobile需要理解页面结构。为此，我们要使用data-role属性来提供这些信息

### 7.5.3 一个文档支持多个页面

除了能通过Ajax加载其他文档，jQuery Mobile还可以基于包含所有内容的单个文档实现同样的导航功能。为演示这一点，只要在文档链接中使用标准的#符号，同时就像标记独立文档一样使用data-role="page"属性标记那些内容区块

### 7.5.4 交互式元素

jQuery Mobile中的大部分组件都是交互式元素。折叠式区块、可切换开关、幻灯片式面板，以及响应式表格，都是交互式元素的例子。

> jQuery UI与jQuery Mobile有相当数量的元素是重复的。不推荐在一个页面中同时使用它们，毕竟最重要的部件它们各自都有。

#### 1. 列表视图

通过jQuery Mobile很容易将页面中的列表转换成移动应用中的列表。

```

```

```
<ul data-role="listview" data-inset="true" data-filter="true"> 
```

添加的data-role="listview"告诉jQuery Mobile把列表中的链接转换成适合手指触摸的大按钮。而data-inset="true"则用于给列表添加一个漂亮的边框。可以进一步添加筛选搜索框，以便通过关键词来筛选（减少）列表项。

#### 2. 工具栏按钮

某些情况下，jQuery Mobile甚至会帮我们创建原来没有的按钮。

例如，屏幕左上角的Back，点击可以返回上一层。只要给页面中的``元素添加data-add-back-btn属性，就可以得到这么一个按钮：

```

```

```
<div data-role="page" data-add-back-btn="true"> 
```

### 7.5.5 高级功能

- 移动优化的事件。在页面引用jQuery Mobile后，jQuery代码就可以访问一些特殊的事件，比如tap、taphold和swipe。这些事件的处理程序同样以.on()方法绑定，与绑定其他事件一样。其中，taphold和swipe默认的配置（包括触摸时长）可以通过`$.event. special.taphold`和`$.event.special.swipe`对象来修改。除了基于触摸的事件，jQuery Mobile还支持能响应滚动、屏幕翻转和页面导航不同阶段的特殊事件，以及一组虚拟的鼠标事件，能够同时响应鼠标和触摸操作。
- 主题定制。与jQuery UI一样，jQuery Mobile也提供ThemeRoller用于定制部件的外观。
- PhoneGap集成。使用PhoneGap（Cordova）很容易将通过jQuery Mobile构建的网站转换成原生应用，从而能够访问移动设备的API（相机、加速计和地理定位等）和应用商店。通过`$.support.cors`和`$.mobile.allowCrossDomainPages`属性，甚至可以访问不包含在应用中的页面，比如包含在远程服务器中的页面。

## 7.6小结

本章介绍了在网页中整合第三方插件的各种方式。其中，着重讨论了Cycle、jQuery UI和jQuery Mobile，并展示了在其他插件中同样会遇到的一些模式。

# 第8章 开发插件

## 8.1 在插件中使用$别名

不能假设`$`别名一定可用。对于代码比较长的插件来说，很多开发人员都觉得不能使用$别名会导致代码难以理解。为了解决这个问题，我们可以在插件的作用域内定义这个快捷方式，方法就是定义一个函数并马上调用它。这种定义并立即调用函数的语法通常被称为立即调用的函数表达式（IIFE，Immediately Invoked Function Expression）：

```

```

```
(function($) { 
```

```
    //在这里添加代码
```

```
})(jQuery); 
```

这个包装函数只接收一个参数，我们通过这个参数传入了jQuery对象。这个参数的名字是$，因此在这个函数内部，使用$别名就不会有冲突了。

## 8.2 添加新的全局函数

 所谓**全局函数**，实际上就是jQuery对象的方法，但从实践的角度上看，它们是位于jQuery命名空间内部的函数。

核心jQuery库提供的很多全局函数都是**实用方法**；所谓实用方法，就是一些常用功能的快捷方式，但即使手工编写同样功能的代码也不是很难。数组处理方法、​.map()和$.grep()都是实用方法。

#### 添加多个函数

#### 1. 扩展全局jQuery对象

利用`$.extend()`函数，还可以通过另外一种语法来定义全局函数 

```

```

```
(function($) { 
```

```
  $.extend({
```

```
      sum: function(array) { 
```

```
          ...
```

```
      },
```

```
      average: function(array) {
```

```
          ...
```

```
      }
```

```
  });
```

```
})(jQuery);
```

这样调用$.extend()就可以给全局jQuery对象添加属性（如果原来有相同的属性，就会替换原来的属性）。

#### 2. 使用命名空间隔离函数

为了避免冲突，最好的办法是把属于一个插件的全局函数都封装到一个对象中

```

```

```
(function($) { 
```

```
  $.mathUtils = { 
```

```
    ...
```

```
  }; 
```

```
})(jQuery); 
```

这个模式的本质是为所有的全局函数又创建了一个命名空间，叫做jQuery.mathUtils。

在调用它们时就必须得加上插件的名字了：

```

```

```
$.mathUtils.sum(sum); 
```

```
$.mathUtils.average(average); 
```

> **选择命名空间** 
>
> 对于仅限于个人使用的函数，一般来说还是把它保存在项目的命名空间中最方便。换句话说，不要保存在jQuery命名空间中，而要选择一个我们自己的全局对象。

## 8.3 添加jQuery对象方法

添加全局函数需要以新方法来扩展jQuery对象。添加实例方法也与此类似，但扩展的却是jQuery.fn对象：

```

```

```
jQuery.fn.myMethod = function() { 
```

```
    alert('Nothing happens.'); 
```

```
}; 
```

> jQuery.fn对象是jQuery.prototype的别名，使用别名是出于简洁的考虑。

一个合理的实例方法应该包含对它的上下文的操作。

### 8.3.1 对象方法的上下文

在任何插件方法内部，关键字this引用的都是当前的jQuery对象。

### 8.3.2 隐式迭代

要在无论匹配多个元素的情况下都保证行为正确，最简单的方式就是始终在方法的上下文上调用.each()方法；这样就会执行隐式迭代，而执行隐式迭代对于维护插件与内置方法的一致性是至关重要的。

在调用的.each()方法内部，this依次引用每个DOM元素

> **this的含义**
>
> 注意！在对象方法体内，关键字this引用的是一个jQuery对象，但在每次调用的.each()方法中，this引用的则是一个DOM元素。

### 8.3.3 方法连缀

返回的jQuery对象通常就是this所引用的对象。如果我们使用.each()迭代遍历this，那么可以只返回迭代的结果

## 8.4 提供灵活的方法参数

### 8.4.1  参数对象

作为一种向插件用户公开选项的方式，对象要比刚刚使用的参数列表更加友好。对象会为每个参数提供一个有意义的标签，同时也会让参数次序变得无关紧要。而且，只要有可能通过插件来模仿jQuery API，就应该使用对象来提高一致性和易用性

### 8.4.2  默认参数值

实用函数$.extend()可以用接受的opts对象参数覆盖defaults中的选项，并保持选项对象中未指定的默认项不变。

```
var defaults = { 
  copies: 5, 
  opacity: 0.1 
}; 
var options = $.extend(defaults, opts);
```

$.extend()方法甚至可以接受null值

### 8.4.3 回调函数

要在方法中使用回调函数，需要接受一个函数对象作为参数，然后在方法中适当的位置上调用该函数。

### 8.4.4 可定制的默认值

要支持默认值的可定制，需要把它们从方法定义中移出，然后放到外部代码可以访问的地方

```

```

```
(function($) { 
```

```
  $.fn.shadow = function(opts) { 
```

```
    var options = $.extend({}, $.fn.shadow.defaults, opts); 
```

```
        // ... 
```

```
    }; 
```

```
    $.fn.shadow.defaults = { 
```

```
        //...
```

```
    } 
```

```
  }; 
```

```
})(jQuery); 
```

由于现在所有对.shadow()的调用都要重用defaults对象，因此不能让`$.extend()`修改它。我们就在此将一个空对象（{}）作为`$.extend()`的第一个参数，让这个新对象成为被修改的目标。

## 8.5 使用jQuery UI部件工厂创建插件

jQuery UI库的核心包含了一个工厂方法，叫`$.widget()`

使用部件工厂创建的插件具有很多不错的特性。只要编写少量代码，就可以额外获得这些功能（甚至更多）：

- 插件具有了“状态”，可以检测、修改甚至在应用之后完全颠覆插件的原始效果；
- 自动将用户提供的选项与定制的选项合并到一起；
- 多个插件方法无缝组合为一个jQuery方法，这个方法接受一个表明要调用哪个子方法的字符串；
- 插件触发的自定义事件处理程序可以访问部件实例的数据。

### 8.5.1 创建部件

每次调用`$.widget()`都会通过部件工厂创建一个jQuery UI插件。这个函数接受部件的名称和一个包含部件属性的对象作为参数。部件名称必须带命名空间

```

```

```
(function($) { 
```

```
  $.widget('ljq.tooltip', { 
```

```
    _create: function() {
```

```
        //...
```

```
    } 
```

```
  }); 
```

```
})(jQuery); 
```

> 部件属性（如_create()）以下划线开头，表示私有。

.on()调用中还涉及了另一个新语法：把处理程序传递给$.proxy()函数。这个函数会修改方法中this的指向。

### 8.5.2 销毁部件

一个内置的子方法是destroy。

> 注意，这一次的destroy前面并没有加下划线，这是因为它是一个可以过.tooltip('destroy')调用的公有子方法。

### 8.5.3 启用和禁用部件

内置的enable和disable子方法可以帮我们实现部件的启用和禁用，方法是将this.options.disabled的值设置为true或false。

### 8.5.4 接受部件选项

> **对选项变化作出响应** 
>
> 如果需要立即对选项变化作出响应，可以在部件中添加一个`_setOption`函数，这个函数负责处理变化，然后调用`_setOption`的默认实现。

### 8.5.5 添加子方法

有时候我们可能想为自己插件的用户提供更多“挂钩”。前面已经介绍过如何在部件中创建私有函数，实际上创建公有函数（也就是子方法）也一样，唯一的区别在于部件的属性名不以下划线开头。

### 8.5.6 触发部件事件

真正的好插件不仅自己扩展jQuery，而且还能为其他代码提供机制来扩展它。提供这种扩展能力的方法之一就是支持与插件相关的一组自定义事件。

## 8.6 插件设计建议

- 为避免`$`别名与其他库发生冲突，可以使用jQuery，或者在立即调用的函数表达式（IIFE）中传入`$`，使其成为一个局部变量。
- 无论是以`$.myPlugin`的方式扩展jQuery，还是以`$.fn.myPlugin`的方式扩展jQuery的原型，给`$`命名空间添加的属性都不要超过一个。更多的公有方法和属性应该添加到插件的命名空间中。
- 别忘了为插件提供一个默认选项的对象：`$.fn.myPlugin.defaults = {size: 'large'}`。
- 要允许插件用户有选择地覆盖任何默认选项，包括影响后续方法的调用(`$.fn.myPlugin. defaults.size = 'medium';`）和单独调用（`$('div').myPlugin ({size: 'small'});`）。
- 多数情况下，扩展jQuery原型时（`$.fn.myPlugin`）要返回this，以便插件用户通过连缀语法调用其他jQuery方法（如`$('div').myPlugin().find('p').addClass('foo')`）。
- 在扩展jQuery原型时（`$.fn.myPlugin`），通过调用this.each()强制执行隐式迭代。
- 合适的时候，利用回调函数支持灵活地修改插件行为，从而不必修改插件代码。
- 如果插件是为了实现用户界面元素，或者需要跟踪元素的状态，使用jQuery UI部件工厂来创建。
- 利用QUnit等测试框架为自己的插件维护一组自动的单元测试，以确保插件能够按预期工作。
- 使用Git或其他版本控制系统跟踪代码的版本。
- 在把自己的插件提供给别人使用时，务必明确许可条款。建议考虑使用MIT许可，这也是jQuery使用的许可。

#### 分发插件

还应该在分发插件之前，给它配上完整的文档。可以选择一种恰当的文档格式，也可以利用现有的文档标准，例如JSDoc、doco和dox等。

## 8.7小结

# 第9章 高级选择符与遍历

## 9.1 深入选择与遍历

### 9.1.1 动态筛选表格内容

第一步，就是隐藏所有不包含相关主题的表格行

```

```

```
#news tr:has(td):not(:contains("topic")) 
```

> **选择符与遍历方法**
>
> 使用选择符还是使用与其对应的遍历方法，最终可能会导致性能上的差异。

### 9.1.2 为表格行添加条纹效果

为表格中的行交替应用不同颜色的方式：

使用:even和:odd自定义选择符可以迅速实现这一效果，而使用CSS原生的:nth-child()伪类也可以实现同样的效果

```

```

```
$(document).ready(function() { 
```

```
    $('#news').find('tr:nth-child(even)').addClass('alt'); 
```

```
});
```

如果想实现更复杂一些的行条纹，可以尝试每两行一组地应用alt类。因为没有再使用`:nth-child()`伪类，所以交替效果不会在每个元素中分别开始。同时，为了保证外观的一致，还要跳过表格中的标题行。

```

```

```
$(document).ready(function() {
```

```
  $('#news tbody').each(function() {
```

```
    $(this).children().has('td').filter(function(index) {
```

```
        return (index % 4) < 2;
```

```
    }).addClass('alt');
```

```
  });
```

```
});
```

### 9.1.3 组合筛选与条纹

为了让筛选与条纹可以完美地共存，必须在每次筛选之后重新应用条纹效果。此外，在应用alt类的时候，还要考虑某些行当前是否隐藏了。

这里用到的伪类:visible（及其对应的伪类`:hidden`）非常重要，它会排除由于各种原因隐藏的元素，包括display值为none以及width和height属性被设置为0。

### 9.1.4 更多选择符与遍历方法

所有选择符的介绍：[http://api.jquery.com/category/selectors/](http://api.jquery.com/category/selectors/)，而这里有遍历方法的介绍：[http://api.jquery.com/category/traversing/](http://api.jquery.com/category/traversing/)。

## 9.2 定制与优化选择符

### 9.2.1 编写定制的选择符插件

提高代码可读性的一种方式是自定义选择符表达式。

最容易添加的选择符是伪类，也就是以冒号开头的选择符表达式，比如:checked或:nth-child()。

在使用选择符表达式查找元素的时候，jQuery会在一个内部的对象expr中取得JavaScript代码。这个对象中的值与我们传入到.filter()或.not()中的筛选函数非常相似，当且仅当取得的函数返回true的情况下，才会让每个元素包含在结果集中。使用$.extend()函数可以为这个对象添加新的表达式。

```

```

```
(function($) {
```

```
  .extend(.expr[':'], {
```

```
    group: function(element, index, matches, set) {
```

```
      var num = parseInt(matches[3], 10);
```

```
      if (isNaN(num)) {
```

```
        return false;
```

```
      }
```

```
        return index % (num * 2) <num;
```

```
    }
```

```
  });
```

```
})(jQuery);
```

以上代码告诉jQuery：group是一个有效的字符串，可以放在一个冒号的后面构成选择符表达式。而在遇到这个选择符表达式的时候，应该调用给定的函数，用以决定相应的元素是否应该包含在结果集中。

这个被求值的函数一共接收了4个参数。

- element：当前考虑的DOM元素。这个参数对于大多数选择符都是必须的，但我们这个选择符则不需要。
- index：DOM元素在结果集中的索引。
- matches：数组，包含用于解析这个选择符的正则表达式的解析结果。一般来说，matches[3]是这个数组中唯一有用的值；假设有一个选择符的形式为:group(b)，则matches[3]中包含的值就是b，也就是括号中的文本。
- set：匹配到当前元素的整个DOM元素集合。这个参数很少用。

伪类选择符需要使用包含在这4个参数中的信息，决定当前元素是否应该包含在结果集中。

### 9.2.2 选择符的性能问题

在规划任何Web项目的时候，都需要考虑项目周期、维护代码的难易程度和效率，以及用户使用网站过程中的性能等问题。

选择符及遍历的性能问题经常是解决用户感觉网页反应迟钝的一个突破口。

> 为了真正提升性能，最好反复思考自己假定的条件，然后在使jsPerf（[http://jsperf.com/](http://jsperf.com/)）等工具实际测量之后，再动手编写优化代码。

#### 1. Sizzle的选择符实现

在把一个选择符表达式传递给$()函数时，jQuery的Sizzle引擎会解析这个表达式，并确定如何收集该表达式所表示的元素。

在最本质的层次上，Sizzle会应用浏览器支持的最高效的原生DOM方法取得nodeList。这个节点列表是一个包含DOM元素的类似数组的对象，jQuery最终会将这个对象转换成真正的数组，并将其添加到jQuery对象中。下面就是jQuery内部使用的几个DOM方法，同时给出了支持它们的浏览器及版本。

| 方 法                       | 选择目标                 | 支持的浏览器                      |
| ------------------------- | -------------------- | --------------------------- |
| .getElementById()         | 取得ID与给定的字符串匹配的一个元素   | 全部                          |
| .getElementsByTagName()   | 取得标签名与给定的字符串匹配的所有元素  | 全部                          |
| .getElementsByClassName() | 取得某个类名与给定的字符串匹配的所有元素 | IE 9+、Firefox 3+、Safari 4+、 |
| .querySelectorAll()       | 取得与给定的选择符表达式匹配的所有元素  | IE 8+、Firefox 3.5+、Safari   |

在这些方法都不能处理某个选择符表达式的情况下，Sizzle会退而求其次地循环遍历已经收集到的所有元素，并根据这个表达式来测试每一个元素。

具体来说，假如没有现成的DOM方法可以拿来处理这个选择符表达式，Sizzle就会使用document.getElementsByTagName('*')来取得文档中的全部元素，然后再遍历并测试每个元素。

与使用任何一个原生DOM方法相比，这种遍历和测试每个元素的方法十分影响性能。好就好在，所有现代浏览器的最新版本都开始原生支持.querySelectorAll()方法了，此时Sizzle就会在其他（也许更快的）原生方法不可用的情况下使用这个方法。但也有一个例外：如果选择符表达式中包含自定义的jQuery选择符（例如:eq()、:odd或:even），而这些选择符并没有对应的CSS版本，那Sizzle也别无选择，只能循环加测试了。

#### 2. 测试选择符的速度

用来测试的现代浏览器（Chrome 26、Firefox 20和Safari 6）由于支持选择符可以利的.querySelectorAll()方法，平均速度比使用jQuery自定义选择符快得多

在不支持.querySelectorAll()的浏览器（如IE7）中，这两个选择符的速度几乎相同。因为这时候两个选择符都会强迫jQuery遍历页面中的每一个元素，并逐个进行测试

`$('input:eq(1)')` 和`$('input').eq(1)`，后者速度比前者快很多

一条通用的经验法则：要尽可能使用CSS规范中规定的选择符，除非没有可使用jQuery的自定义选择符。同样，在修改选择符之前，也要记住只在确实有必要提升性能的情况下再去提升。

## 9.3 DOM遍历背后的秘密

每当我们从一个（组）DOM元素转移到另一个（组）DOM元素时，jQuery都会留意我们移动的路线并留下“面包屑”，以便我们在必要时能够找到“回家”的路。

### 9.3.1 jQuery对象属性

通过`$()`函数得到的对象里面还隐藏着其他一些属性。

比如.context属性中包含着一个DOM节点（通常是document）的引用，搜索就是从这个节点开始的；比如.selector属性中保存着创建最终对象的选择符表达式。在调用`.on()`等事件委托方法时，这两个属性就会派上用场。在调用某个DOM遍历方法时，则会用上第三个属性：`.prevObject`。这个属性中保存着调用遍历方法的那个jQuery对象。

### 9.3.2 DOM元素栈

每个jQuery对象都有一个`.prevObject`属性指向前一个对象。这样，就有了一个实现了栈的列表结构。

`.end()`和`.addBack()`方法就是用来操作这个栈的。

`.end()`方法只是简单地从栈中弹出一个元素，结果就是栈的最上方保存着与`.prevObject`属性中相同的引用。

调用`.addBack()`时，jQuery会在栈中回溯一个位置，把两个位置上的元素集组合起来。

### 9.3.3 编写DOM遍历方法插件

可以通过为$.fn添加属性的方式来向jQuery中添加遍历方法。

> **处理嵌套的表格**
>
> 为了支持表格嵌套，需要确定是否存在标签，并在DOM树中上下移动适当的位置

`.pushStack()`方法接收一批DOM元素，并将它们添加到栈中，以便接下来对`.addBack()`和`.end()`的调用能够准确无误地执行。

### 9.3.4 DOM遍历的性能问题

最低限度地重复选择符和遍历方法则始终是值得提倡的，有两个策略值得讨论，那就是连缀和缓存对象。

#### 1. 使用连缀来改进性能

事实上，使用连缀还有可能带来性能上的提升，而关键则是利用它来减少重复。（比如：利用栈的技术）

#### 2. 使用缓存来改进性能

考虑到使用选择符和遍历方法的性能问题，缓存的目标可以确定为把jQuery对象保存在一个变量中，以便将来使用时不再重新创建同样的对象。

与连缀的方法相比，缓存方式稍嫌冗长，因为额外创建了一个用于保存jQuery对象的变量。但从另一个角度来看，这种方式在代码中可以完全分离选中元素的两次操作

## 9.4 小结

# 第10章 高级事件处理

## 10.1 再谈事件

### 10.1.1 追加数据页面

在单击More Photos链接时，需要执行一次Ajax请求，加载下一组照片并将它们追加到``。

此外，还要更新More Photos链接的目标，让它指向包含下一组照片的页面。

> **渐进增强**这个示例可以离线使用，不需要Web服务器。在实际应用当中，相关数据可能会保存在一个数据库里。此外，还需要考虑使用HTML5的历史记录API，让用户能够把我们用Ajax加载的内容保存为书签。

### 10.1.2 悬停时显示数据

首先，为了显示这些信息，可以使用.hover()方法。

由于两个处理程序中有一部分代码完全相同，因此可以把它们组合起来以减少冗余的代码。比如，可以为mouseenter和mouseleave绑定同一个处理程序，只在两个事件名称之间加一个空格即可。

但有一个例外，那就是当用户单击More Photos链接加载了更多照片时，新加载的照片不会响应那两个事件。事件处理程序只会添加到调用.on()方法时已经存在的元素上。像通过Ajax调用这样后来添加的元素，不会绑定那些事件。当前，我们针对这个问题给出了两个解决方案：一是在加载了新内容之后，“重新绑定”事件处理程序；二是一开始就把事件绑定到包含元素上，不依赖于事件冒泡。后一个解决方案，叫做事件委托。

## 10.2 事件委托

前面提到，为了实现事件委托，我们需要检测event对象的target属性，以便知道事件目标是不是我们想要触发行为的那个元素。事件目标，指的是接收到事件的那个最里面、最深层的元素。对于目前的示例程序而言，``元素不可能成为事件目标，因为它还包含着其他元素，比如图像和图像的信息。我们需要使用.closest()方法，这个方法可以沿DOM树向上一层一层移动，直至找到与给定的选择符表达式匹配的那个元素。如果没有找到这个元素，那它就会像其他DOM遍历方法一样，返回一个“空的”jQuery对象。

注意，还需要把事件的类型由mouseenter和mouseleave改为mouseover和mouseout。因为前两个事件只有在鼠标最先进入和最后离开``时才会触发，而我们需要在鼠标进入这个包含``内部的任何照片时都触发处理程序。然而，使用后两个事件又会引入另外一个问题，即必须额外再检测event对象的relatedTarget属性，否则``就会反复淡入淡出。

### 10.2.1 使用jQuery的委托方法

jQuery的.on()方法内置了委托管理能力。

```

```

```
$(document).ready(function() {
```

```
  $('#gallery').on('mouseenter mouseleave', 'div.photo',
```

```
    function(event) {
```

```
     ...
```

```
    }
```

```
  });
```

```
});
```

在把'div.photo'作为第二个参数的情况下，.on()方法会把this关键字映射为'#gallery'中与该选择符匹配的元素。

> 有些开发人员使用.delegate()和.undelegate()方法，虽然语法不同，但作用是一样的。

### 10.2.2 选择委托的作用域

实际上，照片元素的任何祖先元素都可以作为这个委托的作用域。

在安排事件委托时，把处理程序绑定到document很方便。因为所有元素都是document的后代，这样不用担心是否会选错容器。可是，这种方便也需要牺牲一定的性能。如果DOM嵌套结构很深，事件冒泡通过大量祖先元素也会导致较大的性能损失。

### 10.2.3 早委托

一般来说，只有当相应的DOM元素加载完毕，才能给它绑定事件处理程序。这就是为什么我们通常都把代码放到`$(document).ready()`内部的原因。

可是，document元素是随着页面加载几乎立即就可以调用的，把处理程序绑定到document不用再等到完整的DOM构建结束。

> **立即被调用的函数表达式**
>
> 我们使用了立即调用的函数表达式（IIFE）来取代$(document).ready()。IIFE形同第8章讨论过的闭包，可以在同一个页面中使用其他脚本时，避免可能的函数或变量的命名冲突（因为变量都被“限定”在了函数中）。

## 10.3 自定义事件

.on()方法对应着一个函数的定义，而.trigger()方法对应着一次函数调用。

### 10.3.1 无穷滚动

所谓无穷滚动，是一种让用户控制滚动条来加载内容的流行技术，即当到达目前加载的内容底部时，就会自动取得新内容。

### 10.3.2 自定义事件参数

在触发自定义事件时，我们也可以给任何注册的事件处理程序传入额外的信息。这种技术就叫做自定义事件参数。

任何事件处理程序的第一个参数是由jQuery增强和扩展之后的DOM事件对象。在这个参数之后，我们可以根据需要传递任意数量的参数。

这个自定义事件参数在调用和接收的任何一端都是可选的。都不会出错。

## 10.4 节流事件

无穷滚动功能的主要问题是性能。由于某些浏览器中的scroll事件会在窗口滚动期间重复触发，因此计算过程会不断累积。浏览器中有几个原生事件都会频繁触发。最常见的事件有scroll、resize和mousemove。

为了解决这个问题，就需要节流事件。这个技术会限制一些无谓的计算，即不是每次事件发生都计算，而是选择在部分事件发生时计算。

使用JavaScript的setTimeout函数，延迟250毫秒再调用它。更重要的是，我们会在执行任何代码之前先检查当前运行的计时器。

#### 其他节流方案

这个轮询式的方案会调用JavaScript的setInterval()函数，每250毫秒检查一次scrolled变量的状态。不管什么时候发生滚动事件，scrolled都会被设置为true，以确保在下一次轮询时调用checkScrollPosition()。

> 在频繁重复的事件发生期间限制处理次数的第三种技术叫**消除抖动**（debouncing）。这种技术是以电子开关重复发送信号必需的后处理技术命名的，可以确保在发生多个事件的情况下，最终只会有一个事件实际地起作用。

## 10.5 扩展事件

可以创建一个特殊的新事件，用它来封装相应的节流技术。为了实现一个事件的特殊行为，需要为`$.event.special`对象添加属性。这个属性的键是我们的事件名称，而它的值本身是一个对象。这个特殊的事件对象包含可以在不同时刻调用的回调函数：

1. add会在每次为当前事件绑定处理程序时调用；
2. remove会在每次为当前事件删除处理程序时调用；
3. setup会在为当前事件绑定处理程序，且没有为元素的这个事件绑定其他处理程序时调用；
4. teardown是setup的反操作，会在某个元素删除这个事件的最后一个处理程序时调用；
5. _default是当前事件的默认行为，在没有被事件处理程序阻止的情况下会执行。

### 深入学习特殊事件

创建特殊事件其他可能的应用包括：

- 修改事件对象，以便事件处理程序可以使用不同的信息；
- 让DOM中的某个地方发生的事件触发与不同元素关联的行为；
- 对新的浏览器特有的非标准DOM事件作出响应，让jQuery代码像处理标准事件一样处理它们；
- 改变处理事件冒泡和事件委托的方式。

## 10.6 小结

本章介绍了事件系统的几个方面，包括事件委托方法、自定义事件和事件扩展API。同时，还讨论了如何避免事件委托以及频繁触发事件的一些陷阱。

# 第11章 高级效果

## 11.1 再谈动画

鼠标悬停动画。

## 11.2 观测及中断动画

存在问题：一个给定元素的动画会逐一被添加到一个队列中，然后再依次调用。第一个动画会立即被调用，在指定时间内完成，然后从队列中移除。此时，第二个动画又排在了第一位，于是接着被调用，完成，移除，以此类推，直至队列为空。

很多情况下，jQuery中这个叫做fx的动画队列都不会给我们带来问题。不过，在遇到像我们前面例子中这种悬停动画时，就要跟这个队列斗斗智了。

### 11.2.1 确定动画状态

若要避免产生不合需要的动画队列，一种方式是使用jQuery自定义的:animated选择符。

在mouseenter/mouseleave事件处理程序中，可以使用这个选择符来检测图像，看它当前是否正处于动画的过程中。

现在的动画仍然还需要改进。当鼠标快速进入和离开``时，图像仍然会完成整个mouseenter动画（增大），然后才开始mouseleave动画（缩小）。但测试`:animated`伪类又引入了一个更大的问题：如果鼠标进入``时，图像正在“缩小”，那么此后的图像也不会再增大了。只有当动画完成之后发生的mouseenter和mouseleave事件，才会引发另一次动画。这说明，尽管`:animated`选择符适用于在某些情况下检测动画状态，但在我们这里还不够。

### 11.2.2 中止运行的动画

.stop()方法能在动画运行过程中让动画立即停止。

#### 中止动画的注意事项

`.stop()`方法默认情况下会在动画的当前位置中止动画，在动画之前，这些简写的动画方法会确定最终的值，然后动态变化到该值。比如说，如果使用`.stop()`在`.slideDown()`动画的中途将其中止，然后调用`.slideUp()`。那么下次再在同一个元素上调用.slideDown()时，就只会向下滑动到上一次停止时的高度。

为了解决这个问题，`.stop()`方法可以接收两个布尔值参数（true/false），其中第二个参数叫goToEnd。如果把这个参数设置为true，那么当前动画不仅会停止，而且会立即跳到最终值。

更好的办法是把最终值保存在一个变量中，使用`.animate()`显式变化到该值，而不要依赖jQuery确定的值。

> jQuery还有一个方法可以中断动画：`.finish()`。这个方法与`.stop(true, true)`效果类似，因为它会清除排队的动画并使当前动画跳到最终值。不过，与`.stop(true, true)`不同的是，它也会使所有排队的动画都跳到各自的最终值。

## 11.3 全局效果属性

### 11.3.1 禁用所有效果

为了实现这个功能，只要简单地把`$.fx.off`属性设置为true即可。

### 11.3.2 定义效果时长

`$.fx`对象还有一个speeds属性。这个属性本身是一个对象，包含三个属性，通过jQuery核心源代码中这一小段可以看出来：

```

```

```
speeds: { 
```

```
  slow: 600, 
```

```
  fast: 200, 
```

```
  //默认速度
```

```
  _default: 400 
```

```
} 
```

每次调用一个动画方法，jQuery都要通过以下步骤来确定效果的持续时间。

1. 检测`$.fx.off`是否为true。如果是则持续时间为0。
2. 检测传入的持续时间是否为数值；如果是，则将持续时间设置为该毫秒数。
3. 检测传入的持续时间是否与`$.fx.speeds`的某个属性键匹配。如果是，则将持续时间设置为该属性的值。


1. 如果前面检测未发现传入持续时间参数，则将持续时间设置为`$.fx.speeds._default`的值。

注意，调用的`.fadeOut()`方法也使用了前面定义的比较快的250毫秒持续时间。这个默认值对jQuery所有的预置效果都是有效的，就像它对前面那个`.animate()`方法起作用一样。

## 11.4 多属性缓动

只要把top属性的缓动函数修改为easeInQuart，就可以改变一下效果；也就是让元素以曲线的方式运动，而不是径直地出来。

使用非swing和linear的任何缓动函数都需要插件。

通过specialEasing选项可以为每个要应用动画的属性设置不同的加速度曲线。任何没有包含在这个选项中的属性，都会使用easing选项中指定的缓动函数——如果提供了的话；否则，就要使用默认的swing函数。

## 11.5 使用延迟对象

延迟对象用以封装一个需要花一定时间才能完成的操作。

通过调用`$.Deferred()`构造函数可以创建一个新的延迟对象。有了延迟对象之后，就可以执行长时间的操作，然后在成功或不成功的情况下调用这个对象的`.resolve()`或`.reject()`方法。不过，很少需要手工调用这两个方法。

每一个延迟对象都会向其他代码**承诺**（promise）提供数据。这个承诺以另一个对象的形式来兑现，这个对象也有自己的一套方法。对于任何延迟对象，调用它的`.promise()`方法就可以取得其承诺对象。然后，通过调用这个承诺对象的各种方法，就可以添加在各种承诺兑现时调用的处理程序。

- 通过.done()方法添加的处理程序会在延迟对象被成功解决之后调用。
- 通过.fail()方法添加的处理程序会在延迟对象被拒绝之后调用。
- 通过.always()方法添加的处理程序会在延迟对象完成其任务（无论解决或拒绝）时调用。

这些处理程序与回调函数还是有一些重要的区别：

- 承诺的处理程序只会被调用一次，因为延迟对象不能解决两次。
- 而且，如果在我们添加承诺处理程序时延迟对象已经解决，那么就会立即调用这个处理程序。

#### 动画承诺

特别地，我们可以使用这个承诺对象在匹配元素上的所有动画运行完成后再执行某项操作。

使用`$.extend()`方法将始终保持不变的基本样式与根据不同成员位置变化的top和left属性合并在一起。然后，就是使用`.css()`来设置其开始样式，再使用`.animate()`来设置最终样式了。

第4章曾介绍过，jQuery动画方法的回调函数会在集合中每个元素的动画完成之后被调用。现在，我们想在其他``元素出现之后再显示成员的简介。这要是在jQuery引入`.promise()`方法之前，就是一个非常麻烦的任务。因为需要在每次执行回调函数时，都要倒减元素的个数，直至最后一次执行回调函数，然后才能执行简介的动画代码。而现在，只要在showDetails()函数中简单地把`.promise()`和`.done()`方法连缀在`.each()`方法之后即可。

## 11.6 精细地控制动画

jQuery 1.8重写了这个模块之后，又给高级开发人员提供了一些精细控制各种效果的手段，甚至可以让我们修改底层的动画引擎。比如，除了duration和easing选项之外，`.animate()`方法还提供了两个回调选项：

```

```

```
$('#mydiv').animate({
```

```
  height: '200px',
```

```
  width: '400px'
```

```
  }, {
```

```
  step: function(now, tween) {
```

```
    //监控高度和宽度，
```

```
    //调整补间属性
```

```
  },
```

```
  progress: function(animation, progress, remainingMs) {
```

```
  }
```

```
});
```

在动画过程中，这里的setup()函数大约每13毫秒会针对每个动画属性被调用一次。这样，我们就可以调整tween对象的属性，比如终止值、缓动类型，或者根据传入的now参数中属性的当前值修改实际的动画属性。

类似地，progress()函数在动画生命周期中也会被多次调用：

- 它与setup()的区别在于，它只会在动画的每一步针对每个元素被调用一次，与多少属性产生动画效果无关；
- 它提供了动画其他方面的调整选项，包括动画的承诺对象、进度（0到1之间的一个值）和动画剩余的毫秒数。

jQuery所有的动画都使用JavaScript的计时函数setTimeout()来重复调用函数。默认间隔时间为13毫秒，每次调用都会修改样式属性的值。

有些现代浏览器支持比setTimeout()更好的requestAnimationFrame()函数，使用这个函数不仅控制更精确（因此动画也更平顺），而且在移动设备上还能节省电量消耗。不管浏览器标签页是否活动，setTimeout()始终都不会停止运行。而requestAnimationFrame()函数则会在标签页不可见的时候暂停执行，因而更省电。

jQuery动画的Corey Frang写了一个用requestAnimationFrame()替代setTimeout()的插件（只要浏览器支持就替换）。这个插件会修改$.fx对象的两个方法：.timer()和.stop()。

对于动画而言，一般都应该使用requestAnimationFrame()替代setTimeout()。不过，由于在代码中同时使用这两者可能会引发冲突，jQuery核心库并没有实现requestAnimationFrame()。

jQuery动画系统最底层的方法是`$.Animation()`和`$.Tween()`函数。这两个函数及其对应的对象可以用来调整动画的每个可能的方面。比如，可以使用`$.Animation()`来创建动画滤清器（prefilter）。

## 11.7 小结

现在，我们知道了怎样单独控制每个动画属性的加速和减速，甚至在必要时单独地或全面地停止动画效果。讲到了jQuery效果库内部定义的几个属性，以及如何更改这些属性以适应我们的需求。本章还介绍了jQuery的延迟对象系统。最后，我们又学习了jQuery为高级程序员提供的精细控制动画效果的手段。

# 第12章 高级DOM操作

## 12.1 排序表格行

### 12.1.1 服务器端排序

经常可以看到类似下面的用户界面：让用户点击表头（`）中的链接来按照指定的列排序表格数据。这些链接都指向当前页面，但后面附加的查询字符串则用来表示作为排序依据的列：

```

```

```
<table id="my-data"> 
```

```
  <thead> 
```

```
    <tr> 
```

```
      <th class="name"> 
```

```
        <a href="index.php?sort=name">Name</a>
```

```
      </th> 
```

```
      <th class="date"> 
```

```
        <a href="index.php?sort=date">Date</a> 
```

```
      </th> 
```

```
    </tr> 
```

```
  </thead> 
```

```
  <tbody> 
```

```
    ... 
```

```
  </tbody> 
```

```
</table> 
```

### 12.1.2 Ajax排序

可以通过jQuery把那些链接转换为Ajax请求：

```

```

```
$(document).ready(function() { 
```

```
  $('#my-data th a').click(function(event) { 
```

```
    event.preventDefault(); 
```

```
    $('#my-data tbody').load($(this).attr('href')); 
```

```
  }); 
```

```
});
```

### 12.1.3 JavaScript排序

可行的方案就是在浏览器中使用JavaScript客户端脚本和jQuery的DOM操作方法来排序。包括：

- 根据从HTML内容中提取的内容排序；
- 根据HTML5自定义数据属性排序；
- 根据表格数据的JSON表示排序。

## 12.2 移动和插入元素

从最简单的地方着手——为表头加链接。

### 12.2.1 为已有的文本添加链接

`.wrapInner()`方法，这个方法会把一个新元素（在这里就是`[`](undefined)元素）放到匹配元素的内部，同时包含匹配元素的子元素。

首先（使用`.slice()`方法）跳过每个表格的第一个`元素。

### 12.2.2 简单的JavaScript数组排序

JavaScript内置的.sort()方法。这个方法会对数组元素进行就地排序，可以接受一个比较函数作为参数。这个比较函数比较数组中的两个元素，根据哪个元素应该在排序后的数组中排在前面返回正值或负值。

### 12.2.3 对DOM元素排序

在找到被单击的表头单元格的索引之后，取得了包含所有数据行的数组。使用`.get()`方法将jQuery对象转换为DOM节点数组。之所以要这样做，是因为jQuery对象本身虽然与数组类似，但它却没有`.pop()`或`.shift()`等原生的数组方法。

> jQuery 内部确实定义了一些与原生数组方法类似的方法。例如，`.sort()`、`.push()`和`.splice()`都是jQuery对象的方法。不过，这些方法都是内部使用的，并没有在文档中公开出来。总之，不能在jQuery对象上调用它们。

通过调用`.index()`方法返回的列索引，我们知道应该查找哪个单元格。而使用jQuery的`$.trim()`方法删掉文本内容前后的空格，之后再将它们转换成全部大写。

## 12.3 在DOM元素中保存数据

> **数组排序的性能**JavaScript实际使用的排序算法在标准中没有定义。

要解决比较函数造成的排序速度慢的问题，就需要预先计算要比较的关键字。换句话说，可以在一开始的循环中完成大部分费时的工作，并使用jQuery的`.data()`方法（用于设置和取得与页面元素相关的任意信息）把计算结果保存起来。

这里的`.data()`方法，再加上对应的`.removeData()`方法所提供的数据存储机制，可以非常方便地替代所谓的扩展属性（expando property）或其他直接添加给DOM元素的非标准属性。使用`.data()`而不是扩展属性可以避免在IE早期版本中导致内存泄漏。

### 12.3.1 执行预先计算

通过把标签中的排序关键字放到以前计算的关键字前头，可以实现以按姓排序为主，以按单元格中的整个字符串排序为辅的操作。

### 12.3.2 存储非字符串数据

之所以要对parseFloat()返回的结果进行检查，是因为如果不能从文本中解析出数字，该函数就会返回NaN，而这将会对`.sort()`函数造成严重破坏，所以需要将任何非数值设置为0。

表格中的日期只包含月和年，但Date.parse()方法需要一个完整的日期，因此我们前置了一个1，以便补足月和年前面的日（“September 2010”会变成“1 September 2010”）。

### 12.3.3 变换排序方向

当用户单击一个已经排序的表格列时，应该反转当前的排序次序。

## 12.4 使用HTML5自定义数据属性

通过让服务器输出带有HTML5 data-*属性的HTML，可以让代码更加有效。

为取得自定义数据属性，需要把属性名中data-之后的部分传给`.data()`方法。

使用像这里这样的数据属性的一个最大好处是，这些值可以输出为不同于表格单元格内容的形式。换句话说，我们对前面第一个表格所做的细节处理——把字符串转换为全部大写、改变日期的格式以及把价格转换为数值，都已经被处理好了。

## 12.5 使用JSON排序和构建行

首先，我们来编写两个函数：buildRow()和buildRows()。前者用于构建表格中的一行，后者使用`$.map()`循环遍历数据集中的所有行，在每一行数据上调用buildRow()。

虽然这里用一个函数也可以达到相同的目的，但使用两个独立的函数则可以方便我们在某个时刻单独地构建和插入一个表格行。这两个函数会从一次Ajax请求的响应取得数据

```

```

```
$.getJSON('books.json', function(json) {
```

```
  $(document).ready(function() {
```

```
    var table3 = ('#t-3');
```

```
    $table3.find('tbody').html(buildRows(json));
```

```
  });
```

```
});
```

关于这段代码，有几个地方需要说明一下。首先，这两个函数是在`$(document).ready()`外部定义的。通过等待`$.getJSON()`的回调函数调用`$(document).ready()`，可以让部分代码不必依赖于DOM而提前执行。

而在`$.each()`循环后面，又将生成的数组的值通过一个逗号和一个空格连接起来，得到了一个格式规范的名字列表。确保HTML字符串安全的一种方式就是在服务器上处理它们，比如把所有<转换成<、把>转换成>、把&转换成& ，等等。

### 12.5.1 修改JSON对象

通过给这个函数传入JSON数据，我们为表示每一行的对象又添加了两个属性：authorsFormatted和titleFormatted。这两个属性将用于显示表格内容，而原始的authors和title属性则用于排序。

当我们在`$.getJSON()`的回调函数中调用这个preRows()函数后，我们把修改后的JSON对象保存在变量rows中，然后基于这个修改后的对象进行排序和构建。这意味着还必须修改buildRow()函数，使其在提前准备数据的基础上能够变得更加简洁

### 12.5.2 按需重新构建内容

如何修改列标题和编写排序的代码

唯一的明显区别是这里的每次排序只向DOM中插入一次元素。

从性能的角度来看，重复性的DOM插入操作是非常费时间的，需要插入的表格行越多，效率就越低。

## 12.6 高级属性操作

可以使用`.attr()`、`.prop()`和`.css()`等简单的方法，以及`.addClass()`、`.css()`和`.val()`等方便的快捷方法，还可以使用像`.animate()`这样封装了复杂行为的方法。不过，即便是简单的方法都在后台帮我们完成了很多工作。

### 12.6.1 简捷地创建元素

我们在jQuery代码中创建元素时经常会把HTML字符串传递给`$()`函数，或者传递给其他DOM插入函数。但有时候，这种方式也不是最理想的，需要创建相应的元素然后连缀其他jQuery方法对它进行修改。不过，除了这种标准的技术之外，$()函数还提供了一种很有吸引力的语法。

假设我们要在文档中的每个表格前面都加上一个标题。可以使用`.each()`循环每一个表格，然后为每个表格创建适当的标题。

```

```

```
$(document).ready(function() { 
```

```
  $('table').each(function(index) { 
```

```
    var $table = $(this); 
```

```
    $('<h3></h3>', { 
```

```
      id: 'table-title-' + index,
```

```
        'class': 'table-title', 
```

```
      text: 'Table ' + (index + 1), 
```

```
      data: {'index': index}, 
```

```
      click: function(event) { 
```

```
        event.preventDefault(); 
```

```
        $table.fadeToggle(); 
```

```
      }, 
```

```
       css: {glowColor: '#00ff00'} 
```

```
    }).insertBefore($table); 
```

```
  }); 
```

```
}); 
```

为$()函数传递选项对象作为第二个参数，与先创建元素再将该对象传递给.attr()方法的结果是一样的。

简写的`$()`语法之所以可以处理这些，是因为它首先检查是否存在给定名字的jQuery方法，如果是就会调用相应的方法，而不是设置相应的属性。

> 鉴于jQuery为方法赋予了比属性名更高的优先级，因此我们必须自己注意那些容易存在歧义的情况。比如，``元素的size属性就不能以这种方式来设置，因为还有一个`.size()`方法存在。

简写的`$()`函数以及`.attr()`方法通过使用挂钩（hook），还能够处理很多额外的DOM属性。

### 12.6.2 DOM创建挂钩

通过定义适当的挂钩，可以扩展很多取得和设置属性的jQuery方法，从而满足某些特殊情况下的需要。

这些挂钩实际上是jQuery命名空间中的数组，比如`$.cssHooks`、`$.attrHooks`。

一般来说，挂钩是保存着get和set方法的对象，前者用于取得请求的值，后者的作用则是提供新值。

以下是其他几种挂钩。

| 挂钩类型        | 修改的方法   | 示例用法                              |
| ----------- | ------- | --------------------------------- |
| $.attrHooks | .attr() | 阻止元素的type属性被修改                    |
| $.cssHooks  | .css()  | 对Internet Explorer中的opacity进行特殊处理 |
| $.propHooks | .prop() | 纠正Safari中selected属性的行为            |
| $.valHooks  | .val()  | 支持单选按钮和复选框跨浏览器报告一致的值              |

#### 编写CSS挂钩

一个挂钩由针对元素的get方法和set方法构成。

> **查找挂钩**
>
> 仅向读者推荐Brandon Aaron开发的CSS挂钩：[https://github.com/brandonaaron/jquery-cssHooks](https://github.com/brandonaaron/jquery-cssHooks)。

## 12.7 小结

本章我们解决了一个常见的开发问题——数据表格排序。从三个不同角度阐述了实现表格排序的方法，分别展示了各自的优劣势。与此同时，我们也进一步掌握了原来学习过的DOM操作技术，同时探索了使用`.data()`方法与HTML5的数据属性在DOM元素上设置相关数据的新方式。此外，本章还揭开了一些DOM修改的底层机制，向大家展示了如何根据需要扩展这些机制。

# 第13章 高级Ajax

## 13.1 渐进增强与Ajax

大量运用Ajax的应用经常会面临用户不能使用JavaScript的风险。为了避免这种风险，可以先使用表单构建一个传统的客户端-服务器页面，而在JavaScript可用的情况下再修改表单，提供更有效的交互方式。

#### 收获JSONP数据

在请求JSONP数据时，需要提供一个特殊的查询字符串参数，发送请求的脚本就是通过该参数来收获数据的。JSONP服务器可以在认为合适的任何时候调用该参数。对于jQuery API站点而言，这个参数（也是默认的名字）是callback。

```

```

```
$.ajax({ 
```

```
  url: 'http://book.learningjquery.com/api/', 
```

```
  dataType: 'jsonp', 
```

```
  data: { 
```

```
    title: $('#title').val() 
```

```
  }, 
```

```
  success: function(data) { 
```

```
    console.log(data); 
```

```
  } 
```

```
}); 
```

## 13.2 处理Ajax错误

$.ajax()函数可以接收一个名为error的回调函数

触发这个错误回调函数的情况有很多种。下面列出了其中的一些错误。

- 服务器返回了错误状态码，例如403 Forbidden、404 Not Found或500 Internet Server Error。
- 服务器返回了间接的状态码，例如301 Moved Permanently。状态码为304 Not Modified的异常不会触发错误，因为浏览器可以正确地处理这种情况。
- 服务器返回的数据不能按照指定方式正确解析（例如，在dataType指定为json时，返回的不是有效的JSON数据）。
- XMLHttpRequest对象调用了`.abort()`方法。

如果服务器返回错误，那么通过传递给错误回调函数的jqXHR对象的`.status`属性，可以检测到该错误。换句话说，使用`jaXHR.status`的值可以对不同的错误给出不同的响应。

在没有既定的服务器端超时机制的情况下，我们可以在客户端强制设定请求的超时。通过给timeout选项传递一个以毫秒表示的时间值，就相当于告诉`$.ajax()`:如果响应在多长时间内没有返回，那么就调用它自己的`.abort()`方法

## 13.3 jqXHR对象

在发出Ajax请求时，jQuery会帮我们确定取得数据的最佳方式。可用的方式包括标准的XMLHttpRequest对象、微软的ActiveX对象XMLHTTP，或者``标签。

需要一个公共的接口与这些通信交互。jqXHR对象提供了这种接口：在XMLHttpRequest对象可用的情况下，封装该对象的行为；在XMLHttpRequest对象不可用的情况下，则尽可能模拟它。这个对象提供给我们的属性和方法包括：

- 包含返回数据的`.responseText`或`.responseXML`；
- 包含状态码和状态描述的`.status`和`.statusText`；
- 操作与请求一起发送的HTTP头部的`.setRequestHeader()`；
- 提早中断通信的`.abort()`。

### 13.3.1 Ajax承诺

与标准的XMLHttpRequest对象相比，jqXHR对象有一点非常值得重视，那就是它也是一个**承诺对象**。可以通过它来设置在某个操作完成后触发的回调函数。Ajax调用就是这样一种操作，而jqXHR对象提供了延迟对象所承诺的方法。

使用这些承诺对象的方法，可以重写`$.ajax()`调用，替换success和error回调函数

这两个承诺方法的确是有好处的：

- 可以多次调用这两个方法，根据需要添加多个处理程序。
- 如果把调用`$.ajax()`的结果保存在一个变量中，那么就可以考虑代码的可读性，在后面再添加处理程序。
- 如果在添加处理程序的时候Ajax操作已经完成，就会立即调用该处理程序。
- 最好采用与jQuery库中其他代码一致的语法

使用承诺方法的另一个好处是可以在请求期间添加一个加载指示器，然后在请求完成时或在其他情况下隐藏它。这时候，使用.always()方法就非常方便。

### 13.3.2 缓存响应

为了避免重复发送Ajax请求，能够利用承诺对象的属性，那就非常简单了。

首先，如果以前没有查询过，那么可能会发送Ajax请求。

如果以前执行过这个查询，那么jqXHR对象已经保存在api里面了。这一次不会执行新的查询，但我们仍然可以在保存的对象上调用承诺方法。而这会给该对象添加新的处理程序，由于作为延迟对象它已经被解决了，所以会立即触发相关的处理程序。

## 13.4 截流Ajax请求

实现搜索功能时，越来越常见的一个功能是在用户输入过程动态地列出搜索结果来。

```

```

```
$('#title').on('keyup', function(event) { 
```

```
    $ajaxForm.triggerHandler('submit'); 
```

```
}); 
```

如果用户连续输入的速度很快，那么就会通过网络发送很多请求。通过缓存请求的结果，我们已经节省了一些请求了。不过，通过**截流请求**，还能够进一步减少服务器的负担。

```

```

```
//每一次击键动作都会重置该计时器，只有用户停止击键的时间超过预定的300毫秒后，才会触发submit处理程序并发送Ajax请求。
```

```
var searchTimeout, 
```

```
  searchDelay = 300; 
```

```
    
```

```
$('#title').on('keyup', function(event) { 
```

```
  clearTimeout(searchTimeout); 
```

```
  searchTimeout = setTimeout(function() { 
```

```
    $ajaxForm.triggerHandler('submit'); 
```

```
  }, searchDelay); 
```

```
}); 
```

## 13.5 扩展Ajax功能

### 13.5.1 数据类型转换器

通过`$.ajaxSetup()`函数，也可以为`$.ajax()`添加它能够请求和解释的各种数据类型。

例子：一个能够解释YAML数据格式的转换器。

可以给jQuery附加一个已有的YAML解析器，比如Diogo Costa开发的，从而让`$.ajax()`能够解析这种格式。

要定义一种新的Ajax数据类型，需要给`$.ajaxSetup()`传递三个参数：accepts、contents和converters。其中，accepts属性会添加发送到服务器的头部信息，声明我们的脚本可以理解的特定MIME类型；contents属性处理数据交换的另一方，它提供一个与响应的MIME类型进行匹配的正则表达式，以尝试自动检测这个元数据当中的数据类型。最后，converters中包含解析返回数据的函数。

`$.ajax()`读取了一个YAML文件并将数据库声明为yaml。因为到来的数据会按照text格式解析，jQuery需要一种机制能把一种数据类型转换为另一种数据类型。converters的'text yaml'告诉jQuery，这个转换函数以text格式接收数据，然后以yaml格式重新解析。在转换函数内部，我们把文本内容记录到控制台中，以便验证这个函数能够被正确调用。要实际地执行转换，需要加载第三方的YAML解析库（yaml.js）并调用其方法。

这里要注意的是，在插入类别名的时候，需要把相应的代码放在`$(doucment).ready()`调用中。Ajax操作可能会立即运行，无需访问DOM，但当结果返回后，必须等到DOM可用才能继续操作。以这种方式来编写代码，可以让它尽可能早地运行，从而增强用户对页面加载时间的感知速度。

```

```

```
$(document).on('click', '#categories a', function(event) {
```

```
  event.preventDefault();
```

```
  $(this).parent().toggleClass('active')
```

```
    .siblings('.active').removeClass('active');
```

```
  $('#ajax-form').triggerHandler('submit');
```

```
});
```

通过把click处理程序绑定到文档并使用事件委托，可以避免某些耗时的重复性操作。而且，可以马上运行这些代码，而不必等待Ajax调用完成。

### 13.5.2 Ajax预过滤器

通过`$.ajaxPrefilter()`函数可以添加预过滤器。所谓预过滤器，就是一些回调函数，它们可以在发送请求之前对请求进行过滤。预过滤器会在`$.ajax()`修改或使用它的任何选项之前调用，因此通过预过滤器可以修改这些选项或基于新的、自定义选项发送请求。

预过滤器通过返回要使用的数据类型，也可以操作请求的数据类型。

### 13.5.3 替代传输方式

jQuery在适当的时候会使用XMLHttpRequest、ActiveX或``标签来处理Ajax事务。可扩展这种传输（transport）机制。

这种传输机制依赖于一个对象来实际地负责Ajax数据的传输。新的传输对象定义为工厂函数，返回一个带有`.send()`和`.abort()`方法的对象。其中，.send()方法负责发送请求、处理响应并把数据发送给回调函数。而`.abort()`方法会立即停止请求。

可以使加载图像的处理方式会与其他Ajax请求的处理方式相同，这样会让代码在内部更好地保持一致。

在定义传输对象时，首先需要向`$.ajaxTransport()`传入一个数据类型。这是告诉jQuery什么时候该使用我们的传输方式，而不是使用内置的机制。然后，再提供一个函数，该函数能够返回带有相应的`.send()`和`.abort()`方法的新传输对象。

对这个img传输对象，`.send()`方法需要创建一个新的``元素，并为它设置src特性。这个特性的值来自settings.url，是由jQuery通过$.ajax()调用传入的。浏览器在创建这个``元素时，会加载引用的图像文件，因此在这里需要检查什么时候加载完成，然后触发完成回调函数。

在检测到图像加载完成后（可能成功、完成，也可能出错），调用callback()函数，callback()函数再调用传递给`.send()`的complete()函数。这样，`$.ajax()`就能对图像的加载给出响应。

对于停止加载的处理就要简单多了。这里的.abort()方法要做的就是一些清理工作，它只需要在创建了``元素的情况下把该元素删除即可。

要使用自定义的传输机制，需要给`$.ajax()`提供一个对应的dataType值。

## 13.6小结

学习了如何在页面中营造更加流畅的用户体验，如何根据需要获取外部资源，同时也关注了错误处理、缓存以及截流等技术。随后，我们又学习了Ajax框架的内部运行机制，包括承诺、传输、预先筛选和转换器。最后还学习了如何根据我们的需求扩展传输机制。

# 附录 A  JavaScript闭包

本附录将探讨如此内容：

- JavaScript在其他函数中定义函数的能力；
- 传递函数对象的方式；
- 在函数内部和外部定义的变量的作用域；
- 由变量作用域及闭包导致的常见问题；
- 在jQuery中使用函数；
- 函数交互导致的内存问题。

## A.1 创建内部函数

JavaScript支持内部函数声明。

支持内部函数的语言，则允许开发者在必要的地方集合小型实用函数，以避免污染命名空间。所谓内部函数，就是定义在另一个函数中的函数。

在outerFn()内部调用innerFn()是有效的，而在outerFn()外部调用innerFn()则是无效的。

```

```

```
//js错误
```

```
function outerFn() { 
```

```
  console.log('Outer function'); 
```

```
  function innerFn() { 
```

```
    console.log('Inner Function'); 
```

```
  } 
```

```
} 
```

```
console.log('innerFn():'); 
```

```
innerFn(); 
```

这种技术特别适合于小型、单用途的函数。例如，递归但却带有非递归API包装的算法通常最适合通过内部函数来表达。

### A.1.1 在任何地方调用内部函数

JavaScript允许开发人员像传递任何类型的数据一样传递函数。也就是说，JavaScript中的内部函数能够逃脱定义它们的外部函数。

逃脱的方式有很多种。例如，可以将内部函数指定给一个全局变量：

```

```

```
var globalVar; 
```

```
function outerFn() { 
```

```
  console.log('Outer function'); 
```

```
  function innerFn() { 
```

```
    console.log('Inner function'); 
```

```
  } 
```

```
  globalVar = innerFn; 
```

```
} 
```

```
console.log('outerFn():'); 
```

```
outerFn(); 
```

```
console.log('globalVar():'); 
```

```
globalVar(); 
```

注意，此时在outerFn()外部直接调用innerFn()仍然会导致错误！

也可以通过在父函数中返回值来“营救出”内部函数的引用：

```

```

```
function outerFn() { 
```

```
console.log('Outer function'); 
```

```
  function innerFn() { 
```

```
    console.log('Inner function'); 
```

```
  } 
```

```
    return innerFn; 
```

```
} 
```

```
console.log('var fnRef = outerFn():'); 
```

```
var fnRef = outerFn(); 
```

```
console.log('fnRef():'); 
```

```
fnRef(); 
```

这种即使在离开函数作用域的情况下仍然能够通过引用调用内部函数的事实，意味着只要存在调用这些内部函数的可能，JavaScript就需要保留被引用的函数。

而且，JavaScript运行时需要跟踪引用这个内部函数的所有变量，直至最后一个变量废弃，JavaScript的垃圾收集器才能出面释放相应的内存空间。

### A.1.2 理解变量作用域

内部函数当然也可以拥有自己的变量，只不过这些变量都被限制在内部函数的作用域中：内部函数可以像其他函数一样引用全局变量

但是，如果这个变量是父函数的局部变量又会怎样呢

``

```
function outerFn() { 
```

```
  var outerVar = 0; 
```

```
  function innerFn() { 
```

```
    outerVar++; 
```

```
    console.log('outerVar = ' + outerVar); 
```

```
} 
```

```
  return innerFn; 
```

```
} 
```

```

```

```
var fnRef = outerFn(); 
```

```
fnRef(); 
```

```
fnRef(); 
```

```
var fnRef2 = outerFn(); 
```

```
fnRef2(); 
```

```
fnRef2(); 
```

```

```

```
//这一次，对内部函数的调用会产生有意思的行为：
```

```
outerVar = 1 
```

```
outerVar = 2 
```

```
outerVar = 1 
```

```
outerVar = 2 
```

当内部函数在定义它的作用域的外部被引用时，就创建了该内部函数的一个闭包。在这种情况下，我们称既不是内部函数局部变量，也不是其参数的变量为**自由变量**，称外部函数的调用环境为**封闭闭包的环境**。从本质上讲，如果内部函数引用了位于外部函数中的变量，相当于授权该变量能够被延迟使用。因此，当外部函数调用完成后，这些变量的内存不会被释放，因为闭包仍然需要使用它们。

## A.2 处理闭包之间的交互

这在本质上是创建了一个新对象，自由变量就是这个对象的实例变量，而闭包就是这个对象的实例方法。而且，这些变量也是私有的，因为不能在封装它们的作用域外部直接引用这些变量，从而确保了面向对象的数据专有特性。

## A.3 在jQuery中创建闭包

内部函数很容易就会变成闭包。

### A.3.1 `$(document).ready()`的参数

当创建了一个函数并把它传递给`.ready()`之后，这个函数的引用就会被保存为全局jQuery对象的一部分。在稍后的某个时间——当DOM就绪时，这个引用就会被调用。由于我们通常把`$(document).ready()`放在代码结构的顶层，因而这个函数不会成为闭包。但是，我们的代码通常都是在这个函数内部编写的，所以这些代码都处于一个内部函数中。

把大多数jQuery代码都放在一个函数体中是很有用的，因为这样可以避免某些命名空间冲突。例如，正是这个特性可以使我们通过调用`jQuery.noConflict()`为其他库释放简写方式`$`，但我们仍然能够定义在`$(document).ready()`中使用的局部简写方式。

### A.3.2 绑定事件处理程序

`.ready()`结构通常用于包装其他的jQuery代码，包括事件处理程序的赋值。因为处理程序是函数，它们也就变成了内部函数；而且，因为这些内部函数会被保存并在以后调用，于是它们也会创建闭包。

### A.3.3 在循环中绑定处理程序

鉴于闭包的独特运行方式，在循环中绑定处理程序需要一些特殊的技巧。

``

```
$(document).ready(function() {
```

```
  for (var i = 0; i < 5; i++) {
```

```
    $('<div>Print ' + i + '</div>')
```

```
    .click(function() {
```

```
        console.log(i);
```

```
    }).insertBefore('#results');
```

```
  }
```

```
});
```

```
//每个click处理程序最终引用的i都相同，都等于单击事件实际发生时i的最终值（5）。
```

解决这个问题的方式有很多。首先，可以使用jQuery的`$.each()`函数来代替for循环：

```

```

```
$(document).ready(function() {
```

```
  $.each([0, 1, 2, 3, 4], function(index, value) {
```

```
    $('<div>Print ' + value + '</div>')
```

```
    .click(function() {
```

```
        console.log(value);
```

```
    }).insertBefore('#results');
```

```
  });
```

```
});
```

```
//因为函数的参数类似于在函数中定义的变量，所以每次循环的value实际上都是不同的变量。结果，每个click处理程序都指向一个不同的value变量，因而每次单击输出的值会与元素的标签文本匹配。
```

同样利用函数参数的这个特性，不必使用`$.each()`也可以解决这个问题。在for循环内部，可以定义并执行一个新函数，让它负责把变量i的值分配到不同的变量中去：

``

```
$(document).ready(function() {
```

```
  for (var i = 0; i < 5; i++) {
```

```
    (function(value) {
```

```
      $('<div>Print ' + value + '</div>')
```

```
      .click(function() {
```

```
        console.log(value);
```

```
      }).insertBefore('#results');
```

```
    })(i);
```

```
  }
```

```
});
```

```
//它的名字叫立即调用的函数表达式（IIFE），前面曾在调用$.noConflict()之后利用它为jQuery对象重新定义别名$。
```

最后，还可以使用jQuery的事件系统换个角度来解决这个问题。我们知道，`.on()`方法接受一个对象参数，该参数以`event.data`的形式传入事件处理程序中：

```

```

```
$(document).ready(function() {
```

```
  for (var i = 0; i < 5; i++) {
```

```
    $('<div>Print ' + i + '</div>')
```

```
    .on('click', {value: i}, function(event) {
```

```
        console.log(event.data.value);
```

```
    }).insertBefore('#results');
```

```
  }
```

```
});
```

```
//因为event是函数的参数，每次调用处理程序时它都是一个独立的实例，而不是在所有调用中共享的一个值。
```

### A.3.4 命名及匿名函数

无论命名函数还是匿名函数，都可以用来创建闭包。

```
$(document).ready(function() {
```

```
  $('input').each(function(index) {
```

```
    $(this).click(function(event) {
```

```
      event.preventDefault();
```

```
      console.log('index = ' + index);
```

```
    });
```

```
  });
```

```
});
```

## A.4 应对内存泄漏的风险

JavaScript使用一种称为垃圾收集的技术来管理分配给它的内存。JavaScript是一种高级语言，它一般是通过后台来维护这种引用计数系统。

### A.4.1 避免意外的引用循环

闭包可能会导致在不经意间创建引用循环。

``

```
function outerFn() {
```

```
  var outerVar = {};
```

```
  function innerFn() {
```

```
    console.log(outerVar);
```

```
  }
```

```
  outerVar.fn = innerFn;
```

```
  return innerFn;
```

```
};
```

```

```

```
function outerFn() {
```

```
  var outerVar = {};
```

```
  function innerFn() {
```

```
    console.log('hello');
```

```
  }
```

```
  outerVar.fn = innerFn;
```

```
  return innerFn;
```

```
};
```

```
//即使innerFn()不再引用outerVar，outerVar也仍然位于innerFn()的封闭环境中。由于闭包的原因，位于outerFn()中的所有变量都隐含地被innerFn()所引用
```

### A.4.2 控制DOM与JavaScript的循环

上述这些情况通常不是什么问题，因为JavaScript能够检测到这些情况并在它们孤立时将其清除。

然而，旧版本IE中存在一种难以处理的引用循环问题。当一个循环中同时包含DOM元素和常规JavaScript对象时，IE无法释放任何一个对象——因为这两类对象是由不同的内存管理程序负责管理的。换句话说，除非关闭浏览器，否则这种循环在IE中永远得不到释放。

导致这种循环的一个常见原因是简单的事件处理

``

```
$(document).ready(function() {
```

```
  var button = document.getElementById('button-1');
```

```
  button.onclick = function() {
```

```
    console.log('hello');
```

```
    return false;
```

```
  };
```

```
});
```

当指定单击事件处理程序时，就创建了一个在其封闭的环境中包含button变量的闭包。而且，现在的button也包含一个指向闭包（onclick属性自身）的引用。这样，就导致了在IE中即使离开当前页面也不会释放这个循环。

为了释放内存，就需要断开循环引用，例如在关闭窗口关删除onclick属性（此时必须注意不要在window及其onunload处理程序间引入新的循环）。另外，也可以**重写代码来避免这种闭包：**

```

```

```
function hello() {
```

```
  console.log('hello');
```

```
  return false;
```

```
}
```

```
$(document).ready(function() {
```

```
  var button = document.getElementById('button-1');
```

```
  button.onclick = hello;
```

```
});
```

```
//因为hello()函数不再包含button，引用就成了单向的（从button到hello）、不存在循环，所以就不会造成内存泄漏了。
```

**用jQuery化解引用循环**

```
$(document).ready(function() {
```

```
  var $button = $('#button-1');
```

```
  $button.click(function(event) {
```

```
    event.preventDefault();
```

```
    console.log('hello');
```

```
  });
```

```
});
```

jQuery会手动释放自己指定的所有事件处理程序。只要坚持使用jQuery的事件绑定方法，就无需为这种特定的常见原因导致的内存泄漏而担心。

但是，只要是将JavaScript对象指定给DOM元素，就可能在旧版本IE中导致内存泄漏。jQuery只是有助于减少发生这种情况的可能性。

有鉴于此，jQuery为我们提供了另一个避免这种泄漏的工具。使用`.data()`方法可以像使用**扩展属性（expando）**一样，将信息附加到DOM元素。由于这里的数据并非直接保存在扩展属性中（jQuery使用一个内部对象并通过它创建的ID来保存这里所说的数据），因此永远也不会构成引用循环，从而有效回避了内存泄漏问题。无论什么时候，当我们觉得扩展属性好像是一种方便的数据存储机制时，都应该首选`.data()`这种更安全可靠的替代方案。

## A.5 小结

JavaScript闭包是一种强大的语言特性。通过使用这个语言特性来隐藏变量，可以避免覆盖其他地方使用的同名变量。由于jQuery经常依赖于把函数作为方法的参数，所以在编写jQuery代码时也会经常在不经意间创建闭包。理解闭包有助于编写出更有效也更简洁的代码，如果再加上一些小心并利用好jQuery内置的安全措施，则可以有效地防止闭包可能引发的内存泄漏问题。

# 附录B 使用QUnit测试JavaScript

## B.1 下载QUnit

可以在官方网站下载QUnit框架，地址为：[http://qunitjs.com/](http://qunitjs.com/)。

## B.2 设置文档

下载了QUnit文件之后，接下来要设置HTML测试文档。在典型的项目中，这个文件叫index.html，而且与qunit.js和qunit.css放在相同的测试文件夹中。不过，我们这里把这个测试文件放在一个父目录中。

这个文档的``元素中包含一个``标签，用于链接CSS文件；还包含几个``标签，用于加载jQuery、QUnit、要测试的JavaScript文件（B.js），以及测试文件（test/test.js）。文档的``标签中包含两个主要元素，每个元素的ID将由QUnit用来运行测试和显示结果。

## B.3 组织测试

QUnit提供两个级别的分组，分别以它们的函数调用命名：module()和test()。其中，module类似于通用的类别，测试将在该类别下运行；而test实际上是一组接收回调函数的测试，在这些回调函数中运行相应测试的特定单元测试。

在这里，我们要把测试按照每一章的主题组织起来，把代码放到test/test.js文件中：

```
module('Selecting');
```

```
test('Child Selector', function() {
```

```
  ok(true, 'Placeholder is entered');
```

```
});
```

```
test('Attribute Selectors', function() {
```

```
  ok(true, 'Placeholder is entered');
```

```
});
```

```
module('Ajax');
```

虽然不一定非要把测试文件按照这个测试结构来组织，但最好还是对整个结构有一个大致的概念。除了module()和test()之外，我们还在每个测试中插入了一个断言占位语句。即便有一个断言测试失败，QUnit都会抛出错误。

因为QUnit默认会在文档加载完成之后才会运行测试，所以我们的模块还有测试都不需要放在`$(document).ready()`调用中。

## B.4 添加和运行测试

在测试驱动的开发中，需要在编写代码之前编写测试。这样一来，在看到测试失败之后，开始添加新的代码，然后再让测试通过，验证新代码实现了应有的功能。

首先，我们来测试第2章用到的子选择符，为``的所有子元素``添加horizontal类：

```
test('Child Selector', function() {
```

```
  expect(1);
```

```
  var topLis = $('#selected-plays > li.horizontal');
```

```
  equal(topLis.length, 3, 'Top LIs have horizontal class');
```

```
});
```

这里实际上加入了两个测试。第一个是expect()测试，它告诉QUnit我们想在这个测试集中运行多少个测试。然后，因为我们想要测试在页面中选择元素的能力，所以使用equal()测试来比较顶级``元素与数值3。如果这两个值相等，测试通过且通过的次数会加1。

另一种测试方式：ok()。这个测试接收两个参数：一个应该被求值为true的表达式和一个描述。module()接收可选的第二个参数，这个参数是一个对象，可以包含setup()和teardown()函数。在这两个函数中，可以使用this关键字为模块中的所有测试一次性地指定变量。

ok()测试和equal()测试失败时不同的输出。前者只显示测试的标签和来源，后者还会详细列出期待的结果。鉴于equal()比ok()提供的测试失败的细节更多，因此应该优先使用它。

#### **异步测试**

测试异步JavaScript，比如Ajax请求，核心在于当异步测试开始时，测试必须暂停；而当异步请求完成时，测试必须恢复。这种情况我们还是比较熟悉的，在效果队列、Ajax回调函数以及承诺对象中，都存在这种异步操作。在QUnit中，我们要使用一个特殊的测试集，它的名字叫asyncTest()。这个测试集与常规的test()测试集很相似；不同的是，在我们调用一个特殊的start()函数恢复它们之前，它们会暂停运行。

```
asyncTest('JSON', function() {
```

```
  expect(2);
```

```
  var backbite = {
```

```
    "term": "BACKBITE",
```

```
    "part": "v.t.",
```

```
    "definition": "To speak of a man as you find him when he can't find you."
```

```
  };
```

```
  $.getJSON('b.json', function(json, textStatus) {
```

```
    equal(textStatus, 'success', 'Request successful');
```

```
    deepEqual(json[1], backbite,
```

```
    'result array matches "backbite" map');
```

```
  }).always(function() {
```

```
    start();
```

```
  });
```

```
});
```

为了测试响应的值，这里又使用了一个函数：deepEqual()。正常情况下，在比较两个对象时，除非它们引用的是相同的内存地址，否则不会判定它们相等。但如果我们想比较的是它们的内容，那么使用deepEqual()很合适。这个函数会遍历两个对象，确保它们拥有相同的属性，而且每个属性都有相同的值。

## B.5 其他测试类型

QUnit也提供了其他一些测试函数。有一些函数，比如notEqual()和notDeepEqual()只不过是我们用过的函数的逆运算，而另外一些函数，比如strictEqual()和throws()则具有更加特定的用途。

## B.6 最佳实践

在测试通过但仍然出现错误的情况下，正确的反应不是立即修复问题，而是首先针对失败的行为编写一个新测试。这样一来，不仅可以验证在修复代码之后是否解决了问题，而且也添加了一个可以在将来避免回归的测试。

除了进行单元测试之外，QUnit还可以用于**功能测试**。单元测试主要是为了验证代码单元（方法和函数）的操作是否正确，而功能测试则是为了确保用户输入能够在界面上得到响应。

> 可以将dominator.js（[http://mwbrooks.github.io/dominator.js/](http://mwbrooks.github.io/dominator.js/)）和FuncUnit（[http://funcunit.com/](http://funcunit.com/)）等功能测试框架与QUnit一起使用，从而简化编写功能测试和模拟事件的工作。如果想在不同浏览器中实现自动化测试，可以再选择Selenium（[http://seleniumhq.org](http://seleniumhq.org)）等专用的功能测试框架。

## B.7 小结

通过测试小型、具体的代码单元，可以在项目变复杂的时候减少很多问题。与此同时，还可以更加有效地对整个项目进行回归测试，从而节省大量宝贵的开发时间。

# 附录C 简明参考

## C.1 选择符表达式

### C.1.1 简单的CSS选择符

| 选  择  符 | 匹 配                |
| ------- | ------------------ |
| *       | 所有元素               |
| #id     | 带有给定ID的元素          |
| element | 给定类型的所有元素          |
| .class  | 带有给定类的所有元素         |
| a, b    | 与a或b匹配的元素          |
| a b     | 作为a后代的b匹配的元素       |
| a > b   | 作为a子元素的b匹配的元素      |
| a + b   | 作为a后面直接同辈元素的b匹配的元素 |
| a ~ b   | 作为a后面同辈的b匹配的元素     |

### C.1.2 在同辈元素间定位

| 选  择  符             | 匹 配                                      |
| ------------------- | ---------------------------------------- |
| :nth-child(index)   | 作为其父元素第index个子元素的元素（从1开始计数）              |
| :nth-child(even)    | 作为其父元素第偶数个子元素的元素（从1开始计数）                 |
| :nth-child(odd)     | 作为其父元素第奇数个子元素的元素（从1开始计数）                 |
| :nth-child(formula) | 作为其父元素第n个子元素的元素（从1开始计数）。formula（公式）的格式为an+b，a、b为整数 |
| :nth-last-child()   | 与:nth-child()相同，只不过是从最后一个元素开始倒计数         |
| :first-child        | 作为其父元素第一个子元素的元素                          |
| :last-child         | 作为其父元素最后一个子元素的元素                         |
| :only-child         | 作为其父元素唯一一个子元素的元素                         |
| :nth-of-type()      | 与:nth-child()相同，只不过只计相同元素                |
| :nth-last-of-type() | 与:nth-of-type()相同，只不过是从最后一个元素开始倒计数       |
| :first-of-type      | 同名的同辈元素中的第一个元素                           |
| :last-of-type       | 同名的同辈元素中的最后一个元素                          |
| :only-of-type       | 没有同名的同辈元素的元素                             |

### C.1.3 在匹配的元素间定位

| 选  择  符    | 匹 配                              |
| ---------- | -------------------------------- |
| :first     | 结果集中的第一个元素                       |
| :last      | 结果集中的最后一个元素                      |
| :not(a)    | 结果集中与a不匹配的所有元素                   |
| :even      | 结果集中的偶数元素（从0开始计数）                |
| :odd       | 结果集中的奇数元素（从0开始计数）                |
| :eq(index) | 结果集中索引为index的元素（从0开始计数）          |
| :gt(index) | 结果集中所有位于给定索引之后（大于该索引）的元素（从0开始计数） |
| :lt(index) | 结果集中所有位于给定索引之前（小于该索引）的元素（从0开始计数） |

### C.1.4 属性

| 选  择  符          | 匹 配                                    |
| ---------------- | -------------------------------------- |
| [attr]           | 带有属性attr的元素                            |
| [attr="value"]   | attr属性的值为value的元素                      |
| [attr!="value"]  | attr属性的值不为value的元素                     |
| [attr^="value"]  | attr属性的值以value开头的元素                    |
| [attr$="value"]  | attr属性的值以value结尾的元素                    |
| [attr*="value"]  | attr属性的值包含子字符串value的元素                 |
| [attr~="value"]  | attr属性的值是空格分隔的多个字符串，其中一个字符串的值为value的元素 |
| [attr\|="value"] | attr属性的值等于value或者以value开头后跟一个连字符的元素    |

#### C.1.5 表单

| 选  择  符   | 匹 配                     |
| --------- | ----------------------- |
| :input    | 所有``、``、``和``元素         |
| :input    | 所有``、``、``和``元素         |
| :password | type="password"的``元素    |
| :file x   | type="file"的``元素        |
| :radio    | type="radio"的``元素       |
| :checkbox | type="checkbox"的``元素    |
| :submit   | type="submit"的``元素      |
| :image    | type="image"的``元素       |
| :reset    | type="reset"的``元素       |
| :button   | type="button"的``元素及``元素 |
| :enabled  | 启用的表单元素                 |
| :disabled | 禁用的表单元素                 |
| :checked  | 选中的复选框和单选按钮元素           |
| :selected | 选中的``元素                 |

### C.1.6 其他自定义选择符

| 选  择  符         | 匹 配                              |
| --------------- | -------------------------------- |
| :root           | 文档的根元素                           |
| :header         | 标题元素（如``、``）                     |
| :animated       | 其动画正在播放的元素                       |
| :contains(text) | 包含给定文本text的元素                    |
| :empty          | 不包含子节点的元素                        |
| :has(a)         | 后代元素中至少有一个与a匹配的元素                |
| :parent         | 包含子节点的元素                         |
| :hidden         | 隐藏的元素，包括通过CSS隐藏的元素及``            |
| :visible        | 与:hidden匹配的元素相反                  |
| :focus          | 获得键盘焦点的元素                        |
| :lang(language) | 具有给定（在元素的lang属性或``标签中声明的）语言代码的元素 |
| :target         | URI标识符指向的目标元素                    |

## C.2 DOM遍历方法

### C.2.1 筛选元素

| 遍历方法                 | 返回的jQuery对象中包含          |
| -------------------- | ----------------------- |
| .filter(selector)    | 与给定的选择符selector匹配的选中元素  |
| .filter(callback)    | 回调函数callback返回true的选中元素 |
| .eq(index)           | 从0开始计数的第index个选中元素      |
| .first()             | 选中元素中的第一个元素             |
| .last()              | 选中元素中的最后一个元素            |
| .slice(start, [end]) | 从0开始计数的给定范围内的选中元素       |
| .not(selector)       | 选中元素中与给定选择符不匹配的元素       |
| .has(selector)       | 选中元素中有后代匹配给定选择符的元素      |

### C.2.2 后代元素

| 遍历方法                  | 返回的jQuery对象中包含              |
| --------------------- | --------------------------- |
| .find(selector)       | 与给定选择符selector匹配的后代元素       |
| .contents()           | 子节点（包括文本节点）                 |
| .children([selector]) | 子节点，可以传入可选的选择符selector进一步筛选 |

### C.2.3 同辈元素

| 遍历方法                            | 返回的jQuery对象中包含                           |
| ------------------------------- | ---------------------------------------- |
| .next([selector])               | 每个选中元素紧邻的下一个同辈元素，可以传入可选的选择符selector进一步筛选 |
| .nextAll([selector])            | 每个选中元素之后的所有同辈元素，可以传入可选的选择符selector进一步筛选  |
| .nextUntil([selector],[filter]) | 每个选中元素之后、直至但不包含第一个匹配selector元素的同辈元素，可以传入可选的选择符filter进一步筛选 |
| .prev([selector])               | 每个选中元素紧邻的上一个同辈元素，可以传入可选的选择符selector进一步筛选 |
| .prevAll([selector])            | 每个选中元素之前的所有同辈元素，可以传入可选的选择符selector进一步筛选  |
| .prevUntil([selector],[filter]) | 每个选中元素之前、直至但不包含第一个匹配selector元素的同辈元素，可以传入可选的选择符filter进一步筛选 |
| .siblings([selector])           | 所有同辈元素，可以传入可选的选择符selector进一步筛选           |

### C.2.4 祖先元素

| 遍历方法                               | 返回的jQuery对象中包含                           |
| ---------------------------------- | ---------------------------------------- |
| .parent([selector])                | 每个选中元素的父元素，可以传入可选的选择符selector进一步筛选       |
| .parents([selector])               | 每个选中元素的所有祖先元素，可以传入可选的选择符selector进一步筛选    |
| .parentsUntil([selector],[filter]) | 每个选中元素的所有祖先元素，直至但不包含第一个匹配selector的祖先元素，可以传入可选的选择符filter进一步筛选 |
| .closest(selector)                 | 与选择符selector匹配的第一个元素，遍历路径从选中元素开始，沿DOM树向上在其中祖先节点中的查找 |
| .offsetParent()                    | 第一个选中元素被定位的父元素（如，通过relative或absolute定位）  |

### C.2.5 集合操作

| 遍历方法                 | 返回的jQuery对象中包含               |
| -------------------- | ---------------------------- |
| .add(selector)       | 选中的元素，加上与给定选择符匹配的元素          |
| .addBack()           | 选中的元素，加上内部jQuery栈中之前选中的那一组元素 |
| .end()               | 内部jQuery栈中之前选中的元素            |
| .map(callback)       | 对每个选中元素调用回调函数callback之后的结果   |
| .pushStack(elements) | 指定的元素                        |

### C.2.6 操作选中的元素

| 遍历方法            | 说 明                        |
| --------------- | -------------------------- |
| .is(selector)   | 确定匹配的元素中是否有传入的选择符匹配的元素     |
| .index()        | 取得匹配元素相对于其同辈元素的索引          |
| .index(element) | 取得匹配元素中与指定元素对应的DOM节点的索引    |
| $.contains(a,b) | 确定DOM节点b是否包含DOM节点a         |
| .each(callback) | 迭代匹配的元素，针对每个元素执行callback函数 |
| .length         | 取得匹配元素的数量                  |
| .get()          | 取得与匹配元素对应的DOM节点的列表         |
| .get(index)     | 取得匹配元素中与指定索引对应的DOM节点       |
| .toArray()      | 取得与匹配元素对应的DOM节点的列表         |

## C.3 事件方法

### C.3.1 绑定

| 事件方法                                     | 说 明                                      |
| ---------------------------------------- | ---------------------------------------- |
| .ready(handler)                          | 绑定在DOM和CSS完全加载后调用的处理程序handler            |
| .on(type, [selector],[data], handler)    | 绑定在给定类型的事件type发送到元素时调用的处理程序handler；如果提供了selector则执行事件委托 |
| .on(events, [selector] , [data])         | 根据events对象中的事件绑定多个事件处理程序                 |
| .off(type, [selector], [handler])        | 解除元素上绑定的处理程序                             |
| .bind(type, [data], handler)             | 绑定在给定类型的事件type发送到元素时调用的处理程序handler；一般都用.on()代替 |
| .one(type, [data], handler)              | 绑定在给定类型的事件type发送到元素时调用的处理程序handler，并在handler被调用后立即解除绑定 |
| .unbind([type], [handler])               | 解除元素上绑定的处理程序（可以指定事件类型或处理程序，不指定则解除所有绑定）   |
| .delegate(selector, type, [data],handler) | 绑定当给定事件发送到与selector匹配的后代元素后调用的处理程序       |
| .delegate(selector, handlers)            | 绑定当给定事件发送到与selector匹配的后代元素后调用的处理程序       |
| .undelegate(selector, type, [handler])   | 解除之前通过.delegate()绑定的到元素上的处理程序            |

### C.3.2 简写绑定

| 事件方法                 | 说  明                               |
| -------------------- | ---------------------------------- |
| .blur(handler)       | 绑定当元素失去键盘焦点时调用的处理程序                |
| .change(handler)     | 绑定当元素的值改变时调用的处理程序                  |
| .click(handler)      | 绑定当元素被单击时调用的处理程序                   |
| .dblclick(handler)   | 绑定当元素被双击时调用的处理程序                   |
| .error(handler)      | 绑定当元素接收到错误事件（取决于浏览器）时调用的处理程序       |
| .focus(handler)      | 绑定当元素获得键盘焦点时调用的处理程序                |
| .focusin(handler)    | 绑定当元素或后代元素获得键盘焦点时调用的处理程序           |
| .focusout(handler)   | 绑定当元素或后代元素失去键盘焦点时调用的处理程序           |
| .keydown(handler)    | 绑定当元素拥有键盘焦点且有键被按下时调用的处理程序          |
| .keypress(handler)   | 绑定当元素拥有键盘焦点且有按键事件发生时调用的处理程序        |
| .keyup(handler)      | 绑定当元素拥有键盘焦点且有键被释放时调用的处理程序          |
| .load(handler)       | 绑定当元素加载完成时调用的处理程序                  |
| .mousedown(handler)  | 绑定当在元素中按下鼠标键时调用的处理程序               |
| .mouseenter(handler) | 绑定当鼠标指针进入元素时调用的处理程序。不受事件冒泡影响       |
| .mouseenter(handler) | 绑定当鼠标指针进入元素时调用的处理程序。不受事件冒泡影响       |
| .mousemove(handler)  | 绑定当在元素中移动鼠标指针时调用的处理程序              |
| .mouseout(handler)   | 绑定当鼠标指针离开元素时调用的处理程序                |
| .mouseover(handler)  | 绑定当鼠标指针进入元素时调用的处理程序                |
| .mouseup(handler)    | 绑定当在元素中释放鼠标键时调用的处理程序               |
| .resize(handler)     | 绑定当调整元素大小时调用的处理程序                  |
| .scroll(handler)     | 绑定当元素的滚动位置改变时调用的处理程序               |
| .select(handler)     | 绑定当元素中的文本被选中时调用的处理程序               |
| .submit(handler)     | 绑定当表单元素被提交后调用的处理程序                 |
| .unload(handler)     | 绑定当元素从内存中被卸载后调用的处理程序               |
| .hover(enter, leave) | 绑定在鼠标进入元素时调用的enter和鼠标离开元素时调用的leave |

### C.3.3 触发事件

| 事件方法                          | 说  明                |
| ----------------------------- | ------------------- |
| .trigger(type, [data])        | 触发元素上的事件并执行该事件的默认操作 |
| .triggerHandler(type, [data]) | 触发元素上的事件，但不执行任何默认操作 |

### C.3.4 简写触发方法

| 事件方法  说 明   |              |
| ----------- | ------------ |
| .blur()     | 触发blur事件     |
| .change()   | 触发change事件   |
| .click()    | 触发click事件    |
| .dblclick() | 触发dblclick事件 |
| .error()    | 触发error事件    |
| .focus()    | 触发focus事件    |
| .keydown()  | 触发keydown事件  |
| .keypress() | 触发keypress事件 |
| .keyup()    | 触发keyup事件    |
| .select()   | 触发select事件   |
| .submit()   | 触发submit事件   |

### C.3.5 实用方法

| 事件方法                | 说 明                |
| ------------------- | ------------------ |
| $.proxy(fn,context) | 创建一个新的在指定上下文中执行的函数 |

## C.4 效果方法

### C.4.1 预定义效果

| 效果方法                                | 说 明                  |
| ----------------------------------- | -------------------- |
| .show()                             | 显示匹配的元素              |
| .hide()                             | 隐藏匹配的元素              |
| .show(speed, [callback])            | 通过高度、宽度及透明度动画显示匹配的元素 |
| .hide(speed, [callback])            | 通过高度、宽度及透明度动画隐藏匹配的元素 |
| .toggle([speed], [callback])        | 显示或隐藏匹配的元素           |
| .slideDown([speed], [callback])     | 以滑入方式显示匹配的元素         |
| .slideUp([speed], [callback])       | 以滑出方式隐藏匹配的元素         |
| .slideToggle([speed], [callback])   | 以滑动方式显示或隐藏匹配的元素      |
| .fadeIn([speed], [callback])        | 以淡入方式显示匹配的元素         |
| .fadeOut([speed], [callback])       | 以淡出方式隐藏匹配的元素         |
| .fadeToggle([speed], [callback])    | 以淡入淡出方式显示或隐藏匹配的元素    |
| .fadeTo(speed, opacity, [callback]) | 调整匹配元素的不透明度          |

### C.4.2 自定义动画

| 效果方法                                     | 说 明                        |
| ---------------------------------------- | -------------------------- |
| .animate(attributes, [speed],[easing], [callback]) | 针对指定的CSS属性执行自定义动画          |
| .animate(attributes, options)            | .animate()的底层接口，支持对动画队列的控制 |

### C.4.3 队列操作

| 效果方法                             | 说  明                          |
| -------------------------------- | ----------------------------- |
| .queue([queueName])              | 取得第一个匹配元素上的动画队列               |
| .queue([queueName],callback)     | 在动画队列的最后添加回调函数                |
| .queue([queueName],newQueue)     | 以新队列替换原队列                     |
| .dequeue([queueName])            | 执行队列中的下一个动画                   |
| .clearQueue([queueName])         | 清除所有未执行的函数                    |
| .stop([clearQueue], [jumpToEnd]) | 停止当前播放的动画，然后启动排列的动画（如果有）      |
| .finish([queueName])             | 停止当前播放的动画并将所有排队的动画立即提前到它们的目标值 |
| .delay(duration, [queueName])    | 在执行队列中的下一项前等待duration毫秒       |
| .promise([queueName],[target])   | 在集合中所有排队的操作完成后返回一个待解决的承诺对象    |

## C.5 DOM操作方法

### C.5.1 特性与属性

| DOM操作方法             | 说 明                               |
| ------------------- | --------------------------------- |
| .attr(key)          | 取得特性key的值                         |
| .attr(key, value)   | 设置特性key的值为value                   |
| .attr(key, fn)      | 设置特性key的值为fn（基于每个匹配的元素单独调用）返回的结果  |
| .attr(obj)          | 根据传入的键值对参数设置属性的值                 |
| .removeAttr(key)    | 删除特性key                           |
| .prop(key)          | 取得属性key的值                         |
| .prop(key,value)    | 设置属性key的值为value                   |
| .prop(key,fn)       | 将设置属性key的值为fn（基于每个匹配的元素单独调用）返回的结果 |
| .prop(obj)          | 设置属性值，以键值对形式传入                    |
| .removeProp(key)    | 删除属性key                           |
| .addClass(class)    | 为每个匹配的元素添加传入的类                    |
| .removeClass(class) | 从每个匹配的元素中删除传入的类                   |
| .toggleClass(class) | （针对每个匹配的元素）如果传入的类存在则删除该类，否则添加该类   |
| .hasClass(class)    | 如果匹配的元素中至少有一个包含传入的类，则返回true       |
| .val()              | 取得第一个匹配元素的value属性的值               |
| .val(value)         | 设置每个匹配元素的value属性的值为传入的value       |
| .html()             | 取得第一个匹配元素的HTML内容                  |
| .html(value)        | 将每个匹配元素的HTML内容设置为传入的value         |
| .text()             | 取得所有匹配元素的文本内容，返回一个字符串             |
| .text(value)        | 设置每个匹配元素的文本内容为传入的value            |

### C.5.2 内容

| DOM操作方法      | 说 明                       |
| ------------ | ------------------------- |
| .html()      | 取得第一个匹配元素的HTML内容          |
| .html(value) | 将每个匹配元素的HTML内容设置为传入的value |
| .text()      | 取得所有匹配元素的文本内容，返回一个字符串     |
| .text(value) | 设置每个匹配元素的文本内容为传入的value    |

### C.5.3 CSS

| DOM操作方法          | 说 明                   |
| ---------------- | --------------------- |
| .css(key)        | 取得CSS属性key的值          |
| .css(key, value) | 设置CSS属性key的值为传入的value |
| .css(obj)        | 根据传入的键值对参数设置CSS属性的值   |

### C.5.4 尺寸

| DOM操作方法                     | 说 明                                      |
| --------------------------- | ---------------------------------------- |
| .offset()                   | 取得第一个匹配元素相对于视口的上、左坐标值（单位：像素）             |
| .position()                 | 取得第一个匹配元素相对于.offsetParent()返回元素的上、左坐标值（单位：像素） |
| .scrollTop()                | 取得第一个匹配元素的垂直滚动位置                         |
| .scrollTop(value)           | 设置每个匹配元素的垂直滚动位置为传入的value                 |
| .scrollLeft()               | 取得第一个匹配元素的水平滚动位置                         |
| .scrollLeft(value)          | 设置每个匹配元素的水平滚动位置为传入的value                 |
| .height()                   | 取得第一个匹配元素的高度                             |
| .height(value)              | 设置每个匹配元素的高度为传入的value                     |
| .width()                    | 取得第一个匹配元素的宽度                             |
| .width(value)               | 设置每个匹配元素的宽度为传入的value                     |
| .innerHeight()              | 取得第一个匹配元素的包含内边距但不包含边框的高度                 |
| .innerWidth()               | 取得第一个匹配元素的包含内边距但不包含边框的宽度                 |
| .outerHeight(includeMargin) | 取得第一个匹配元素的包含内边距、边框及可选的外边距的高度             |
| .outerWidth(includeMargin)  | 取得第一个匹配元素的包含内边距、边框及可选的外边距的宽度             |

### C.5.5 插入

| DOM操作方法                 | 说 明                            |
| ----------------------- | ------------------------------ |
| .append(content)        | 在每个匹配元素内部的末尾插入content          |
| .appendTo(selector)     | 将匹配的元素插入到selector选择符匹配的元素内部的末尾 |
| .prepend(content)       | 在每个匹配元素内部的开头插入content          |
| .prependTo(selector)    | 将匹配的元素插入到selector选择符匹配的元素内部的开头 |
| .after(content)         | 在每个匹配元素的后面插入content            |
| .insertAfter(selector)  | 将匹配的元素插入到selector选择符匹配的元素的后面   |
| .before(content)        | 在每个匹配元素的前面插入content            |
| .insertBefore(selector) | 将匹配的元素插入到selector选择符匹配的元素的前面   |
| .wrap(content)          | 将匹配的每个元素包装在content中            |
| .wrapAll(content)       | 将匹配的每个元素作为一个单元包装在content中      |
| .wrapInner(content)     | 将匹配的每个元素内部的内容包装在content中       |

### C.5.6 替换

| DOM操作方法               | 说 明                       |
| --------------------- | ------------------------- |
| .replaceWith(content) | 将匹配的元素替换为content          |
| .replaceAll(selector) | 将selector选择符匹配的元素替换为匹配的元素 |

### C.5.7 删除

| DOM操作方法             | 说 明                                      |
| ------------------- | ---------------------------------------- |
| .empty()            | 删除每个匹配元素的子节点                             |
| .remove([selector]) | 从DOM中删除匹配的节点，也可以通过selector选择符筛选          |
| .detach([selector]) | 从DOM中删除匹配的节点，也可以通过selector选择符筛选，但保留jQuery给它们添加的数据 |
| .unwrap()           | 删除元素的父元素                                 |

### C.5.8 复制

| DOM操作方法                                  | 说 明                     |
| ---------------------------------------- | ----------------------- |
| .clone([withHandlers],[deepWithHandlers]) | 返回所有匹配元素的副本，也可以复制事件处理程序 |

### C.5.9 数据

| DOM操作方法           | 说 明                        |
| ----------------- | -------------------------- |
| .data(key)        | 取得与第一个匹配元素关联的key键的数据项      |
| .data(key, value) | 设置与每个匹配元素关联的key键的数据项为value |
| .removeData(key)  | 移除与每个匹配元素关联的key键的数据项       |

## C.6 Ajax方法

### C.6.1 发送请求

| Ajax方法                                   | 说 明                                     |
| ---------------------------------------- | --------------------------------------- |
| $.ajax([url], options)                   | 使用传入的options生成一次Ajax请求。这是一个通常由其他便       |
| .load(url, [data], [callback])           | 向传入的url生成一次Ajax请求，然后将响应放在匹配的元素中         |
| $.get(url, [data], [callback], [returnType]) | 使用GET方法向传入的url生成一次Ajax请求                |
| $.getJSON(url, [data], [callback])       | 向传入的url生成一次Ajax请求，并且将响应作为JSON数据结构解析     |
| $.getScript(url, [callback])             | 向传入的url生成一次Ajax请求，并且将响应作为JavaScript脚本执行 |
| $.post(url, [data], [callback], [returnType]) | 使用POST方法向传入的url生成一次Ajax请求               |

### C.6.2 监视请求

| Ajax方法                 | 说 明                                  |
| ---------------------- | ------------------------------------ |
| .ajaxComplete(handler) | 绑定当任意Ajax事务完成后调用的处理程序                |
| .ajaxError(handler)    | 绑定当任意Ajax事务发生错误时调用的处理程序              |
| .ajaxSend(handler)     | 绑定当任意Ajax事务开始时调用的处理程序                |
| .ajaxStart(handler)    | 绑定当任意Ajax事务开始但没有其他Ajax事务活动时调用的处理程序   |
| .ajaxStop(handler)     | 绑定当任意Ajax事务结束但没有其他Ajax事务还在活动时调用的处理程序 |
| .ajaxSuccess(handler)  | 绑定当任意Ajax事务成功完成时调用的处理程序              |

### C.6.3 配置

| Ajax方法                                | 说 明                             |
| ------------------------------------- | ------------------------------- |
| $.ajaxSetup(options)                  | 为后续的Ajax事务设置默认选项                |
| $.ajaxPrefilter([dataTypes], handler) | 在$.Ajax()处理每个请求之前，修改每个Ajax请求的选项 |
| $.ajaxTransport(transportFunction)    | 为Ajax事务定义一个新的传输机制               |

### C.6.4 实用方法

| Ajax方法             | 说 明                        |
| ------------------ | -------------------------- |
| .serialize()       | 将一组表单控件的值编码为一个查询字符串        |
| .serializeArray()  | 将一组表单控件的值编码为一个JSON数据结构     |
| $.param(obj)       | 将任意值的对象编码为一个查询字符串          |
| $.globalEval(code) | 在全局上下文中求值给定的JavaScript字符串  |
| $.parseJSON(json)  | 将给定的JSON字符串转换为JavaScript对象 |
| $.parseXML(xml)    | 将给定的XML字符串转换为XML文档         |
| $.parseHTML(html)  | 将给定的HTML字符串转换为DOM元素        |

## C.7 延迟方法

### C.7.1 创建对象

| 函 数                         | 说 明                       |
| --------------------------- | ------------------------- |
| $.Deferred([setupFunction]) | 返回一个新的延迟对象                |
| $.when(deferreds)           | 在给定的延迟对象解决了之后返回一个待解决的承诺对象 |

### C.7.2 延迟对象的方法

| 方 法                          | 说 明                                      |
| ---------------------------- | ---------------------------------------- |
| .resolve([args])             | 解决延迟对象并使用给定的参数调用完成回调函数                   |
| .resolveWith(context,[args]) | 解决延迟对象并使用给定的参数调用完成回调函数，同时让关键字this引用回调函数中的context |
| .reject([args])              | 拒绝延迟对象并使用给定的参数调用失败回调函数                   |
| .rejectWith(context,[args])  | 拒绝延迟对象并使用给定的参数调用失败回调函数，同时让关键字this引用回调函数中的context |
| .notify([args])              | 执行progress回调                             |
| .notifyWith(context, [args]) | 执行progress回调并将关键字this设定为引用context        |
| .promise([target])           | 返回与当前延迟对象对应的承诺对象                         |

### C.7.3 承诺对象的方法

| 方 法                                | 说 明                                      |
| ---------------------------------- | ---------------------------------------- |
| .done(callback)                    | 当对象被解决之后调用callback                       |
| .fail(callback)                    | 当对象被拒绝之后调用callback                       |
| .always([callback])                | 当对象被解决或被拒绝之后调用callback                   |
| .then(doneCallbacks,failCallbacks) | 当对象被解决之后调用doneCallbacks，或在对象被拒绝之后调用failCallbacks |
| .progress(callback)                | 当对象每次接收到进度通知时就执行callback                 |
| .isRejected()                      | 如果对象被拒绝了，返回true                          |
| .isResolved()                      | 如果对象被解决了，返回true                          |
| .state()                           | 根据当前状态运行'pending'、'resolved'或'rejected'  |
| .pipe([doneFilter],[failFilter])   | 返回一个新的承诺对象，该对象在原始承诺对象被解决时也会被解决，可选地通过一个函数来进行筛选 |

## C.8 其他方法

### C.8.1 jQuery对象的属性

| 属 性       | 说 明                       |
| --------- | ------------------------- |
| $.support | 返回一个属性对象，表示浏览器是否支持各种特性和标准 |

### C.8.2 数组和对象

| 函 数                               | 说 明                                      |
| --------------------------------- | ---------------------------------------- |
| $.each(collection, callback)      | 迭代遍历集合，针对集合中的每一项执行回调函数                   |
| $.extend(target, addition, ...)   | 扩展target对象，即将后面传入对象的属性添加到这个对象中           |
| $.grep(array, callback, [invert]) | 通过使用回调函数测试来筛选数组                          |
| $.makeArray(object)               | 将对象转换为一个数组                               |
| $.map(array, callback)            | 针对数组中每一项执行回调函数，将返回的结果组织成一个新数组返回          |
| $.inArray(value, array)           | 确定数组array中是否包含值value；如果value没有包含在array中，则返回1 |
| $.merge(array1, array2)           | 合并数组array1和array2                        |
| $.unique(array)                   | 从数组中移除重复的DOM元素                           |

### C.8.3 对象内省

| 函 数                     | 说 明                              |
| ----------------------- | -------------------------------- |
| $.isArray(object)       | 确定object是不是一个数组                  |
| $.isEmptyObject(object) | 确定object是不是空的                    |
| $.isFunction(object)    | 确定object是不是一个函数                  |
| $.isPlainObject(object) | 确定object是不是通过对象字面量或new Object创建的 |
| $.isNumeric(object)     | 确定object是不是数值                    |
| $.isWindow(object)      | 确定object是不是浏览器窗口                 |
| $.isXMLDoc(object)      | 确定object是不是XML节点                 |
| $.type(object)          | 取得object的JavaScript类             |

### C.8.4 其他

| 函 数                       | 说 明                         |
| ------------------------- | --------------------------- |
| $.trim(string)            | 从字符串末尾移除空白符                 |
| $.noConflict([removeALL]) | 向其他库让渡$标识符使用权，恢复使用jQuery标识符 |
| $.noop()                  | 一个什么也不做的函数                  |
| $.now()                   | 返回当前时间，以自纪元时间戳开始到现在的秒数表示    |
| $.holdReady(hold)         | 防止触发ready事件或者释放当前的保留        |