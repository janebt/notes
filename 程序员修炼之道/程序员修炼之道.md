# 程序员修炼之道 #

# 序 #
## 注重实效的程序员有哪些特征 ##
- 早期的采纳者/快速的改编者
- 好奇
- 批判的思考者
- 有现实感
- 多才多艺

> TIP1：Care About Your Craft
> 关心你的几亿

> TIP2：Think!About Your Work
思考！你的工作

## 第1章 注重实效的哲学 ##
### 1 我的源码让猫给吃了 ###
#### 负责 ####
> TIP3：Provide Options,Don't Make Lame Excuses
> 提供各种选择，不要找蹩脚的借口

### 2 软件的熵 ###
> TIP4：Don't Live With Broken Windows
> 不要容忍破窗户

### 3 石头汤和煮青蛙 ###
> TIP5：Be a Catalyst for Change
> 做变化的催化剂

> TIP6：Remember the Big Picture
> 记住大图景

### 4 足够好的软件 ###
#### 让你的用户参与权衡 ####
> TIP7：Make Quality a Requirements Issue
> 使质量成为需求问题

#### 知道何时止步 ####

### 5 你的知识资产 ###
#### 你的知识资产 ####
#### 经营你的资产 ####
- 定期投资
- 多元化
- 管理风险
- 低买高卖
- 重新评估和平衡

> TIP8：Invest Regularly in Your Knowledge Portfolio
> 定期为你的知识资产投资

#### 目标 ####
- 每年至少学习一种新语言
- 每季度阅读一本技术书籍
- 也要阅读非技术书籍
- 上课
- 参加本地用户组织
- 试验不同的环境
- 跟上潮流
- 上网

#### 学习的机会 ####
#### 批判的思考 ####
> TIP9：Critically Analyze What You Read and Hear
> 批判地分析你读到的和听到的

### 6 交流 ###
#### 知道你想要说什么 ####
#### 了解你的听众 ####    
- WISDOM离合诗     
#### 选择时机 ####
#### 选择风格 ####
#### 让文档美观 ####
#### 让听众参与 ####
#### 做倾听者 ####
#### 回复他人 ####
> TIP10：It's Both What You Say and the Way You Say it
> 你说什么和你怎么说同样重要

## 第2章 注重实效的途径 ##
### 7 重复地危害 ###
- 遵循DRY的原则：
    系统中的每一项知识都必须具有单一、无歧义、权威的表示

> TIP11：DRY - Don't Repeat Yourself
> 不要重复你自己

#### 重复时怎么发生的 ####

#### 强加的重复 ####
- 信息的多种表示
- 代码中的文档
    文档与代码
    语言问题

#### 无意的重复 ####
#### 无耐性的重复 ####
#### 开发者之间的重复 ####
> TIP12：Make It Easy to Reuse
> 让复用变得容易

### 8 正交性 ###
#### 正交的好处 ####
> TIP13：Eliminate Effects Between Unrelated Things
> 消除无关事物之间的影响

- 提高生产率
- 降低风险

#### 项目团队 ####
- 偏好从基础设施与应用分离开始

#### 设计 ####
#### 工具箱和库 ####
#### 编码 ####
- 让你的代码保持解耦
- 避免使用全局数据
- 避免编写相似的函数

#### 测试 ####
#### 文档 ####
#### 认同正交性 ####

### 9 可撤销性 ###
#### 可撤销性 ####
> TIP14：There Are No Final Decisions
> 不存在最终决策

#### 灵活的架构 ####

### 10 曳光弹 ###
#### 在黑暗中发光的代码 ####
> TIP15：Use Tracer Bullets to Find the Target
> 用曳光弹找到目标

- 曳光弹代码方法优点：
    用户能够及早看到能工作的东西
    开发者构建了一个他们能在其中工作的结构
    你有了一个集成平台
    你有了可用于演示的东西
    你将更能够感觉到工作进展

#### 曳光弹并非总能击中目标 ####
#### 曳光代码 vs 原型制作 ####

### 11 原型与便签 ###
#### 应制作原型的事物 ####
- 架构
- 已有系统中的新功能
- 外部数据的结构或内容
- 第三方工具或组件
- 性能问题
- 用户界面设计

> TIP16：Prototype to Learn
> 为了学习而制作原型

#### 怎样使用原型 ####
- 可以忽略细节：
    正确性
    完整性
    健壮性
    风格

#### 制作架构原型 ####
- 一些可在架构原型中寻求解答的具体问题：
    主要组件的责任是否得到了良好定义？是否恰当？
    主要组件间的协作是否得到了良好定义？
    耦合是否得以最小化？
    你能否确定重复的潜在来源？
    接口定义和各项约束是否可接受？
    每个模块在执行过程中是否能访问到其所需的数据？是否能在需要时进行访问？

#### 怎样“不”使用原型 ####

### 12 领域语言 ###
> TIP17：Program Close to the Problem domain
> 靠近问题领域编程

#### 实现小型语言 ####
#### 数据语言与命令语言 ####
#### 独立语言与嵌入式语言 ####
#### 易于开发还是易于维护 ####

### 13 估算 ###
> TIP18：Estimate to Avoid Suprises
> 估算，以避免发生意外

#### 多准确才足够准确 ####
#### 估算来自哪里 ####
- 理解提问内容
- 建立系统的模型
- 把模型分解为组件
- 给每个参数指定值
- 计算答案
- 追踪你的估算能力

#### 估算项目进度 ####
- 检查需求
- 分析风险
- 设计、实现、集成
- 向用户确认

> TIP19：Iterate the Schedule with the Code
> 通过代码对进度表进行迭代

#### 在被要求进行估算时说什么 ####

## 第3章 基本工具 ##
### 14 纯文本的威力 ###
> TIP20：Keep Knowledge in Plain Text
> 用纯文本保存知识

#### 文本的威力 ####
- 保证不过时
- 杠杆作用
- 更易于测试

### 15 shell游戏 ###
> TIP21：Use the Power of Command Shells
> 利用命令shell的力量

### 16 强力编辑 ###
> TIP22：Use a Single Editor Well
> 用好一种编辑器

### 17 源码控制 ###
> TIP23：Always Use Source Code Control
> 总是使用源码控制

### 18 调试 ###
> TIP24：Fix the Problem，Not the Blame
> 要修正问题，而不是发出指责

> TIP25：Don't Panic
> 不要恐慌

#### 从何处开始 ####
#### 测试策略 ####
- 使你的数据可视化
- 跟踪
- 橡皮鸭
- 消除过程

> TIP26："Select" Isn't Broken
> "Select"没有问题

#### 造成惊讶的要素 ####
> TIP27：Don't Assume it - Prove it
> 不要假定，要证明

#### 调试检查列表 ####

### 19 文本操纵 ###
> TIP28：Learn a Text Manipulation Language
> 学习一种文本操纵语言

### 20 代码生成器 ###
> TIP29：Write Code That Writes Code
> 编写能编写代码的代码

#### 被动代码生成器 ####
#### 主动代码生成器 ####
#### 代码生成不一定要很复杂 ####
#### 代码生成器不一定要生成代码 ####

## 第4章 注重实效的偏执 ##
> TIP30：You Can't Write Perfect Software
> 你不可能写出完美的软件

### 21 按合约设计 ###
#### DBC ####
- 前条件
- 后条件
- 类不变项
- 如果调用者满足了例程的所有前条件，例程应该保证在其完成时，所有后条件和不变项将为真

> TIP31：Design with Contracts
> 通过合约进行设计

#### 实现DBC ####
- 断言
- 语言支持

#### DBC与早崩溃 ####
#### 不变项的其他用法 ####
- 循环不变项
- 语义不变项

#### 动态合约与代理 ####

### 22 死程序不说谎 ###
> TIP32：Crash Early
> 早崩溃

#### 要崩溃。不要破坏 ####

### 23 断言式编程 ###
> TIP33：If It Can't Happen,Use Assertions to Ensure That It Won't
> 如果它不可能发生，用断言确保它不会发生

#### 让断言开着 ####

### 24 何时使用异常 ###
> TIP34：Use Exceptions for Exceptional Problems
> 将异常用于异常的问题

#### 什么事异常情况 ####
#### 错误处理器是另一种选择 ####

### 25 怎样配平资源 ###
> TIP35：Finish What You Start
> 要有始有终

#### 嵌套的分配 ####
- 以与资源分配的次序相反的次序解除资源分配
- 在代码不同地方分配同一组资源时，总以相同的次序分配它们，这将降低发生死锁的可能性。

#### 对象与异常 ####
#### 配平与异常 ####
- 在C++中配平资源
- 在Java中配平资源

#### 当你无法配平资源时 ####
- 为内存分配设立一个语义不变项：
    顶层结构还负责释放它包含的任何子结构
    知识解除顶层结构的分配，它指向的任何结构（没有在别处引用的）任何结构都会被遗弃
    如果顶层结构含有任何子结构，它就拒绝解除自身的分配

#### 检查配平 ####

## 第5章 弯曲，或折断 ##
### 26 解耦与得墨忒耳法则 ###
#### 使耦合减至最少 ####
#### 函数的得墨忒耳法则 ####
> TIP36：Minimize Coupling Between Modules
> 使模块之间的耦合减至最少

### 27 元程序设计 ###
#### 动态配置 ####
> TIP37：Configure，Don't Integrate
> 要配置，不要集成

#### 元数据驱动的应用 ####
> TIP38：Put Abstractions in Code,Details in Metadata
> 将抽象放进代码，细节放进元数据

### 28 时间耦合 ###
#### 工作流 ####
> TIP39：Analyze Workflow to Improve Concurrency
> 分析工作流，以改善并发性

#### 架构 ####
> TIP40：Design Using Services
> 用服务进行设计

#### 为并发进行设计 ####
> TIP41：Always Design for Concurrency
> 总是为并发进行设计

### 29 它只是视图 ###
#### 发布/订阅 ####
#### Model-View-Controller ####
> TIP42：Separate Views from Models
> 使视图与模型分离

#### 超越GUI ####
    模型：表示目标对象的抽象数据模型。模型对任何视图或控制器都没有直接的了解
    视图：解释模型的方式。它订阅模型中的变化和来自控制器的逻辑事件
    控制器：控制视图，并向模型提供新数据的途径，它既向模型、也向视图发布事件

### 30 黑板 ###
#### 黑板实现 ####
- 现代的分布式类黑板系统，以一种键/值对模型为基础。
- 黑板方式的编程消除了对太多接口的需要，从而带来更优雅、更一致的系统     
> TIP43：Use Blackboards to Coordinate Workflow
> 用黑板协调工作流

## 第6章 当你编码时 ##
### 31 靠巧合编程 ###
#### 怎样靠巧合编程 ####
- 实现的偶然
    它也许并不是真的能工作————它也许只是看起来能工作
    你依靠的边界条件也许只是一个偶然，在不同情形下它的表现可能就会不同
    没有记入文档的行为可能随着库的下一次发布而变化
    多余的和不必要的调用会使你的代码变慢
    多余的调用会增加引入它们自己的新bug风险

- 语境的偶然

- 隐含的假定
> TIP44：Don't Program by Coincidence
> 不要靠巧合编程

#### 怎样深思熟虑地编程 ####
    总是意识到你在做什么
    不要盲目地编程，视图构建你不完全理解的应用，或是使用你不熟悉的技术，就是希望自己被巧合误导
    按照计划行事
    依靠可靠的事物，不要依赖巧合和假定
    为你的假定建立稳定。“按合约编程”有助于澄清你头脑中的假定，并有助于把它们传达给别人
    不要只是测试你的代码，还要测试你的假定，不要猜测，要实际尝试它，编写断言测试你的假定
    为你的工作划分优先级
    不要做历史的奴隶，不要让已有的代码支配将来的代码。

### 32 算法速率 ###
#### 常识估算 ####
    简单循环    O(n)
    嵌套循环    O(m*n)
    二分法     O(lg(n))
    分而治之    O(nln(n))
    组合      在特定问题领域，常常用启发式方法减少这类算法运行时间

#### 实践中算法速率 ####
> TIP45：Estimate the Order of Your Algorithms
> 估算你的算法的阶

> TIP46：Test Your Estimates
> 测试你的估算

### 33 重构 ###
#### 你应在何时进行重构 ####
    **重复**
    **非正交的设计**
    **过时的知识**
    **性能**

> TIP47：Refactor Early，Refactor Often
> 早重构，常重构

#### 怎样进行重构 ####
1.不要试图在重构的同时增加功能
2.在开始重构前，确保你拥有良好的测试。尽可能经常运行这些测试
3.采取短小、深思熟虑的步骤

### 34 易于测试的代码 ###
#### 单元测试 ####
#### 针对合约进行测试 ####
> TIP48：Design to Test
> 为测试而设计

#### 编写单元测试 ####
1.一些例子。说明怎样使用你的模块的所有功能
2.用以构建回归测试，以验证未来对代码的任何改动是否正确的一种手段

#### 使用测试装备 ####
- 测试装备应有功能：
    用以指定设置与清理的标准途径
    用以选择个别或所有可用测试的方法
    分析输出是否是预期（或意外）结果的手段
    标准化的故障报告形式
- 构建测试窗口
    含有跟踪消息的日志文件
    “热键”序列
    使用内建的Web服务器
- 测试文化
> TIP49：Test Your Software,or Your Users Will
> 测试你的软件，否则你的用户就得测试

### 35 邪恶的向导 ###
> TIP50：Don't Use Wizard Code You Don't Understand
> 不要使用你不理解的向导代码

## 第7章 在项目开始之前 ##
### 36 需求之坑 ###
> TIP51：Don't Gather Requirements - Dig for Them
> 不要搜集需求————挖掘它们
#### 挖掘需求 ####
- 把政策的文档与需求的文档分开
- 找出用户为何要做特定事情的原因，而不只是他们目前做这件事情的方式
> TIP52：Work with a User to Think Like a User
> 与用户一同工作，以像用户一样思考

#### 建立需求文档 ####
#### 用例图 ####
#### 规定过度 ####
#### 看远些 ####
> TIP53：Abstractions Live Longer than Details
> 抽象比细节活得更长久

#### 再抹一层薄薄的薄荷 ####
#### 维护词汇表 ####
> TIP54：Use a Project Glossary
> 使用项目词汇表

#### 把话说出来 ####
- 基于Web的分发方式

### 37 解开不可能解开的谜题 ###
#### 自由度 ####
> TIP55：Don't Think Outside the Box - Find the Box
> 不要在盒子外面思考————要找到盒子
#### 一定有更容易的方法 ####

### 38 等你准备好 ###
> TIP56：Listen to Nagging Doubts - Start When You're Ready
> 倾听反复出现的疑惑————等你准备好再开始
#### 是良好的判断，还是拖延 ####
- 一种行之有效的技术是开始构建原型，选择 一个觉得会有困难的地方，开始进行某种“概念验证”。可能会发生两种情况：
    一种情况是：开始不久就觉得自己是在浪费时间，这种厌烦可能很好地表明，你最初的勉强知识希望推迟启动。放弃原型，回到真正的开发中
    另一种情况是，随着原型取得进展，你可能会在某个时刻得到启示，突然意识到有些基本前提错了。不仅如此，你还将清楚的看到怎样纠正错误，你将会愉快地放弃原型，投入正常的项目。

### 39 规范陷阱 ###
> TIP57：Some Things Are Better Done than Described
> 对有些事情“做”胜于“描述”
- 作为注重实效的程序员，应该倾向于把需求搜集、设计、以及实现视为同一个过程————交付高质量的系统————的不同方面。

### 40 圆圈与箭头 ###
> TIP58：Don't Be Slave to Formal Methods
> 不要做形式方法的奴隶
- 形式方法的一些严重缺点：
    - 大多数形式方法结合图和某些说明文件来捕捉需求。
    - 形式方法似乎鼓励专门化。
    - 大多数形式方法鼓励你在对象之间建立静态关系，而这些对象本来应该动态地编织在一起。
#### 形式方法能成功吗 ####
#### 我们应否使用形式方法 ####
> TIP59：Expensive Tools Do Not Produce Better Designs
> 昂贵的工具不一定能制作出更好的设计

## 第8章 注重实效的项目 ##
### 41 注重实效的团队 ###
#### 不要留破窗户 ####
#### 煮青蛙 ####
#### 交流 ####
#### 不要重复你自己 ####
#### 正交性 ####
> TIP60：Organize Around Functionality，Not Job Functions
> 围绕功能，而不是工作职务进行组织
#### 自动化 ####
#### 知道何时停止绘画 ####

### 42 无处不在的自动化 ###
#### 一切都要自动化 ####
> TIP61：Don't Use Manual Procedures
> 不要使用手工流程
#### 项目编译 ####
- 生成代码
- 回归测试
    递归make不知道对make的其他调用可能具有依赖关系
#### 构建自动化 ####
#### 自动化管理 ####

### 43 无情的测试 ###
> TIP62：Test Early.Test Often.Test Automatically
> 早测试，常测试，自动测试

> TIP63：Coding Ain't Done 'TIl All the Tests Run
> 要到通过全部测试，编码才算完成
#### 测试什么 ####
- 单元测试
- 集成测试
- 验证和校验
- 资源耗尽、错误几恢复
- 性能测试
- 可用性测试

#### 怎样测试 ####
- 回归测试
- 测试数据
- 演练GUI系统
- 对测试进行测试
> TIP64：Use Saboteurs to Test Your Testing
> 通过”蓄意破坏“测试你的测试
- 彻底测试
> TIP65：Test  State Coverage，Not Code Coverage
> 通过状态覆盖，而不是代码覆盖

#### 何时进行测试 ####

#### 把网收紧 ####
> TIP66：Find Bugs Onces
> 一个bug只抓一次

### 44 全都是写 ###
> TIP67：Treat English as Just Another Programming Language
> 把英语当做又一种编程语言

> TIP68：Build Documentation In，Don't Bolt It On
> 把文档建在里面，不要拴在外面
#### 代码中的注释 ####
- 不应该出现在源码注释中的一些内容:
    文件中的代码导出的函数的列表。
    修订历史。
    该文件使用的其他文件的列表。
    文件名。
#### 可执行文档 ####

#### 技术文档撰写者 ####
- 打印还是编排
- 标记语言

### 45 极大的期望 ###
> TIP69：Gently Exceed Your Users' Expectations
> 温和地超出用户的期望
#### 交流期望 ####
#### 额外的一英里 ####
- 让一般用户觉得很好的特性包括：
    气球式帮助或工具提示帮助
    快捷键
    作为用户手册的补充材料的快速参考手册
    彩色化
    日志文件分析器
    自动化安装
    用于检查系统完整性的工具
    运行系统的多个版本、以进行培训的能力
    为他们的机构定制的splash屏幕（交互式软件显示的初始画面）

### 46 傲慢与偏见 ###
> TIP70：Sign Your Work
> 在你的作品上签名