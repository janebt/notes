#编程规范
##1 排版
1-5：较长的语句（>100字符）要分成多行书写，长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要进行适当的缩进，使排版整齐，语句可读。
示
1-6：循环、判断等语句中若有较长的表达式或语句，则要进行适应的划分，长表达式要在低优先级操作符处划分新行，操作符放在新行之首。若屏幕能清楚看到行末操作符，为美观对齐，也可以将操作符放在行末。
1-11： switch与case的缩进方式是个例外，switch、‘{’和case三者处于同一缩进层次。
1-12： (3)"!"、"~"、"++"、"--"、"&"（地址运算符）等单目操作符前后不加空格。

##2 注释
2-1：一般情况下，源程序有效注释量必须在20％以上。
2-7：避免在注释中使用缩写，特别是非常用缩写。
2-10：注意注释的左对齐（与结构成员用TAB键隔开、对齐）
2-11：全局变量要有较详细的注释，包括对其功能、取值范围、哪些函数或过程存取它以及存取时注意事项等的说明。
2-12：注释与所描述内容进行同样的缩排。
2-14：对变量的定义和分支语句（条件分支、循环语句等）必须编写注释。
2-4：在程序块的结束行右方加注释标记，以表明某程序块的结束。
/* end of while (index < MAX_INDEX) */ // 指明该条while语句结束
 /* end of if (...)*/ // 指明是哪条if语句结束
2-6：注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。

##3 标识符命名
3-1: 说明：较短的单词可通过去掉“元音”形成缩写；较长的单词可取单词的头几个字母形成缩写；一些单词有大家公认的缩写。
示例：如下单词的缩写能够被大家基本认可。
temp 􀃆 tmp
buffer 􀃆 buf
length 􀃆 len
packet 􀃆 pkt
statistic 􀃆 stat
increment 􀃆 inc
message 􀃆 msg
3-4:下面所示的局部变量名的定义方法可以借鉴。
int liv_Width
其变量名解释如下：
l 局部变量（Local） （其它：g 全局变量（Global）...）
i 数据类型（Interger）
v 变量（Variable） （其它：c 常量（Const）...）
Width 变量含义
这样可以防止局部变量与全局变量重名。
3-5：命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用UNIX的全小写加下划线的风格或大小写混排的方式，不要使用大小写与下划线混排的方式，用作特殊标识，如标识成员变量或全局变量的m_和g_，标识所属模块的模块前缀fw_等，其后加上大小写
仅供内部使用 13
软件编程规范 3 标志符命名
混排的方式是允许的。
3-1：除非必要，不要用数字或较奇怪的字符来定义标识符。
3-2：在同一软件产品内，应规划好接口部分标识符（变量、结构、函数及常量）的命名，防止编译、链接时产生冲突.
说明：对接口部分的标识符应该有更严格限制，防止冲突。如可规定接口部分的变量与常量之前加上“模块”前缀标识等，如fw_addUser()和web_addUser()。
3-3：用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。
说明：下面是一些在软件中常用的反义词组。
add / remove begin / end create / destroy
insert / delete first / last get / release
increment / decrement get / set
add / delete lock / unlock open / close
min / max old / new start / stop
next / previous source / target show / hide
send / receive source / destination
cut / paste up / down
3-4：除了编译开关/头文件等特殊应用，应避免使用_EXAMPLE_TEST_之类以下划线开始和结尾的定义。

##4 可读性
4-2：避免使用不易理解的数字，用有意义的标识来替代。涉及物理状态或者含有物理意义的常量，不应直接使用数字，必须用有意义的枚举或宏来代替。

##5 变量、结构
5-4：当向全局变量传递数据时，要十分小心，防止赋与不合理的值或越界等现象发生。
5-6：严禁使用未经初始化的变量作为右值。
½5-1：构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象。
½5-2：只在某个模块内部使用的全局变量，应该用static定义为局部静态变量，限制全局变量的作用域范围。如果模块外的函数需要访问此变量，则应在模块内部设置对此变量的Set和Get函数。
½5-5：不要设计面面俱到、非常灵活的数据结构。
½5-7：结构中元素的个数应适中。若结构中元素个数过多可考虑依据某种原则把元素组成不同的子结构，以减少原结构中元素的个数。
½5-8：仔细设计结构中元素的布局与排列顺序，使结构容易理解、节省占用空间，并减少引起误用现象。
??????????????????????????????????????????????
½5-9：结构的设计要尽量考虑向前兼容和以后的版本升级，并为某些未来可能的应用保留余地（如预留一些空间等）。
½5-11：对自定义数据类型进行恰当命名，使它成为自描述性的，以提高代码可读性。注意其命名方式在同一产品中的统一。
说明：使用自定义类型，可以弥补编程语言提供类型少、信息量不足的缺点，并能使程序清晰、简洁。
示例：可参考如下方式声明自定义数据类型。
下面的声明可使数据类型的使用简洁、明了。
typedef unsigned char UINT8;
typedef unsigned short UINT16;
typedef unsigned int UINT32;
下面的声明可使数据类型具有更丰富的含义。
typedef float DISTANCE;
typedef float SCORE;
½5-12：编程时，要注意数据类型的强制转换。
½5-16：当声明用于分布式环境或不同CPU间通信环境的数据结构时，必须考虑机器的字节顺序、使用的位域及字节对齐等问题。

##6 函数、过程
6-1：对所调用函数的错误返回码要仔细、全面地处理。
6-3：编写可重入函数时，应注意局部变量的使用（如编写C/C++语言的可重入函数时，应使用auto即缺省态局部变量或寄存器变量）。
说明：编写C/C++语言的可重入函数时，不应使用static局部变量，否则必须经过特殊处理，才能使函数具有可重入性。
6-4：编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。
6-5：在同一项目组应明确规定对接口函数参数的合法性检查应由函数的调用者负责还是由接口函数本身负责，缺省是由函数调用者负责。
½6-1：防止将函数的参数作为工作变量。
½6-2：函数的规模尽量限制在200行以内。
½6-3：一个函数仅完成一件功能。
½6-4：为简单功能编写函数。
½6-6：函数的功能应该是可以预测的，也就是只要输入数据相同就应产生同样的输出。
在C/C++语言中，函数的static局部变量是函数的内部存储器，有可能使函数的功能不可预测，然而，当某函数的返回值为指针类型时，则必须是STATIC的局部变量的地址作为返回值，若为AUTO类，则返回为错针。
½6-7：尽量不要编写依赖于其他函数内部实现的函数。
½6-9：非调度函数应减少或防止控制参数，尽量只使用数据参数。
。非调度函数的控制参数增加了函数间的控制耦合，很可能使函数间的耦合度增大，并使函数的功能不唯一。
½6-11：检查函数所有非参数输入的有效性，如数据文件、全局变量等。
½6-13：使用动宾词组为执行某操作的函数命名。如果是OOP方法，可以只有动词（名词是对象本身）。
½6-23：设计高扇入、合理扇出（小于7）的函数。
说明：扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。函数较合理的扇出（调度函数除外）通常是3-5。
较良好的软件结构通常是顶层函数的扇出较高，中层函数的扇出较少，而底层函数则扇入到公共模块中。
½6-27：在多任务操作系统的环境下编程，要注意函数可重入性的构造。
½6-30：当一个过程（函数）中对较长变量（一般是结构的成员）有较多引用时，可以用一个意义相当的宏代替。

##7 可测性
7-6：正式软件产品中应把断言及其它调测代码去掉（即把有关的调测开关关掉）。
说明：加快软件运行速度。
7-8：用调测开关来切换软件的DEBUG版和正式版，而不要同时存在正式版本和DEBUG版本的不同源文件，以减少维护的难度。

##8 程序效率
8-5：循环体内工作量最小化。
½8-6：要仔细地构造或直接用汇编编写调用频繁或性能要求极高的函数。
½8-8：在多重循环中，应将最忙的循环放在最内层。
说明：减少CPU切入循环层的次数。
½8-10：避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中。
½8-11：尽量用乘法或其它方法代替除法，特别是浮点运算中的除法。
说明：浮点运算除法要占用较多CPU资源。
示例：如下表达式运算可能要占较多CPU资源。
#define PAI 3.1416
radius = circle_length / (2 * PAI);
应如下把浮点除法改为浮点乘法。
#define PAI_RECIPROCAL (1/3.1416) // 编译器编译时，将生成具体浮点数
radius = circle_length * PAI_RECIPROCAL / 2;

##9 质量保证
9-9：系统运行之初，要初始化有关变量及运行环境，防止未经初始化的变量被引用。
9-16：有可能的话，if语句尽量加上else分支，对没有else分支的语句要小心对待；switch语句必须有default分支。
9-17：多线程的中的子线程退出必需采用主动退出方式，即子线程应return出口。
½9-8：留心程序机器码大小（如指令空间大小、数据空间大小、堆栈空间大小等）是否超出系统有关限制。
½9-13：资源文件（多语言版本支持），如果资源是对语言敏感的，应让该资源与源代码文件脱离，具体方法有下面几种：使用单独的资源文件、DLL文件或其它单独的描述文件（如数据库格式）

##10 代码编辑、编译、审查
10-1：打开编译器的所有告警开关对程序进行编译，在 gcc 中是 –wall 。
½10-5：某些语句经编译后产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。
说明：在GNU C中，可用“#pragma warn”来关掉或打开某些告
½10-6：使用代码检查工具（如C语言用PC-Lint）对源程序检查。
½10-7：使用软件工具（如 LogiSCOPE）进行代码审查。

#11 代码测试、维护
11-1：单元测试要求至少达到语句覆盖。
11-2：单元测试开始要跟踪每一条语句，并观察数据流及变量的变化。
½11-2：关键的代码在汇编级跟踪。
½11-8：对自动消失的错误进行分析，搞清楚错误是如何消失的。（这个很有必要）

#12 宏
12-2:将宏所定义的多条表达式放在大括号中。
12-3:使用宏时，不允许参数发生变化。