#跟我一起写 Makefile
##第一部分 概述
##第二部分 关于程序的编译和链接
* 一般每个源文件对应一个中间目标文件（O 文件或是 OBJ 文件）。
* 链接时，主要是链接函数和全局变量
* 给中间目标文件打包，Windows 下这种包叫“库文件”，也就是 .lib 文件，在 UNIX下，是 Archive File，也就是 .a 文件。
* 在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成 Object File。
* 在链接程序时，链接器会在所有的 Object File 中找寻函数的实现，如果找不到，那到就会报链接错误码，在 VC 下一般是：Link 2001 错误

##第三部分 Makefile 介绍
###一、Makefile的规则
	target ... : prerequisites ... 
	command 
或

	targets : prerequisites ; command 
	command 
... 
###二、一个示例

###三、make是如何工作的
* 在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个 Tab 键作为开头。
- make 会比较 targets 文件和prerequisites 文件的修改日

###三、make是如何工作的
	1、make 会在当前目录下找名字叫“Makefile”或“makefile”的文件。
	2、如果找到，它会找文件中的第一个目标文件（target），并把这个文件作为最终的目标文件。
	3、如果目标文件不存在或是所依赖的后面的 .o 文件的文件修改时间要比目标这个文件新，那么会执行后面所定义的命令来生成目标文件。
	4、如果目标所依赖的.o 文件也存在，那么 make 会在当前文件中找目标为.o 文件的依赖性，如果找到则再根据那一个规则生成.o 文件。


###四、makefile中使用变量
* 可在一开始定义 objects = ...   ，然后使用$(objects)

###五、让make自动推导
* .PHONY:clean表示，clean是个伪目标文件。 
* 隐晦规则：看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中

###六、另类风格的makefile 
- e.g.
    $(objects) : defs.h 
    kbd.o command.o files.o : command.h 
    display.o insert.o search.o files.o : buffer.h

###七、清空目标文件的规则
* 在 rm 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。

##第四部分、Makefile 总述
###一、Makefile里有什么？
####1、显式规则。
####2、隐晦规则。
####3、变量的定义。
####4、文件指示。
	1.在一个 Makefile 中引用另一个Makefile
	2.根据某些情况指定 Makefile 中的有效部分
	3.定义一个多行的命令。
####5、注释。
* 注释是用“#”字符
* “\#”转义
* **在 Makefile 中的命令，必须要以[Tab]键开始**。

###二、Makefile的文件名
* 推荐Makefile > makefile > GNUmakefile
* make -f和--file参数来指定特定的 Makefile，如
make -f Make.Linux 

###三、引用其它的Makefile 
` include <filename> `

* 在 include前面可以有一些空字符，但是绝不能是[Tab]键开始
* include 和<filename>可以用一个或多个空格隔开
*  include寻址：
	
		1.没有指定绝对路径或是相对路径的话，make 会在当前目录下首先寻找
		2.当前目录下没有找到：
			2.1 如果 make 执行时，有“-I”或“--include-dir”参数，那么 make 就会在这个参数所指定的目录下去寻找。
			2.2 如果目录<prefix>/include（一般是：/usr/local/bin 或/usr/include）存在的话，make 也会去找。如果有文件没有找到的话，make 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找到，或是不能读取的文件，如果还是不行，make 才会出现一条致命信息。如果你想让 make不理那些无法读取的文件，而继续执行，你可以在 include 前加一个减号“-”。

###四、环境变量MAKEFILES
* 当前环境中定义了环境变量 MAKEFILES，make 会把这个变量中的值做一个类似于 include 的动作。
* 区别于include，从这个环境变中引入的 Makefile 的“目标”不会起作用，如果环境变量中定义的文件发现错误，make 也会不理。 

###五、make的工作方式

	1、读入所有的 Makefile。 
	2、读入被 include 的其它 Makefile。 
	3、初始化文件中的变量。 
	4、推导隐晦规则，并分析所有规则。 
	5、为所有的目标文件创建依赖关系链。 
	6、根据依赖关系，决定哪些目标要重新生成。 
	7、执行生成命令。 

##第五部分 书写规则
###一、规则举例
###二、规则的语法
* 可以使用反斜框（‘\’）作为换行符
* 一般make 会以 UNIX 的标准 Shell，也就是/bin/sh 来执行命令。

###三、在规则中使用通配符
* make 支持通配符：*   ? 和 [...]
* ~：~/test表示$HOME；~hchen/test表示用户 hchen 的宿主目录下的 test 目录
* 
- 要让通配符在变量中展开：objects := $(wildcard *.o)

###四、文件搜寻
* VPATH = src:../headers 如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。 
* make 的“vpath”关键字（PS：这不是变量，这是一个 make 的关键字），使用方法：
		1、vpath <pattern> <directories> 
			为符合模式<pattern>的文件指定搜索目录<directories>。
		2、vpath <pattern> 
			清除符合模式<pattern>的文件的搜索目录。 
		3、vpath 
			清除所有已被设置好了的文件搜索目录。
* <pattern>需要包含“%”字符(匹配零或若干字符)

###五 伪目标
* 避免伪目标和文件重名,.PHONY”来显示地指明一个目标是“伪目标”
* 伪目标同样可以作为“默认目标”，只要将其放在第一个。e.g.  
    all : prog1 prog2 prog3    
    .PHONY : all 
- 伪目标的特性是，总是被执行的
* 伪目标同样也可成为依赖。
- “伪目标”的取名不能和文件名重名。为了避免这个问题，可用标记“.PHONY”来显示地指明

###六 多目标
- 使用一个自动化变量“$@”，这个变量表示着目前规则中所有的目标的集合

### 七、静态模式 ###
- 语法：
    <targets ...>: <target-pattern>: <prereq-patterns ...> 
    <commands> 
- “目标模式”或是“依赖模式”中都应该有“%”这个字符
- $<”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是“foo.o bar.o”）。
- $(filter %.o,$(files))表示调用Makefile 的 filter 函数，过滤“$filter”集，只要其中模式为“%.o”的内容。

### 八、自动生成依赖性 ###
- 大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。
- 如果你使用 GNU 的 C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。
- 。GNU 组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的 Makefile 文件，[.d]文件中就存放对应[.c]文件的依赖关系。

## 第六部分  书写命令 ##
### 一、显示命令 ###
- @echo 正在编译 XXX 模块......
- 带入 make 参数“-n”或“--just-print”，那么其只是显示命令，但不会执行命令
- make 参数“-s”或“--slient”则是全面禁止命令的显示。

### 二、命令执行 ###
- 如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。

### 三、命令出错 ###
- 如果一个规则中的某个命令出错了（命令退出码非零），那么 make 就会终止执行当前规则，这将有可能终止所有规则的执行。 
- 解决方法：
    在 Makefile 的命令行前加一个减号“-”（在 Tab 键之后），标记为不管命令出不出错都认为是成功的。
    全局的办法是，给 make 加上“-i”或是“--ignore-errors”参数
    如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。
    make 的参数的是“-k”或是“--keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。

### 四、嵌套执行make  ###
- 总控 Makefile 的变量可以传递到下级的 Makefile 中（如果你显示的声明），但是不会覆盖下层的 Makefile 中所定义的变量，除非指定了“-e”参数。 
- 如果你要传递变量到下级 Makefile 中，那么你可以使用这样的声明： 
    export <variable ...> 
- 如果你不想让某些变量传递到下级 Makefile 中，那么你可以这样声明： 
    unexport <variable ...> 
- 需要注意的是，有两个变量，一个是 SHELL，一个是 MAKEFLAGS，这两个变量不管你是否 export，其总是要传递到下层 Makefile 中，特别是 MAKEFILES 变量，其中包含了 make的参数信息，这是一个系统级的环境变量。 
- 如果你不想往下层传递参数，那么，你可以这样来： 
    subsystem: 
    cd subdir && $(MAKE) MAKEFLAGS=
-  make 命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”
- 在“嵌套执行”中比较有用的参数，“-w”或是“--print-directory”会在make 的过程中输出一些信息，让你看到目前的工作目录。当你使用“-C”参数来指定 make 下层 Makefile 时，“-w”会被自动打开的。如果参数中有“-s”（“--slient”）或是“--no-print-directory”，那么，“-w”总是失效的。

### 五、定义命令包 ###
- 定义这种命令序列的语法以“define”开始，以“endef”结束

## 第七部分  使用变量 ##
- 变量是大小写敏感的。
### 一、变量的基础 ###
- 变量在声明时需要给予初值

### 二、变量中的变量 ###
- 在 Makefile 中有两种方式来在用变量定义变量的值。
    使用“=”       优：可以把变量的真实值推到后面来定义；劣：递归定义
    使用“:=”      这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。
- 定义一个变量，其值是一个空格：
    nullstring := 
    space := $(nullstring) # end of the line 
- 采用“#”注释符来表示变量定义的终止。注释符“#”的这种特性值得我们注意
- 比较有用的操作符是“?=”
    没有被定义过，那么变量xxx的值就是“xxx”，如果 xxx 先前被定义过，那么这条语将什么也不做

### 三、变量高级用法 ###
- 变量值的替换
    格式是“$(var:a=b)”或是“${var:a=b}”    e.g.
    foo := a.o b.o c.o 
    bar := $(foo:.o=.c)
    另外一种变量替换的技术是以“静态模式”定义的.这依赖于被替换字串中的有相同的模式    e.g.
    foo := a.o b.o c.o 
    bar := $(foo:%.o=%.c) 

- 把变量的值再当成变量    e.g.
    x = y 
    y = z 
    a := $($(x)) 

### 四、追加变量值 ###
- 使用“+=”操作符给变量追加值
- 如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符

### 五、override 指示符 ###
- 如果有变量是通常make 的命令行参数设置的，那么Makefile 中对这个变量的赋值会被忽略。
- 如果你想在 Makefile 中设置这类参数的值，那么，你可以使用“override”指示符。
- 对于多行的变量定义，我们用 define 指示符，在 define 指示符前，也同样可以使用 ovveride指示符

### 六、多行变量 ###
- 使用 define 关键字
- define 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以 endef 关键字结束。
- **命令需要以[Tab]键开头**

### 七、环境变量 ###
- 如果 Makefile 中已定义了这个变量，或是这个变量由 make 命令行带入，那么系统的环境变量的值将被覆盖。（如果 make 指定了“-e”参数，那么，系统环境变量将覆盖 Makefile 中定义的变量） 

### 八、目标变量 ###
- 语法是： 
    <target ...> : <variable-assignment> 
    <target ...> : overide <variable-assignment>(<variable-assignment>可以是前面讲过的各种赋值表达式)

### 九、模式变量 ###
- 模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。
- 语法：
    <pattern ...> : <variable-assignment> 
    <pattern ...> : override <variable-assignment> 

## 第八部分  使用条件判断 ##
### 一、示例 ###
- 可用ifeq、else 和 endif等

### 二、语法 ###
- 条件表达式的语法为： 
    <conditional-directive> 
    <text-if-true> 
    endif 
以及： 
    <conditional-directive> 
    <text-if-true> 
    else 
    <text-if-false> 
    endif
- 关键字有四个：ifeq，ifneq，ifdef，ifndef
- 关于ifdef：如果变量<variable-name>的值非空，那到表达式为真。
- 注意，ifdef 只是测试一个变量是否有值，其并不会把变量扩展到当前位置。e.g.
    bar = 
    foo = $(bar) 
    ifdef foo   ： yes

    foo = 
    ifdef foo   ：no
- 注意：在<conditional-directive>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。else”和“endif”也一样，只要不是以[Tab]键开始就行了。      
- 注意：make 是在读取 Makefile 时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。 

## 第九部分  使用函数 ##
### 一、函数的调用语法 ###
    $(<function> <arguments>) 
    或是 
    ${<function> <arguments>} 

### 二、字符串处理函数 ###
#### 1、subst ####
    $(subst <from>,<to>,<text>) 
    名称：字符串替换函数——subst。 
    功能：把字串<text>中的<from>字符串替换成<to>。 
    返回：函数返回被替换过后的字符串。 

#### 2、patsubst ####
    $(patsubst <pattern>,<replacement>,<text>) 
    名称：模式字符串替换函数——patsubst。 
    功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“\”来转义，以“\%”来表示真实含义的“%”字符） 
    返回：函数返回被替换过后的字符串。

#### 3、strip ####
    $(strip <string>) 
    名称：去空格函数——strip。 
    功能：去掉<string>字串中开头和结尾的空字符。 
    返回：返回被去掉空格的字符串值。

#### 4、findstring  ####
    $(findstring <find>,<in>) 
    名称：查找字符串函数——findstring。 
    功能：在字串<in>中查找<find>字串。 
    返回：如果找到，那么返回<find>，否则返回空字符串。

#### 5、filter  ####
    $(filter <pattern...>,<text>) 
    名称：过滤函数——filter。 
    功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可以有多个模式。 
    返回：返回符合模式<pattern>的字串。

#### 6、filter-out  ####
    $(filter-out <pattern...>,<text>) 
    名称：反过滤函数——filter-out。 
    功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可以有多个模式。 
    返回：返回不符合模式<pattern>的字串。

#### 7、sort  ####
    $(sort <list>) 
    名称：排序函数——sort。 
    功能：给字符串<list>中的单词排序（升序）。 
    返回：返回排序后的字符串。 
    备注：sort 函数会去掉<list>中相同的单词。 

#### 8、word  ####
    $(word <n>,<text>) 
    名称：取单词函数——word。 
    功能：取字符串<text>中第<n>个单词。（从一开始） 
    返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返 回空字符串。 

#### 9、wordlist  ####
    $(wordlist <s>,<e>,<text>) 
    名称：取单词串函数——wordlist。 
    功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。 
    返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单词串。 

#### 10、words  ####
    $(words <text>) 
    名称：单词个数统计函数——words。 
    功能：统计<text>中字符串中的单词个数。 
    返回：返回<text>中的单词数。 
    备注：如果我们要取<text>中最后的一个单词，我们可以这样：$(word $(words <text>),<text>)。 

#### 11、firstword  ####
    $(firstword <text>) 
    名称：首单词函数——firstword。 
    功能：取字符串<text>中的第一个单词。 
    返回：返回字符串<text>的第一个单词。 
    备注：这个函数可以用 word 函数来实现：$(word 1,<text>)。

#### 12、字符串函数实例 ####
- e.g.make 使用“VPATH”变量来指定“依赖文件”的搜索路径。可以利用这个搜索路径来指定编译器对头文件的搜索路径参数 CFLAGS：
    override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))

### 三、文件名操作函数 ###
#### 1、dir ####
    $(dir <names...>) 
    名称：取目录函数——dir。 
    功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。 
    返回：返回文件名序列<names>的目录部分。

#### 2、notdir ####
    $(notdir <names...>) 
    名称：取文件函数——notdir。 
    功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“ /”）之后的部分。 
    返回：返回文件名序列<names>的非目录部分。

#### 3、suffix ####
    $(suffix <names...>) 
    名称：取后缀函数——suffix。 
    功能：从文件名序列<names>中取出各个文件名的后缀。 
    返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。

#### 4、basename  ####
    $(basename <names...>) 
    名称：取前缀函数——basename。 
    功能：从文件名序列<names>中取出各个文件名的前缀部分。 
    返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。

#### 5、addsuffix ####
    $(addsuffix <suffix>,<names...>) 
    名称：加后缀函数——addsuffix。 
    功能：把后缀<suffix>加到<names>中的每个单词后面。 
    返回：返回加过后缀的文件名序列。 

#### 6、addprefix ####
    $(addprefix <prefix>,<names...>) 
    名称：加前缀函数——addprefix。 
    功能：把前缀<prefix>加到<names>中的每个单词后面。 
    返回：返回加过前缀的文件名序列。

#### 7、join ####
    $(join <list1>,<list2>) 
    名称：连接函数——join。 
    功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比
    <list2>的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比
    <list1>多，那么，<list2>多出来的单词将被复制到<list2>中。 
    返回：返回连接过后的字符串。 

### 四、foreach 函数 ###
    $(foreach <var>,<list>,<text>)
    把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。 
    注意，foreach 中的<var>参数是一个临时的局部变量

### 五、if 函数 ###
    $(if <condition>,<then-part>) 
    或是 
    $(if <condition>,<then-part>,<else-part>)

### 六、call函数 ###
    $(call <expression>,<parm1>,<parm2>,<parm3>...)
    call 函数是唯一一个可以用来创建新的参数化的函数  
    <expression>的返回值就是 call 函数的返回值。

### 七、origin函数 ###
    $(origin <variable>)
    origin 函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的
    注意：<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用“$”字符。
    origin函数的返回值:
        “undefined”         如果<variable>从来没有定义过
        “default”           如果<variable>是一个默认的定义，比如“CC”这个变量
        “environment”       如果<variable>是一个环境变量，并且当 Makefile 被执行时，“-e”参数没有被打开。
        “file”              如果<variable>这个变量被定义在Makefile 中。 
        “command line”      如果<variable>这个变量是被命令行定义的。 
        “override”          如果<variable>是被 override 指示符重新定义的。 
        “automatic”         如果<variable>是一个命令运行中的自动化变量。
- 这些信息对于我们编写 Makefile 是非常有用
- override过于粗暴，它同时会把从命令行定义的变量和环境中的变量覆盖

### 八、shell函数 ###
- 它和反引号“`”是相同的功能
-  e.g.     contents := $(shell cat foo)
- 注意，这个函数会新生成一个 Shell 程序来执行命令，所以你要注意其运行性能，如果你的Makefile 中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是 Makefile 的隐晦的规则可能会让你的 shell 函数执行的次数比你想像的多得多。

### 九、控制make的函数 ###
#### 1、error ####
    $(error <text ...>) 
    产生一个致命的错误，<text ...>是错误信息。注意，error 函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。

#### 2、warning ####
    $(warning <text ...>) 
    这个函数很像 error 函数，只是它并不会让 make 退出，只是输出一段警告信息，而 make 继续执行。 

## 第十部分make 的运行 ##
### 一、make的退出码 ###
    0 - 表示成功执行。 
    1 - 如果 make 运行时出现任何错误，其返回 1。 
    2 - 如果你使用了 make 的“-q”选项，并且 make 使得一些目标不需要更新，那么返回 2。

### 二、指定Makefile ###
- GNU make 找寻默认的 Makefile 的规则是在当前目录下依次找三个文——“GNUmakefile”、“makefile”和“Makefile”。
- 使用 make 的“-f”或是“--file”参数（“--makefile”参数也行）指定一个特殊名字的 Makefile.

### 三、指定目标 ###
- 一般来说，make 的最终目标是 makefile 中的第一个目标，而其它目标一般是由这个目标连带出来的。
- 任何在 makefile 中的目标都可以被指定成终极目标，但是除了以“-”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。
- 有一个 make 的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表
- 伪目标：
    “all” 
    这个伪目标是所有目标的目标，其功能一般是编译所有的目标。 
    “clean” 
    这个伪目标功能是删除所有被 make 创建的文件。 
    “install” 
    这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。 
    “print” 
    这个伪目标的功能是例出改变过的源文件。 
    “tar” 
    这个伪目标功能是把源程序打包备份。也就是一个 tar 文件。 
    “dist” 
    这个伪目标功能是创建一个压缩文件，一般是把 tar 文件压成 Z 文件。或是 gz 文件。 
    “TAGS” 
    这个伪目标功能是更新所有的目标，以备完整地重编译使用。 
    “check”和“test” 
    这两个伪目标一般用来测试 makefile 的流程。 

### 四、检查规则 ###
- 不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行。
    “-n” 
    “--just-print” 
    “--dry-run” 
    “--recon”
- 把目标文件的时间更新，但不更改目标文件。也就是说，make 假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。
    “-t” 
    “--touch” 
- 这个参数的行为是找目标的意思。如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。
    “-q” 
    “--question”
- 这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make 会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。 
    “-W <file>” 
    “--what-if=<file>” 
    “--assume-new=<file>” 
    “--new-file=<file>” 

### 五、make的参数 ###
-  GNU make 3.80 版的参数定义
    “-b” 
    “-m”
    这两个参数的作用是忽略和其它版本 make 的兼容性。

    “-B” 
    “--always-make” 
    认为所有的目标都需要更新（重编译）。 

    “-C <dir>” 
    “--directory=<dir>” 
    指定读取 makefile 的目录。如果有多个“-C”参数，make 的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。

    “—debug[=<options>]” 
    输出 make 的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值： 
        a —— 也就是 all，输出所有的调试信息。（会非常的多） 
        b —— 也就是 basic，只输出简单的调试信息。即输出不需要重编译的目标。 
        v —— 也就是 verbose，在 b 选项的级别之上。输出的信息包括哪个 makefile 被解析，不需要被重编译的依赖文件（或是依赖目标）等。 
        i —— 也就是 implicit，输出所以的隐含规则。 
        j —— 也就是 jobs，输出执行规则中命令的详细信息，如命令的 PID、返回码等。 
        m —— 也就是 makefile，输出 make 读取 makefile，更新 makefile，执行 makefile 的信息。 

    “-d” 
    相当于“--debug=a”。 

    “-e” 
    “--environment-overrides” 
    指明环境变量的值覆盖 makefile 中定义的变量的值。 

    “-f=<file>” 
    “--file=<file>” 
    “--makefile=<file>” 
    指定需要执行的 makefile。 

    “-h” 
    “--help” 
    显示帮助信息。
 
    “-i” 
    “--ignore-errors” 
    在执行时忽略所有的错误。 

    “-I <dir>”
    “--include-dir=<dir>” 
    指定一个被包含 makefile 的搜索目标。可以使用多个“-I”参数来指定多个目录。 

    “-j [<jobsnum>]” 
    “--jobs[=<jobsnum>]” 
    指同时运行命令的个数。如果没有这个参数，make 运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。

    “-k” 
    “--keep-going” 
    出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。 

    “-l <load>” 
    “--load-average[=<load]” 
    “—max-load[=<load>]” 
    指定 make 运行命令的负载。 

    “-n” 
    “--just-print” 
    “--dry-run” 
    “--recon” 
    仅输出执行过程中的命令序列，但并不执行。 
    
    “-o <file>” 
    “--old-file=<file>” 
    “--assume-old=<file>” 
    不重新生成的指定的<file>，即使这个目标的依赖文件新于它。 
    
    “-p” 
    “--print-data-base” 
    输出 makefile 中的所有数据，包括所有的规则和变量。这个参数会让一个简单的 makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -qp”命令。如果你想查看执行 makefile 前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的 makefile 文件的文件名和行号，所以，用这个参数来调试你的 makefile 会是很有用的，特别是当你的环境变量很复杂的时候。
     
    “-q” 
    “--question” 
    不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是 0 则说明要更新，如果是 2 则说明有错误发生。 
    
    “-r” 
    “--no-builtin-rules”
    禁止 make 使用任何隐含规则。 
    
    “-R” 
    “--no-builtin-variabes” 
    禁止 make 使用任何作用于变量上的隐含规则。 
    
    “-s” 
    “--silent” 
    “--quiet” 
    在命令运行时不输出命令的输出。 

    “-S”
    “--no-keep-going” 
    “--stop” 
    取消“-k”选项的作用。因为有些时候，make 的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。 

    “-t” 
    “--touch” 
    相当于 UNIX 的 touch 命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。 
    
    “-v” 
    “--version” 
    输出 make 程序的版本、版权等关于 make 的信息。 
    
    “-w” 
    “--print-directory” 
    输出运行 makefile 之前和之后的信息。这个参数对于跟踪嵌套式调用 make 时很有用。 
    
    “--no-print-directory” 
    禁止“-w”选项。 
    
    “-W <file>” 
    “--what-if=<file>” 
    “--new-file=<file>” 
    “--assume-file=<file>” 
    假定目标<file>需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行 UNIX 的“touch”命令一样，使得<file>的修改时间为当前时间。 
    
    “--warn-undefined-variables” 
    只要 make 发现有未定义的变量，那么就输出警告信息。

## 第十一部分  隐含规则 ##
### 一、使用隐含规则 ###
- 在 make 的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。make 找到可以生成的规则就不再寻找下一条规则了。
- 如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。

### 二、隐含规则一览 ###
- 可以使用 make的参数“-r”或“--no-builtin-rules”选项来取消所有的预设置的隐含规则。
- 当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表”（也就一系统定义在目标.SUFFIXES 的依赖目标），那么隐含规则就会生效。
- 常用的隐含规则：
    1、编译C程序的隐含规则 
    “<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)” 

    2、编译C++程序的隐含规则
    “<n>.o”的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为 C++源文件的后缀，而不是“.C”）
 
    3、编译Pascal程序的隐含规则
    “<n>.o”的目标的依赖目标会自动推导为“<n>.p”，并且其生成命令是“$(PC) –c $ (PFLAGS)”。
 
    4、编译Fortran/Ratfor程序的隐含规则
    “<n>.o”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”或“<n>.f”，并且其生成命令是: 
    “.f” “$(FC) –c $(FFLAGS)” 
    “.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)” 
    “.f” “$(FC) –c $(FFLAGS) $(RFLAGS)”
 
    5、预处理Fortran/Ratfor程序的隐含规则 
    “<n>.f”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”。这个规则只是转换Ratfor 或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是： 
    “.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)” 
    “.r” “$(FC) –F $(FFLAGS) $(RFLAGS)”
 
    6、编译Modula-2程序的隐含规则 
    “<n>.sym”的目标的依赖目标会自动推导为“<n>.def”，并且其生成命令是：
    “$(M2C)$(M2FLAGS)  $(DEFFLAGS)”。
    “<n.o>”的目标的依赖目标会自动推导为“<n>.mod”， 并且其生成命令是：
    “$(M2C) $(M2FLAGS) $(MODFLAGS)”。

    7、汇编和汇编预处理的隐含规则 
    “<n>.o” 的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：
    “$(AS) $(ASFLAGS)”。
    “<n>.s” 的目标的依赖目标会自动推导为“<n>.S”，默认使用 C 预编译器“cpp”，并且其生成命令是：
    “$(AS) $(ASFLAGS)”。
 
    8、链接Object文件的隐含规则 
    “<n>”目标依赖于“<n>.o”，通过运行 C 的编译器来运行链接程序生成（一般是“ld”），其生成命令是：
    “$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)”。
    这个规则对于只有一个源文件的工程有效，同时也对多个 Object 文件（由不同的源文件生成）的也有效。
    如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。

    9、Yacc C程序时的隐含规则
    “<n>.c”的依赖文件被自动推导为“n.y”（Yacc 生成的文件），其生成命令是：
    “$(YACC) $(YFALGS)”。

    10、Lex C程序时的隐含规则
    “<n>.c”的依赖文件被自动推导为“n.l”（Lex 生成的文件），其生成命令是：
    “$(LEX) $(LFALGS)”。

    11、Lex Ratfor程序时的隐含规则
    “<n>.r”的依赖文件被自动推导为“n.l”（Lex 生成的文件），其生成命令是：
    “$(LEX) $(LFALGS)”。 

    12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则
    “<n>.ln” （lint 生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：
    “$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。
    对于“<n>.y”和“<n>.l”也是同样的规则。
 
### 三、隐含规则使用的变量 ###
- 隐含规则预先设置的变量，可以在你的makefile 中改变这些变量的值，或是在 make 的命令行中传入这些值，或是在你的环境变量中设置这些值
- 可以利用 make 的“-R”或“--no–builtin-variables”参数来取消你所定义的变量对隐含规则的作用。
- 
#### 1、关于命令的变量。 ####
    AR          函数库打包程序。默认命令是“ar”。 
    AS          汇编语言编译程序。默认命令是“as”。
    CC          C 语言编译程序。默认命令是“cc”。 
    CXX         C++语言编译程序。默认命令是“g++”。 
    CO          从 RCS 文件中扩展文件程序。默认命令是“co”。 
    CPP         C 程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。 
    FC          Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。 
    GET         从 SCCS 文件中扩展文件的程序。默认命令是“get”。 
    LEX         Lex 方法分析器程序（针对于 C 或 Ratfor）。默认命令是“lex”。 
    PC          Pascal 语言编译程序。默认命令是“pc”。 
    YACC        Yacc 文法分析器（针对于 C 程序）。默认命令是“yacc”。 
    YACCR       Yacc 文法分析器（针对于 Ratfor 程序）。默认命令是“yacc –r”。 
    MAKEINFO    转换 Texinfo 源文件（.texi）到 Info 文件程序。默认命令是“makeinfo”。 
    TEX         从 TeX 源文件创建 TeX DVI 文件的程序。默认命令是“tex”。 
    TEXI2DVI    从 Texinfo 源文件创建军 TeX DVI 文件的程序。默认命令是“texi2dvi”。 
    WEAVE       转换 Web 到 TeX 的程序。默认命令是“weave”。 
    CWEAVE      转换 C Web 到 TeX 的程序。默认命令是“cweave”。 
    TANGLE      转换 Web 到 Pascal 语言的程序。默认命令是“tangle”。 
    CTANGLE     转换 C Web 到 C。默认命令是“ctangle”。 
    RM          删除文件命令。默认命令是“rm –f”。

#### 2、关于命令参数的变量 ####
    ARFLAGS         函数库打包程序 AR 命令的参数。默认值是“rv”。 
    ASFLAGS         汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。 
    CFLAGS          C 语言编译器参数。 
    CXXFLAGS        C++语言编译器参数。 
    COFLAGS         RCS 命令参数。 
    CPPFLAGS        C 预处理器参数。（ C 和 Fortran 编译器也会用到）。 
    FFLAGS          Fortran 语言编译器参数。 
    GFLAGS          SCCS “get”程序参数。 
    LDFLAGS         链接器参数。（如：“ld”） 
    LFLAGS          Lex 文法分析器参数。 
    PFLAGS          Pascal 语言编译器参数。 
    RFLAGS          Ratfor 程序的 Fortran 编译器参数。 
    YFLAGS          Yacc 文法分析器参数。

### 四、隐含规则链 ###
- 可以阻止 make 自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。 

### 五、定义模式规则 ###
- "%"的展开发生在变量和函数的展开之后，变量和函数的展开发生在 make 载入 Makefile 时，而模式规则中的"%"则发生在运行时。

#### 1、模式规则介绍 ####
- 模式规则中，至少在规则的目标定义中要包含"%"，否则，就是一般的规则。

#### 2、模式规则示例 ####

#### 3、自动化变量 ####
- 自动化变量及其说明：
    $@      表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，"$@"就是匹配于目标中模式定义的集合。
 
    $%      仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是"foo.a (bar.o)"，那么，"$%"就是"bar.o"，"$@"就是"foo.a"。如果目标不是函数库文件（Unix下是[.a]，Windows 下是[.lib]），那么，其值为空。

    $<      依赖目标中的第一个目标名字。如果依赖目标是以模式（即"%"）定义的，那么"$<"将是符合模式的一系列的文件集。注意，其是一个一个取出来的。 

    $?      所有比目标新的依赖目标的集合。以空格分隔。 

    $^      所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。 

    $+      这个变量很像"$^"，也是所有依赖目标的集合。只是它不去除重复的依赖目标。 

    $*      这个变量表示目标模式中"%"及其之前的部分。如果目标是"dir/a.foo.b"，并且目标的模式是"a.%.b"，那么，"$*"的值就是"dir/a.foo"。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么"$*"也就不能被推导出，但是，如果目标文件的后缀是 make 所识别的，那么"$*"就是除了后缀的那一部分。这个特性是 GNU make 的，很有可能不兼容于其它版本的 make，所以，你应该尽量避免使用"$*"，除非是在隐含规则或是静态模式中。如果目标中的后缀是 make 所不能识别的，那么"$*"就是空值。

    $?      只对更新过的依赖文件进行操作。

    $(@D)   表示"$@"的目录部分（不以斜杠作为结尾），如果"$@"值是"dir/foo.o"，那么"$(@D)"就是"dir"，而如果"$@"中没有包含斜杠的话，其值就是"."（当前目录）。 

    $(@F)   表示"$@"的文件部分，如果"$@"值是"dir/foo.o"，那么"$(@F)"就是"foo.o"，"$(@F)"相当于函数"$(notdir $@)"。 

    "$(*D)" 
    "$(*F)" 
    和上面所述的同理，也是取文件的目录部分和文件部分。

    "$(%D)" 
    "$(%F)" 
    分别表示了函数包文件成员的目录部分和文件部分。这对于形同"archive(member)"形式的目标中的"member"中包含了不同的目录很有用。 

    "$(<D)" 
    "$(<F)" 
    分别表示依赖文件的目录部分和文件部分。
 
    "$(^D)" 
    "$(^F)" 
    分别表示所有依赖文件的目录部分和文件部分。（无相同的）

    "$(+D)" 
    "$(+F)" 
    分别表示所有依赖文件的目录部分和文件部分。（可以有相同的） 

    "$(?D)" 
    "$(?F)" 
    分别表示被更新的依赖文件的目录部分和文件部分。
- 注意：对于"$<"，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，"$(<)"就要比"$<"要好一些。
- 注意的是，这些变量只使用在规则的命令中，而且一般都是"显式规则"和"静态模式规则"。其在隐含规则中并没有意义。

#### 4、模式的匹配 ####
- 因为"%"代表一个或多个字符，所以在定义好了的模式中，我们把"%"所匹配的内容叫做"茎"
- 当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。

#### 5、重载内建隐含规则 ####
- e.g.重新构造和内建隐含规则不同的命令
    %.o : %.c 
    $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)
- e.g.取消内建的隐含规则，只要不在后面写命令
    %.o : %.s

### 六、老式风格的"后缀规则" ###
- 后缀规则有两种方式："双后缀"和"单后缀"。 
    双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如".c.o"相当于"%o : %c"。
    单后缀规则只定义一个后缀，也就是源文件的后缀。如".c"相当于"% :%.c"。 
- 后缀规则中所定义的后缀应该是 make 所认识的，如果一个后缀是 make 所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被 make 所认识，那就是双后缀规则。
- 后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名
- 后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则
- 要让 make 知道一些特定的后缀，我们可以使用伪目标".SUFFIXES"来定义或是删除
    e.g.    .SUFFIXES: .hack .win   #把后缀.hack 和.win 加入后缀列表中的末尾。
            .SUFFIXES:              # 删除默认的后缀 
            .SUFFIXES: .c .o .h     # 定义自己的后缀 
- make 的参数"-r"或"-no-builtin-rules"也会使用得默认的后缀列表为空。而变量"SUFFIXE"被用来定义默认的后缀列表，你可以用".SUFFIXES"来改变后缀列表，但请不要改变变量"SUFFIXE"的值。

### 七、隐含规则搜索算法 ###
- 所有的后缀规则在 Makefile 被载入内存时，会被转换成模式规则
- 搜索算法:
    1、把 T 的目录部分分离出来。叫 D，而剩余部分叫 N。 （如：如果 T 是"src/foo.o"，那么，D 就是"src/"，N 就是"foo.o"） 
    2、创建所有匹配于 T 或是 N 的模式规则列表。 
    3、如果在模式规则列表中有匹配所有文件的模式，如"%"，那么从列表中移除其它的模式。 
    4、移除列表中没有命令的规则。 
    5、对于第一个在列表中的模式规则： 
    1）推导其"茎"S，S 应该是 T 或是 N 匹配于模式中"%"非空的部分。 
    2）计算依赖文件。把依赖文件中的"%"都替换成"茎"S。如果目标模式中没有包含斜框字符，而把 D 加在第一个依赖文件的开头。 
    3）测试是否所有的依赖文件都存在或是理当存在。 （如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫"理当存在"）
    4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。 
    6、如果经过第 5 步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则： 
    1）如果规则是终止规则，那就忽略它，继续下一条模式规则。 
    2）计算依赖文件。（同第 5 步） 
    3）测试所有的依赖文件是否存在或是理当存在。 
    4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。
    5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。 
    7、如果没有隐含规则可以使用，查看".DEFAULT"规则，如果有，采用，把".DEFAULT"的命令给 T 使用。

## 第十二部分  使用make更新函数库文件 ##
- 函数库文件也就是对 Object 文件（程序编译的中间文件）的打包文件。在 Unix 下，一般是由命令"ar"来完成打包工作。 

### 一、函数库文件的成员 ###
- 以如下格式指定函数库文件及其组成： 
    archive(member) 
- 这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了"ar"命令来服务的。如： 
    foolib(hack.o) : hack.o 
    ar cr foolib hack.o 
- 如果要指定多个 member，那就以空格分开
- 你还可以使用 Shell 的文件通配符来定义

### 二、函数库成员的隐含规则 ###
- 当 make 搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是"a(m)"形式的，其会把目标变成"(m)"。

### 三、函数库文件的后缀规则 ###
- 可以使用"后缀规则"和"隐含规则"来生成函数库打包文件，如：
    .c.a: 
    $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o 
    $(AR) r $@ $*.o 
    $(RM) $*.o

### 四、注意事项 ###
- 在进行函数库打包文件生成时，请小心使用 make 的并行机制（"-j"参数）。如果多个ar 命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在 make 未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。

## 第十三部分  后序 ##