# Advanced Bash-Scripting Guide #
# 第一部分  热身 #
## 第1章  为什么使用shell编程 ##
- 什么时候不使用Shell脚本
       资源密集型的任务,尤其在需要考虑效率时(比如,排序,hash等等) 
       需要处理大任务的数学操作,尤其是浮点运算,精确运算,或者复杂的算术运算(这种情况一般使用C++或FORTRAN来处理) 
       有跨平台移植需求(一般使用C或Java) 
       复杂的应用,在必须使用结构化编程的时候(需要变量的类型检查,函数原型,等等) 
       对于影响系统全局性的关键任务应用。
       对于安全有很高要求的任务,比如你需要一个健壮的系统来防止入侵,破解,恶意破坏等等. 
       项目由连串的依赖的各个部分组成。
       需要大规模的文件操作
       需要多维数组的支持
       需要数据结构的支持,比如链表或数等数据结构
       需要产生或操作图形化界面GUI 
       需要直接操作系统硬件
       需要I/O或socket接口
       需要使用库或者遗留下来的老代码的接口
       私人的,闭源的应用(shell脚本把代码就放在文本文件中,全世界都能看到) 

## 第2章  带着一个Sha-Bang出发(Sha-Bang指的是#!) ##
- Example 2-3. cleanup:一个增强的和广义的删除logfile的脚本 
- #!实际上是一个2字节[1]的魔法数字,这是指定一个文件类型的特殊标记

### 2.1 调用一个脚本 ###
- 脚本权限：
       chmod 555 scriptname (允许任何人都具有 可读和执行权限)
       chmod +rx scriptname (允许任何人都具有 可读和执行权限) 
       chmod u+rx scriptname (只给脚本的所有者 可读和执行权限)
- ,在脚本被测试和debug之后,你可能想把它移动到/usr/local/bin(当然是以root身份) ,来让你的脚本对所有用户都有用.这样用户就可以直接敲脚本名字来运行了.
- 那些具有UNIX味道的脚本(基于4.2BSD)需要一个4字节的魔法数字,在#!后边需要一个空格#! /bin/sh.
- 小技巧：#!/bin/rm      #!/bin/more
- 小心:使用sh scriptname来调用脚本的时候将会关闭一些Bash特定的扩展,脚本可能因此而调用失败
- 为什么不直接使用scriptname来调用脚本?如果你当前的目录下($PWD)正好有你想要执行的脚本,为什么它运行不了呢?失败的原因是,出于安全考虑,当前目录并没有被加在用户的$PATH变量中.因此,在当前目录下调用脚本必须使用./scriptname这种形式. 

# 第二部分  基本 #
## 第3章  特殊字符 ##
       #  注释,行首以#开头为注释(#!是个例外).
       ;      命令分隔符,可以用来在一行中来写多个命令. 
       ;;     终止"case"选项. 
       .      .命令等价于source命令(见Example 11-20).这是一个bash的内建命令. 
              .作为文件名的一部分.如果作为文件名的前缀的话,那么这个文件将成为隐藏文件. 将不被ls 命令列出. 
              .字符匹配,这是作为正则表达是的一部分,用来匹配任何的单个字符. 
       "      部分引用."STRING"阻止了一部分特殊字符. 
       '      全引用. 'STRING' 阻止了全部特殊字符.  
       ,      逗号链接了一系列的算术操作,虽然里边所有的内容都被运行了,但只有最后一项被返回. 
       \      转义字符,如\X等价于"X"或'X'. 
       /      文件名路径分隔符.或用来做除法操作. 
       `      后置引用,命令替换
       :      空命令,等价于"NOP"(no op,一个什么也不干的命令).也可以被认为与shell 的内建命令(true)作用相同.":"命令是一个bash的内建命令,它的返回值为0,就是shell返回的true. 
              使用"参数替换"来评估字符串变量，见Example 9-14
              "变量扩展/子串替换" ：在和> (重定向操作符)结合使用时,把一个文件截断到0长度,没有修改它的权限. 如果文件在之前并不存在,那么就创建它.见Example 12-14. 
              在和>>重定向操作符结合使用时,将不会对想要附加的文件产生任何影响. 如果文件不存在,将创建. 注意: 这只适用于正规文件,而不是管道,符号连接,和某些特殊文件. 
              也可能用来作为注释行,虽然我们不推荐这么做.使用#来注释的话,将关闭剩余行的错误检查,所以可以在注释行中写任何东西.然而,使用:的话将不会这样.
              ":"还用来在/etc/passwd和$PATH变量中用来做分隔符. 
       !      取反操作符,将反转"退出状态"结果,(见Example 6-2).也会反转test操作符的意义.
              在一个不同的上下文中,!也会出现在"间接变量引用"见Example 9-22. 
              *  万能匹配字符,用于文件名匹配(这个东西有个专有名词叫file globbing),或者是正则表达式中.注意:在正则表达式匹配中的作用和在文件名匹配中的作用是不同的. 
              数学乘法. **是幂运算. 
       ?      测试操作.在一个确定的表达式中,用?来测试结果.
              在file globbing中和在正则表达式中一样匹配任意的单个字符.
       $      变量替换
              在正则表达式中作为行结束符.
       ${}    参数替换.
       $*,$@  位置参数
       $?     退出状态变量.$?保存一个命令/一个函数或者脚本本身的退出状态. 
       $$     进程ID变量.这个$$变量保存运行脚本进程ID 
       ()     命令组.注意:在()中的命令列表,将作为一个子shell来运行. 在()中的变量,由于是在子shell中,所以对于脚本剩下的部分是不可用的. 
              用在数组初始化
       {xxx,yyy,zzz...}     大括号扩展.  e.g. cp file22.{txt,backup} 
                            一个命令可能会对大括号中的以逗号分割的文件列表起作用[1]. file globbing将对大括号中的文件名作扩展
                            在大括号中,不允许有空白,除非这个空白是有意义的.
       {}     代码块.又被称为内部组.事实上,这个结构创建了一个匿名的函数.但是与函数不同的是,在其中声明的变量,对于脚本其他部分的代码来说还是可见的
              {}中的代码块将不能正常地开启一个新shell
       {} \;  路径名.一般都在find命令中使用.这不是一个shell内建命令. 注意: ";"用来结束find命令序列的-exec选项. 
       []     test. test的表达式将在[]中.值得注意的是[是shell内建test命令的一部分,并不是/usr/bin/test中的扩展命令的一个连接. 
              数组元素
              字符范围.在正则表达式中使用,作为字符匹配的一个范围 
       [[]]   test. test表达式放在[[]]中.(shell关键字) 
       (())   数学计算的扩展
       >&>>&>><      重定向.
                     scriptname >filename 重定向脚本的输出到文件中.覆盖文件原有内容. 
                     command &>filename 重定向stdout和stderr到文件中
                     command >&2  重定向command的stdout到stderr 
                     scriptname >>filename 重定向脚本的输出到文件中.添加到文件尾端,如果没有文件, 则创建这个文件. 
                     进程替换,具体见"进程替换部分",跟命令替换极其类似. 
                            (command)> 
                            <(command) 
       <<     重定向,用在"here document" 
       <<<    重定向,用在"here string"
       <,>    ASCII比较
       \<,\>  正则表达式中的单词边界.
       |      管道.分析前边命令的输出,并将输出作为后边命令的输入.这是一种产生命令链的好方法. 
              注意:管道中的一个进程的stdout必须被下一个进程作为stdin读入.否则,数据流会阻塞,并且管道将产生非预期的行为. 
              如果管道中的某个命令产生了一个异常,并中途失败,那么这个管道将过早的终止. 这种行为被叫做a broken pipe,并且这种状态下将发送一个SIGPIPE信号
       >|     强制重定向(即使设置了noclobber选项--就是-C选项).这将强制的覆盖一个现存文件.
       ||     或-逻辑操作
       &      后台运行命令.一个命令后边跟一个&,将表示在后台运行. 
       &&     与-逻辑操作.
       -      选项,前缀.在所有的命令内如果想使用选项参数的话,前边都要加上"-".
              用于重定向stdin 或stdout. 
              "-"常用于管道后边的命令
              注意:以"-"开头的文件名在使用"-"作为重定向操作符的时候,可能会产生问题. 应该写一个脚本来检查这个问题,并给这个文件加上合适的前缀.
              之前工作的目录."cd -"将回到之前的工作目录,具体请参考"$OLDPWD"环境变量. 注意:一定要和之前讨论的重定向功能分开,但是只能依赖上下文区分. 
              算术减号. 
       =      算术等号,有时也用来比较字符串. 
       +      算术加号,也用在正则表达式中.
              选项,对于特定的命令来说使用"+"来打开特定的选项,用"-"来关闭特定的选项.
       %      算术取模运算.也用在正则表达式中.
       ~      home目录.相当于$HOME变量.
       ~+     当前工作目录,相当于$PWD变量.
       ~-     之前的工作目录,相当于$OLDPWD内部变量. 
       =~     用于正则表达式,这个操作将在正则表达式匹配部分讲解,只有version3才支持.
       ^      行首,正则表达式中表示行首."^"定位到行首.

### 控制字符 ###
       Ctl-B  光标后退,这应该依赖于bash输入的风格,默认是emacs风格的. 
       Ctl-C  Break,终止前台工作. 
       Ctl-D  从当前shell登出(和exit很像) 
       Ctl-G  beep.在一些老的终端,将响铃. 
       Ctl-H  backspace,删除光标前边的字符.
       Ctl-I  就是tab键.
       Ctl-J  新行.
       Ctl-K  垂直tab.作用就是删除光标到行尾的字符. 
       Ctl-L  clear,清屏.
       Ctl-M  回车
       Ctl-Q  继续(等价于XON字符),这个继续的标准输入在一个终端里
       Ctl-S  挂起(等价于XOFF字符),这个被挂起的stdin在一个终端里,用Ctl-Q恢复
       Ctl-U  删除光标到行首的所有字符,在某些设置下,删除全行. 
       Ctl-V  当输入字符时,Ctl-V允许插入控制字符.比如,下边2个例子是等价的
                     echo -e '\x0a' 
                     echo <Ctl-V><Ctl-J> 
              Ctl-V在文本编辑器中十分有用,在vim中一样. 
       Ctl-W  删除当前光标到前边的最近一个空格之间的字符. 在某些设置下,删除到第一个非字母或数字的字符. 
       Ctl-Z  终止前台工作. 

### 空白部分 ###
- "$IFS",对于某些命令输入的特殊变量分割域,默认使用的是空白. 如果想保留空白,使用引用. 

### 注意事项: ###
- shell做大括号的命令扩展.但是命令本身需要对扩展的结果作处理.
- 在pipe中的一个大括号中的代码段可能运行在一个子shell中.

## 第4章 变量和参数的介绍 ##
### 4.1 变量替换 ###
       $  变量替换操作符
- 只有在变量被声明,赋值,unset或exported或者是在变量代表一个signal的时候, 变量才会是以本来的面目出现在脚本里.
- 在""中还是会发生变量替换,这被叫做部分引用,或叫弱引用.而在''中就不会发生变量替换,这叫做全引用,也叫强引用.
- 在赋值的前后一定不要有空格
- $var与${var}的区别,不加{},在某些上下文将引起错误,为了安全,使用2. 
- 一个空值变量,或者是根本就没声明的变量,在赋值之前使用它可能会引起问题. 但是还是可以用来做算术运算
- 对于一个空值变量在做算术操作的时候,就好像它的值为0一样. 
- echo $a和echo "$a"，前者可能丢失空白部分

### 4.2 变量赋值 ###
       =  赋值操作符(前后都不能有空白) 
- 使用$(...)机制进行的变量赋值(除去使用``来赋值的另外一种新方法).事实上这两种方法都是命令替换的一种形式. 来自于/ect/rc.d/rc.local 
       R=$(cat /ect/redhat-release) 
       arch=$(uname -m) 

### 4.3 Bash变量是不分类型的 ###

### 4.4 特殊的变量类型 ###
#### local variables  ####
- 这种变量只有在代码块或者是函数中才可见

#### environmental variables ####
- 这种变量将改变用户接口和shell的行为.
- 注意:分配给环境变量的空间是受限的.创建太多的环境变量将引起空间溢出,这会引起问题.

#### positional parameters  ####
- 从命令行中传进来的参数,$0, $1, $2, $3...
- $0就是脚本文件的名字,$1是第一个参数,$2为第2个...,$9 以后就需要打括号了,如${10},${11},${12}... 
- 两个值得注意的变量$*和$@,表示所有的位置参数.
- $#表示位置参数的个数
- 一些脚本可能会依赖于使用不同的调用名字,而表现出不同的行为,这样一般都需要判断$0,而其他的名字都是通过ln 命令产生的链接.
- 如果脚本需要一个命令行参数,而调用的时候,没用这个参数,这就有可能造成分配一个空变量,这样估计就会引起问题.一种解决办法就是在这个位置参数,和相关的变量后边,都添加一个额外的字符.一个解决这种问题的更简单的做法就是,判断一下这个位置参数是否传递下来。
- 参数替换的更好的办法应该是: `${1:-$DefaultVal} `
- shift  shift命令重新分配位置参数,其实就是向左移动一个位置.$1 <--- $2, $2 <--- $3。老的$1将消失,但是$0(脚本名)是不会改变的。

## 第5章 引用（特指引号） ##
- 引号的特殊效果就是,保护字符串中的特殊字符不被shell或者是shell脚本重新解释或者扩展
- 引用还可以抑制echo命令的换行作用. 

### 5.1 引用变量 ###
- 在一个双引号中直接使用变量名,一般都是没有问题的.它阻止了所有在引号中的特殊字符的重新解释。但是$,`和\除外。
- 使用""来防止单词分割。
       e.g. `variable2=""`
       `COMMAND $variable2 $variable2 $variable2`         # COMMAND将不带参数执行
       `COMMAND "$variable2" "$variable2" "$variable2"`   # COMMAND将以3个空参数来执行       
       `COMMAND "$variable2 $variable2 $variable2"`       # COMMAND将以1个参数来执行(2空格)  



### 5.2 转义(\) ###
- 在某些特定的命令和工具中,比如echo和sed,转义符往往会起到相反的效果, 它反倒有可能引发出这个字符特殊的含义.
       \n     意味着新的一行
       \r     回车
       \t     tab键
       \v     vertical tab(垂直tab),查前边的Ctl-K 
       \b     backspace,查前边的Ctl-H 
       \a     "alert"(如beep或flash) 
       \0xx   转换成8进制ASCII解码,等价于oxx 
       \"     表达引号本身
       \$     $号本身,跟在\$后的变量名,将不能扩展
       \\     \号本身.

- 使用-e选项的echo命令来打印转义符;如果使用$'\X'结构,那-e选项就不必要了
- \的行为依赖于它是否被转义,被"",或者是否在"命令替换"和"here document"中.
- 如果一个脚本以|(管道字符)结束.那么一个\(转义符),就不用非加上不可了. 但是一个好的shell脚本编写风格,还是应该在行尾加上\,以增加可读性. 

## 第6章 退出和退出状态 ##
- exit命令会返回一个值来传给父进程,父进程会判断是否可用. 
- 成功返回0,如果返回一个非0值,通常情况下都会被认为是一个错误码.
- 当一个脚本以不带参数exit来结束时,脚本的退出状态就由脚本中最后执行命令来决定. 
- $?读取最后执行命令的退出码.
- 注意事项: 特定的退出码都有预定的含义(见附录D),用户不应该在自己的脚本中指定他.

## 第7章Tests  ##
### 7.1 Test结构 ###
- 有一个专用命令"["(左中括号,特殊字符).这个命令与test命令等价,但是出于效率上的考虑, 它是一个内建命令.这个命令把它的参数作为比较表达式或是文件测试,并且根据比较的结果, 返回一个退出码. 
- 在版本2.02的Bash中,推出了一个新的[[...]]扩展test命令.注意"[["是一个关键字,并不是一个命令. 
- Bash把[[ $a -lt $b ]]看作一个单独的元素,并且返回一个退出码.
- ((...))和let...结果也能够返回一个退出码,当它们所测试的算术表达式的结果为非0的时候, 他们的退出码将返回0.
- 当if 和then在一个条件测试的同一行中的话,必须使用";"来终止if 表达式.if和then都是关键字.关键字(或者命令)作为一个表达式的开头,并且在一个新的表达式开始之前,必须结束上一个表达式. 
- 注意:test命令是Bash的内建命令,用来测试文件类型和比较字符串.因此,在Bash脚本中,test 并不调用/usr/bin/test的二进制版本(这是sh-utils工具包的一部分).同样的,[并不调用/usr/bin/[,被连接到/usr/bin/test.

- [[]]结构比Bash的[]更加灵活,这是一个扩展的test命令,从ksh88继承过来的.  
- 注意:在[[]]结构中,将没有文件扩展或者是单词分离,但是会发生参数扩展和命令替换. 
- 注意:使用[[]],而不是[],能够阻止脚本中的许多逻辑错误.比如,尽管在[]中将给出一个错误, 但是&&,||,<>操作还是能够工作在一个[[]]test之中. 

- if 命令将返回if 后边的命令的退出码.
- (())结构扩展并计算一个算术表达式的结果.如果表达式的结果为0,它将返回1作为退出码,或者是"false".而一个非0表达式的结果将返回0作为退出码,或者是"true". 

### 7.2 文件测试操作 ###
       -e            文件存在
       -a            文件存在
                     这个选项的效果与-e相同.但是它已经被弃用了,并且不鼓励使用
       -f            file是一个regular文件(不是目录或者设备文件) 
       -s            文件长度不为0 
       -d            文件是个目录
       -b            文件是个块设备(软盘,cdrom等等) 
       -c            文件是个字符设备(键盘,modem,声卡等等) 
       -p            文件是个管道
       -h            文件是个符号链接
       -L            文件是个符号链接
       -S            文件是个socket 
       -t            关联到一个终端设备的文件描述符
                     这个选项一般都用来检测是否在一个给定脚本中的stdin[-t0]或[-t1]是一个终端
       -r            文件具有读权限(对于用户运行这个test) 
       -w            文件具有写权限(对于用户运行这个test) 
       -x            文件具有执行权限(对于用户运行这个test) 
       -g            set-group-id(sgid)标志到文件或目录上
                     如果一个目录具有sgid标志,那么一个被创建在这个目录里的文件,这个目录属于创建这个目录的用户组,并不一定与创建这个文件的用户的组相同.对于workgroup的目录共享来说,这非常有用.见<<UNIX环境高级编程中文版>>第58页. 
       -u            set-user-id(suid)标志到文件上
                     如果运行一个具有root权限的文件,那么运行进程将取得root权限,即使你是一个普通用户.[1]这对于需要存取系统硬件的执行操作(比如pppd和cdrecord)非常有用.如果没有suid标志的话,那么普通用户(没有root权限)将无法运行这种程序. 见<<UNIX环境高级编程中文版>>第58页. 
                     -rwsr-xr-t 1 root 178236 Oct 2 2000 /usr/sbin/pppd 
                     对于设置了suid的文件,在它的权限标志中有"s". 
       -k            设置粘贴位,见<<UNIX环境高级编程中文版>>第65页. 
                     对于"sticky bit",save-text-mode标志是一个文件权限的特殊类型.如果设置了这个标志,那么这个文件将被保存在交换区,为了达到快速存取的目的.如果设置在目录中,它将限制写权限.对于设置了sticky bit位的文件或目录,权限标志中有"t". 
                     drwxrwxrwt 7 root 1024 May 19 21:26 tmp/ 
                     如果一个用户并不时具有stick bit位的目录的拥有者,但是具有写权限,那么用户只能在这个目录下删除自己所拥有的文件.这将防止用户在一个公开的目录中不慎覆盖或者删除别人的文件,比如/tmp(当然root或者是目录的所有者可以随便删除或重命名其中的文件). 
       -O            你是文件的所有者. 
       -G            文件的group-id和你的相同. 
       -N            从文件最后被阅读到现在,是否被修改. 
       f1 -nt f2     文件f1比f2新
       f1 -ot f2     f1比f2老
       f1 -ef f2     f1和f2都硬连接到同一个文件. 
       !             非--反转上边测试的结果(如果条件缺席,将返回true) 

### 7.3 其他比较操作 ###
#### 整数比较 ####
       -eq    等于,如:if [ "$a" -eq "$b" ] 
       -ne    不等于,如:if [ "$a" -ne "$b" ] 
       -gt    大于,如:if [ "$a" -gt "$b" ] 
       -ge    大于等于,如:if [ "$a" -ge "$b" ] 
       -lt    小于,如:if [ "$a" -lt "$b" ] 
       -le    小于等于,如:if [ "$a" -le "$b" ] 
       <      小于(需要双括号),如:(("$a" < "$b")) 
       <=     小于等于(需要双括号),如:(("$a" <= "$b")) 
       >      大于(需要双括号),如:(("$a" > "$b")) 
       >=     大于等于(需要双括号),如:(("$a" >= "$b")) 

#### 字符串比较 ####
       =      等于
       ==     等于
                     注意:==的功能在[[]]和[]中的行为是不同的: 
                     [[ $a == z* ]]     # 如果$a以"z"开头(模式匹配)那么将为true 
                     [[ $a == "z*" ]]   # 如果$a等于z*(字符匹配),那么结果为true 
                     [ $a == z* ]       # File globbing 和word splitting将会发生
                     [ "$a" == "z*" ]   # 如果$a等于z*(字符匹配),那么结果为true 
       !=     不等于
                     这个操作符将在[[]]结构中使用模式匹配. 
       <      小于,在ASCII字母顺序下
                     注意:在[]结构中"<"需要被转义. 
       >      大于,在ASCII字母顺序下
                     注意:在[]结构中">"需要被转义. 
       -z     字符串为"null".就是长度为0. 
       -n     字符串不为"null" 
                     注意: 使用-n在[]结构中测试必须要用""把变量引起来.

#### 混合比较 ####
       -a     逻辑与
              exp1 -a exp2 如果exp1和exp2都为true的话,这个表达式将返回true 
       -o     逻辑或
              exp1 -o exp2 如果exp1和exp2中有一个为true的话,那么这个表达式就返回true 

### 7.4 嵌套的if/then 条件test  ###

### 7.5 检查你的test知识 ###

## 第8章 操作符和相关的主题 ##
### 8.1 操作符 ###
#### 等号操作符 ####
#### 算术操作符 ####
- `**`  幂运算
- Bash并不能理解浮点运算.它把包含的小数点看作字符串.
- 如果真想做浮点运算的话使用bc,bc可以进行浮点运算或调用数学库函数.

#### 位操作符.  ####
       <<     左移1位(每次左移都将乘2) 
       <<=    左移几位,=号后边将给出左移几位
       >>     右移1位(每次右移都将除2) 
       >>=    右移几位
       &=     按位与赋值
       |=     按位或赋值
       ^=     异或赋值

#### 逻辑操作 ####
- 注意&&不允许出现在[ ... ]中.能出现在[[ ... ]]中.
- 注意||不允许出现在[ ... ]中.能出现在[[ ... ]]中.

#### 混杂操作 ####
       ,      逗号操作符
              主要用在for循环中

### 8.2 数字常量 ###
- shell脚本默认都是将数字作为10进制数处理,除非这个数字某种特殊的标记法或前缀开头. 以0开头就是8进制.以0x开头就是16进制数.使用BASE#NUMBER这种形式可以表示其它进制表示法

# 第三部分  超越基本 #
## 第9章  变量重游 ##
### 9.1 内部变量 ###
#### Builtin variable ####
       $BASH                这个变量将指向Bash的二进制执行文件的位置.
       $BASH_ENV            这个环境变量将指向一个Bash启动文件,这个启动文件将在调用一个脚本时被读取.
       $BASH_SUBSHELL       这个变量将提醒subshell的层次,这是一个在version3才被添加到Bash中的新特性. 
       $BASH_VERSINFO[n]    记录Bash安装信息的一个6元素的数组.与下边的$BASH_VERSION很像,但这个更加详细. 
       $BASH_VERSION        安装在系统上的Bash的版本号. 
       $DIRSTACK            在目录栈中最上边的值(将受到pushd和popd的影响). 这个内建的变量与dirs命令是保持一致的,但是dirs命令将显示目录栈的整个内容. 
       $EDITOR              脚本调用的默认编辑器,一般是vi或者是emacs. 
       $EUID                "effective"用户ID号. 当前用户被假定的任何id 号.可能在su命令中使用. 注意:$EUID并不一定与$UID相同. 
       $FUNCNAME            当前函数的名字.
       $GLOBIGNORE          一个文件名的模式匹配列表,如果在file globbing中匹配到的文件包含这个列表中的某个文件,那么这个文件将被从匹配到的文件中去掉. 
       $GROUPS              当前用户属于的组. 这是一个当前用户的组id 列表(数组),就像在/etc/passwd中记录的一样. 
       $HOME                用户的home目录
       $HOSTNAME            hostname命令将在一个init 脚本中,在启动的时候分配一个系统名字. gethostname()函数将用来设置这个$HOSTNAME内部变量.
       $HOSTTYPE            主机类型
       $IFS                 内部域分隔符. 这个变量用来决定Bash在解释字符串时如何识别域,或者单词边界. $IFS默认为空白(空格,tab,和新行),但可以修改,比如在分析逗号分隔的数据文件时. 注意:$*使用$IFS中的第一个字符
       $IGNOREEOF           忽略EOF: 告诉shell在log out 之前要忽略多少文件结束符(control-D). 
       $LC_COLLATE          常在.bashrc或/etc/profile中设置,这个变量用来在文件名扩展和模式匹配校对顺序. 如果$LC_COLLATE被错误的设置,那么将会在filename globbing中引起错误的结果. 
       $LC_CTYPE            这个内部变量用来控制globbing和模式匹配的字符串解释. 
       $LINENO              这个变量记录它所在的shell脚本中它所在行的行号.这个变量一般用于调试目的. 
       $MACHTYPE            系统类型,提示系统硬件
       $OLDPWD              老的工作目录("OLD-print-working-directory",你所在的之前的目录) 
       $OSTYPE              操作系统类型. 
       $PATH                指向Bash外部命令所在的位置,一般为/usr/bin,/usr/X11R6/bin,/usr/local/bin等. 
       $PIPESTATUS          数组变量将保存最后一个运行的前台管道的退出码.
                            有趣的是,这个退出码和最后一个命令.运行的退出码并不一定相同. 
                            $PIPESTATUS数组的每个成员都会保存一个管道命令的退出码,$PIPESTATUS[0]保存第一个管道命令的退出码,$PIPESTATUS[1]保存第2个,以此类推. 
                            注意:$PIPESTATUS变量在一个login shell 中可能会包含一个错误的0值(3.0以下版本) 
                            注意:在某些上下文$PIPESTATUS可能不会给出正确的结果. 
                            PIPESTATUS[@],所有值
                            $PIPESTATUS是一个"volatile"变量.在任何命令插入之前,并且在pipe询问之后, 这个变量需要立即被捕捉. 
       $PPID                一个进程的$PPID就是它的父进程的进程id(pid)
       $PROMPT_COMMAND      这个变量保存一个在主提示符($PS1)显示之前需要执行的命令. 
       $PS1                 主提示符
       $PS2                 第2提示符,当你需要额外的输入的时候将会显示,默认为">". 
       $PS3                 第3提示符,在一个select循环中显示
       $PS4                 第4提示符,当使用-x选项调用脚本时,这个提示符将出现在每行的输出前边. 默认为"+". 
       $PWD                 工作目录(你当前所在的目录). 与pwd内建命令作用相同. 
       $REPLY               read命令如果没有给变量,那么输入将保存在$REPLY中.在select菜单中也可用,但是只提供选择的变量的项数,而不是变量本身的值. 
       $SECONDS             这个脚本已经运行的时间(单位为秒).
       $SHELLOPTS           这个变量里保存shell允许的选项,这个变量是只读的. 
       $SHLVL               Shell层次,就是shell层叠的层次,如果是命令行那$SHLVL就是1,如果命令行执行的脚本中,$SHLVL就是2,以此类推. 
       $TMOUT               如果$TMOUT环境变量被设置为一个非零的时间值,那么在过了这个指定的时间之后, shell提示符将会超时,这会引起一个logout. 
       $UID                 用户ID号. 当前用户的id 号,在/etc/passwd中记录. 这个值不会因为用户使用了su命令而改变.$UID是只读变量,不容易在命令行或者是脚本中被修改,并且和内建的id 命令很相像. 

- 注意
       变量$ENV,$LOGNAME,$MAIL,$TERM,$USER,和$USERNAME并不是Bash的内建变量.它们经常被设置成环境变量,它们一般都放在Bash的安装文件中.
       $SHELL,用户登录的shell的名字,可能是从/etc/passwd设置的,也可能是在一个"init"脚本中设置的,同样的,它也不是Bash的内建变量. 

#### 位置参数 ####
       $0, $1, $2    位置参数,从命令行传递给脚本,或者是传递给函数.或者赋职给一个变量.
       $#            命令行或者是位置参数的个数.
       $*            所有的位置参数,被作为一个单词. 注意:"$*"必须被""引用. 
       $@            与$*同义,但是每个参数都是一个独立的""引用字串,这就意味着参数被完整地传递, 并没有被解释和扩展.这也意味着,每个参数列表中的每个参数都被当成一个独立的单词. 注意:"$@"必须被引用.

- 在shift命令后边,$@将保存命令行中剩余的参数,而$1被丢掉了. 
- 注意:$*和$@的参数有时会不一致,发生令人迷惑的行为,这依赖于$IFS的设置. 
- 注意:$@和$*中的参数只有在""中才会不同.

#### 其他的特殊参数 ####
       $-     传递给脚本的flag(使用set命令).注意:这起初是ksh的特征,后来被引进到Bash中,但不幸的是,在Bash中它看上去也不能可靠的工作
       $!     在后台运行的最后的工作的PID(进程ID). 
       $_     保存之前执行的命令的最后一个参数.
       $?     命令,函数或者脚本本身的退出状态.
       $$     脚本自身的进程ID.这个变量经常用来构造一个"unique"的临时文件名. 

### 9.2 操作字符串 ###
- 字符串长度
       ${#string} 
       expr length $string 
       expr "$string" : '.*' 
- 从字符串开始的位置匹配子串的长度
       expr match "$string" '$substring'         $substring是一个正则表达式
       expr "$string" : '$substring'             $substring是一个正则表达式
- 索引
       expr index $string $substring             匹配到子串中任一字符的第一个字符的位置. 
- 提取子串
       ${string:position}                        在string中从位置$position开始提取子串. 如果$string为"*"或"@",那么将提取从位置$position开始的位置参数,[1] 
       ${string:position:length}                 在string中从位置$position开始提取$length长度的子串. 
                                                 以${parameter:-default}方式,默认是提取完整地字符串. 
                                                 可以使用圆括号或者添加一个空格来转义这个位置参数. 
                                                 如果$string参数为"*"或"@",那将最大的提取从$position开始的$length个位置参数.
       expr substr $string $position $length     在string中从位置$position开始提取$length长度的子串. 
       expr match "$string" '\($substring\)'     从$string的开始位置提取$substring,$substring是一个正则表达式. 
       expr "$string" : '\($substring\)'         从$string的开始位置提取$substring,$substring是一个正则表达式. 
- 子串削除
       ${string#substring}         从$string的左边截掉第一个匹配的$substring（最近的匹配） 
       ${string##substring}        从$string的左边截掉最后一个匹配的$substring（最远的匹配） 
       ${string%substring}         从$string的右边截掉第一个匹配的$substring 
       ${string%%substring}        从$string的右边截掉最后一个匹配的$substring
- 子串替换
       ${string/substring/replacement}    使用$replacement来替换第一个匹配的$substring. 
       ${string//substring/replacement}   使用$replacement来替换所有匹配的$substring. 
       ${string/#substring/replacement}   如果$substring匹配$string的开头部分,那么就用$replacement来替换$substring. 
       ${string/%substring/replacement}   如果$substring匹配$string的结尾部分,那么就用$replacement来替换$substring. 

#### 9.2.1 使用awk来操作字符串 ####
- 注意,对于awk和Bash来说,它们使用的是不同的string索引系统: 
       Bash 的第一个字符是从'0'开始记录的. 
       Awk 的第一个字符是从'1'开始记录的. 

#### 9.2.2 更深的讨论 ####

### 9.3 参数替换 ###
#### 操作和扩展变量 ####
       ${parameter}         与$parameter相同,就是parameter的值.
       ${parameter-default},${parameter:-default}       如果parameter没被set,那么就使用default.
       这两种办法绝大部分时候是相同的. 额外的":"在parameter被声明的时候(而且被赋空值),会有一些不同. 
       ${parameter=default},${parameter:=default}       如果parameter未设置,那么就设置为default. 
       这两种办法绝大多数时候用法都一样,只有在$parameter被声明并设置为空的时候, 才会有区别
       ${parameter+alt_value},${parameter:+alt_value}   如果parameter被set了,那就使用alt_value,否则就使用null字符串.
       这两种办法绝大多数时候用法都一样,只有在$parameter被声明并设置为空的时候, 会有区别
       ${parameter?err_msg}, ${parameter:?err_msg}      如果parameter被set,那就是用set的值,否则print err_msg. 
       这两种办法绝大多数时候用法都一样,只有在$parameter被声明并设置为空的时候, 会有区别
       ${parameter?err_msg}, ${parameter:?err_msg}      如果parameter被set,那就是用set的值,否则print err_msg. 
       这两种办法绝大多数时候用法都一样,只有在$parameter被声明并设置为空的时候, 会有区别

#### 参数替换和扩展 ####

#### 变量长度/子串删除 ####
       ${#var}       字符串长度($var的字符数量).对于一个数组,${#array}是数组中第一个元素的长度. 
                     一些例外: 
                     ${#*}和${#@}将给出位置参数的个数. 
                     对于数组来说${#array[*]}和${$#array[@]}将给出数组元素的个数. 
       ${var#Pattern}, ${var##Pattern}    从$var开头删除最近或最远匹配$Pattern的子串. 
       ${var%Pattern}, ${var%%Pattern}    从$var结尾删除最近或最远匹配$Pattern的子串. 

#### 变量扩展/子串替换 ####
       ${var:pos}                         变量var从位置pos开始扩展. 
       ${var:pos:len}                     从位置pos开始,并扩展len 长度个字符.
       ${var/Pattern/Replacement}         使用Replacement来替换var中的第一个Pattern的匹配. 
       ${var//Pattern/Replacement}        全局替换.在var中所有的匹配,都会用Replacement来替换. 
       ${var/#Pattern/Replacement}        如果var的前缀匹配到了Pattern,那么就用Replacement来替换Pattern. （必须在开头或结尾匹配）
       ${var/%Pattern/Replacement}        如果var的后缀匹配到了Pattern,那么就用Replacement来替换Pattern. （必须在开头或结尾匹配）
       ${!varprefix*}, ${!varprefix@}     使用变量的前缀来匹配前边所有声明过的变量.

### 9.4 指定类型的变量:declare或者typeset ###
- declare或者typeset内建命令(这两个命令是完全一样的)允许指定变量的具体类型.在某些特定的语言中,这是一种指定类型的很弱的形式

#### declare/typeset 选项 ####
       -r 只读         这和C语言中的const关键字一样,都是强制指定只读.如果你尝试修改一个只读变量的值,那么你将得到一个错误消息. 
       -i 整形         如果把一个变量指定为整形,那么即使没有expr和let 命令,也允许使用特定的算术运算 
       -a 数组
       -f 函数         如果使用declare -f而不带参数的话,将会列出这个脚本中之前定义的所有函数
       -x export
- 注意:使用declare内建命令将会限制变量的作用域. 

### 9.5 变量的间接引用 ###
- eval var1=\$$var2
- 间接引用给Bash添加了一种类似于C语言指针的功能
- Bash并不支持指针的算术运算,并且这严格的限制了间接引用的使用.

### 9.6 $RANDOM: 产生随机整数 ###
- $RANDOM是Bash的内部函数(并不是常量),这个函数将返回一个范围在0 - 32767之间的一个伪随机整数.它不应该被用来产生密匙. 
- Bill Gradwohl 提出了一个重要的规则来产生正数. 
`rnumber=$(((RANDOM%(max-min+divisibleBy))/divisibleBy*divisibleBy+min))` 
- /dev/urandom设备文件提供了一种比单独使用$RANDOM更好的,能产生更"随机"的随机数的方法. 
 `dd if=/dev/urandom of=targetfile bs=1 count=XX`能够产生一个很分散的为随机数.
- 真正的随机事件(在它存在的范围内),只发生在特定的几个未知的自然界现象中,比如放射性衰变.
- 计算机产生的伪随机数序列用的种子可以被看成是一种标识标签.比如,使用种子23所 产生的伪随机数序列就被称作序列#23. 
- 一个伪随机序列的特点就是在这个序列开始重复之前的所有元素的个数的和,也就是这个序列的长度.

### 9.7 双圆括号结构 ###
- ((...))与let 命令很像,允许算术扩展和赋值.
- 双圆括号也是一种在Bash中允许使用C风格的变量处理的机制.

## 第10章 循环和分支 ##
### 10.1 循环 ###
#### for ####
       for arg in [list] 
       do 
              command(s)... 
       done 
- 每个[list]中的元素都可能包含多个参数.在处理参数组时,这是非常有用的. 在这种情况下,使用set命令(见Example 11-15)来强制解析每个[list]中的元素, 并且分配每个解析出来的部分到一个位置参数中
- 如果在for循环的[list]中有通配符(*和?),那将会产生文件名扩展,也就是file globbing. 
- 在"globbing"中,是不能比配"."文件的. 
- 在一个for循环中忽略[list]的话,将会使循环操作$@(从命令行传递给脚本的参数列表). 
- for循环的输出也可以通过管道传递到一个或多个命令中. 

#### while ####
       while [condition] 
       do 
              command... 
       done 
- while循环的stdin可以用<来重定向到文件. 
- whild循环的stdin支持管道.

#### until  ####
       until [condition-is-true] 
       do 
              command... 
       done 

### 10.2 嵌套循环 ###

### 10.3 循环控制 ###
- break,continue
- break命令可以带一个参数.一个不带参数的break循环只能退出最内层的循环,而break N 可以退出N层循环.
- continue命令也可以带一个参数.一个不带参数的continue命令只去掉本次循环的剩余代码.而continue N将会把N层循环剩余的代码都去掉,但是循环的次数不变.
- 这两个命令是shell的内建命令,而不像其它的循环命令那样,比如while和case,这两个是关键字

### 10.4 测试与分支(case和select结构)  ###
#### case (in) / esac  ####
       case "$variable" in 
       "$condition1") 
       command... 
       ;; 
       esac 
- 对变量使用""并不是强制的,因为不会发生单词分离.

#### select ####
       select variable [in list] 
       do 
       command... 
       break 
       done 
- select结构是建立菜单的另一种工具,这种结构是从ksh中引入的. 
- 提示用户选择的内容比如放在变量列表中.注意:select命令使用PS3提示符[默认为(#? )] ,但是可以修改PS3. 
- 如果忽略了in list 列表,那么select命令将使用传递到脚本的命令行参数,或者是函数参数前提是将select写到这个函数中. 

## 第11章 内部命令与内建 ##
- 内建命令指的就是包含在Bash工具集中的命令.
- 内建命令将比外部命令的执行得更快,外部命令通常需要fork出一个单独的进程来执行.另外一部分原因是特定的内建命令需要直接存取shell内核部分. 
- 一个内建命令通常与一个系统命令同名,但是Bash在内部重新实现了这些命令.
- 与内建命令相同的是,关键字也是Bash的骨干部分, 但是与内建命令不同的是,关键字自身并不是命令,而是一个比较大的命令结构的一部分.

### I/O类 ###
#### echo  ####
- echo需要使用-e参数来打印转移字符.
- 一般的每个echo命令都会在终端上新起一行,但是-n选项将会阻止新起一行. 
- 注意:echo `command`将会删除任何有命令产生的换行符.
- $IFS(内部域分隔符)一般都会将\n(换行符)包含在它的空白字符集合中.Bash因此会根据参数中的换行来分离命令的输出.然后echo将以空格代替换行来输出这些参数.
- 注意: 这个命令是shell的一个内建命令,与/bin/echo不同,虽然行为相似.

#### printf ####
- `printf format-string... parameter...` 这是Bash的内建版本

#### read  ####
- 从stdin中读取一个变量的值,也就是与键盘交互取得变量的值.使用-a参数可以取得数组变量
- 一个不带变量参数的read命令,将把来自键盘的输入存入到专用变量$REPLY中.
- 通常情况下,在使用read命令时,输入一个\然后回车,将会阻止产生一个新行.-r 选项将会 让\转义.
- read命令有些有趣的选项,这些选项允许打印出一个提示符,然后在不输入<ENTER>的情况下,可以读入你的按键字符:
       -s 选项意味着不打印输入. 
       -n N 选项意味着直接受N个字符的输入. 
       -n选项也可以检测方向键,和一些控制按键
       -n选项将不会检测ENTER(新行)键.
       -p 选项意味着在读取输入之前打印出后边的提示符.
- read命令也可以从重定向的文件中读入变量的值.如果文件中的内容超过一行,那么只有第一行被分配到这个变量中.如果read命令有超过一个参数,那么每个变量都会从文件中取得以定义的空白分隔的字符串作为变量的值.
- `read var2 var3`
       重新从文件的开头开始读入变量. 
       每个变量都设置成了以空白分割的字符串, 而不是之前的以整行的内容作为变量的值. 
       而最后一个变量将会取得第一行剩余的全部部分(不管是否以空白分割). 
       如果需要赋值的变量的个数比文件中第一行一空白分割的字符串的个数多的话, 那么这些变量将会被赋空值. 
- 若想读出每行：
       while read line 
       do 
              echo "$line" 
       done <data-file 
- 注意:管道输出到一个read命令中,使用管道echo输出到read会失败. 然而使用管道cat输出看起来能够正常运行.

### 文件系统类 ###
#### cd ####
       -P(physical)选项的作用是忽略符号连接. 
       cd - 将把工作目录改为$OLDPWD,就是之前的工作目录. 

#### pwd  ####
- 打印当前的工作目录.这将给用户(或脚本)当前的工作目录.使用这个命令的结果和从内键变量$PWD中读取的值是相同的. 

#### pushd, popd, dirs  ####
- 这几个命令可以使得工作目录书签化,就是可以按顺序向前或向后移动工作目录. 压栈的动作可以保存工作目录列表.选项可以允许对目录栈作不同的操作. 
       pushd dir-name       把路径dir-name压入目录栈,同时修改当前目录到dir-name. 
       popd                 将目录栈中最上边的目录弹出,同时修改当前目录到弹出来的那个目录. 
       dirs                 列出所有目录栈的内容(与$DIRSTACK便两相比较).一个成功的pushd或者popd将会自动的调用dirs命令. 
- 对于那些并没有对当前工作目录做硬编码,并且需要对当前工作目录做灵活修改的脚本来说,使用这些命令是再好不过的了.注意内建$DIRSTACK数组变量,这个变量可以在脚本内存取, 并且它们保存了目录栈的内容. 

### 变量类 ###
#### let  ####
- let 命令将执行变量的算术操作.在许多情况下,它被看作是复杂的expr版本的一个简化版. 

#### eval  ####
- `eval arg1 [arg2] ... [argN]` 
将表达式中的参数,或者表达式列表,组合起来,并且评估它们.包含在表达式中的任何变量都将被扩展.结果将会被转化到命令中.
- eval命令是有风险的,如果有更合适的方法来实现功能的话,尽量要避免使用它. 

#### set ####
- set命令用来修改内部脚本变量的值.
- 一个作用就是触发选项标志位来帮助决定脚本的行为.另一个应用就是以一个命令的结果(set `command`)来重新设置脚本的位置参数.
- 不使用任何选项或参数来调用set命令的话,将会列出所有的环境变量和其他所有的已经初始化过的命令. 
- 使用参数--来调用set命令的话,将会明确的分配位置参数.如果--选项后边没有跟变量名的话,那么结果就使所有位置参数都比unset了. 

#### unset #### 
- unset命令用来删除一个shell变量,效果就是把这个变量设为null.注意:这个命令对位置参数无效. 

#### export  ####
- 没有办法将变量export到父进程
- 在某些情况下使用`export var1=xxx`这种形式,将与先设置变量,然后export变量效果不同. 
       bash$ export var=(a b); echo ${var[0]}    ：      (a b) 
       bash$ var=(a b); export var; echo ${var[0]}     ：      a 

#### declare, typeset ####
- declare和typeset命令被用来指定或限制变量的属性. 

#### readonly #### 
- 与declare -r作用相同,设置变量的只读属性,也可以认为是设置常量

#### getopts  ####
- 可以说这是分析传递到脚本的命令行参数的最强力工具.这个命令与getopt外部命令,和C语言中的库函数getopt的作用是相同的.它允许传递和连接多个选项[2]到脚本中,并能分配多个参数到脚本中. 
- getopts结构使用两个隐含变量.$OPTIND是参数指针(选项索引),和$OPTARG(选项参数) (可选的)可以在选项后边附加一个参数.在声明标签中,选项名后边的冒号用来提示这个选项名已经分配了一个参数. 
- getopts结构通常都组成一组放在一个while循环中,循环过程中每次处理一个选项和参数, 然后增加隐含变量$OPTIND的值,再进行下一次的处理. 
- 通过命令行传递到脚本中的参数前边必须加上一个减号(-).事实上,getopts不会处理不带"-"前缀的参数,如果第一个参数就没有"-",那么将结束选项的处理. 
- 使用getopts的while循环模版还是与标准的while循环模版有些不同.没有标准while循环中的[]判断条件. 
- 3.getopts结构将会取代getopt外部命令.

### 脚本行为 ###
#### source, . (点命令)  ####
- 在一个文件内一个source file-name 将会加载file-name文件.source一个文件(或点命令)将会在脚本中引入代码,并附加到脚本中(与C语言中的#include指令的效果相同).*
- 也可以向需要source的脚本中传递参数.这些参数在source脚本中被认为是位置参数. `source $filename $arg1 arg2` 

#### exit ####
- 如果不带参数，等价于exit $?.

#### exec ####
- 这个shell内建命令将使用一个特定的命令来取代当前进程.使用exec内建命令,shell就不会fork了,并且命令的执行将会替换掉当前shell.因此,当我们在脚本中使用它时,当命令实行完毕, 它就会强制退出脚本.
- exec命令还能用于重新分配文件描述符.比如: `exec <zzz-file>`将会用zzz-file来代替stdin. 
- 注意: find命令的-exec选项与shell内建的exec命令是不同的. 

#### shopt ####
- 这个命令允许shell在空闲时修改shell选项.
- 它经常出现在启动脚本中,但是在一般脚本中也可用

#### caller ####
- 将caller命令放到函数中,将会在stdout上打印出函数调用者的信息. 
- caller命令也可以返回在一个脚本中被source的另一个脚本的信息.象函数一样,这是一个"子例程调用",你会发现这个命令在调试的时候特别有用. 

### 命令类 ###
#### ture ####
#### flase  ####
#### type[cmd] ####
- 与which扩展命令很相像,type cmd将给出"cmd"的完整路径.与which命令不同的是,type命令是Bash内建命令.
- 一个很有用的选项是-a选项,使用这个选项可以鉴别所识别的参数是关键字还是内建命令,也可以定位同名的系统命令. 

#### hash[cmds] ####
- 在shell的hash表中,记录指定命令的路径名,所以在shell或脚本中在调用这个命令的话,shell或脚本将不需要再在$PATH中重新搜索这个命令了.
- 如果不带参数的调用hash命令,它将列出所有已经被hash的命令.-r 选项会重新设置hash表. 

#### bind ####
- bind内建命令用来显示或修改readline的键绑定

#### help ####
- 获得shell内建命令的一个小的使用总结.这与whatis命令比较象,但是help是内建命令. 

### 11.1 作业控制命令 ###
#### jobs ####
- 在后台列出所有正在运行的作业,给出作业号.
- 注意: 进程和作业的概念太容易混淆了.特定的内建命令,比如kill,disown和wait即可以接受一个作业号作为参数也可以接受一个进程作为参数.但是fg,bg和jobs命令只能接受
作业号作为参数. 
- "1"是作业号(作业是被当前shell所维护的),而"1384"是进程号(进程是被系统维护的).为了kill掉作业/进程,或者使用`kill %1`命令或者使用`kill 1384`命令

#### disown #### 
- 从shell的当前作业表中,删除作业. 

#### fg,bg #### 
- fg命令可以把一个在后台运行的作业放到前台来运行.而bg命令将会重新启动一个挂起的作业,并且在后台运行它.
- 如果使用fg或者bg命令的时候没指定作业号,那么默认将对当前正在运行的作业做操作. 

#### wait #### 
- 停止脚本的运行,直到后台运行的所有作业都结束为止,或者直到指定作业号或进程号为选项的作业结束为止. 
- 可以使用wait命令来防止在后台作业没完成(这会产生一个孤儿进程)之前退出脚本.
- wait 也可以接受一个作业标识符作为参数,比如`wait %1`或`wait $PPID`.
- 在一个脚本中,使用一个后台运行的命令(使用&)可能会使这个脚本挂起,直到敲回车,挂起才会被恢复.看起来只有这个命令的结果需要输出到stdout的时候才会发生这种现象.
       在这个后台运行命令的后边放上一个wait命令可能会解决这个问题.
       如果把这个后台运行命令的输出重定向到文件中或者重定向到/dev/null中,也能解决这个问题.

#### suspend #### 
- 这个命令的效果与Control-Z很相像,但是它挂起的是这个shell(这个shell的父进程应该在合适的时候重新恢复它). 

#### logout ####t 
- 退出一个登陆的shell,也可以指定一个退出码. 

#### times #### 
- 给出执行命令所占的时间

#### kill #### 
- 通过发送一个适当的结束信号,来强制结束一个进程
- kill -l将列出所有信号. kill -9 是"必杀"命令,这个命令将会结束哪些顽固的不想被kill掉的进程.有时候kill -15也可以干这个活.一个僵尸进程不能被登陆的用户kill掉, 因为你不能杀掉一些已经死了的东西,但是init 进程迟早会把它清除干净.
- 僵尸进程就是子进程已经结束掉,而父进程却没kill掉这个子进程, 那么这个子进程就成为僵尸进程. 

#### command #### 
- command命令会禁用别名和函数的查找.它只查找内部命令以及搜索路径中找到的脚本或可执行程序.
- 只在要执行的命令与函数或别名同名时使用,因为函数的优先级比内建命令的优先级高
- bash执行命令的优先级: 
       1.别名
       2.关键字
       3.函数
       4.内置命令
       5.脚本或可执行程序($PATH) 

#### builtin #### 
- 在"builtin"后边的命令将只调用内建命令.暂时的禁用同名的函数或者是同名的扩展命令. 

#### enable #### 
- 这个命令或者禁用内建命令或者恢复内建命令.
- `enable -n`禁用,`-a`选项将会恢复相应的内建命令,如果不带参数的话,将会恢复所有的内建命令. `-f filename`将会从适当的编译过的目标文件中以共享库(DLL)的形式来加载一个内建命令. 

#### autoload #### 
- 这是从ksh的autoloader命令移植过来的.一个带有"autoload"声明的函数,在它第一次被调用的时候才会被加载.这样做会节省系统资源.
- autoload命令并不是Bash安装时候的核心命令的一部分.这个命令需要使用命令`enable -f`来加载.

### 作业标识符 ###
       记法           含义
       %N            作业号[N] 
       %S            以字符串S开头的被(命令行)调用的作业
       %?S           包含字符串S的被(命令行)调用的作业
       %%            当前作业(前台最后结束的作业,或后台最后启动的作业) 
       %+            当前作业(前台最后结束的作业,或后台最后启动的作业) 
       %-            最后的作业
       $!            最后的后台进程

### 注意事项 ###
- time命令,Bash官方文档说这个命令是一个关键字
- 一个选项就是一个行为上比较象标志位的参数,可以用来打开或关闭脚本的某些行为. 而和某个特定选项相关的参数就是用来控制这个选项功能是开启还是关闭的. 
- `typeset -fu`可以达到和autoload命令相同的作用. 

## 第12章 外部过滤器,程序和命令 ##
### 12.1 基本命令 ###
#### ls ####
       -R 选项,这是递归选项
       -S 选项,将会按照文件尺寸列出所有文件
       -t 选项,将会按照修改时间来列出文件
       -i 选项,会显示文件的inode
       -l 选项,将给出一个"长"文件列表.
       -F 选项,将标记出文件类型(比如: 目录是以/结尾, 而可执行文件以*结尾). 

#### cat, tac #### 
- cat, 是单词concatenate的缩写, 把文件的内容输出到stdout. 当与重定向操作符(> 或>>)结合使用时, 一般都是用来将多个文件连接起来. 
       -n 选项是为了在目标文件中的所有行前边插入行号. 
       -b 选项 与-n 选项一样, 区别是不对空行进行编号. 
       -v 选项可以使用^ 标记法 来echo 出不可打印字符.
       -s 选 项可以把多个空行压缩成一个空行.
- tac 命令, 就是cat的反转, 将从文件的结尾列出文件. 

#### rev #### 
- 把每一行中的内容反转, 并且输出到stdout上. 这个命令与tac命令的效果是不同的, 因为它并不反转行序, 而是把每行的内容反转. 

#### cp ####
- 如果存在file2 的话,那file2 将被覆盖
       -a  归档 选项(为了copy一个完整的目录树)
       -u 是更新选项
       -r 与-R 递归选项. 

#### mv ####
- 当使用非交互脚本时,可以使用mv 的-f (强制) 选项来避免用户的输入. 

#### rm ####
- 注意: rm 将无法删除以破折号开头的文件.
       解决这个问题的一个方法就是在要删除的文件的前边加上"./". 
       另一种解决的方法是 在文件名前边加上 " -- ". 

#### rmdir ####
- 只有这个目录中没有文件（包含不可见的点文件）的时候这个命令才会成功.

#### mkdir ####

#### chmod  ####
       chmod +x filename           使得文件filename对所有用户都可执行
       chmod u+s filename          设置"filename"文件的"suid"位. 这样一般用户就可以执行"filename", 他将拥有和文件宿主相同的权限.
       chmod 644 filename          设置文件宿主的r/w 权限,并对一般用户设置读权限. 
       chmod 1777 directory-name   对这个目录设置r/w 和可执行权限, 并开放给所有人. 同时设置"粘贴位". 这意味着, 只有目录宿主、文件宿主, 当然, 还有root 可以删除这个目录中的任何特定的文件. 

#### chattr #### 
- 修改文件属性. 这个命令与上边的chmod 命令相类似, 但是有不同的选项和不同的调用语法, 并且这个命令只能工作在ext2文件系统中. 
       `chattr +i filename` 将使得这个文件被标记为永远不变. 这个文件将不能被修改, 连接, 或删除, 即使是root也不行. 这个文件属性只能被root设置和删除. 
       类似的, a 选项将会把文件标记为只能追加数据. 
       如果文件设置了s(安全)属性, 那么当这个文件被删除时,这个文件所在磁盘的块将全部被0 填充. 
       如果文件设置了u(不可删除)属性, 那么当这个文件被删除后, 这个文件的内容还可以被恢复(不可删除). 
       如果文件设置了c(压缩)属性, 那么当这个文件在进行写操作时,它将自动被压缩,并且在读的时候, 自动解压. 

- 注意: 使用命令`chattr do`设置的属性, 将不会显示在文件列表中(ls -l). 

#### ln #### 
- 创建文件链接, 前提是这个文件是存在的.
- 绝大多数使用ln 命令时使用是-s 选项, 可以称为符号链接, 或软链接.使用-s 选项的一个优点是它可以穿越文件系统来链接目录. 
`ln -s oldfile newfile`
- 硬链接的优点是, 原始文件与链接文件之间是相互独立的
- 而软链接的优点是它可以跨越文件系统(因为它只不过是文件名的一个引用, 而并不是真正的数据). 与硬链接的另一个不同是, 一个符号链接可以指向一个目录. 

#### man, info #### 
- 当两者都可用时, info 页一般比man也会包含更多的细节描述. 

### 12.2 复杂命令 ###
#### find ####
       `-exec COMMAND \;`     命令序列以; 结束（";" 是 转义符）
- 如果COMMAND 中包含{}, 那么find 命令将会用所有匹配文件的路径名来替换"{}" . 
-  find 命令的-exec 选项不应该与shell中的内建命令exec 相混淆.

#### xargs ####
- 这是给命令传递参数的一个过滤器，把一个数据流分割为一些足够小的块, 以方便过滤器和命令进行处理. 在一般使用过多参数的命令替换失败的时候,用xargs 来替换它一般都能成功. 
- xargs的默认命令是echo. 这意味着通过管道传递给xargs的输入将会包含换行和空白, 不过通过xargs的处理, 换行和空白将被空格取代. 
- 注意: 一个有趣的xargs  选项是-n NN, NN 是限制每次传递进来参数的个数. 
- 注意: 另一个有用的选项是-0, 使用find -print0 或grep -lZ 这两种组合方式. 这允许处理包含空白或引号的参数. 
       -t 是"verbose" (输出命令行到stderr) 选项. 
       -i 是"替换字符串"选项. 

#### expr ####
- 通用求值表达式: 通过给定的操作(参数必须以空格分开)连接参数,并对参数求值.
- 在算术表达式expr中使用乘法操作时, 乘法符号必须被转义.

### 12.3 时间/日期 命令 ###
#### date ####
- 需要在调用格式的前边加上一个'+' 号
       %j     给出今天是本年度的第几天
       %s     将产生从"UNIX 元年" 到现在为止的秒数
       -u     选项将给出UTC (译者: UTC 是协调世界时英文缩写) 时间
       %N     将以10亿分之一为单位表示当前时间. 这个选项的一个有趣的用法就是用来产生一个6位的随机数. 
       %j     显示今天是本年度的第几天(从1月1日开始计算).
       %k%M   显示当前小时数和分钟数
- 'TZ' 参数允许改变当前的默认时区.

#### zdump ####
- 查看特定时区的当前时间.

#### time #### 
- 输出统计出来的命令执行的时间. 
- 注意: 在Bash的2.0版本 中, time 成为了shell的一个保留字, 并且在一个带有管道的命令行中,这个命令的行为有些小的变化. 

#### touch ####
- 用来更新文件被存取或修改的时间的工具,这个时间可以是当前系统的时间,也可以是指定的时间, 这个命令也用来产生一个新文件.
- 注意: touch 命令等价于 `: >> newfile`   或 `>> newfile` (对于一个普通文件). 

#### at ####
- at命令是一个作业控制命令, 用来在指定时间执行给定的命令集合.它有点像cron命令, 然而,at命令主要还是用来执行那种一次性执行的命令集合. 
- `at 2pm January 15`将会提示让你输入需要在这个时间你要执行的命令序列. 输入以Ctl-D 结束. 
- 使用-f选项或者使用(<)重定向操作符, 来让at命令从一个文件中读取命令集合.

#### batch #### 
- batch 作业控制命令与at 命令的行为很相像, 但batch 命令被用来在系统平均载量降到0.8 以下时执行一次性的任务. 与at 命令相似的是, 它也可以使用-f 选项来从文件中读取命令. 

#### cal #### 
- 从stdout中输出一个格式比较整齐的日历. 也可以指定年和月来显示那个月的日历. 

#### sleep ####
- 与一个等待循环的效果一样. 你可以指定需要暂停的秒数, 这段时间将什么都不干。
- 当一个后台运行的进程需要偶尔检测一个事件时,这个功能很有用. 也可用于计时.
- 注意: 如果你想每隔一段时间来运行一个命令的话, 那么watch 命令将比sleep 命令好得多. 

#### usleep #### 
- Microsleep 睡眠微秒
- 事实上usleep 命令并不能提供非常精确的计时, 所以如果你需要一个实时的任务的话, 这个命令并不适合.

#### hwclock, clock #### 
- hwclock 命令可以存取或调整硬件时钟. 
- 这个命令的一些选项需要root 权限. 在系统启动的时候, /etc/rc.d/rc.sysinit 这个启动文件,会使用hwclock 来从硬件时钟中读取
并设置系统时间. 
- clock 命令与hwclock命令完全相同.

### 12.4 文本处理命令 ###
#### sort ####
- 通常用在管道中当过滤器来使用.
- 使用-m 选项, 它将会合并预排序的输入文件. 

#### tsort  ####
- 拓扑排序,读取以空格分隔的有序对, 并且依靠输入模式进行排序. 

#### uniq #### 
- 这个过滤器将会删除一个已排序文件中的重复行.这个命令经常出现在sort命令的管道后边. 
- -c选项的意思是在输出行前面加上每行在输入文件中出现的次数. 
- `sort INPUTFILE | uniq -c | sort -nr`  命令
       先对INPUTFILE 排序, 然后统计 每行出现的次数, 最后的(-nr 选项将会产生一个数字的反转排序). 
       一般都用来分析log 文件或者用来分析字典列表, 或者用在那些需要检查文本词汇结构的地方. 

#### expand, unexpand #### 
- expand 将会把每个tab转化为一个空格.这个命令经常用在管道中. 
- unexpand 将会把每个空格转化为一个tab.效果与expand 相反. 

#### cut #### 
- 一个从文件中提取特定域的工具. 
- 这个命令与awk 中使用的print $N命令很相似, 但是更受限. 在脚本中使用cut命令会比使用awk 命令来得容易一些.
- 最重要的选项就是-d (字段定界符) 和-f (域分隔符) 选项. 
- `cut -d ' ' -f2,3 filename` 等价于 `awk -F'[ ]' '{ print $2, $3 }' filename` 
甚至可以指定换行符作为字段定界符. 实际上就是在命令行上插入一个换行(RETURN).

#### paste #### 
- 将多个文件,以每个文件一列的形式合并到一个文件中, 合并后的文件没列就是原来的一个文件
- 于创建系统log 文件来说, 使用cut 命令与paste 命令相结合是非常有用的. 

#### join #### 
- 这个命令与paste 命令属于同类命令, 但是它能够完成某些特殊的目地. 能够以一种特殊的形式来合并2个文件
- join 命令只能够操作2个文件, 它可以将那些具有特定标记域(通常是一个数字标签)的行合并起来, 并且将结果输出到stdout. 被加入的文件应该事先根据标记域进行排序以便于能够正确的匹配. 

#### head #### 
- 将一个文件的头打印到stdout上( 默认为10行, 可以自己修改). 
- '-c' 选项将从文件头输出指定个数的字符.

#### tail ####
- 将一个文件的结尾输出到stdout  中(默认为10 行). 通常用来跟踪一个系统logfile 的修改状况
- 使用-f 选项的话, tail 命令将会继续显示添加到文件中的行. 
- 为了列出一个文本文件中的指定行数, 可以将head 命令的输出通过 管道 传递到tail -1 中。e.g. `head -8 database.txt | tail -1` 将会列出database.txt 文件的第8行. 
- `var=$(head -$m $filename | tail -$n)`
       m = 从文件开头到想取得的指定范围的行数的最后一行
       n = 取得指定范围的行数(从块结尾开始截断)

#### grep ####
- `grep pattern [file...]`
       -i     选项在搜索时忽略大小写. 
       -w     选项用来匹配整词. 
       -l     选项仅列出符合匹配的文件, 而不列出匹配行. 
       -r     (递归) 选项不仅在当前工作目录下搜索匹配, 而且搜索子目录. 
       -n     选项列出所有匹配行, 并显示行号. 
       -v     (或者--invert-match) 选项将会显示所有不匹配的行.
       -c     (--count) 选项将只会显示匹配到的行数的总数,而不会列出具体的匹配.
       -q     (禁止输出)选项
- 如果没有指定文件参数, grep通常用在管道中对stdout进行过滤
- 如果在grep 命令只搜索一个文件的时候, 那么可以简单的把/dev/null 作为第2 个文件参数传给grep . 
- egrep - 扩展的grep - 这个命令与grep -E 等价. 这个命令用起来有些不同, 由于正则表达式扩展, 将会使得搜索更具灵活性. 
- fgrep - 快速的grep - 这个命令与grep -F 等价. 这是一种按照字符串字面意思进行的搜索(即不允许使用正则表达式), 这样有时候会使搜索变得容易一些. 
- agrep (近似grep) 扩展了grep 近似匹配的能力. 搜索的字符串可能会与最终匹配结果所找到字符串有些不同.
- 为了搜索压缩文件, 应使用zgrep, zegrep, 或zfgrep. 
- 如果要搜索bzipped  类型的文件, 使用bzgrep.

#### look ####
- 命令look 与命令grep 很相似, 但是这个命令只能做字典查询, 也就是它所搜索的文件必须已经排过序的单词列表. 默认情况下, 如果没有指定搜索那个文件, 那就默认搜索/usr/dict/words文件(译者: 感觉好像应该是/usr/share/dict/words). 

#### sed #### 
- 非交互式的"流编辑器", 在批量模式下, 允许使用许多ex命令.你会发现它在shell脚本中非常有用.

#### awk ####
- 可编程的文件提取器和文件格式化工具, 在结构化的文本文件中,处理或提取特定域(特定列)具有非常好的表现.

#### wc ####
- wc 可以统计文件或I/O 流中的单词数量. 
       wc -w  统计单词数量. 
       wc -l  统计行数量. 
       wc -c  统计字节数量. 
       wc -m  统计字符数量. 
       wc -L  给出文件中最长行的长度.

#### tr ####
- 字符转换过滤器.
- 注意: 必须使用引用或中括号, 这样做才是合理的. 引用可以阻止shell 重新解释出现在tr 命令序列中的特殊字符.中括号应该被引用起来防止被shell扩展.
- 
       -d     选项删除指定范围的字符. 
       --squeeze-repeats (或-s)     选项用来在重复字符序列中除去除第一个字符以外的所有字符. 这个选项在删除多余的whitespace 的时候非常有用. 
       -c "complement"      选项将会 反转 匹配的字符集. 

- 注意tr 命令支持POSIX 字符类.
- tr 工具在历史上有2个重要版本. BSD 版本不需要使用中括号 (tr a-z A-Z),  但是SysV 版本则需要中括号 (tr '[a-z]' '[A-Z]'). GNU  版本的tr 命令与BSD 版本比较相像, 所以使用中括号来引用字符范围是强制性的

#### fold ####
- 将输入按照指定宽度进行折行. 这里有一个非常有用的选项-s ,这个选项可以使用空格进行断行.(译者: 事实上只有外文才需要使用空格断行, 中文是不需要的)

### fmt ###
- 一个简单的文件格式器, 通常用在管道中, 将一个比较长的文本行输出进行折行. 
- 注意: 如果想找到一个更强力的fmt 工具可以选择Kamil Toman 的par  工具

#### col #### 
- 滤除标准输入的反向换行符号. 这个工具还可以将空白用等价的tab 来替换. col 工具最主要的应用还是从特定的文本处理工具中过滤输出, 比如groff 和tbl. (译者: 主要用来将man页转化为文本) 

#### column #### 
- 列格式化工具. 这个过滤工具将会将列类型的文本转化为"易于打印"的表格式进行输出, 通过在合适的位置插入tab. 

#### colrm ####
- 列删除过滤器. 这个工具将会从文件中删除指定的列(列中的字符串)并且写到文件中, 如果指定的列不存在,那么就回到 stdout. `colrm 2 4 <filename` 将会在filename文件中对每行删除第2到第4列之间的所有字符. 
- 如果这个文件包含tab和不可打印字符, 那将会引起不可预期的行为. 在这种情况下, 应该通过管道的手段使用expand 和unexpand 命令来预处理colrm.

#### nl ####
- 计算行号过滤器. nl filename   将会在stdout 中列出文件的所有内容, 但是会在每个非空行的前面加上连续的行号. 如果没有filename 参数, 那么就操作stdin. 
- nl 命令的输出与`cat -n` 非常相似, 然而, 默认情况下nl 不会列出空行. `cat -n` 对空行也进行计数

#### pr #### 
- 格式化打印过滤器. 这个命令会将文件(或stdout)分页, 将它们分成合适的小块以便于硬拷贝打印或者在屏幕上浏览.
- 使用这个命令的不同的参数可以完成好多任务, 比如对行和列的操作,加入行, 设置页边, 计算行号, 添加页眉, 合并文件等等. pr命令集合了许多命令的功能, 比如 nl, paste, fold, column, 和expand. 
- 一个特定的使用选项-d, 强制隔行打印(与sed -G 效果相同). 

#### gettext ####
- GNU gettext 包是专门用来将程序的输出翻译或者本地化为不同国家语言的工具集.

#### msgfmt ####
- 一个产生2进制消息目录的程序. 这个命令主要用来 本地化.

#### iconv ####
- 一个可以将文件转化为不同编码格式(字符集)的工具. 这个命令主要用来 本地化.

#### recode #### 
- 可认为这个命令是上边iconv 命令的一个空想家版本. 非常灵活的并可以把整个文件都转换为不同编码格式的工具
- 不是Linux 标准安装的一部分. 

#### TeX, gs #### 
- TeX 和Postscript  都是文本标记语言, 用来对打印和格式化的视频显示进行预拷贝. 
- TeX 是Donald Knuth 精心制作的排版系统. 通常情况下, 通过编写脚本的手段来把所有的选项和参数封装起来一起传到标记语言中是一件很方便的事情. 
- Ghostscript (gs) 是一个 遵循GPL 的Postscript 解释器. 

#### enscript #### 
- 将纯文本文件转换为PostScript 的工具
- `enscript filename.txt -p filename.ps`

#### groff, tbl, eqn  ####
- 另一种文本标记和显示格式化语言groff.是一个对传统UNIX roff/troff 显示和排版包的GNU 增强版本.
- tbl 表处理工具可以认为是groff 的一部分, 它的功能就是将表标记转化到groff 命令中. 
- eqn 等式处理工具也是groff 的一部分, 它的功能是将等式标记转化到groff 命令中. 

#### lex, yacc ####
- lex 是用于模式匹配的词汇分析产生程序. 在Linux系统上这个命令已经被flex 取代了. 
- yacc 工具基于一系列的语法规范生成语法分析程序. 在Linux系统上这个命令已经被bison 取代了. 

### 12.5 文件与归档命令 ###
### 归档命令 ###

#### tar ####
- 它能够处理所有设备的所有类型的归档文件, 包括磁带设备, 正常文件, 甚至是stdout
- 一些有用的tar 命令选项: 
       -c            创建(一个新的归档文件) 
       -x            解压文件(从存在的归档文件中) 
       --delete      删除文件(从存在的归档文件中) 注意: 这个选项不能用于磁带类型设备. 
       -r            将文件添加到现存的归档文件的尾部
       -A            将tar 文件添加到现存的归档文件的尾部
       -t            列出现存的归档文件中包含的内容
       -u            更新归档文件
       -d            使用指定的文件系统 比较归档文件
       -z            用gzip 压缩归档文件(压缩还是解压, 依赖于是否组合了-c 或-x)选项
       -j            用bzip2 压缩归档文件

#### shar ####
- Shell 归档工具. 存在于shell 归档文件中的所有文件都是未经压缩的, 并且本质上是一个shell 脚本,以#!/bin/sh 开头, 并且包含所有必要的解档命令.
- unshar 命令用来解档shar 归档文件. 

#### ar ####
- 创建和操作归档文件的工具, 主要在对2进制目标文件打包成库时才会用到.

#### rpm ####
- Red Hat 包管理器, 或者说rpm 工具提供了一种对源文件或2进制文件进行打包的方法. 除此之外, 它还包括安装命令, 并且还检查包的完整性. 
- `rpm -i package_name.rpm`  命令对于安装一个包来说就足够
- `rpm -qf` 列出一个文件属于那个包
- `rpm -qa` 将会列出给定系统上所有安装了的rpm 包. `rpm -qa package_name` 命令将会列出于给定名字匹配的包. 

#### cpio ####
- 这个特殊的归档拷贝命令(拷贝输入和输出).
- 已经很少能见.只在一些比较特殊的地方还在使用,比如拷贝一个目录树.

#### rpm2cpio ####
- 这个命令可以从rpm 归档文件中解出一个cpio 归档文件.

### 压缩命令 ###
#### gzip ####
- 标准的GNU/UNIX 压缩工具, 取代了比较差的compress 命令.
- 解压命令是gunzip, gzip -d 是等价的. 
- zcat 过滤器可以将一个gzip 文件解压到stdout, 所以尽可能的使用管道和重定向. zcat 命令等价于gzip -dc. 
- 注意: 在某些商业的UNIX 系统上, zcat   与uncompress -c 等价, 并且不能工作于gzip文件. 

#### bzip2 ####
- 用来压缩的一个可选的工具, 通常比gzip 命令压缩率更高(所以更慢), 适用于比较大的文件. 
- 相应的解压命令是bunzip2.
- 新版本的tar 命令已经直接支持bzip2 

#### compress, uncompress ####
- 这是一个老的, 私有的压缩工具
- 注意: znew 命令可以将compress 压缩的文件转换为gzip 压缩的文件.

#### sq ####
- 另一种压缩工具, 一个只能工作于排过序的ASCII 单词列表的过滤器.
- 这个命令使用过滤器标准的调用语法, `sq <input-file> output-file`. 速度很快, 但是效率远不及gzip. 相应的解压命令为unsq, 调用方法与sq 相同. 
- 注意: sq 的输出可以通过管道传递给gzip 以便于进一步的压缩. 

#### zip, unzip ####
- 与DOS 下的pkzip.exe 兼容

#### unarc, unarj, unrar ####
- 这些Linux 工具可以用来解档那些用DOS 下的arc.exe, arj.exe, 和rar.exe 程序进行归档的文件.

### 文件信息 ###
#### file ####
- 确定文件类型的工具. 
- 命令`file file-name` 将会用ascii 文本或数据的形式返回file-name 文件的详细描述. 这个命令会使用/usr/share/magic, /etc/magic, 或/usr/lib/magic 中定义的 魔法数字  来标识包含某种魔法数字的文件
- -f 选项将会让file 命令运行于批处理模式, 也就是说它会分析-f 后边所指定的文件, 从中读取需要处理的文件列表, 然后依次执行file 命令. 
- -z 选项, 当对压缩过的目标文件使用时, 将会强制分析压缩的文件类型. 

#### which ####
- which command-xxx 将会给出"command-xxx" 的完整路径. 当你想在系统中准确定位一个特定的命令或工具的时候, 这个命令就非常有用了. 

#### whereis ####
-  与上边的which 很相似, whereis command-xxx 不只会给出"command-xxx" 的完整路径, 而且还会给出这个命令的man页 的完整路径.

#### whatis ####
- whatis filexxx 将会在whatis 数据库中查询"filexxx". 
- 当你想确认系统命令和重要的配置文件的时候, 这个命令就非常重要了.

#### vdir ####
- 显示详细的目录列表. 与ls -l 的效果类似. 
- 这是一个GNU fileutils. 

#### locate, slocate ####
- locate 命令将会在预先建立好的档案数据库中查询文件. 
- slocate 命令是locate 的安全版本( locate 命令可能已经被关联到slocate 命令上了). 

#### readlink ####
- 显示符号连接所指向的文件.

#### strings ####
- 使用strings 命令在二进制或数据文件中找出可打印字符. 
- 它将在目标文件中列出所有找到的可打印字符的序列. 这个命令对于想进行快速查找一个n 个字符的打印检查来说是很方便的,也可以用来检查一个未知格式的图片文件 (strings image-file | more 可能会搜索出像JFIF 这样的字符串, 那么这就意味着这个文件是一个jpeg  格式的图片文件). 
- 在脚本中, 你可能会使用grep 或sed 命令来分析strings 命令的输出.

### 比较命令 ###
#### diff, patch ####
- 在某些应用中, 比如说比较单词词典, 在通过管道将结果传递给diff 命令之前, 使用诸如sort 和uniq 命令来对文件进行过滤将是非常有用的.
- diff 命令的--side-by-side 选项将会把2个比较中的文件全部输出, 按照左右分隔的形式, 并会把不同的行标记出来. -c 和-u 选项也会使得diff 命令的输出变得容易解释一些. 
- 一些diff 命令的变种, 比如sdiff, wdiff, xdiff, 和mgdiff.
- 如果比较的两个文件是完全一样的话, 那么diff 命令会返回0 作为退出码, 如果不同的话就返回1 作为退出码. 
- diff 命令的一个重要用法就是产生区别文件, 这个文件将用作patch 命令的-e 选项的参数, -e 选项接受ed 或ex 脚本. 
- patch: 灵活的版本工具.可以将一个老版本的包更新为一个新版本的包.
- 使用zdiff 来比较gzip 文件.

#### diff3 ####
- 一个diff 命令的扩展版本, 可以同时比较3个文件. 如果成功执行那么这个命令就返回0, 但是不幸的是这个命令不给出比较结果的信息. 

#### sdiff ####
- 比较 和/或 编辑2个文件, 将它们合并到一个输出文件中. 因为这个命令的交互特性, 所以在脚本中很少使用这个命令.

#### cmp ####
- cmp 命令是上边diff 命令的一个简单版本. cmp 命令仅仅指出那些位置有不同, 而不会显示不同的具体细节.
- 注意: 用zcmp 处理gzip 文件

#### comm ####
- 多功能的文件比较工具. 使用这个命令之前必须先排序.
- `comm -options first-file second-file`
       `comm file-1 file-2` 将会输出3列: 
              * 第1 列= 只在file-1 中存在的行
              * 第2 列= 只在file-2 中存在的行
              * 第2 列= 两边相同的行. 
       下列选项可以禁止1列或多列的输出. 
              * -1 禁止显示第一栏(译者: 在File1 中的行) 
              * -2 禁止显示第二栏(译者: 在File2 中的行) 
              * -3 禁止显示第三栏(译者: File1 和File2 公共的行) 
              * -12 禁止第一列和第二列, (就是说选项可以组合).

### 一般工具 ###
#### basename ####
- 从文件名中去掉路径信息, 只打印出文件名.

#### dirname ####
- 从带路径的文件名中去掉文件名, 只打印出路径信息.

#### split, csplit ####
- 将一个文件分割为几个小段的工具. 这些命令通常用来将大的文件分割, 并备份到软盘上, 或者是为了切成合适的尺寸用email 上传.
- csplit 根据 上下文 来切割文件, 切割的位置将会发生在模式匹配的地方. 

#### sum, cksum, md5sum, sha1sum ####
- 出于安全目的一个脚本可能会有一个checksum 列表, 这样可以确保关键系统文件的内容不会被修改或损坏. 对于需要安全性的应用来说, 应该使用 md5sum (message digest 5   checksum) 命令, 或者更好的更新的sha1sum (安全Hash 算法). 
- 注意: cksum 命令将会显示目标的尺寸(字节), 目标可以使文件或stdout. md5sum 和sha1sum 命令在它们收到stdout 的输入时候, 显示一个dash .

#### shred ####
- 用随机字符填充文件, 使得文件无法恢复, 这样就可以保证文件安全的被删除. 
- 这是一个GNU fileutils.
- 注意: 即使使用了shred 命令, 高级的(forensic)辩论技术还是能够恢复文件的内容. 

### 编码和解码 ###
#### uuencode ####
- 把二进制文件编码成ASCII 字符串
- 适用于编码e-mail消息体,或者新闻组消息. 
- Uuencode 过的文件在文件开始的地方有个"begin", 在文件结尾的地方有个"end".

#### uudecode ####
- uuencode 后的ASCII 字符串恢复为二进制文件.
- 注意: fold -s 命令在处理从Usenet 新闻组下载下来的长的uudecode 文本消息的时候可能会有用(可能在管道中).

#### mimencode, mmencode ####
- mimencode 和mmencode 命令处理多媒体编码的email 附件. 
- 虽然mail 用户代理(比如pine 或kmail) 通常情况下都会自动处理, 但是这些特定的工具允许从命令行或 shell脚本中来手动操作这些附件. 

#### crypt ####
- 这个工具曾经是标准的UNIX 文件加密工具.

### 一些杂项工具 ###
#### mktemp ####
- 使用一个"唯一"的文件名来创建一个临时文件如果不带参数的在命令行下调用这个命令时, 将会在/tmp 目录下产生一个零长度的文件.

#### make ####

#### install ####
- 特殊目的的文件拷贝命令, 与cp 命令相似, 但是具有设置拷贝文件的权限和属性的能力.

#### dos2unix ####
- 将DOS 格式的文本文件(以CR-LF 为行结束符) 转换为UNIX 格式(以LF 为行结束符), 反过来也一样.

#### ptx ####
- ptx [targetfile] 命令将会输出目标文件的序列改变的索引(交叉引用列表). 如果必要的话, 这个命令可以在管道中进行更深层次的过滤和格式化.

#### more, less ####
- 分页显示文本文件或stdout, 一次一屏.可以用来过滤stdout 的输出 . . . 或一个脚本的输出.

### 12.6 通讯命令 ###
### 信息与统计 ###
#### host ####
- 通过名字或IP 地址来搜索一个互联网主机的信息, 使用DNS. 

#### ipcalc ####
- 显示一个主机IP 信息. 
- 使用-h 选项, ipcalc 将会做一个DNS 的反向查询, 通过IP 地址找到主机(服务器)名. 

#### nslookup ####
- 通过IP 地址在一个主机上做一个互联网的"名字服务查询". 事实上这与ipcalc -h 或dig -x 等价. 
- 这个命令既可以交互运行也可以非交互运行, 换句话说, 就是在脚本中运行. 

#### dig ####
- 域信息查询. dig 在一个主机上做一个互联网的"名字服务查询". 
- 这个命令既可以交互运行也可以非交互运行, 换句话说, 就是在脚本中运行. 
- dig 命令选项：
       +time=N 选项用来设置查询超时为N 秒,
       +nofail  选项用来持续查询服务器直到收到一个响应, 
       -x 选项会做反向地址查询. 

#### traceroute ####
- 跟踪包发送到远端主机过程中的路由信息. 这个命令在LAN, WAN, 或者在Internet 上都可以正常工作. 
- 远端主机可以通过IP 地址来指定. 
- 这个命令的输出也可以通过管道中的grep 或sed 命令来过滤. 

#### ping ####
- 广播一个"ICMP ECHO_REQUEST" 包到其他主机上, 既可以是本地网络也可以使远端网络. 这是一个测试网络连接的诊断工具
- 一个成功的ping 返回的 退出码 为0.

#### whois ####
- 执行DNS (域名系统) 查询lookup. 
- -h 选项允许指定需要查询的特定的whois 服务器.

#### finger ####
- 取得网络上的用户信息. 
- 另外这个命令可以显示一个用户的~/.plan, ~/.project, 和~/.forward 文件, 如果存在的话.
- 处于安全上的考虑, 许多网络都禁用了finger 以及和它相关的幽灵进程.

#### chfn ####
- 修改finger 命令所显示出来的用户信息.

#### vrfy ####
- 验证一个互联网的e-mail 地址. 

### 远端主机接入 ###
#### sx, rx ####
- sx 和rx 命令使用xmodem 协议, 设置服务来向远端主机传输文件和接收文件.
- 这些都是通讯安装包的一般部分, 比如minicom. 

#### sz, rz ####
- sz 和rz 命令使用zmodem 协议, 设置服务来向远端主机传输文件和接收文件.
- zmodem 协议在某些方面比xmodem强, 比如使用更快的的传输波特率, 并且可以对中断的文件进行续传.
- 与sx 一样rx, 这些都是通讯安装包的一般部分.

#### ftp ####
- 一个ftp会话可以写到脚本中自动运行.

#### uucp, uux, cu ####
- uucp: UNIX 到UNIX 拷贝. 这是一个通讯安装包, 目的是为了在UNIX 服务器之间传输文件.
- uucp 的优点就是它的容错性, 即使有一个服务将拷贝操作中断了, 那么当连接恢复的时候, 这个命令还是可以在中断的地方续传. 
- uux: UNIX 到UNIX 执行. 在远端系统上执行一个命令.这个命令是uucp 包的一部分.
- cu: Call Up 一个远端系统并且作为一个简单终端进行连接. 这是一个telnet 的缩减版本. 这个命令是uucp 包的一部分. 

#### telnet ####
- 连接远端主机的工具和协议. 
- 注意:telnet 协议本身包含安全漏洞, 因此我们应该适当的避免使用.

#### wget ####
- wget 工具使用非交互的形式从web 或ftp 站点上取得或下载文件. 在脚本中使用正好.

#### lynx ####
- lynx 是一个网页浏览器, 也是一个文件浏览器. 
- 它可以(通过使用-dump 选项)在脚本中使用. 它的作用是可以从Web 或ftp 站点上非交互的获得文件. 
- `lynx -dump http://www.xyz23.com/file01.html >$SAVEFILE `
- 使用-traversal 选项, lynx 将从参数中指定的HTTP URL 开始, 遍历指定服务器上的所有链接. 
- 如果与-crawl 选项一起用的话, 将会把每个输出的页面文本都放到一个log 文件中. 

#### rlogin ####
- 远端登陆, 在远端的主机上开启一个会话. 这个命令存在安全隐患, 所以要使用ssh 来代替. 

#### rsh ####
- 远端shell, 在远端的主机上执行命令. 这个命令存在安全隐患, 所以要使用ssh 来代替. 

#### rcp ####
- 远端拷贝, 在网络上的不同主机间拷贝文件.
- e.g. `bash$ rsync -a ~/sourcedir/*txt /node1/subdirectory/`

#### rsync ####
- 远端同步, 在网络上的不同主机间(同步)更新文件.
- 注意：使用rcp, rsync, 和其他一些有安全问题的类似工具, 并将这些工具用在shell 脚本中是不明智的. 应该考虑使用ssh, scp, 或者一个expect 脚本来代替这些不安全的工具.

#### ssh ####
- 安全shell, 登陆远端主机并在其上运行命令. 这个工具具有身份认证和加密的功能, 可以安全的替换 telnet, rlogin, rcp, 和rsh 等工具.
- 注意:  在循环中, ssh 可能会引起意想不到的异常行为. 根据comp.unix 上的shell文档Usenet post , ssh 继承了循环的标准输入.为了解决这个问题, 使用ssh 的-n 或者-f 选项. 

#### scp ####
- 安全拷贝, 在功能上与rcp 很相似, 就是在2个不同的网络主机之间拷贝文件, 但是要通 过鉴权的方式, 并且使用与ssh 类似的安全层.

### Local Network ###
#### write ####
- 这是一个端到端通讯的工具. 这个工具可以从你的终端上(console 或者xterm)发送整行到另一个用户的终端上. 
- mesg 命令当然也可以用来对于一个终端的写权限
- 因为write 是需要交互的, 所以这个命令通常不使用在脚本中. 

#### netconfig ####
- 用来配置网络适配器(使用DHCP)的命令行工具. 
- 这个命令对于红帽发行版来说是内置的.

### Mail ###
#### mail ####
- 发送或读取e-mail 消息.

#### mailto ####
- 与mail 命令很相似, mailto 命令可以使用命令行或在脚本中发送e-mail 消息. 
- 然而, mailto 命令也允许发送MIME (多媒体) 消息. 

#### vacation ####
- 可以自动回复e-mail 给发送者, 表示邮件的接受者正在度假暂时无法收到邮件. 
- 这个工具与sendmail 一起运行于网络上, 并且这个工具不支持拨号的POPmail 帐号. 

### 12.7 终端控制命令 ###
#### tput ####
- 初始化终端或者从terminfo data 中取得终端信息. 不同的选项允许特定的终端操作.
- tput clear 与下边的clear 等价. tput reset 与下边的reset 等价. tput sgr0 也可以重置终端, 但是并不清除屏幕. 
- 使用 tput cup X Y 将会把光标移动到当前终端的(X,Y)坐标上. 使用这个命令之前一边都要先使用一下clear 命令, 把屏幕清除一下.
- 注意: stty 提供了一个更强力的命令专门用来设置如何控制终端. 

#### infocmp ####
- 这个命令会打印出大量的当前终端的信息. 事实上它是引用了terminfo 数据库.

#### reset ####
- 重置终端参数并且清除屏幕. 与clear 命令一样, 光标和提示符将会重新出现在终端的左上角. 

#### clear ####
- clear 命令只不过是简单的清除控制台或者xterm 的屏幕.

#### script ####
- 这个工具将会记录(保存到一个文件中)所有的用户在控制台下的或在xterm window下的按键信息. 这其实就是创建了一个会话记录.

### 12.8 数学计算命令 ###
#### factor ####
- 将一个正数分解为多个素数.

#### bc ####
- Bash 不能处理浮点运算, 并且缺乏特定的一些操作,bc 可以解决这个问题. 
- 因为它是一个完整的UNIX 工具, 所以它可以用在管道中
- 简单的使用bc 命令的模版:`variable=$(echo "OPTIONS; OPERATIONS" | bc) `
- 调用bc 的另一种可选的方法就是使用 here document ,并把它嵌入到 命令替换 块中. 当一个脚本需要将一个选项列表和多个命令传递到bc 中时, 这种方法就显得非常合适. 
       variable=`bc << LIMIT_STRING 
       options
       statements
       operations
       LIMIT_STRING
       `
       ...or...
       
       
       variable=$(bc << LIMIT_STRING 
       options 
       statements 
       operations 
       LIMIT_STRING 
       ) 

#### dc ####
- dc (桌面计算器desk calculator) 工具是面向栈的并且使用RPN (逆波兰表达式 "Reverse Polish Notation" 又叫"后缀表达式"). 

#### awk ####
- 在脚本中使用浮点运算的另一种方法是使用awk  内建的数学运算函数, 可以用在shell wrapper中. 

### 12.9 混杂命令 ###
#### jot, seq ####
- 这些工具通过用户指定的范围和增量来产生一系列的整数. 
- 每个产生出来的整数一般都占一行, 但是可以使用-s 选项来改变这种设置. 
- jot 和seq 命令都经常用在for 循环中. 
- `seq $BEGIN $INTERVAL $END`

#### getopt ####
- getopt 命令将会分析以破折号开头的命令行选项. 
- 这个外部命令与Bash的内建命令getopts 作用相同. 
- 通过使用-l 标志, getopt 可以处理长(多字符)选项, 并且也允许参数重置. 

#### run-parts ####
- run-parts 命令将会执行目标目录中所有的脚本, 这些将本会以ASCII 的循序进行排列.
- cron 幽灵进程 会调用run-parts 来运行/etc/cron.* 下的所有脚本. 

#### yes ####
- yes 命令的默认行为是向stdout 中连续不断的输出字符y,每个y占一行.
- 如果想换一个输出字符的话, 可以使用yes 其他的字符串
- 在命令行或者脚本中, yes的输出可以通过重定向或管道来传递给一些需要用户输入进行交互的命令. 事实上, 这个命令可以说是expect 命令的一个简化版本.
- 注意: 当用yes 的管道形式来使用一些可能具有潜在危险的系统命令的时候一定要深思熟虑, 比如fsck 或fdisk. 可能会产生一些意外的副作用.

#### banner ####
- 将会把字符串用一个ASCII 字符(默认是'#')来画出来(就是将多个'#'拼出一副字符的图形).
- 可以作为硬拷贝重定向到打印机上(译者注: 可以使用-w 选项设置宽度). 

#### printenv  ####
- 对于某个特定的用户, 显示出所有的 环境变量. 

#### lp ####
- lp和lpr 命令将会把文件发送到打印队列中, 并且作为硬拷贝来打印.这些命令会纪录它们名字的起始位置并传递到行打印机的另一个位置.
- 通常情况下都是将pr的格式化的输出传递到lp. `bash$ pr -options file1.txt | lp `
- 格式化的包, 比如groff 和Ghostscript 就可以将它们的输出直接发送给lp. 
        `bash$ groff -Tascii file.tr | lp`  
        `bash$ gs -options | lp file.ps`
- 一些相关的命令:
       lpq    可以查看打印队列
       lprm   可以用来从打印队列中删除作业. 

#### tee ####

#### mkfifo ####
- 这个不大引人注意的命令可以创建一个命名管道, 并产生一个临时的先进先出的buffer 用来在两个进程间传输数据

#### pathchk ####
- 检查文件名的有效性. 如果文件名超过了最大允许长度(255 个字符), 或者它所在的一个或多个路径搜索不到, 那么就会产生一个错误结果. 
- 并不能够返回一个可识别的错误码, 因此它在脚本中几乎没有什么用. 一般都使用文件测试操作. 

#### dd ####
- "数据复制" 命令.
- dd 命令只不过是简单的拷贝一个文件(或者stdin/stdout), 但是它会做一些转换. 
- dd 命令可以在数据流上做随即存取.`echo -n . | dd bs=1 seek=4 of=file conv=notrunc`(conv=notrunc" 选项意味着输出文件不能被截短.)
- dd 命令可以将数据或磁盘镜像拷贝到设备中, 也可以从设备中拷贝数据或磁盘镜像, 比如说磁盘或磁带设备都可以. 通常用来创建启动盘. 
 `dd if=kernel-image of=/dev/fd0H1440 `
- 同样的, dd 可以拷贝软盘的整个内容(甚至是其他操作系统的磁盘格式) 到硬盘驱动器上(以镜像文件的形式). 
 `dd if=/dev/fd0 of=/home/bozo/projects/floppy.img`
- dd 命令还有一些其他用途, 包括可以初始化临时交换文件和ramdisks (内存虚拟硬盘) . 它甚至可以做一些对整个硬盘分区的底层拷贝, 虽然不建议这么做. 

#### od ####
- od(octal dump)过滤器, 将会把输入(或文件)转换为8进制或者其他进制. 
- 在需要查看或处理一些二进制数据文件或者一个不可读的系统设备文件的时候, 这个命令非常有用, 比如/dev/urandom,或者是一个二进制数据过滤器.

#### hexdump ####
- 对二进制文件进行16进制, 8进制, 10进制, 或者ASCII 码的查阅动作. 
- 这个命令大体上与上边的od命令作用相同, 但是远不及od 命令有用. 

#### objdump ####
- 显示编译后的2进制文件或2进制可执行文件的信息, 以16进制的形式显示, 或者显示反汇编列表(使用-d选项). 

#### mcookie ####
- 这个命令会产生一个"magic cookie", 这是一个128-bit (32-字符) 的伪随机16进制数字, 这个数字一般都用来作为X server的鉴权"签名". 
- 这个命令还可以用来在脚本中作为一种生成随机数的手段, 当然这是一种"小吃店"(虽然不太正统, 但是很方便)的风格.

#### units ####
- 这个工具用来在不同的计量单位之间互相转换. 

#### m4 ####
- m4 是一个强力的宏处理过滤器
- 最开始这个工具是用来作为RatFor 的预处理器而编写的, 但是后来证明m4 作为独立的工具也是非常有用的
-  m4 结合了许多工具的功能, 比如eval, tr, 和awk, 除此之外, 它还使得宏扩展变得容易. 

#### doexec ####
- doexec 命令允许将一个随便的参数列表传递到一个二进制可执行文件中. 
- 特别的, 甚至可以传递arg[0] (相当于脚本中的$0 ), 这样可以使用不同的名字来调用这个可执行文件, 并且通过不同的调用的名字, 可以让这个可执行文件执行不同的动作.

#### dialog ####
- dialog 工具集提供了一种从脚本中调用交互对话框的方法. dialog 的更好的变种版本是gdialog, Xdialog, 和kdialog ，事实上是调用的X-Windows 的界面工具集.

#### sox ####
- sox 命令, "sound exchange" (声音转换)命令, 可以进行声音文件的转换.
- 事实上,可执行文件/usr/bin/play (现在不建议使用) 只不过是sox 的一个shell 包装器而已.

## 第13章 系统与管理命令 ##
### Users 和Groups 类命令 ###
#### users ####
- 显示所有的登录的用户. 这个命令与who -q 基本一致.

#### groups ####
- 列出当前用户和他所属于的组. 这相当于$GROUPS 内部变量, 但是这个命令将会给出组名 字, 而不是数字. 

#### chown, chgrp ####
- chown 命令将会修改一个或多个文件的所有权. 对于root来说这是一种非常好的将文件的所有权从一个用户换到另一个用户的方法. 一个普通用户不能修改文件的所有权, 即使他是文件的宿主也不行.
- chgrp 将会修改一个或个文件党组所有权. 你必须是这些文件的宿主, 并且是目的组的成员(或者root), 这样才能使用这个操作. 

#### useradd, userdel ####
- useradd 管理命令将会在系统上添加一个用户帐号, 并且如果指定的话, 还会为特定的用户创建home目录. 
- 相应的userdel 命令将会从系统上删除一个用户帐号, 并且删除相应的文件. 
- 注意: adduser命令与useradd是相同的, adduser通常都是一个符号链接.

#### usermod ####
- 修改用户帐号. 可以修改密码, 组身份, 截止日期, 或者给定用户帐号的其他的属性.

#### groupmod ####
- 修改指定组. 组名字或者ID号都可以使用这个命令来修改.

#### id ####
- id 将会列出当前进程的真实和有效用户ID, 还有用户的组ID. 
- 注意: id 命令只有在有效ID与真实ID不符时才会显示有效id.

#### who ####
- 显示系统上所有已经登录的用户.
- -m 选项将会只给出当前用户的详细信息. 将任意两个参数传递到who中 都等价于who -m. 
- whoami 与who -m 很相似, 但是只列出用户名.

#### w ####
- 示所有的登录的用户和属于它们的进程. 这是一个who的扩展版本. w的输出可以通过管道传递到grep中, 这样就可以查找指定的用户或进程. 

#### logname ####
- 显示当前用户的登录名(可以在/var/run/utmp中找到). 这与上边的whoami很相近.
- logname只会打印出登录的用户名, 而whoami 将会给出附着到当前进程的用户名. 

#### su ####
- 使用一个代替的用户来运行一个程序或脚

#### sudo ####
- 以root(或其他用户)的身份来运行一个命令.
- 文件/etc/sudoers 持有允许调用sudo的用户名. 

#### passwd ####
- 设置, 修改, 或者管理用户的密码. 
- passwd 命令的-l, -u, 和-d 选项允许锁定, 解锁,和删除一个用户的密码. 只有root 用户可以使用这些选项

#### ac ####
- 显示用户登录的连接时间, 就像从/var/log/wtmp 中读取一样. 这是GNU的一个统计工具. 

#### last ####
- 用户最后登录的信息, 就像从/var/log/wtmp中读出来一样. 这个命令也可以用来显示远端登录. 

#### newgrp ####
- 不用登出就可以修改用户的组ID. 并且允许存取新组的文件. 
- 因为用户可能同时属于多个组, 这个命令很少被使用. 

### 终端类命令 ###
#### tty ####
- 显示当前用户终端的名字. 注意每一个单独的xterm窗口都被算作一个不同的终端.

#### stty ####
- 显示并(或)修改终端设置. 
- 这个复杂命令可以用在脚本中, 并可以用来控制终端的行为和其显示输出的方法.
- 终端与模式terminals and modes 一般情况下, 一个终端都是工作在canonical(标准)模式下. 当用户按键后, 事实上所产生的字符并没有马上传递到运行在当前终端上的程序. 终端上的一个本地的缓存保存了这些按键. 当用按下ENTER键的时候, 才会将所有保存的按键信息传递到运行的程序中. 这就意味着在终端内部存在一个基本的行编辑器. 在non-canonical ("raw") 模式, 每次按键(包括特殊定义的按键, 比如ctl-H)将会立即发送一个字符到控制进程. Bash提示符禁用了icanon 和echo, 因为它用自己的更好的行编辑器代替了终端的基本行编辑器

#### setterm ####
- 设置特定的终端属性. 这个命令将向它的终端的stdout写一个字符串, 这个字符串将修改终端的行为. 

#### tset ####
- 显示或初始化终端设置. 可以说这是stty的功能比较弱的版本.

#### setserial ####
- 设置或者显示串口参数. 这个脚本只能被root用户来运行, 并且通常都在系统安装脚本中使用. 

#### getty, agetty ####
- 一个终端的初始化过程通常都是使用getty或agetty来建立, 这样才能让用户登录. 这些命令并不用在用户的shell脚本中. 它们的行为与stty很相似. 

#### mesg ####
- 使能或禁用当前用户终端的存取权限. 禁用存取权限将会阻止网络上的另一用户向这个终端写消息. 

#### wall ####
- 这是一个缩写单词"write all", 也就是, 向登录到网络上的任何终端的所有用户都发送一个消息.

### 信息与统计类 ###
#### uname ####
- 输出系统的说明(OS, 内核版本, 等等.)到stdout.
-  使用-a 选项, 将会给出详细的信息
-  使用-s选项只会输出OS类型. 

#### arch ####
- 显示系统的硬件体系结构. 等价于uname -m.

#### lastcomm ####
- 给出前一个命令的信息, 存储在/var/account/pacct文件中. 命令名字与用户名字都可以使用选项来指定. 这是GNU的一个统计工具.

#### lastlog #### 
- 列出系统上所有用户最后登录的时间. 存在/var/log/lastlog文件中.
- 如果用户对于/var/log/lastlog文件没有读权限的话, 那么调用这个命令就会失败. 

#### lsof ####
- 列出打开的文件. 这个命令将会把所有当前打开的文件列出一份详细的表格, 包括文件的所有者信息, 尺寸, 与它们相关的信息等等. 
- 当然, lsof也可以管道输出到grep 和(或) awk来分析它的结果. 

#### strace ####
- 为了跟踪系统和信号的诊断和调试工具. 调用它最简单的方法就是strace COMMAND.
- 这是Solaris truss命令的Linux的等价工具.  

#### nmap ####
- 网络端口扫描器. 这个命令将会扫描一个服务器来定位打开的端口, 并且定位这些端口相关的服务. 
- 这是一个防止网络被黑客入侵的一个重要的安全工具. 

#### nc ####
- nc(netcat)工具是一个完整的工具包, 可以使用它来连接和监听TCP和UDP端口. 
- 它可以用来作为诊断和测试工具, 也可以用来作为基于脚本的HTTP客户端和服务器的组件.

#### free ####
- 使用表格形式来显示内存和缓存的使用情况. 这个命令的输出非常适合于使用grep, awk 或者Perl来分析. 
- procinfo命令将会显示free命令所能显示的所有信息, 而且更多.

#### procinfo ####
- 从/proc pseudo-filesystem中提取和显示所有信息和统计资料. 这个命令将给出更详细的信息. 

#### lsdev ####
- 显示设备, 也就是显示安装的硬件.

#### du ####
- 递归的显示(磁盘)文件的使用状况. 除非指定, 默认是当前工作目录.

#### df ####
- 使用列表的形式显示文件系统的使用状况. 

#### dmesg ####
- 将所有的系统启动消息输出到stdout上. 方便出错,并且可以查出安装了哪些设备驱动和察看使用了哪些系统中断.

#### stat ####
- 显示一个或多个给定文件(也可以是目录文件或设备文件)的详细的统计信息.

#### vmstat ####
- 显示虚拟内存的统计信息.

#### netstat ####
- 显示当前网络的统计和信息, 比如路由表和激活的连接. 这个工具存取/proc/net 中的信息.
- netstat -r 等价于route 命令. 

#### uptime ####
- 显示系统运行的时间, 还有其他一些统计信息. 
- 注意: load average 如果小于或等于1, 那么就意味着系统会马上处理. 如果load average 大于1, 那么就意味着进程需要排队. 如果load average 大于3, 那么就意味着, 系统性能已经显著下降了. 

#### hostname ####
- 显示系统的主机名字. 这个命令在/etc/rc.d 安装脚本(/etc/rc.d/rc.sysinit 或类似的)中设置主机名. 等价于uname -n, 并且与$HOSTNAME内部变量很相像. 
- 与hostname 命令很相像的命令还有 domainname, dnsdomainname, nisdomainname, 和ypdomainname 命令. 

#### hostid ####
- 显示主机的32位的16进制ID.
- 注意: 这个命令据说对于特定系统可以获得一个"唯一"的序号. 某些产品的注册过程可能会需要这个序号来作为用户的许可证. 不幸的是, hostid 只会使用字节转换的方法来用16进制显示机器的网络地址. 
- 一个没有网络的Linux机器的典型的网络地址设置在/ect/hosts中.

#### sar ####
- sar (System Activity Reporter系统活动报告) 命令将会给出系统统计的一个非常详细的概要.这个命令并不是基本Linux发行版的一部分

#### readelf ####
- 显示指定的elf 格式的2进制文件的统计信息. 这个工具是binutils工具包的一部分. 

#### size ####
- size [/path/to/binary] 命令可以显示2进制可执行文件或归档文件每部分的尺寸.

### 系统日志类 ###
#### logger ####
- 附加一个用户产生的消息到系统日之中(/var/log/messages). 不是root用户也可以调用logger. 

#### logrotate ####
- 这个工具用来管理系统的log 文件, 可以在合适的时候轮换, 压缩, 删除, 和(或)e-mail 它们.
- 这个工具将从老的log 文件中取得一些杂乱的记录保存在/var/log中.  通常使用cron 来每天运行logrotate. 
- 在/etc/logrotate.conf中添加合适的入口就可以管理自己的log 文件了, 就像管理系统log 文件一样. 

### 作业控制 ###
#### ps ####
- 进程统计: 通过进程所有者和PID(进程ID)来列出当前执行的进程. 通常都是使用ax选项来调用这个命令, 并且结果可以通过管道传递到grep 或sed 中来搜索特定的进程
- 如果想使用"树"的形式来显示系统进程: ps afjx 或者 ps ax --forest.

#### pgrep, pkill ####
- ps 命令与grep或kill结合使用.

#### pstree ####
- 使用"树"形式列出当前执行的进程.
- -p选项显示PID,和进程名字.

#### top ####
- 连续不断的显示cpu使用率最高的进程.
- -b 选项将会以文本方式显示, 以便于可以在脚本中分析或存取.

#### nice ####
- 使用修改后的优先级来运行一个后台作业. 优先级从19(最低)到-20(最高). 只有root用户可以设置负的(比较高的)优先级. 相关的命令是renice, snice, 和skill. 

#### nohup ####
- 保持一个命令的运行, 即使用户登出系统. 这个命令做为前台进程来运行, 除非前边加&. 
- 如果你在脚本中使用nohup命令, 最好和wait 命令一起使用, 这样可以避免创建一个孤儿进程或僵尸进程.

#### pidof ####
- 取得一个正在运行的作业的进程ID(PID).
-  pidof命令与$PPID内部变量非常相似. 

#### fuser ####
- 取得一个正在存取某个或某些文件(或目录)的进程ID. 
- 使用-k选项将会杀掉这些进程. 对于系统安全来说, 尤其是在脚本中想阻止未被授权的用户存取系统服务的时候, 这个命令就显得很有用了.
- 当正常的插入或删除保存的媒体, 比如CD ROM或者USB闪存设备的时候, fuser的应用也显得特别重要. 有时候当你想umount一个设备失败的时候(出现设备忙的错误消息), 这意味着某些用户或进程正在存取这个设备. 使用fuser -um /dev/device_name可以搞定这些 
- fuser 的-n选项可以获得正在存取某一端口的进程. 当和nmap命令组合使用的时候尤其有用. 

#### cron ####
- 管理程序调度器, 执行一些日常任务, 比如清除和删除系统log 文件, 或者更新slocate命令的数据库. 
- 这是at命令的超级用户版本(虽然每个用户都可以有自己的crontab文件, 并且这个文件可以使用crontab命令来修改).
- 它以幽灵进程T的身份来运行, 并且从/ect/crontab中获得执行的调度入口. 
- 注意: 一些Linux的风格都使用crond, Matthew Dillon的cron. 

### 进程控制和启动类 ###
#### init ####
- init 命令是所有进程的父进程. 在系统启动的最后一步调用, init 将会依据/etc/inittab来决定系统的运行级别. 只能使用root身份来运行它的别名telinit. 

#### telinit ####
- init 命令的符号链接, 这是一种修改系统运行级别的一个手段, 通常在系统维护或者紧急的文件系统修复的时候才用. 只能使用root身份调用. 调用这个命令是非常危险的

#### runlevel ####
- 显示当前和最后的运行级别, 也就是, 确定你的系统是否终止(runlevel 为0), 还是运行在单用户模式(1), 多用户模式(2), 或者是运行在X Windows(5), 还是正在重启(6).
- 这个命令将会存取/var/run/utmp文件. 

#### halt, shutdown, reboot ####
- 设置系统关机的命令, 通常比电源关机的优先级高.

#### service ####
- 开启或停止一个系统服务. 启动脚本在/etc/init.d中, 并且/etc/rc.d在系统启动的时候使用这个命令来启动服务

### 网络类 ###
#### ifconfig ####
- 网络的接口配置和调试工具.
- ifconfig 命令绝大多数情况都是在启动时候设置接口, 或者在重启的时候关闭它们. 

#### iwconfig ####
- 配置无线网络的命令集合. 可以说是上边的ifconfig 的无线版本.

#### route ####
- 显示内核路由表信息, 或者查看内核路由表的修改

#### chkconfig ####
- 检查网络配置. 这个命令负责显示和管理在启动过程中所开启的网络服务(这些服务都是从/etc/rc?.d目录中开启的). 

#### tcpdump ####
- 网络包的"嗅探器". 这是一个用来分析和调试网络上传输情况的工具, 它所使用的手段是把匹配指定规则的包头都显示出来.

### 文件系统类 ###
#### mount ####
- 加载一个文件系统, 通常都用来安装外部设备
- 文件/etc/fstab 将会提供一个方便的列表, 这个列表列出了所有可用的文件系统, 分区和设备, 另外还包括某些选项, 比如是否可以自动或者手动的mount. 文件/etc/mtab 显示了当前已经mount的文件系统和分区(包括虚拟的, 比如/proc). 
- mount -a 将会mount所有列在/ect/fstab中的文件系统和分区, 除了那些标记有非自动选项的. 在启动的时候, 在/etc/rc.d中的一个启动脚本(rc.sysinit或者一些相似的脚本) 将会这么调用, mount所有可用的文件系统和分区. 
- 这个多功能的命令甚至可以将一个普通文件mount到块设备中, 并且这个文件就好像一个文件系统一样. mount可以将文件与一个loopback 设备相关联来达到这个目的. 

#### umount ####
- 卸除一个当前已经mount的文件系统. 
- 在正常删除之前已经mount的软盘和CDROM之前, 这个设备必须被unmount, 否则文件系统将会损坏. 

#### sync ####
- 强制写入所有需要更新的buffer上的数据到硬盘上(同步带有buffer的驱动器).

#### losetup ####
-  建立和配置loopback 设备. 

#### mkswap ####
- 创建一个交换分区或文件. 交换区域随后必须马上使用swapon来使能. 

#### swapon, swapoff ####
- 使能/禁用 交换分区或文件. 这两个命令通常在启动和关机的时候才有效.

#### mke2fs ####
- 创建Linux ext2 文件系统. 这个命令必须以root身份调用. 

#### tune2fs ####
- 调整ext2文件系统. 可以用来修改文件系统参数, 比如mount的最大数量. 必须以root身份调用. 
- 注意: 这是一个非常危险的命令. 因为它可能会破坏你的文件系统. 

#### dumpe2fs ####
- 打印(输出到stdout上)非常详细的文件系统信息. 必须以root身份调用. 

#### hdparm ####
- 列出或修改硬盘参数. 这个命令必须以root身份调用, 如果滥用的话会有危险.

#### fdisk ####
- 在存储设备上(通常都是硬盘)创建和修改一个分区表. 必须以root身份使用. 
- 注意: 谨慎使用这个命令. 如果出错, 会破坏你现存的文件系统. 

#### fsck, e2fsck, debugfs ####
- fsck: 检查UNIX文件系统的前端工具(也可以调用其它的工具). 文件系统的类型一般都是默认的ext2. 
- e2fsck: ext2文件系统检查器. 
- debugfs: ext2文件系统除错器. 这个多功能但是危险的工具的用处之一就是(尝试)恢复删除的文件. 只有高级用户才能用. 
- 上边的这几个命令都必须以root身份调用, 这些命令都很危险

#### badblocks ####
- 检查存储设备的坏块(物理损坏). 这个命令在格式化新安装的硬盘时或者测试备份的完整性的时候会被用到.

#### lsusb, usbmodules ####
- lsusb 命令会列出所有USB总线和使用USB的设备. 
- usbmodules 命令会输出连接USB设备的驱动模块的信息. 

#### mkbootdisk ####
- 创建启动软盘, 启动盘可以唤醒系统

#### chroot ####
- 修改ROOT目录. 一般的命令都是从$PATH中获得的, 相对的默认的根目录是/. 这个命令将会把根目录修改为另一个目录(并且也将把工作目录修改到那). 
- 注意, 在使用chroot之后, 系统的二进制可执行文件的目录将不再可用了. 
- chroot /opt 将会使得原来的/usr/bin目录变为/opt/usr/bin.chroot /aaa/bbb /bin/ls 将会使得ls 命令以/aaa/bbb作为根目录, 而不是以前的/. 
- 只能以root身份调用, 小心使用. 
- 注意: 由于正常的$PATH将不再被关联了, 所以可能需要将一些特定的系统文件拷贝到chrooted目录中.

#### lockfile ####
- 这个工具是procmail包的一部分(www.procmail.org). 它可以创建一个锁定文件, 锁定文件是一种用来控制存取文件, 设备或资源的标记文件. 
- 锁定文件就像一个标记一样被使用
- 注意如果脚本尝试创建一个已经存在的锁定文件的话, 那么脚本很可能被挂起. 
- 一般情况下, 应用创建或检查锁定文件都放在/var/lock目录中. 

#### flock<rojy bug> ####
- flock命令比lockfile 命令用得少得多.
- 注意: 与lockfile 不同, flock不会自动创建一个锁定文件. 

#### mknod ####
- 创建块或者字符设备文件(当在系统上安装新硬盘时可能是必要的). 
- MAKEDEV工具事实上具有nknod的全部功能, 而且更容易使用. 

#### MAKEDEV ####
- 创建设备文件的工具. 必须在/dev目录下, 并且以root身份使用. 

#### tmpwatch ####
- 自动删除在指定时间内未被存取过的文件. 通常都是被cron调用, 用来删掉老的log 文件. 

### 备份类 ###
#### dump, restore ####
- dump 命令是一个精巧的文件系统备份工具, 通常都用在比较大的安装和网络上.
- restore命令用来恢复dump所产生的备份.

#### fdformat  ####
- 对软盘进行低级格式化. 

### 系统资源类 ###
#### ulimit ####
- 设置使用系统资源的上限. 
- 通常情况下都是使用-f选项来调用, -f用来设置文件尺寸的限制(ulimit -f 1000就是将文件大小限制为1M). 
- -t选项来限制coredump(译者注: 核心转储, 程序崩溃时的内存状态写入文件) 尺寸(ulimit -t 0 就是不要coredumps). 一般情况下, ulimit的值应该设置在/etc/profile 和(或)~/.bash_profile中
- 注意：使用ulimit 可以保护系统免受可怕的fork炸弹的迫害.

#### quota ####
- 显示用户或组的磁盘配额. 

#### setquota ####
- 从命令行中设置用户或组的磁盘配额.

#### umask ####
- 设定用户创建文件时权限的缺省mask(掩码). 也可以用来限制特定用户的默认文件属性. 
- 所有用户创建的文件属性都是由umask所指定的. The (octal) 传递给umask的8进制的值定义了文件的权限.
- 用户一般都是将umask设置值的地方放在/etc/profile 和(或) ~/.bash_profile中

#### rdev ####
- 取得root device, swap space, 或video mode的相关信息, 或者对它们进行修改. 
- 通常说来rdev都是被lilo 所使用, 但是在建立一个ram disk的时候, 这个命令也很有用. 小心使用, 这是一个危险的命令. 

### 模块类 ###
#### lsmod ####
- 列出所有安装的内核模块. 
- 注意: 使用cat /proc/modules可以得到同样的结果.

#### insmod ####
- 强制一个内核模块的安装(如果可能的话, 使用modprobe来代替) 必须以root身份调用.

#### rmmod ####
- 强制卸载一个内核模块. 必须以root身份调用.

#### modprobe ####
- 模块装载器, 一般情况下都是在启动脚本中自动调用. 必须以root身份调用.

#### depmod ####
- 创建模块依赖文件, 一般都是在启动脚本中调用.

#### modinfo ####
- 输出一个可装载模块的信息.

### 杂项类 ###
#### env ####
- 使用设置过的或修改过(并不是修改整个系统环境)的环境变量来运行一个程序或脚本. 
- 使用[varname=xxx] 形式可以在脚本中修改环境变量. 
- 如果没有指定参数, 那么这个命令将会列出所有设置的环境变量. 
- 注意: 当不知道shell或解释器的路径的时候, 脚本的第一行(#!行)可以使用env. 

#### ldd ####
- 显示一个可执行文件的共享库的依赖关系.

#### watch ####
- 以指定的时间间隔来重复运行一个命令. 
- 默认的时间间隔是2秒, 但时刻以使用-n选项来修改. 

#### strip ####
- 从可执行文件中去掉调试符号引用. 这样做可以减小尺寸, 但是就不能调试了. 
- 这个命令一般都用在Makefile中, 但是很少用在shell脚本中. 

#### nm ####
- 列出未strip过的编译后的2进制文件的符号.

#### rdist ####
- 远程文件分布客户机程序: 在远端服务器上同步, 克隆, 或者备份一个文件系统.

## 第14章 命令替换 ##
- 命令替换会将命令的输出如实地添加到另一个上下文中.
- 使用命令替换的典型形式是使用后置引用(`...`).
- 注意: 命令替换将会调用一个subshell. 
- 注意: 命令替换可能会引起word splitting. 
       COMMAND `echo a b`          # 2个参数: a and b 
       COMMAND "`echo a b`"        # 1个参数: "a b" 
       COMMAND `echo`              # 无参数
       COMMAND "`echo`"            # 一个空的参数
- 即使没有引起word splitting, 命令替换也会去掉多余的新行.
- 注意: 当一个变量是使用命令替换的结果做为值的时候, 然后使用echo命令来输出这个变量(并且不引用这个变量, 就是不用引号括起来), 那么命令替换将会从最终的输出中删掉换行符. 这可能会引起一些异常情况. 
- 命令替换甚至允许将整个文件的内容放到变量中, 可以使用重定向或者cat命令.
- 注意: 不要将一个非常长的文本文件的内容设置到一个变量中, 除非你有一个非常好的原因非要这么做不可. 不要将2进制文件的内容保存到变量中. 
- 注意, 在这里是不会发生缓冲区溢出错误. 因为这是一个解释型语言的实例, Bash就是一种解释型语言, 解释型语言会比编译型语言提供更多的对程序错误的保护措施.
- 变量替换允许将一个循环的输出放入到一个变量中.这么做的关键就是将循环中echo命令的输出全部截取. 
- 注意: 对于命令替换来说,$(COMMAND) 形式已经取代了反引号"`". 
- $(...) 形式的命令替换在处理双反斜线(\\)时与`...`形式不同. 
       bash$ echo `echo \\` 
       bash$ echo $(echo \\) 
       \      
- $(...) 形式的命令替换是允许嵌套的.
- 从技术的角度来讲, 命令替换将会抽取出一个命令的输出, 然后使用=操作赋值到一个变量中.
- 事实上, 对于反引号的嵌套是可行的, 但是只能将内部的反引号转义才行

## 第15章 算术扩展 ##
- 可以使用backticks, double parentheses, 或let 来将字符串转换为数字表达式. 
- 使用反引号的算术扩展(通常都是和expr一起使用)
- 使用双括号, 和let 形式的算术扩展
- 反引号形式的算术扩展已经被双括号形式所替代

## 第16章 I/O重定向 ##
- 每个打开的文件都会被分配一个文件描述符.stdin, stdout, 和stderr的文件描述符分别是0, 1, 和2. 对于正在打开的额外文件, 保留了描述符3到9.
       COMMAND_OUTPUT >          # 如果没有这个文件就创建, 否则就覆盖. 
       : > filename              # : 是一个占位符, 不产生任何输出.
       > filename                # (与上边的": >"效果相同, 但是在某些shell下可能不能工作.)
       COMMAND_OUTPUT >>         # 如果文件不存在, 那么就创建它, 如果存在, 那么就追加到文件后边.单行重定向命令(只会影响它们所在的行)
       &>filename                # 将stdout和stderr都重定向到文件"filename". 
       2>&1                      # 重定向stderr到stdout.
       i>&j                      # 指向i 文件的所有输出都发送到j中去.
       >&j                       # 所有传递到stdout的输出都送到j中去.
       [j]<>filename             # 如果文件"filename"不存在, 那么就创建它.  # 如果文件描述符"j"没指定, 那默认是fd 0, stdin. 

#### 关闭文件描述符 ####
       n<&-          关闭输入文件描述符n. 
       0<&-, <&-     关闭stdin. 
       n>&-          关闭输出文件描述符n. 
       1>&-, >&-     关闭stdout.

- 子进程继承了打开的文件描述符. 这就是为什么管道可以工作. 如果想阻止fd被继承, 那么可以关掉它. 

### 16.1. 使用exec ###
- `exec <filename` 命令会将stdin重定向到文件中. 从这句开始, 后边的输入就都来自于这个文件了, 而不是标准输入了(通常都是键盘输入). 这样就提供了一种按行读取文件的方法, 并且可以使用sed 和/或awk来对每一行进行分析.
- 同样的, exec >filename 命令将会把stdout重定向到一个指定的文件中. 这样所有的命令输出就都会发向那个指定的文件, 而不是stdout.

#### 注意事项: ####
- 使用文件描述符5可能会引起问题. 当Bash使用exec创建一个子进程的时候, 子进程会继承fd5

## 第17章Here Documents ##
- here document 就是一段特殊目的的代码块. 他使用I/O 重定向的形式来将一个命令序列传递到一个交互程序或者命令中, 比如ftp, cat, 或者ex文本编辑器.
- limit string 用来划定命令序列的范围(译者注: 两个相同的limit string 之间就是命令序列) . 
- 特殊符号<< 用来表识limit string. 这个符号具有重定向文件的输出到程序或命令的输入的作用. 
- Here document 包含ex命令列表的做法足够形成自己的类别了, 叫ex scripts.
- - 选项用来标记here document的limit string (<<-LimitString), 可以抑制输出时前边的tab (不是空格). 这可以增加一个脚本的可读性. 注意, 这个选项对于*嵌在*中间的tab没作用. 
- here document 支持参数和命令替换. 所以也可以给here document的消息体传递不同的参数, 这样相应的也会修改输出. 
- 在here document的开头引用或转义"limit string"会使得here document的消息体中的参数替换被禁用. 禁用了参数替换后, 将允许输出文本本身(译者注: 就是未转义的原文). 产生脚本甚至是程序代码就是这种用法的用途之一. 
- 也可以将here document的输出保存到变量中. 
- 同一脚本中的函数也可以接受here document的输出作为自身的参数. 
- 也可以这么使用: 做一个假命令来从一个here document中接收输出. 这么做事实上就是创建了一个"匿名"的here document. 上边所示技术的一种变化可以用来"注释"掉代码块.关于这种小技巧的另一个应用就是能够产生自文档化(self-documenting)的脚本.
- 注意: Here document创建临时文件, 但是这些文件将在打开后被删除, 并且不能够被任何其他进程所存取. 
- 注意: 某些工具是不能工作在here document中的. 警告: 结束的limit string, 就是here document最后一行的limit string, 必须开始于第一个字符位置. 它的前面不能够有任何前置的空白. 而在这个limit string 后边的空白也会引起异常问题. 空白将会阻止limit string 的识别.
- 对于那些使用"here document"得非常复杂的任务, 最好考虑使用expect脚本语言, 这种语言就是为了达到向交互程序添加输入的目的而量身定做

### 17.1. Here Strings ###
- here string 可以被认为是here document的一种定制形式. 除了COMMAND <<<$WORD 就什么都没有了, $WORD将被扩展并且被送入COMMAND的stdin中.

## 第18章 休息时间 ##

# 第四部分  高级 #
## 第19章 正则表达式 ##
### 19.1 一个简要的正则表达式介绍 ###
- 一个正则表达式包含下面一个或多个项: 
       1.  一个字符集. 
       这里的字符集里的字符表示的就是它们字面上的意思.正则表达式最简单的情况就是仅仅由字符集组成,而没有其他的元字符. 
       2.  锚. 
       一个锚指明了正则表达式在一行文本中要匹配的位置,例如^和$就是锚. 
       3.  修饰符
       它们用于展开或缩小(即是修改了)正则表达式匹配文本行的范围.修饰符包括了星号. 括号和反斜杠符号. 

       星号            -- * -- 匹配前一个字符的任意多次(包括零次). 
       点             -- . -- 匹配除了新行符之外的任意一个字符. [1] 
       脱字符           -- ^ -- 匹配一行的开头,但依赖于上下文环境,可能在正则表达式中表示否定一个字符集的意思. 
       美元符           -- $ -- 在正则表达式中匹配行尾. "^$" 匹配空行. 
       方括号           -- [...] -- 在正则表达式中表示匹配括号中的一个字符. 
                     "[xyz]" 匹配字符x, y, 或z. 
                     "[c-n]" 匹配从字符c到n之间的任意一个字符. 
                     "[B-Pk-y]" 匹配从B到P 或从k到y的任意一个字符. 
                     "[a-z0-9]" 匹配任意小写字母或数字. 
                     "[^b-d]" 匹配除了从b到d范围内所有的字符. 
                     多个方括号字符集组合使用可以匹配一般的单词和数字模式."[Yy][Ee][Ss]" 匹配yes, Yes, YES, yEs, 等等. 
                     "[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]"匹配社会安全码
       反斜杠字符                -- \ -- 转义(escapes) 一个特殊的字符
       转义(escape)"尖角号"      -- \<...\> -- 用于表示单词的边界. 
       扩展的正则表达式.     增加了一些元字符到上面提到的基本的元字符集合里. 它们在egrep, awk,和Perl中使用. 
       问号                  -- ? -- 匹配零或一个前面的字符. 它一般用于匹配单个字符. 
       加号                  -- + -- 匹配一个或多个前面的字符.它的作用和*很相似,但唯一的区别是它不匹配零个字符的情况. 
       转义"大括号"           -- \{ \} -- 指示前面正则表达式匹配的次数. 
                            注意:  大括号不能在“经典”(不是POSIX兼容)的正则表达式版本的awk中使用. 然而, gawk 有一个选项--re-interval来允许使用大括号(不必转义). 
                            Perl和一些egrep版本不要求转义大括号.
       圆括号                  -- ( ) -- 括起一组正则表达式. 它和下面要讲的"|"操作符或在用expr进行子字符串提取(substring extraction)一起使用很有用. 
       竖线            -- | -- "或"正则操作符用于匹配一组可选的字符. 
                     注意:  一些sed, ed, 和ex的版本像GNU的软件版本一样支持上面描述的扩展正则表达式的版本.
       POSIX字符类.   [:class:]     这是另外一个可选的用于指定匹配字符范围的方法. 
                     [:alnum:]     匹配字母和数字.等同于A-Za-z0-9. 
                     [:alpha:]     匹配字母. 等同于A-Za-z. 
                     [:blank:]     匹配一个空格或是一个制表符(tab). 
                     [:cntrl:]     匹配控制字符. 
                     [:digit:]     匹配(十进制)数字. 等同于0-9. 
                     [:graph:]     (可打印的图形字符). 匹配ASCII 码值的33 - 126之间的字符. 这和下面提到的[:print:]一样,但是不包括空格字符. 
                     [:lower:]     匹配小写字母. 等同于a-z. 
                     [:print:]     (可打印字符). 匹配ASCII码值32 - 126之间的字符. 这和上面提到的一样[:graph:],但是增多一个空格字符. 
                     [:space:]     匹配空白字符(空格符和水平制表符). 
                     [:upper:]     匹配大写字母. 等同于A-Z. 
                     [:xdigit:]    匹配十六进制数字. 等同于0-9A-Fa-f.
                     注意: POSIX字符类一般都要求用引号或是双方括号double brackets ([[ ]])引起来. 
                     这些字符类在一个受限的范围内甚至可能用在能用在通配(globbing)中.
- Sed, awk, 和Perl在脚本中被用作过滤器, "过滤"或转换文件/IO流的时候以正则表达式作为参数.
- 因为sed, awk, 和grep 通常处理单行,而不能匹配一个新行符. 在要处理多行的一个输入时,可以使用点操作符,它可以匹配新行符. 

#### 19.2 通配 ####
- Bash所做的是展开文件名扩展 -- 这就是所谓的通配(globbing) -- 但它不是使用标准的正则表达式. 而是使用通配符. 通配解释标准的通配符：*和?, 方括号括起来的字符,还有其他的一些特殊的字符(比如说^用来表示取反匹配).
- 通配机制的通配符有很大的局限性. 包含有*号的字符串将不会匹配以点开头的文件;通配机制的? 字符和正则表达式中表示的意思不一样. 
- Bash会对命令行中没有引号引起来的字符尝试文件名扩展.
- 注意:  可以改变Bash对通配字符进行解释的行为. set -f 命令可以禁止通配机制, 并且shopt的选项nocaseglob和nullglob 能改变通配的行为. 
- 注意事项:文件名扩展能匹配点开头的文件,但仅在模式字串明确地包含字面意思的点(.)时才扩展. 

## 第20章 子shell(Subshells) ##
- 子shell(即子进程)使脚本因为效率而同时进行多个子任务执行时能做串行处理. 
- 脚本里的一个外部命令能生成出一个子进程,然而Bash内建的命令却不这样做,因此,内建命令比起外部的等价命令执行起来更快. 
- ( 命令1; 命令2; 命令3; ... ) 嵌在圆括号里的一列命令在一个子shell里运行.
- 注意:  在子shell里的变量不能被这段子shell代码块之外外面的脚本访问.这些变量是不能被产生这个子shell的父进程存取的,实际上它们是局部变量
- 子shell可用于为一组命令设定临时的环境变量.
- 用"|"管道操作把I/O流重定向到子shell,例如ls -al | (command).
- 注意:  在一个花括号内的代码块{ command1; command2; command3; ... }不会运行一个子shell.  

## 第21章 受限shell(Restricted Shells) ##
### 在受限shell中禁用的命令 ###
       使用cd 命令更改工作目录. 
       更改环境变量$PATH, $SHELL, $BASH_ENV,或$ENV 的值. 
       读或更改shell环境选项变量$SHELLOPTS的值. 
       输出重定向. 
       调用的命令路径中包括有一个或更多个/字符. 
       调用exec来把当前的受限shell替换成另外一个不同的进程. 
       脚本中许多其他无意中能破坏或捣乱的命令. 
       在脚本中企图脱离受限shell模式的操作. 

## 第22章 进程替换 ##
- 进程替换与命令替换很相似.进程替换是把一个进程的输出回馈给另一个进程(换句话说,它把一个命令的结果发送给另一个命令).
- 由圆括号括起的命令启动进程替换.它是用/dev/fd/<n>文件把在圆括号内的进程的处理结果发送给另外一个进程.(整数n指的就是在进程运行时对应数字的文件描述符)
       >(command) 
       <(command) 
- 注意:  在"<" 或or ">" 与圆括号之间是没有空格的. 如果加了空格将会引起错误信息. 
- Bash在两个文件描述符之间创建了一个管道, fIn 和fOut
- 进程替换能比较两个不同命令之间的输出,或者甚至相同命令不同选项的输出. 

## 第23章 函数 ##
       function function_name { 
       command... 
       } 
       或
       function_name () { 
       command... 
       } 
- 在一个函数内嵌套另一个函数也是可以的,但是不常用.
       e.g. f1中包含f2,调用f2需要： f1 ; f2.因为之前调用"f1"使"f2"在脚本中变得可见了. 

### 23.1. 复杂函数和函数复杂性 ###
#### 间接变量 ####
- 间接变量引用提供了传递变量指针给函数的一个笨拙的机制. 
       e.g.   message=Hello 
              Hello=Goodbye
              echo_var "$message"         # Hello 
              echo_var "${!message}"      # Goodbye 
- 解除参数的引用:eval

#### 退出和返回 ####
- return 终止一个函数,并且这个值也被赋给变量$?.函数最大可返回的正整数为255.

#### 重定向 ####
- return命令是Bash内建(builtin)的.

### 23.2. 局部变量 ###
- 如果变量用local 来声明,那么它只能在该变量声明的代码块中可见.
- 与C相比, 在函数内声明的Bash变量只有在它被明确声明成局部的变量时才是局部的. 

#### 23.2.1. 局部变量使递归变得可能. ####
- 局部变量可以递归,但这个办法会产生大量的计算,因此它在shell脚本中是被明确表明不推荐的. 非常可能段错误(依赖于栈的大小,它由ulimit -m设置). 

### 23.3. 不使用局部变量的递归 ###

## 第24章 别名(Aliases) ##
- Bash别名本质上是一个简称, 缩写, 这可避免键入过长的命令序列. 
- Bash中别名限制：
       Bash不能在别名中扩展参数.
       别名不能在“混合型的结构”中使用,比如if/then 语句, 循环, 和函数. 
       别名不能递归地扩展. 
- `shopt -s expand_aliases` 必须设置这个选项,否则脚本不会扩展别名功能. 
- alias设置别名，unalias 命令删除先前设置的别名. 
- 注意事项: 别名好像能扩展位置参数. 

## 第25章 列表结构 ##
### 连接命令 ###
#### 与列表 ####
- 一个与列表也能给变量设置默认值. e.g.[ -z "$arg1" ] && arg1=DEFAULT

#### 或列表 ####
- 与列表或是或列表的退出状态是最后一个执行命令的退出状态.

## 第26章 数组 ##
- 较新的Bash版本支持一维数组. 数组元素可以用符号variable[xx]来初始化。
- 脚本可以用declare -a variable语句来清楚地指定一个数组. 
- 要访问一个数组元素,可以使用花括号来访问,即${variable[xx]}. 
- 数组成员不必一定要连贯或连续的.
- 数组的一部分成员允许不被初始化.
- 另一种指定数组元素的值的办法： array_name=( XXX YYY ZZZ ... ) 
- 从0开始计数
- 第三种指定数组元素值的办法： array_name=([xx]=XXX [yy]=YYY ...) 
- 注意: Bash 允许把变量当成数组来操作,即使这个变量没有明确地被声明为数组.
- 数组用法：
       array=( zero one two three four five )
       echo ${array[0]}     # zero 
       echo ${array:0}      # zero 第一个元素的参数扩展, 从位置0开始(即第一个字符).
       echo ${array:1}      # ero  第一个元素的参数扩展, 从位置1开始(即第二个字符).
       echo ${#array[0]}    # 4    数组第一个元素的长度. 
       echo ${#array}       # 4    数组第一个元素的长度. 
       echo ${#array[1]}    # 3    数组第二个元素的长度. 
       echo ${#array[*]}    # 6    数组中元素的个数. 
       echo ${#array[@]}    # 6    数组中元素的个数. 

       arrayZ=( one two three four five five ) 
       提取尾部的子串
       echo ${arrayZ[@]:0}      # one two three four five five      所有的元素. 
       echo ${arrayZ[@]:1}      # two three four five five     在第一个元素element[0]后面的所有元素. 
       echo ${arrayZ[@]:1:2}    # two three      只提取在元素element[0]后面的两个元素. 
       子串删除，从字符串的前部删除最短的匹配,匹配字串是一个正则表达式. 
       echo ${arrayZ[@]#f*r}       # one two three five five   匹配了"four"并把它删除.
       字符串前部最长的匹配
       echo ${arrayZ[@]##t*e}   # one two four five five       匹配"three"并把它删除. 
       字符串尾部的最短匹配
       echo ${arrayZ[@]%h*e}    # one two t four five five     匹配"hree"并把它删除.
       字符串尾部的最长匹配
       echo ${arrayZ[@]%%t*e}   # one two four five five       匹配"three"并把它删除.
       子串替换
       echo ${arrayZ[@]/fiv/XYZ}    # one two three four XYZe XYZe 
       所有匹配的子串会被替换   
       echo ${arrayZ[@]//iv/YY}     # one two three four fYYe fYYe 
       删除所有的匹配子串
       cho ${arrayZ[@]//fi/}       # one two three four ve ve
       替换最前部出现的字串
       echo ${arrayZ[@]/#fi/XY}     # one two three four XYve XYve
       替换最后部出现的字串
       echo ${arrayZ[@]/%ve/ZZ}     # one two three four fiZZ fiZZ
- name[@]的写法指定了一个"for-each"的操作.
- 在数组的环境里, 一些Bash 内建的命令 含义有一些轻微的改变. 例如, unset 会删除数组元素, 或甚至删除整个数组.
- 如果结果是一个零长度的字符串, Bash支持字符串向量操作, 元素会在结果赋值中消失不见. 
- ${array_name[@]}和${array_name[*]} 的关系类似于$@ and $*. 这种数组用法非常有用.
       复制一个数组. 
              array2=( "${array1[@]}" ) 
              array2="${array1[@]}" 
       给数组增加一个元素. 
              array=( "${array[@]}" "new element" ) 
              array[${#array[*]}]="new element"         
- 注意:  对变量增加declare -a  语句声明可以加速后面的数组操作速度. 
- ( ${bigOne[@]} ) 和${bigOne[@]}，前者比后者慢：
  bigTwo 数组是被赋值了一个单字符串, bigThree 则赋值时一个一个元素的赋值.

- 数组操作是Bash特有的属性. 原来的UNIX /bin/sh 没有类似的功能. 

## 第27章/dev 和/proc ##
### 27.1. /dev ###
- 在/dev 目录内包含以或不以硬件形式出现的物理设备条目.
- /dev 目录也包含环回设备，例如/dev/loop0. 环回设备是一个使普通文件能被像对待块设备一样来进行存取的机制. 这使我们可以将一个大文件内的整个文件系统挂载到系统目录下.
- /dev还有少量的伪设备用于特殊的用途, 例如/dev/null, /dev/zero, /dev/urandom, /dev/sda1, /dev/udp, 和/dev/tcp. 

### 27.2. /proc ###
- /proc目录实际上是一个伪文件系统. 在/proc 目录里的文件是当前运行系统和内核进程及它们的相关信息和统计.
- 文件stat 和status 保存着进程运行时的各项统计, the cmdline文件保存该进程的被调用时的命令行参数, 而and the exe 文件是该运行进程完整路径名的符号链接. 

## 第28章 关于Zeros和Nulls ##
### 使用/dev/null ###
- 禁止标准输出.     e.g. cat $filename >/dev/null
- 禁止标准错误      e.g. rm $badname 2>/dev/null
- 禁止标准输出和标准错误的输出.    e.g. cat $filename 2>/dev/null >/dev/null ，也可以cat $filename &>/dev/null 
- 删除一个文件的内容, 但是保留文件本身, 和所有的文件权限    e.g. cat /dev/null > /var/log/messages
- 自动清空日志文件的内容

### 使用/dev/zero ###
- 它实际上产生连续不断的null的流(二进制的零流,而不是ASCII型的). 写入它的输出会丢失不见, 而从/dev/zero读出一连串的null也比较困难
- /dev/zero主要的用处是用来创建一个指定长度用于初始化的空文件,就像临时交换文件. 
- 另一个应用是为特定的目的而用零去填充一个指定大小的文件, 如挂载一个文件系统到环回设备或"安全地" 删除一个文件
- ELF二进制文件利用了/dev/zero

## 第29章 调试 ##
### 调试工具 ###
       echo 语句
       使用tee 过滤器来检查临界点的进程或数据流.
       设置选项 -n -v -x 
              sh -n scriptname 不会实际运行脚本,而只是检查脚本的语法错误. 这等同于把set -n 或 set -o noexec 插入脚本中. 注意还是有一些语法错误不能被这种检查找出来. 
              sh -v scriptname 在实际执行一个命令前打印出这个命令. 这也等同于在脚本里设置set -v 或set -o verbose. 
              选项-n 和-v 可以一块使用. sh -nv scriptname 会打印详细的语法检查. 
              sh -x scriptname 打印每个命令的执行结果, 但只用在某些小的方面. 它等同于脚本中插入set -x 或 set -o xtrace. 
              把set -u 或 set -o nounset 插入到脚本里并运行它, 就会在每个试图使用没有申明过的变量的地方打印出一个错误信息. 
       使用一个"assert"(断言) 函数在脚本的临界点上测试变量或条件. (这是从C语言中借用来的.) 
       用变量$LINENO和内建的caller. 
       捕捉exit. 脚本中的The exit 命令会触发信号0,终结进程,即脚本本身.这常用来捕捉exit命令做某事, 如强制打印变量值. trap 命令必须是脚本中第一个命令.        
       
### 捕捉信号 ###
#### trap ####
- 当收到一个信号时指定一个处理动作
e.g. `trap 'echo "Control-C disabled."' 2`       # 当按Control-C 时显示一行信息.
- 注意: trap 的DEBUG参数在每个命令执行完后都会引起一个指定的执行动作,例如,这可用来跟踪变量. 
- 注意:  trap '' SIGNAL (两个引号引空) 在脚本中禁用了SIGNAL 信号的动作(即忽略了). trap SIGNAL 则恢复了SIGNAL 信号前次的处理动作. 这在保护脚本的某些临界点的位置不受意外的中断影响时很有用.

## 第30章 选项 ##
- set 命令用来在脚本里激活各种选项. 在脚本中任何你想让选项生效的地方,插入
- set -o option-name 或, 用更简短的格式, set -option-abbrev. 这两种格式都是等价的.
- 注意:  为了在脚本里停用一个选项, 插入 set +o option-name 或set +option-abbrev. 
- 另一个在脚本里启用选项的方法是在脚本头部的#!后面指定选项
- -i可以使脚本以交互方式运行.
- 可以用简短格式来指定(以一个短横线开头)也可以用完整的名字来指定(用双短横线开头或用-o来指定).
       缩写            名称                   作用
       -C            noclobber            防止重定向时覆盖文件(此作用会被>|覆盖) 
       -D            (none)               列出双引号引起的含有$前缀的字符串,但不执行脚本中的命令
       -a            allexport            导出所有定义的变量到环境变量中
       -b            notify               当后台任务终止时给出通知(在脚本中用的不多) 
       -c...         (none)               从...读命令
       -e            errexit              脚本发生第一个错误时就中止脚本运行,即当一个命令返回非零值时退出脚本(除了until 或while loops, if-tests, list constructs) 
       -f            noglob               文件名替换停用(指像*这样的符号不能替换为文件名了) 
       -i            interactive          使脚本以交互式方式运行
       -n            noexec               从脚本里读命令但不执行它们(语法检查) 
       -o Option-Name       (none)        调用Option-Name 选项
       -o posix      POSIX                更改Bash或脚本的行为,使之符合POSIX标准. 
       -p            privileged           脚本作为"suid"程序来运行(小心!) 
       -r            restricted           脚本在受限模式中运行
       -s            stdin                从标准输入读命令
       -t            (none)               第一个命令后就退出
       -u            nounset              当使用一个未定义的变量时产生一个错误信息,并强制退出脚本. 
       -v            verbose              执行命令之前打印命令到标准输出
       -x            xtrace               与-v相似, 但打印完整的命令
       -             (none)               选项列表结束的标志. 后面的参数是位置参数. 
       --            (none)               释放位置参数. 如果参数列表被指定了(-- arg1 arg2), 则位置参数被依次设置为参数列表中的值. 

## 第31章Gotchas ##
- 将保留字和字符声明为变量名. 
- 用连字符或其他保留字符当做变量名(或函数名).
- 给变量和函数使用相同的名字. 这会使脚本不能分辨两者.
- 不适当地使用宽白符(whitespace). 和其它的编程语言相比,Bash非常讲究空白字符的使用. 
- 未初始化的变量(指赋值前的变量)被认为是NULL值的,而不是有零值.
- 混淆测试里的= 和-eq 操作符. 请记住, = 是比较字符变量而-eq 比较整数.
- 误用字符串比较操作符.
- 有时在测试时的方括号([ ])里的变量需要引用起来(双引号). 
- 在脚本里的命令可能会因为脚本没有运行权限而导致运行失败.
- 试图用- 来做重定向操作(事实上它不是操作符)会导致令人讨厌的意外.
- 在非Linu
- x的机器上使用Bourne shell脚本(#!/bin/sh)的Bash专有功能可能会引起不可预料的行为. 
- 使用Bash中没有文档化的属性是危险的尝试.
- 一个带有DOS风格新行符(\r\n) 的脚本会执行失败
- shell脚本以#!/bin/sh 行开头将不会在Bash兼容的模式下运行.一些Bash专有的功能可能会被禁用掉.
- 脚本里在here document 的终结输入的字符串前加入空白字符会引起不可预料的结果. 
- 脚本不能export(导出)变量到它的父进程(parent process),或父进程的环境里.
- 在子SHELL(subshell)设置和操作变量, 然后尝试在子SHELL的作用范围外使用相同名的变量将会导致非期望的结果
- 把echo 的输出用管道(Piping)输送给read命令可能会产生不可预料的结果. 在这个情况下, read 表现地好像它是在一个子SHELL里一样. 可用set 命令代替
- 管道任何的数据到循环里都会引起相似的问题. 
- 相关的问题是：当尝试写tail -f 的输出给管道并传递给grep时会发生问题.
- 在脚本中使用"suid" 的命令是危险的, 因为这会危及系统安全.
- Shell脚本的变量不是"类型安全的", 这样它用于CGI连接使用时会引发不希望的结果. 其次, 它很难防范骇客的攻击.
- Bash 不能正确处理双斜线(//) 字符串. 
- 注意事项:给脚本设置suid 权限是没有用的.

## 第32章 脚本编程风格 ##
### 32.1. 非官方的Shell脚本风格 ###
- 注释你的代码.
- 给脚本和函数加上描述性的头部信息.
- 确认#!/bin/bash 在脚本的第一行,在任何头部注释行之前. 
- 避免使用"魔数,"它是硬编码的字符常量. 用有意义的变量名来代替. 
- 为变量和函数选择描述性的名字
- 用有含义和系统的方法来使用退出代码
- 建议在脚本中使用/usr/include/sysexits.h的退出码
- 使用标准的参数选项. 建议使用下面一组参数标志.
       -a     All: Return all information (including hidden file info). 
       -b     Brief: Short version, usually for other scripts. 
       -c     Copy, concatenate, etc.     
       -d     Daily: Use information from the whole day, and not merely information for a specific instance/user. 
       -e     Extended/Elaborate: (often does not include hidden file info). 
       -h     Help: Verbose usage w/descs, aux info, discussion, help. See also -V.   
       -l     Log output of script.   10 -m Manual: Launch man-page for base command. 
       -n     Numbers: Numerical data only. 
       -r     Recursive: All files in a directory (and/or all sub-dirs). 
       -s     Setup & File Maintenance: Config files for this script. 
       -u     Usage: List of invocation flags for the script. 
       -v     Verbose: Human readable output, more or less formatted. 
       -V     Version / License / Copy(right|left) / Contribs (email too).
- 把复杂的脚本分割成简单一些的模块. 用合适的函数来实现各个功能. 
- 如果有简单的结构可以使用,不要使用复杂的结构

## 第33章 杂项 ##
### 33.1. 交互式和非交互式的shells和脚本 ###
- 非交互式的脚本可以在后台运行,但交互脚本在后台运行则会被挂起,等待永远不会到达的输入.解决这个难点的办法可以写预料这种情况的脚本或是内嵌here document 的脚本来获取脚本期望的输入,这样就可作为后台任务运行了.
- 如果脚本需要测试当前是否运行在交互shell中,一个简单的办法是找一下是否有提示符变量, 即$PS1是否设置了.
- 另一个办法是脚本可以测试是否在变量$-中出现了选项"i"
- 注意:  脚本可以使用-i选项强制在交互式模式下运行或脚本头用#!/bin/bash -i. 注意这样可能会引起脚本古怪的行为或当没有错误出现时也会显示错误信息. 

### 33.2. Shell 包装 ###
- 包装脚本是指嵌有一个系统命令和程序的脚本,也保存了一组传给该命令的参数.包装脚本使原本很复杂的命令行简单化. 这对sed 和awk 特别有用. 
- 事实上,相当数量的Linux软件工具包是shell包装脚本. 例如/usr/bin/pdf2ps, /usr/bin/batch, 和/usr/X11R6/bin/xmkmf.

### 33.3. 测试和比较: 另一种方法 ###
- 对于测试,[[ ]]结构可能比[ ]更合适.同样地,算术比较可能用(( ))结构更有用. 

### 33.4. 递归 ###
- 注意:  过多层次的递归调用会耗尽脚本的堆栈空间,会引起段错误.

### 33.5. 彩色脚本 ###
- ANSI 定义了屏幕属性的转义序列集合,例如粗体文本,背景和前景颜色. 一般使用ANSI的转义代码来控制色彩输出
- 最简单也可能是最有用的ANSI转义序列是加粗文本, \033[1m ... \033[0m. \033 触发转义序列, 而"[1" 启用加粗属性, 而"[0" 表示切换回禁用加粗状态. "m"则表示终止一个转义序列.
- 注意: echo使用-e选项可以启用转义序列
- tput sgr0 把终端设置恢复为原样.注意:  因为tput sgr0 在某些环境下不能恢复终端设置, echo -ne \E[0m 会是更好的选择.
- 注意:  然而,有一个主要的问题,那就是ANSI 转义序列是不可移植的. 
- Moshe Jacobson的颜色工具(http://runslinux.net/projects.html#color)能相当容易地使用ANSI转义序列. 它用清晰和较有逻辑的语法来代替刚才讨论的难用的结构. 
- Henry/teikedvl 也同样开发了一个软件包来简化彩色脚本的一些操作(http://scriptechocolor.sourceforge.net/).

### 33.6. 优化 ###
- 检查脚本中的循环. 
- 优先使用内建(builtin)命令而不是系统命令. 内建命令执行起来更快并且一般调用时不会产生新的子shell.
- 避免不需要的命令, 特别是管道(pipe).
- 用time和times工具去了解计算花费的时间. 
- 尝试最小化文件I/O. Bash在文件处理上不是特别地有效率, 所以要考虑在脚本中使用更合适地工具来处理, 比如说awk 或Perl. 
- 采用结构化的思想来写脚本, 使各个模块能够依据需要组织和合并起来.

### 33.7. 各种小技巧 ###
- 为了记录在一个实际的会话期或多个会话期内运行的用户脚本,可以加下面的代码到每个你想追踪记录的脚本里. 这会记录下连续的脚本名记录和调用的次数. 
- >> 操作符可以在文件尾添加内容.  "cat -" 可在文件头添加内容
- 脚本也可以像内嵌到另一个shell脚本的普通命令一样调用, 如Tcl 或wish 脚本, 甚至可以是Makefile. 它们可以作为外部shell命令用C语言的system() 函数调用
- 把内嵌的sed 或awk 脚本的内容赋值给一个变量可以增加包装脚本的可读性.
- 把你最喜欢和最有用的定义和函数放在一些文件中. 当需要的使用的时候, 在脚本中使用dot (.) 或source 命令来"包含(include)"这些"库文件"的一个或多个.
- 在脚本中添加特殊种类的注释开头标识有助于条理清晰和可读性.
       +      表示继续上一行. 
              这是第一行
       +      这是多行的注释, 
       +      这里是最后一行. 
       *      表示标注. 
       o      表示列表项.  
       >      表示另一个观点.                  
- if-test 结构的一种聪明用法是用来注释一块代码块. 
- 测试$? 退出状态变量
- 0 - 255 范围的函数返回值是个严格的限制. 用全局变量和其他方法常常出问题. 函数内返回值给脚本主体的另一个办法是让函数写值到标准输出(通常是用echo) 作为"返回值", 并且将其赋给一个变量. 这实际是命令替换(command substitution)的变体. 
- 相同的技术也可用在字符串中. 这意味着函数可以"返回"一个非数字的值. 
- 传递数组给函数的技术, 然后"返回" 一个数组给脚本. 用变量替换把数组的所有元素用空格分隔开来并赋给一个变量就可以实现给函数传递数组
- 利用双括号结构,使在for 和while 循环中可以使用C风格的语法来设置和增加变量
- 在脚本开头设置path 和umask 增加脚本的"可移植性" -- 在某些把$PATH 和umask 弄乱的系统里也可以运行. 
- 一个有用的脚本技术是：重复地把一个过滤器的输出回馈(用管道)给另一个相同过滤器, 但过滤器有不同的参数和/或选项. 尤其对tr 和grep 更合适. 
- 使用"匿名的here documents" 来注释代码块,这样避免了对代码块的每一块单独用#来注释了
- 当依赖某个命令脚本在一台没有安装该命令的机器上运行时会出错. 使用whatis 命令可以避免此问题. 
- 在发生错误的情况下if-grep test 可能不会返回期望的结果,因为文本是打印在标准出错而不是标准输出上. 
- The run-parts 命令很容易依次运行一组命令脚本,特别是和cron 或at 组合起来.
- 在shell脚本里能调用X-Windows 的窗口小部件：Xscript, Xmenu, 和widtools. 
- dialog 工具集提供了shell脚本使用一种称为"对话框"的窗口部件. 原始的dialog 软件包工作在文本模式的控制台下, 但它的后续软件gdialog, Xdialog, 和kdialog 使用基于X-Windows的窗口小部件集. 
- 其他的在脚本中使用窗口的工具还有Tk 或wish (Tcl 派生物), PerlTk (Perl 的Tk 扩展), tksh (ksh 的Tk 扩展), XForms4Perl (Perl 的XForms 扩展), Gtk-Perl  (Perl 的Gtk 扩展), 或PyQt (Python 的Qt 扩展).
- 为了对复杂的脚本做多次的版本修订管理, 可以使用rcs 软件包. 使用这个软件包的好处之一是会自动地升级ID头标识.在rcs 的co命令处理一些预定义的关键字参数替换

### 33.8. 安全话题 ###
#### 33.8.1. 被感染的脚本 ####
#### 33.8.2. 隐藏Shell脚本源码 ####
- 为了安全, 使脚本不可读是有必要的.

### 33.9. 移植话题 ###
- 用 --posix 选项调用Bash或在脚本开头插入 set -o posix 就能使Bash能以很接近这个标准的方式运行.
- Bash 有传统的Bourne shell 缺乏的一些属性. 下面是其中一些: 
       一些扩展的调用选项
       使用$( ) 结构来完成命令替换
       一些 字符串处理操作符
       进程替换
       Bash的内建命令

### 33.10. 在Windows下进行Shell编程 ###
- Cygwin 软件结合来自Mortice Kern的MKS软件包

## 第34章Bash, 版本2 和3  ##
### 34.1. Bash, 版本2 ###
### 34.2. Bash版本3 ###
- 增加的一些属性有: 
       新的,更特别的不可移植的{a..z} 花括号扩展 操作符
       ${!array[@]} 操作符, 它扩展给定的数组的所有元素下标. 
       ~ 正则表达式(Regular Expression) 匹配操作符在双方括号，测试表达式中使用. (Perl也有一个相似的操作符.) 

# 后记 #
## 第35章 后记 ##
### 35.1. 作者后记 ###
### 35.2. 关于作者 ###
### 35.3. 哪里可以取得帮助?  ###
### 35.4. 制作这本书的工具 ###
#### 35.4.1 硬件 ####
#### 35.4.2 软件和排版软件 ####