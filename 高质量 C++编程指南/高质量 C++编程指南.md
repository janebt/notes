# 高质量 C++/C 编程指南 #
## 第1章  文件结构 ##
### 1.1 版权和版本的声明 ###
- 版权和版本的声明位于头文件和定义文件的开头 参见示例 1-1 主要内容有
    版权信息
    文件名称 标识符 摘要
    当前版本号 作者/修改者 完成日期
    版本历史信息

### 1.2 头文件的结构 ###
- 头文件由三部分内容组成
    头文件开头处的版权和版本声明
    预处理块
    函数和类结构声明等

> 规则1-2-1 为了防止头文件被重复引用 应当用 ifndef/define/endif 结构产生预处理块
> 规则1-2-2 用  #include < filename.h>  格式来引用标准库的头文件 编译器将从标准库目录开始搜索
> 规则1-2-3 用  #include “filename.h”  格式来引用非标准库的头文件 编译器将从用户的工作目录开始搜索
> 建议1-2-1 头文件中只存放声明而不存放定义
> 建议1-2-2不提倡使用全局变量尽量不要在头文件中出现象 extern int value 这类声明

### 1.3 定义文件的结构 ###
- 定义文件有三部分内容
    定义文件开头处的版权和版本声明
    对一些头文件的引用
    程序的实现体 包括数据和代码

### 1.4 头文件的作用 ###
1. 通过头文件来调用库功能 在很多场合 源代码不便 或不准 向用户公布 只要向用户提供头文件和二进制的库即可 用户只需要按照头文件中的接口声明来调用库功能 而不必关心接口怎么实现的 编译器会从库中提取相应的代码      
2. 头文件能加强类型安全检查 如果某个接口被实现或被使用时 其方式与头文件中的声明不一致 编译器就会指出错误 这一简单的规则能大大减轻程序员调试 改错的负担     

### 1.5 目录结构 ###
- 如果某些头文件是私有的 它不会被用户的程序直接引用则没有必要公开其声明,为了加强信息隐藏 这些私有的头文件可以和定义文件存放于同一个目录

## 第2章 程序的版式 ##
### 2.1 空行 ###
> 规则 2-1-1 在每个类声明之后 每个函数定义结束之后都要加空行
> 规则 2-1-2 在一个函数体内 逻揖上密切相关的语句之间不加空行 其它地方应加空行分隔 

### 2.2 代码行 ###
> 规则 2-2-1 一行代码只做一件事情 如只定义一个变量 或只写一条语句 这样的代码容易阅读 并且方便于写注释
> 规则 2-2-2 if for while do 等语句自占一行 执行语句不得紧跟其后 不论执行语句有多少都要加{} 这样可以防止书写失误
> 建议 2-2-1 尽可能在定义变量的同时初始化该变量 就近原则.如果变量的引用处和其定义处相隔比较远 变量的初始化很容易被忘记 如果引用了未被初始化的变量 可能会导致程序错误 本建议可以减少隐患 

### 2.3 代码行内的空格 ###
> 规则 2-3-1 关键字之后要留空格。象 const virtual inline case 等关键字之后至少要留一个空格,否则无法辨析关键字。象 if for while 等关键字之后应留一个 空格 再跟左括号( , 以突出关键字
> 规则 2-3-2 函数名之后不要留空格 紧跟左括号( 以与关键字区别
> 规则 2-3-3 ( 向后紧跟 ,  ),; 向前紧跟 , 紧跟处不留空格
> 规则 2-3-4 之后要留空格,如 Function(x, y, z).如果;不是一行的结束符号 其后要留空格,如 for (initialization; condition; update)
> 规则 2-3-5 赋值操作符 比较操作符 算术操作符 逻辑操作符 位域操作符等二元操作符的前后应当加空格
> 规则 2-3-6 一元操作符如 ! ~ ++ -- & 地址运算符 等前后不加空格
> 规则 2-3-7 象 . -> 这类操作符前后不加空格
> 建议 2-3-1 对于表达式比较长的 for 语句和 if 语句 为了紧凑起见可以适当地去掉一些空格 如 for (i=0; i<10; i++)和 if ((a<=b) && (c<=d))

### 2.4 对齐 ###
> 规则 2-4-1 程序的分界符 { 和 } 应独占一行并且位于同一列 同时与引用它们的语句左对齐
> 规则 2-4-2 { }之内的代码块在 { 右边数格处左对齐

### 2.5 长行拆分 ###
> 规则 2-5-1 代码行最大长度宜控制在70至80个字符以内 代码行不要过长 否则眼睛看不过来 也不便于打印
> 规则 2-5-2 长表达式要在低优先级操作符处拆分成新行 操作符放在新行之首,以便突出操作符 拆分出的新行要进行适当的缩进 使排版整齐,语句可读

### 2.6 修饰符的位置 ###
> 规则 2-6-1 应当将修饰符 * 和 & 紧靠变量名

### 2.7 注释 ###
> 规则 2-7-1 注释是对代码的 "提示" 而不是文档 程序中的注释不可喧宾夺主注释太多了会让人眼花缭乱 注释的花样要少
> 规则 2-7-2 如果代码本来就是清楚的 则不必加注释 否则多此一举 令人厌烦
> 规则 2-7-3 边写代码边注释 修改代码同时修改相应的注释 以保证注释与代码的一致性 不再有用的注释要删除
> 规则 2-7-4 注释应当准确 易懂 防止注释有二义性 错误的注释不但无益反而有害
> 规则 2-7-5 尽量避免在注释中使用缩写 特别是不常用缩写
> 规则 2-7-6 注释的位置应与被描述的代码相邻 可以放在代码的上方或右方 不可放在下方
> 规则 2-7-8 当代码比较长 特别是有多重嵌套时 应当在一些段落的结束处加注释 便于阅读

### 2.8 类的版式 ###
- 类的版式主要有两种方式
    1 将 private 类型的数据写在前面 而将 public 类型的函数写在后面 .采用这种版式的程序员主张类的设计 以数据为中心 重点关注类的内部结构
    2 将 public 类型的函数写在前面 而将 private 类型的数据写在后面 .采用这种版式的程序员主张类的设计 以行为为中心 重点关注的是类应该提供什么样的接口 或服务

## 第3章 命名规则 ##
- 比较著名的命名规则当推 Microsoft 公司的 匈牙利 法 该命名规则的主要思想是在变量和函数名中加入前缀以增进人们对程序的理解 
- 匈牙利 法最大的缺点是烦琐

### 3.1 共性规则 ###
> 规则 3-1-1 标识符应当直观且可以拼读 可望文知意 不必进行 解码
> 规则 3-1-2 标识符的长度应当符合 min-length && max-information 原则
> 规则 3-1-3 命名规则尽量与所采用的操作系统或开发工具的风格保持一致
    Windows 应用程序的标识符通常采用 大小写 混排的方式
    Unix 应用程序的标识符通常采用 小写加下划线 的方式
> 规则 3-1-4 程序中不要出现仅靠大小写区分的相似的标识符
> 规则 3-1-5 程序中不要出现标识符完全相同的局部变量和全局变量 尽管两者的作用域不同而不会发生语法错误 但会使人误解
> 规则 3-1-6 变量的名字应当使用 名词 或者 形容词+名词
> 规则 3-1-7 全局函数的名字应当使用 动词 或者 动词+名词(动宾词组)。类的成员函数应当只使用 动词 ,被省略掉的名词就是对象本身
> 规则 3-1-8 用正确的反义词组命名具有互斥意义的变量或相反动作的函数等
> 建议 3-1-1 尽量避免名字中出现数字编号 如 Value1,Value2 等,除非逻辑上的确需要编号

### 3.2 简单的 Windows 应用程序命名规则 ###
> 规则 3-2-1 类名和函数名用大写字母开头的单词组合而成
> 规则 3-2-2 变量和参数用小写字母开头的单词组合而成
> 规则 3-2-3 常量全用大写的字母 用下划线分割单词
> 规则 3-2-4 静态变量加前缀 s_ 表示 static
> 规则 3-2-5 如果不得已需要全局变量 则使全局变量加前缀 g_ 表示 global
> 规则 3-2-6 类的数据成员加前缀 m_ 表示 member 这样可以避免数据成员与成员函数的参数同名
> 规则 3-2-7 为了防止某一软件库中的一些标识符和其它软件库中的冲突 可以为各种标识符加上能反映软件性质的前缀 

### 3.3 简单的 Unix 应用程序命名规则 ###

## 第4章 表达式和基本语句 ##
### 4.1 运算符的优先级 ###
> 规则 4-1-1 如果代码行中的运算符比较多,用括号确定表达式的操作顺序,避免使用默认的优先级

### 4.2 复合表达式 ###
> 规则 4-2-1 不要编写太复杂的复合表达式
> 规则 4-2-2 不要有多用途的复合表达式
> 规则 4-2-3 不要把程序中的复合表达式与 真正的数学表达式 混淆

### 4.3 if语句 ###
#### 4.3.1 布尔变量与零值比较 ####
> 规则 4-3-1 不可将布尔变量直接与 TRUE 、FALSE 或者 1 、0 进行比较。TRUE 的值究竟是什么并没有统一的标准 例如 Visual C++  将 TRUE 定义为 1，而 Visual Basic 则将 TRUE 定义为-1

#### 4.3.2 整型变量与零值比较 ####
> 规则 4-3-2 应当将整型变量用 == 或 = 直接与 0 比较

#### 4.3.3 浮点变量与零值比较 ####
> 规则 4-3-3 不可将浮点变量用 == 或 = 与任何数字比较

#### 4.3.4 指针变量与零值比较 ####
> 规则 4-3-4 应当将指针变量用 == 或 = 与 NULL 比较

#### 4.3.5 对 if 语句的补充说明 ####
- 程序中有时会遇到 if/else/return 的组合,应该将不良风格的程序改写为return (condition ? x : y);

### 4.4 循环语句的效率 ###
> 建议 4-4-1 在多重循环中 如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少CPU跨切循环层的次数 
> 建议 4-4-2 如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面 

### 4.5 for语句的循环控制变量 ###
> 规则 4-5-1 不可在 for 循环体内修改循环变量，防止 for 循环失去控制
> 建议 4-5-1 建议 for 语句的循环控制变量的取值采用"半开半闭区间"写法

### 4.6 switch 语句 ###
> 规则 4-6-1 每个 case 语句的结尾不要忘了加 break ,否则将导致多个分支重叠除非有意使多个分支重叠
> 规则 4-6-2 不要忘记最后那个 default 分支 ,即使程序真的不需要 default 处理也应该保留语句 default:break; 这样做并非多此一举,而是为了防止别人误以为你忘了 default 处理

### 4.7 goto 语句 ###

## 第5章 常量 ##
### 5.1 为什么需要常量 ###
> 规则 5-1-1 尽量使用含义直观的常量来表示那些将在程序中多次出现的数字或字符串

### 5.2 const与#define的比较 ###
- 前者比后者有更多的优点
    1.const 常量有数据类型 而宏常量没有数据类型 编译器可以对前者进行类型安全检查 而对后者只进行字符替换 没有类型安全检查 并且在字符替换可能会产生意料不到的错误 边际效应
    2.有些集成化的调试工具可以对 const 常量进行调试 但是不能对宏常量进行调试

> 规则 5-2-1 在 C++ 程序中只使用 const 常量而不使用宏常量,即const常量完全取代宏常量

### 5.3 常量定义规则 ###
> 规则 5-3-1 需要对外公开的常量放在头文件中 不需要对外公开的常量放在定义文件的头部.为便于管理,可以把不同模块的常量集中存放在一个公共的头文件中
> 规则 5-3-2 如果某一常量与其它常量密切相关,应在定义中包含这种关系,而不应给出一些孤立的值

### 5.4 类中的常量 ###
- 不能在类声明中初始化 const 数据成员 ,const 数据成员的初始化只能在类构造函数的初始化表中进行 
- 怎样才能建立在整个类中都恒定的常量呢?别指望 const 数据成员了,应该用类中的枚举常量来实现 
- 枚举常量不会占用对象的存储空间 它们在编译时被全部求值 枚举常量的缺点是它的隐含数据类型是整数 其最大值有限 且不能表示浮点数

## 第6章 函数设计 ##
### 6.1 参数的规则 ###
> 规则 6-1-1 参数的书写要完整 不要贪图省事只写参数的类型而省略参数名字如果函数没有参数,则用 void 填充.
> 规则 6-1-2 参数命名要恰当,顺序要合理.参数的顺序要遵循程序员的习惯 一般地 应将目的参数放在前面 源参数放在后面
> 规则 6-1-3 如果参数是指针,且仅作输入用 则应在类型前加 const ,以防止该指针在函数体内被意外修改
> 规则 6-1-4 如果输入参数以值传递的方式传递对象,则宜改用 const & 方式来传递,这样可以省去临时对象的构造和析构过程,从而提高效率
> 建议 6-1-1 避免函数有太多的参数,参数个数尽量控制在 5 个以内,如果参数太多,在使用时容易将参数类型或顺序搞错
> 建议 6-1-2 尽量不要使用类型和数目不确定的参数C.e.g.标准库函数 printf 是采用不确定参数的典型代表,其原型为int printf(const chat *format[, argument] );这种风格的函数在编译时丧失了严格的类型安全检查

### 6.2 返回值的规则 ###
> 规则 6-2-1 不要省略返回值的类型
    C 语言中 凡不加类型说明的函数 一律自动按整型处理 这样做不会有什么好处,却容易被误解为 void 类型
    C++语言有很严格的类型安全检查 不允许上述情况发生.由于 C++程序可以调用 C函数,为了避免混乱 规定任何 C++/C 函数都必须有类型,如果函数没有返回值,那么应声明为 void 类型
> 规则 6-2-2 函数名字与返回值类型在语义上不可冲突.e.g. int getchar(void);
> 规则 6-2-3 不要将正常值和错误标志混在一起返回.正常值用输出参数获得,而错误标志用 return 语句返回
> 建议 6-2-1 有时候函数原本不需要返回值,但为了增加灵活性如支持链式表达可以附加返回值
> 建议 6-2-2 如果函数的返回值是一个对象,有些场合用"引用传递"替换"值传递"可以提高效率.而有些场合只能用"值传递"而不能用"引用传递",否则会出错

### 6.3 函数内部实现的规则 ###
> 规则 6-3-1 在函数体的 入口处 对参数的有效性进行检查
    很多程序错误是由非法参数引起的 我们应该充分理解并正确使用 断言 assert来防止此类错误 

> 规则 6-3-2 在函数体的 出口处 对 return 语句的正确性和效率进行检查
- 注意事项如下
    1 return 语句不可返回指向"栈内存"的"指针"或者"引用",因为该内存在函数体结束时被自动销毁 
    2 要搞清楚返回的究竟是"值"、"指针"还是"引用"
    3 如果函数返回值是一个对象,要考虑 return 语句的效率 

### 6.4 其它建议 ###
> 建议 6-4-1 函数的功能要单一 不要设计多用途的函数
> 建议 6-4-2 函数体的规模要小 尽量控制在 50 行代码之内
> 建议 6-4-3 尽量避免函数带有 "记忆" 功能 ,相同的输入应当产生相同的输出。在 C/C++语言中，函数的static 局部变量是函数的 记忆 存储器。建议尽量少用 static 局部变量，除非必需
> 建议 6-4-4 不仅要检查输入参数的有效性 还要检查通过其它途径进入函数体内的变量的有效性 例如全局变量 文件句柄等
> 建议 6-4-5 用于出错处理的返回值一定要清楚 让使用者不容易忽视或误解错误情况

### 6.5 使用断言 ###
- 断言assert是仅在 Debug 版本起作用的宏.它用于检查 不应该 发生的情况 
> 规则 6-5-1 使用断言捕捉不应该发生的非法情况 不要混淆非法情况与错误情况之间的区别 后者是必然存在的并且是一定要作出处理的
> 规则 6-5-2 在函数的入口处 使用断言检查参数的有效性 合法性
> 建议 6-5-1 在编写函数时 要进行反复的考查 并且自问 我打算做哪些假定一旦确定了的假定 就要使用断言对假定进行检查
> 建议 6-5-2 一般教科书都鼓励程序员们进行防错设计 但要记住这种编程风格可能会隐瞒错误 当进行防错设计时 如果 不可能发生 的事情的确发生了 则要使用断言进行报警

### 6.6 引用与指针的比较 ###
- 引用的一些规则如下
    1 引用被创建的同时必须被初始化(指针则可以在任何时候被初始化)
    2 不能有 NULL 引用,引用必须与合法的存储单元关联(指针则可以是 NULL)
    3 一旦引用被初始化,就不能改变引用的关系(指针则可以随时改变所指的对象)

- 引用的主要功能是传递函数的参数和返回值 
- 如果的确只需要借用一下某个对象的 别名 ,那么就用 引用 ,而不要用 指针以免发生意外 

## 第7章 内存管理 ##
### 7.1 内存分配方式 ###
- 内存分配方式有三种
    1 从静态存储区域分配 内存在程序编译的时候就已经分配好 这块内存在程序的整个运行期间都存在 例如全局变量 static 变量
    2 在栈上创建 在执行函数时 函数内局部变量的存储单元都可以在栈上创建 函数执行结束时这些存储单元自动被释放 栈内存分配运算内置于处理器的指令集中 效率很高 但是分配的内存容量有限
    3 从堆上分配 亦称动态内存分配 程序在运行的时候用 malloc 或 new 申请任意多少的内存 程序员自己负责在何时用 free 或 delete 释放内存 动态内存的生存期由我们决定 使用非常灵活 但问题也最多

### 7.2 常见的内存错误及其对策 ###
- 常见的内存错误及其对策如下:

1. 内存分配未成功 却使用了它
    编程新手常犯这种错误 因为他们没有意识到内存分配会不成功 常用解决办法是在使用内存之前检查指针是否为 NULL 如果指针 p 是函数的参数 那么在函数的入口处用 assert(p!=NULL) 进行检查 如果是用 malloc 或 new 来申请内存 应该用 if(p==NULL)或 if(p!=NULL)进行防错处理

2. 内存分配虽然成功 但是尚未初始化就引用它
    犯这种错误主要有两个起因 一是没有初始化的观念 二是误以为内存的缺省初值全为零 导致引用初值错误 例如数组

3. 内存分配成功并且已经初始化 但操作越过了内存的边界
    例如在使用数组时经常发生下标 多 1 或者 少 1 的操作 特别是在 for 循环语句中 循环次数很容易搞错 导致数组操作越界

4. 忘记了释放内存 造成内存泄露
    含有这种错误的函数每被调用一次就丢失一块内存 刚开始时系统的内存充足 你看不到错误 终有一次程序突然死掉 系统出现提示:内存耗尽
    动态内存的申请与释放必须配对 程序中 malloc 与 free 的使用次数一定要相同 否则肯定有错误 new/delete 同理

5. 释放了内存却继续使用它 .有三种情况:
    1 程序中的对象调用关系过于复杂 实在难以搞清楚某个对象究竟是否已经释放了内存 此时应该重新设计数据结构 从根本上解决对象管理的混乱局面
    2 函数的 return 语句写错了 注意不要返回指向 栈内存 的 指针 或者 引用因为该内存在函数体结束时被自动销毁
    3 使用 free 或 delete 释放了内存后 没有将指针设置为 NULL 导致产生 野指针

> 规则 7-2-1 用 malloc 或 new 申请内存之后 应该立即检查指针值是否为 NULL,防止使用指针值为 NULL 的内存
> 规则 7-2-2 不要忘记为数组和动态内存赋初值,防止将未被初始化的内存作为右值使用
> 规则 7-2-3 避免数组或指针的下标越界,特别要当心发生 多 1 或者 少 1操作
> 规则 7-2-4 动态内存的申请与释放必须配对,防止内存泄漏
> 规则 7-2-5 用 free 或 delete 释放了内存之后,立即将指针设置为 NULL,防止产生 野指针

### 7.3 指针与数组的对比 ###
- 数组要么在静态存储区被创建 如全局数组;要么在栈上被创建.数组名对应着,而不是指向 一块内存.其地址与容量在生命期内保持不变,只有数组的内容可以改变

#### 7.3.1 修改内容 ####
#### 7.3.2 内容复制与比较 ####
#### 7.3.3 计算内存容量 ####
- sizeof计算字符串长度时要算上\0
- 注意当数组作为函数的参数进行传递时,该数组自动退化为同类型的指针 

### 7.4 指针参数是如何传递内存的? ###
- 如果函数的参数是一个指针 不要指望用该指针去申请动态内存 
    编译器总是要为函数的每个参数制作临时副本 指针参数 p 的副本是_p 编译器使_p = p 如果函数体内的程序修改了_p 的内容 就导致参数 p 的内容作相应的修改 这就是指针可以用作输出参数的原因 在本例中 _p 申请了新的内存 只是把_p 所指的内存地址改变了 但是 p 丝毫未变 所以函数 GetMemory并不能输出任何东西 事实上 每执行一次 GetMemory 就会泄露一块内存 因为没有用free 释放内存
- 如果非得要用指针参数去申请内存 那么应该改用 指向指针的指针 
- 不要用 return 语句返回指向 栈内存 的指针 

### 7.5 free和delete把指针怎么啦 ###
- free 和 delete 并没有把指针本身干掉，需要手动置空。

### 7.6 动态内存会被自动释放吗 ###
- 指针有一些 似是而非 的特征
    1 指针消亡了 并不表示它所指的内存会被自动释放
    2 内存被释放了 并不表示指针会消亡或者成了 NULL 指针

### 7.7  杜绝 野指针 ###
- 野指针 的成因主要有两种
    1 指针变量没有被初始化 任何指针变量刚被创建时不会自动成为 NULL 指针 它的缺省值是随机的 它会乱指一气 所以指针变量在创建的同时应当被初始化 要么将指针设置为 NULL 要么让它指向合法的内存 
    2 指针 p 被 free 或者 delete 之后 没有置为 NULL 让人误以为 p 是个合法的指针
    3 指针操作超越了变量的作用范围 这种情况让人防不胜防 

### 7.8 有了 malloc/free 为什么还要 new/delete ###
- malloc 与 free 是 C++/C 语言的标准库函数 new/delete 是 C++的运算符 
- 对于非内部数据类型的对象而言 光用 maloc/free 无法满足动态对象的要求 对象在创建的同时要自动执行构造函数 对象在消亡 之前要自动执行析构函数 
- 由于malloc/free 是库函数而不是运算符 不在编译器控制权限之内 不能够把执行构造函数和析构函数的任务强加于 malloc/free
- 注意 new/delete 不是库函数，是运算符
- 不要企图用 malloc/free 来完成动态对象的内存管理 应该用 new/delete

### 7.9 内存耗尽怎么办 ###
- 如果在申请动态内存时找不到足够大的内存块 malloc 和 new 将返回 NULL 指针宣告内存申请失败 通常有三种方式处理 内存耗尽 问题：
    1 判断指针是否为 NULL 如果是则马上用 return 语句终止本函数 
    2 判断指针是否为 NULL 如果是则马上用 exit(1)终止整个程序的运行 
    3 为 new 和 malloc 设置异常处理函数 .例如 Visual C++可以用_set_new_hander 函数为 new 设置用户自己定义的异常处理函数 也可以让 malloc 享用与 new 相同的异常处

### 7.10 malloc/free 的使用要点 ###
- 函数 malloc 的原型如下
    void * malloc(size_t size);
- 用 malloc 申请一块长度为 length 的整数类型的内存 程序如下
    int *p = (int *) malloc(sizeof(int) * length); 
- 函数 free 的原型如下
    void free( void * memblock );
- 如果 p 是 NULL 指针那么 free 对 p 无论操作多少次都不会出问题 如果 p 不是 NULL 指针 那么 free 对 p连续操作两次就会导致程序运行错误

### 7.11 new/delete的使用要点 ###
- 如果用 new 创建对象数组 那么只能使用对象的无参数构造函数 
- 在用 delete 释放对象数组时 留意不要丢了符号 [] ,否则相当于delete [0] 

### 7.12 一些心得体会 ###
- 经验教训是
    1 越是怕指针 就越要使用指针 不会正确使用指针 肯定算不上是合格的程序员
    2 必须养成 使用调试器逐步跟踪程序 的习惯 只有这样才能发现问题的本质

## 第8章 C++函数的高级特性 ##
### 8.1  函数重载的概念 ###
#### 8.1.1 重载的起源 ####
- C++语言采用重载机制的理由：
    便于记忆 提高了函数的易用性 
    类的构造函数需要重载机制 
#### 8.1.2 重载是如何实现的？ ####
- 编译器根据参数为每个重载函数产生不同的内部标识符 
    e.g.    _eat_beef _eat_fish _eat_chicken 之类的内部标识符
- C++程序要调用已经被编译后的C函数：
    e.g.    void foo(int x, int y);
        C 编译器编译后在库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字用来支持函数重载和类型安全连接 

- C++提供了一个 C 连接交换指定符号 extern "C" 来解决这个问题:
    extern  C
    {
        void foo(int x, int y);
        // 其它函数
    }
    或者写成
    extern  C
    {
        #include  myheader.h
        // 其它 C 头文件
    }
    告诉 C++编译译器,函数 foo 是个 C 连接,应该到库中找名字_foo,而不是找_foo_int_int 

- 注意并不是两个函数的名字相同就能构成重载 全局函数和类的成员函数同名不算重载。因为函数的作用域不同 
- 全局函数被调用时应加 :: 标志 

#### 8.1.3 当心隐式类型转换导致重载函数产生二义性 ####
- e.g. 由于数字本身没有类型 将数字当作参数时将自动进行类型转换 
    e.g.    output(0.5); X
            output((int)0.5);
            float x=0.5;output(x);

### 8.2 成员函数的重载 覆盖与隐藏 ###
#### 8.2.1 重载与覆盖 ####
- 成员函数被重载的特征:
    1 相同的范围（在同一个类中）
    2 函数名字相同
    3 参数不同
    4 virtual（关键字可有可无）

- 覆盖是指派生类函数覆盖基类函数，特征是
    1 不同的范围（分别位于派生类与基类）
    2 函数名字相同
    3 参数相同
    4 基类函数必须有（virtual 关键字）

#### 8.2.2 令人迷惑的隐藏规则 ####
- C++的隐藏规则（派生类的函数屏蔽了与其同名的基类函数）：
    1 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual关键字，基类的函数将被隐藏（注意别与重载混淆）
    2 如果派生类的函数与基类的函数同名，并且参数也相同。但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）

#### 8.2.3 摆脱隐藏 ####
- 隐藏规则至少有两个存在的理由：
    写语句 pd ->f(10)的人可能真的想调用 Derived::f(char *) 函数 只是他误将参数写错了 有了隐藏规则 编译器就可以明确指出错误 这未必不是好事 
    假如类 Deriv ed 有多个基类 多重继承 有时搞不清楚哪些基类定义了函数 f 如果没有隐藏规则 那么 pd ->f(10) 可能会调用一个出乎意料的基类函数 f 
### 8.3 参数的缺省值 ###
> 规则 8-3-1 参数缺省值只能出现在函数的声明中 而不能出现在定义体中
> 规则 8-3-2 如果函数有多个参数 参数只能从后向前挨个儿缺省 否则将导致函数调用语句怪模怪样

### 8.4 运算符重载 ###
#### 8.4.1 概念 ####
- 运算符的重载规则
    运算符                                   规则
    所有的一元运算符                       建议重载为成员函数
    = () [] ->                           只能重载为成员函数
    += -= /= *= &= |= ~= %= >>= <<=      建议重载为成员函数
    所有其它运算符                         建议重载为全局函数

#### 8.4.2 不能被重载的运算符 ####
- 不允许被重载的运算符：
    1 不能改变 C++内部数据类型 如（int,float等）的运算符
    2 不能重载 '.' ,因为 '.' 在类中对任何成员都有意义,已经成为标准用法
    3 不能重载目前 C++运算符集合中没有的符号 如#,@,$等。原因有两点，一是难以理解，二是难以确定优先级
    4 对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱

### 8.5 函数内联 ###
#### 8.5.1 用内联取代宏代码 ####
- 对于任何内联函数 编译器在符号表里放入函数的声明 包括名字 参数类型 返回值类型 如果编译器没有发现内联函数存在错误 那么该函数的代码也被放入符号表里 在调用一个内联函数时 编译器首先检查调用是否正确 进行类型安全检查 或者进行自动类型转换 当然对所有的函数都一样 如果正确 内联函数的代码就会直接替换函数调用 于是省去了函数调用的开销 
- assert 不是函数，而是宏 

#### 8.5.2 内联函数的编程风格 ####
- inline 是一种 用于实现的关键字 而不是一种 用于声明的关键字
- 定义在类声明之中的成员函数将自动地成为内联函数 
- 将成员函数的定义体放在类声明之中虽然能带来书写上的方便 但不是一种良好的编程风格

#### 8.5.3 慎用内联 ####
- 内联是以代码膨胀 复制 为代价 仅仅省去了函数调用的开销 从而提高函数的执行效率 
- 以下情况不宜使用内联
    1 如果函数体内的代码比较长 使用内联将导致内存消耗代价较高
    2 如果函数体内出现循环 那么执行函数体内代码的时间要比函数调用的开销大

### 8.6 一些心得体会 ###

## 第9章 类的构造函数、析构函数与赋值函数 ##
### 9.1 构造函数与析构函数的起源 ###
### 9.2 构造函数的初始化表 ###
- 构造函数初始化表的使用规则：
    如果类存在继承关系 派生类必须在其初始化表里调用基类的构造函数
    类的 const 常量只能在初始化表里被初始化 因为它不能在函数体内用赋值的方式来初始化
    类的数据成员的初始化可以采用初始化表或函数体内赋值两种方式，这两种方式的效率不完全相同。

### 9.3 构造和析构的次序 ###
- 构造从类层次的最根处开始 在每一层中 首先调用基类的构造函数 然后调用成员对象的构造函数 析构则严格按照与构造相反的次序执行 该次序是唯一的 

### 9.4 示例：类 String 的构造函数与析构函数 ###
### 9.5 不要轻视拷贝构造函数与赋值函数 ###
- 如果不主动编写拷贝构造函数和赋值函数 编译器将以“位拷贝”的方式自动生成缺省的函数 倘若类中含有指针变量 那么这两个缺省的函数就隐含了错误 
- 拷贝构造函数和赋值函数非常容易混淆 常导致错写、错用。拷贝构造函数是在对象被创建时调用的，而赋值函数只能被已经存在了的对象调用 

### 9.6 示例：类 String 的拷贝构造函数与赋值函数 ###
- 类 String 拷贝构造函数与普通构造函数 的区别是：在函数入口处无需与 NULL 进行比较。这是因为 引用 不可能是 NULL，而 指针 可以为 NULL
- 类 String 的赋值函数比构造函数复杂得多 分四步实现：
    第一步 检查自赋值。如果发现自赋值 应该马上终止函数 
    第二步 用 delete 释放原有的内存资源 
    第三步 分配新的内存资源 并复制字符串 
    第四步 返回本对象的引用 目的是为了实现象  a =  b  = c  这样的链式表达 

### 9.7 偷懒的办法处理拷贝构造函数与赋值函数 ###
- 不想编写拷贝构造函数和赋值函数 又不允许别人使用编译器生成的缺省函数：
    只需将拷贝构造函数和赋值函数声明为私有函数 不用编写代码

### 9.8 如何在派生类中实现类的基本函数 ###
派生类的构造函数应在其初始化表里调用基类的构造函数 
基类与派生类的析构函数应该为虚（即加 virtual 关键字） 
在编写派生类的赋值函数时 注意不要忘记对基类的数据成员重新赋值 

### 9.9 一些心得体会 ###

## 第10章 类的继承与组合 ##
### 10.1 继承 ###
> 规则 10-1-1 如果类 A 和类 B 毫不相关,不可以为了使 B 的功能更多些而让 B 继承 A 的功能和属性 
> 规则 10-1-2 若在逻辑上 B 是 A 的一种("a kind of"), 则允许 B 继承 A 的功能和属性 
- 更加严格的继承规则应当是 若在逻辑上 B 是 A 的 一种,并且 A 的所有功能和属性对 B 而言都有意义,则允许 B 继承 A 的功能和属性

### 10.2 组合 ###
> 规则 10-2-1 若在逻辑上 A 是 B 的 一部分("a part of"),则不允许 B 从 A 派生而是要用 A 和其它东西组合出 B

## 第11章 其它编程经验 ##
### 11.1 使用 const 提高函数的健壮性 ###
#### 11.1.1 用 const 修饰函数的参数 ####
- const 只能修饰输入参数 
    1. 如果输入参数采用 指针传递 那么加 const 修饰可以防止意外地改动该指针 起到保护作用
    2. 如果输入参数采用 值传递 由于函数将自动产生临时变量用于复制该参数 该输入参数本来就无需保护 所以不要加 const 修饰
    3. 对于非内部数据类型的参数而言 象 void Func(A a) 这样声明的函数注定效率比较低 因为函数体内将产生 A 类型的临时对象用于复制参数 a 而临时对象的构造复制 析构过程都将消耗时间

- const & 修饰输入参数的规则
    1. 对于非内部数据类型的输入参数 应该将 值传递 的方式改为 const 引用传递 目的是提高效率 例如将 void Func(A a) 改为 void Func(const A &a)
    2. 对于内部数据类型的输入参数 不要将 值传递 的方式改为 const 引用传递否则既达不到提高效率的目的 又降低了函数的可理解性 例如 void Func(int x) 不应该改为 void Func(const int &x)

#### 11.1.2 用 const 修饰函数的返回值 ####
1. 如果给以 指针传递 方式的函数返回值加 const 修饰 那么函数返回值 即指针的内容不能被修改 该返回值只能被赋给加 const 修饰的同类型指针
2. 如果函数返回值采用 值传递方式 由于函数会把返回值复制到外部临时的存储单元中 加 const 修饰没有任何价值。如果返回值不是内部数据类型 将函数 A GetA(void) 改写为 const A & GetA(void)的确能提高效率 但此时千万千万要小心 一定要搞清楚函数究竟是想返回一个对象的拷贝 还是仅返回 别名 就可以了 否则程序会出错 
3. 函数返回值采用 引用传递 的场合并不多 这种方式一般只出现在类的赋值函数中 目的是为了实现链式表达

#### 11.1.3 const 成员函数 ####
- 任何不会修改数据成员的函数都应该声明为 const 类型 
- const 成员函数的声明看起来怪怪的 const 关键字只能放在函数声明的尾部

### 11.2 提高程序的效率 ###
> 规则 11-2-1 不要一味地追求程序的效率 应当在满足正确性 可靠性 健壮性 可读性等质量因素的前提下 设法提高程序的效率
> 规则 11-2-2 以提高程序的全局效率为主 提高局部效率为辅
> 规则 11-2-3 在优化程序的效率时 应当先找出限制效率的 瓶颈 不要在无关紧要之处优化
> 规则 11-2-4 先优化数据结构和算法 再优化执行代码
> 规则 11-2-5 有时候时间效率和空间效率可能对立 此时应当分析那个更重要作出适当的折衷
> 规则 11-2-6 不要追求紧凑的代码 因为紧凑的代码并不能产生高效的机器码

### 11.3  一些有益的建议 ###
> 建议 11-3-1 当心那些视觉上不易分辨的操作符发生书写错误
> 建议 11-3-2 变量 指针 数组 被创建之后应当及时把它们初始化 以防止把未被初始化的变量当成右值使用
> 建议 11-3-3 当心变量的初值 缺省值错误 或者精度不够
> 建议 11-3-4 当心数据类型转换发生错误 尽量使用显式的数据类型转换 让人们知道发生了什么事 避免让编译器轻悄悄地进行隐式的数据类型转换
> 建议 11-3-5 当心变量发生上溢或下溢 数组的下标越界
> 建议 11-3-6 当心忘记编写错误处理程序 当心错误处理程序本身有误
> 建议 11-3-7 当心文件 I/O 有错误
> 建议 11-3-8 避免编写技巧性很高代码
> 建议 11-3-9 不要设计面面俱到 非常灵活的数据结构
> 建议 11-3-10 如果原有的代码质量比较好 尽量复用它 但是不要修补很差劲的代码 应当重新编写  
> 建议 11-3-11 尽量使用标准库函数 不要 发明 已经存在的库函数
> 建议 11-3-12 尽量不要使用与具体硬件或软件环境关系密切的变量
> 建议 11-3-13 把编译器的选择项设置为最严格状态
> 建议 11-3-14 如果可能的话 使用 PC-Lint LogiScope 等工具进行代码审查

# 附录 A C++/C 代码审查表 #
    文件结构
    重要性     审查项                                         结论
            头文件和定义文件的名称是否合理
            头文件和定义文件的目录结构是否合理
            版权和版本声明是否完整  
    重要      头文件是否使用了ifndef/define/endif  预处理块?
            头文件中是否只存放 声明 而不存放 定义
            …… 

    程序的版式
    重要性     审查项                                         结论
            空行是否得体
            代码行内的空格是否得体
            长行拆分是否得体
            “{”  和  “}”  是否各占一行并且对齐于同一列  
    重要      一行代码是否只做一件事？如只定义一个变量 只写一条语句
    重要      If for while do 等语句自占一行 不论执行语句多少都要加 {}
    重要      在定义变量（或参数）时，是否将修饰符 * 和 & 紧靠变量名？
            注释是否清晰并且必要  
    重要      注释是否有错误或者可能导致误解  
    重要      类结构的 public, protected, private 顺序是否在所有的程序中保持一致
            …… 

    命名规则
    重要性     审查项                                         结论
    重要      命名规则是否与所采用的操作系统或开发工具的风格保持一致
            标识符是否直观且可以拼读
            标识符的长度应当 符合 min-length &&
            max-information 原则
    重要      程序中是否出现相同的局部变量和全部变量
            类名、函数名、变量和参数、常量的书写格式是否遵循一定的规则
            静态变量、全局变量、类的成员变量是否加前缀    
            …… 

    表达式与基本语句
    重要性     审查项                                         结论
    重要      如果代码行中的运算符比较多 是否已经用括号清楚地确定表达式的操作顺序
            是否编写太复杂或者多用途的复合表达式  
    重要      是否将复合表达式与“真正的数学表达式”混淆  
    重要      是否用隐含错误的方式写 if 语句?  例如
                1 将布尔变量直接与 TRUE、FALSE 或者 1、0 进行比较
                2 将浮点变量用 == 或 = 与任何数字比较
                3 将指针变量用 == 或 = 与 NULL 比较
            如果循环体内存在逻辑判断 并且循环次数很大 是否已经将逻辑判断移到循环体的外面
    重要      Case 语句的结尾是否忘了加 break  
    重要      是否忘记写 switch 的 default 分支  
    重要      使用 goto  语句时是否留下隐患?  例如跳过了某些对象的构造 变量的初始化 重要的计算等
            ……

    常量
    重要性     审查项                                         结论
            是否使用含义直观的常量来表示那些将在程序中多次出现的数字或字符串
            在 C++ 程序中 是否用 const 常量取代宏常量  
    重要      如果某一常量与其它常量密切相关 是否在定义中包含了这种关系
            是否误解了类中的 const 数据成员 因为 const 数据
            成员只在某个对象生存期内是常量 而对于整个类而言却是可变的
            ……

    函数设计
    重要性     审查项                                         结论
            参数的书写是否完整 不要贪图省事只写参数的类型而省略参数名字
            参数命名 顺序是否合理
            参数的个数是否太多
            是否使用类型和数目不确定的参数
            是否省略了函数返回值的类型
            函数名字与返回值类型在语义上是否冲突    
    重要      是否将正常值和错误标志混在一起返回 正常值应当用输出参数获得 而错误标志用 return 语句返回
    重要      在函数体的 入口处 是否用 assert 对参数的有效性进行检查
    重要      使用滥用了 assert?例如混淆非法情况与错误情况,后者是必然存在的并且是一定要作出处理的
    重要      return 语句是否返回指向“栈内存”的“指针”或者“引用”？
            是否使用 const 提高函数的健壮性？const 可以强制保护函数的参数、返回值，甚至函数的定义体。“Use const whenever you need”
            …… 

    内存管理
    重要性     审查项                                         结论
    重要      用 malloc 或 new 申请内存之后 是否立即检查指针值是否为 NULL？（防止使用指针值为 NULL 的内存）
    重要      是否忘记为数组和动态内存赋初值？（防止将未被初始化的内存作为右值使用）
    重要      数组或指针的下标是否越界  
    重要      动态内存的申请与释放是否配对？（防止内存泄漏）  
    重要      是否有效地处理了“内存耗尽”问题？  
    重要      是否修改“指向常量的指针”的内容  
    重要      是否出现野指针？例如：
                    1 指针变量没有被初始化
                    2 用 free 或 delete 释放了内存之后，忘记将指针设置为 NULL
    重要      是否将 malloc/free  和  new/delete  混淆使用  
    重要      malloc 语句是否正确无误？例如 字节数是否正确？类型转换是否正确？
    重要      在创建与释放动态对象数组时，new/delete 的语句是否正确无误？
            …… 

    C++  函数的高级特性
    重要性     审查项                                         结论
            重载函数是否有二义性  
    重要      是否混淆了成员函数的重载、覆盖与隐藏？
            运算符的重载是否符合制定的编程规范
            是否滥用内联函数？例如函数体内的代码比较长，函数体内出现循环
    重要      是否用内联函数取代了宏代码？
            …… 

    类的构造函数、析构函数和赋值函数
    重要性     审查项                                         结论
    重要      是否违背编程规范而让 C++ 编译器自动为类产生四个缺省的函数：
                1 缺省的无参数构造函数 
                2 缺省的拷贝构造函数 
                3 缺省的析构函数 
                4 缺省的赋值函数
    重要      构造函数中是否遗漏了某些初始化工作  
    重要      是否正确地使用构造函数的初始化表  
    重要      析构函数中是否遗漏了某些清除工作
            是否错写、错用了拷贝构造函数和赋值函数  
    重要      赋值函数一般分四个步骤
                1 检查自赋值
                2 释放原有内存资源
                3 分配新的内存资源 并复制内容
                4 返回 *this 是否遗漏了重要步骤
    重要      是否正确地编写了派生类的构造函数、析构函数、赋值函数？注意事项：
                1 派生类不可能继承基类的构造函数、析构函数赋值函数
                2 派生类的构造函数应在其初始化表里调用基类的构造函数
                3 基类与派生类的析构函数应该为虚（即加 virtual关键字）
                4 在编写派生类的赋值函数时，注意不要忘记对基类的数据成员重新赋值
            …… 

    类的高级特性
    重要性     审查项                                         结论
    重要      是否违背了继承和组合的规则
                1 若在逻辑上B是A的“一种”，并且A的所有功能和属性对B而言都有意义，则允许B继承A的功能和属性
                2 若在逻辑上A是B的“一部分”（a part of），则不允许B从A派生，而是要用A和其它东西组合出B
            …… 
    
    其它常见问题
    重要性     审查项                                         结论
    重要      数据类型问题
                1 变量的数据类型有错误吗
                2 存在不同数据类型的赋值吗
                3 存在不同数据类型的比较吗
    重要      变量值问题
                1 变量的初始化或缺省值有错误吗
                2 变量发生上溢或下溢吗
                3 变量的精度够吗
    重要      逻辑判断问题
                1 由于精度原因导致比较无效吗
                2 表达式中的优先级有误吗
                3 逻辑判断结果颠倒吗
    重要      循环问题
                1 循环终止条件不正确吗
                2 无法正常终止（死循环）吗
                3 错误地修改循环变量吗
                4 存在误差累积吗
    重要      错误处理问题
                1 忘记进行错误处理吗
                2 错误处理程序块一直没有机会被运行
                3 错误处理程序块本身就有毛病吗？如报告的错误与实际错误不一致，处理方式不正确等等
                4 错误处理程序块是“马后炮‘吗？如在被它被调用之前软件已经出错
    重要      文件 I/O 问题
                1 对不存在的或者错误的文件进行操作吗
                2 文件以不正确的方式打开吗
                3 文件结束判断不正确吗
                4 没有正确地关闭文件吗
# 附录 C  C++/C 试题的答案与评分标准 #
- BOOL值比较if语句：if ( flag ) ，不要写成if (flag == TRUE)
- Q：在 C++  程序中调用被  C 编译器编译后的函数 为什么要加  extern “C”？
- A:C++语言支持函数重载 C 语言不支持函数重载 函数被 C++编译后在库中的名字与 C 语言的不同 假设某个函数的原型为   void foo(int x, int y);该函数被 C 编译器编译后在库中的名字为 _foo 而 C++ 编译器则会产生像_foo_int_int 之类的名字。C++提供了 C 连接交换指定符号 extern C 来解决名字匹配问题

- Q：strcpy 能把 strSrc 的内容复制到 strDest 为什么还要 char *  类型的返回值
- A: 为了实现链式表达式.例如  int length = strlen( strcpy( strDest, “hello world”) );

- Q: String temp(s1 + s2); return temp; 与 return String(s1 + s2);比较
- A: 实质不然 上述代码将发生三件事 首先 temp 对象被创建 同时完成初始化 然后拷贝构造函数把 temp 拷贝到保存返回值的外部存储单元中 最后 temp 在函数结束时被销毁 调用析构函数 然而 创建一个临时对象并返回它 的过程是不同的 编译器直接把临时对象创建并初始化在外部存储单元中 省去了拷贝和析构的化费 提高了效率
